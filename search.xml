<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeedCode刷题心得</title>
      <link href="/2021/12/24/LeedCode%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"/>
      <url>/2021/12/24/LeedCode%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h1><p>本文因为采用的是力扣，所以给出的代码均是核心代码，采用力扣模式。而面试如果用的是牛客，那么就是ACM模式，需要注意！！！</p><h2 id="NO-387-字符串中的第一个唯一字符-E"><a href="#NO-387-字符串中的第一个唯一字符-E" class="headerlink" title="NO.387 字符串中的第一个唯一字符 E"></a>NO.387 字符串中的第一个唯一字符 E</h2><p>题目如下所示</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211227110106055.png" alt="image-20211227110106055"></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>可以用哈希表来进行处理。通过创建一个26字母的哈希表，第一次先遍历所有字符，通过<font color="red">ch-‘a’</font>来建立索引。接着找到之后就自增，即++。然后再遍历一遍字符串，如果在哈希表中有一个位置第一次出现==1，那么这个出现的地方的索引就是我们要找的那个字符。要是都没找到，就返回-1。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211227114401970.png" alt="image-20211227114401970"></p><h3 id="代码如下所示"><a href="#代码如下所示" class="headerlink" title="代码如下所示"></a>代码如下所示</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 建立一个26字母的hash表</span></span><br><span class="line">        <span class="keyword">int</span>[] uniqChar = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i ++)&#123;</span><br><span class="line">            <span class="comment">// 遍历字符，传入到hash表中</span></span><br><span class="line">            uniqChar[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>]++;<span class="comment">//利用hash表统计相同的字母</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(uniqChar[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NO-704-二分查找-E"><a href="#NO-704-二分查找-E" class="headerlink" title="NO.704 二分查找 E"></a>NO.704 二分查找 E</h2><p>题目如下所示</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211228201826737.png" alt="image-20211228201826737"></p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>首先，这题可以采用暴力破解，即遍历整个数组，找到就返回下标索引，找不到就返回-1。但是这种效率很慢，又因为题目中明确说了<font color="red">数组中数据不重复且是有序的，因此可以采用二分查找。</font></p><p>其中需要注意的是二分查找是有界限的，二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是 <code>while(left &lt; right)</code> 还是 <code>while(left &lt;= right)</code>，到底是<code>right = middle</code>呢，还是要<code>right = middle - 1</code>呢？</p><p>平时写二分法经常写乱，主要是因为<strong>对区间的定义没有想清楚，区间的定义就是不变量</strong>。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是<strong>循环不变量</strong>规则。</p><p>写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。</p><h3 id="代码1-暴力破解"><a href="#代码1-暴力破解" class="headerlink" title="代码1: 暴力破解"></a>代码1: 暴力破解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码2-二分查找"><a href="#代码2-二分查找" class="headerlink" title="代码2: 二分查找"></a>代码2: 二分查找</h3><h4 id="1-定义target在一个左闭右闭的区间，即-left-right"><a href="#1-定义target在一个左闭右闭的区间，即-left-right" class="headerlink" title="1.定义target在一个左闭右闭的区间，即[left,right]"></a>1.定义target在一个左闭右闭的区间，即[left,right]</h4><p>区间的定义这就决定了二分法的代码应该如何写，<strong>因为定义target在[left, right]区间，所以有如下两点：</strong></p><ul><li>while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;=</li><li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的右区间结束下标位置就是 middle - 1</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 避免当target小于nums[0]或者target大于nums[nums.length-1]时循环多次</span></span><br><span class="line">        <span class="keyword">if</span>(target &lt; nums[<span class="number">0</span>] || target &gt; nums[nums.length - <span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> middle;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            middle = (left + right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target == nums[middle])&#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; nums[middle])&#123;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &gt; nums[middle])&#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-定义target在一个左闭右开的区间，即-left-right"><a href="#2-定义target在一个左闭右开的区间，即-left-right" class="headerlink" title="2.定义target在一个左闭右开的区间，即[left,right)"></a>2.定义target在一个左闭右开的区间，即[left,right)</h4><ul><li>while (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的</li><li>if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 避免当target小于nums[0]或者target大于nums[nums.length - 1]时多次循环</span></span><br><span class="line">        <span class="keyword">if</span>(target&lt;nums[<span class="number">0</span>] || target &gt; nums[nums.length - <span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length;</span><br><span class="line">        <span class="keyword">int</span> middle;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            middle = (left + right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target == nums[middle])&#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; nums[middle])&#123;</span><br><span class="line">                right = middle;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &gt; nums[middle])&#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NO-35-搜索插入位置-E"><a href="#NO-35-搜索插入位置-E" class="headerlink" title="NO.35 搜索插入位置 E"></a>NO.35 搜索插入位置 E</h2><p>题目如下所示</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211229101943721.png" alt="image-20211229101943721"></p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>法一：可以通过暴力破解，直接遍历数组元素，要是找到就返回，找不到就直接返回要插入的顺序。</p><p>法二：二分查找法，注意区分边界问题。</p><h3 id="代码1-暴力破解-1"><a href="#代码1-暴力破解-1" class="headerlink" title="代码1: 暴力破解"></a>代码1: 暴力破解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= nums.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt;= target)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码2-二分查找-1"><a href="#代码2-二分查找-1" class="headerlink" title="代码2: 二分查找"></a>代码2: 二分查找</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义target在左闭右闭的区间,即[left,right]</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> middle;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            middle = (left + right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> middle; <span class="comment">// 1、目标值等于数组中的某一元素,直接就return middle</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[middle] &gt; target)&#123;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[middle] &lt; target)&#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2、目标值在所有元素之前;3、目标值在所有元素之后;4、目标值插入到数组中</span></span><br><span class="line">        <span class="keyword">return</span> right + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NO-34-在排序数组中查找元素的第一个和最后一个位置-M"><a href="#NO-34-在排序数组中查找元素的第一个和最后一个位置-M" class="headerlink" title="NO.34 在排序数组中查找元素的第一个和最后一个位置 M"></a>NO.34 在排序数组中查找元素的第一个和最后一个位置 M</h2><p>题目如下所示</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211229150832068.png" alt="image-20211229150832068"></p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>暴力破解法:我们从左到右对 nums 数组进行遍历，当遇到 target 时中止。如果我们没有中止过，那么 target 不存在，我们可以返回 [-1, -1] 。如果我们找到了有效的左端点坐标，我们可以坐第二遍线性扫描，但这次从右往左进行。这一次，第一个遇到的 target 将是最右边的一个（因为最左边的一个存在，所以一定会有一个最右边的 target）。我们接下来只需要返回这两个坐标。</p><h3 id="代码如下所示-1"><a href="#代码如下所示-1" class="headerlink" title="代码如下所示"></a>代码如下所示</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暴力破解</span></span><br><span class="line"><span class="comment">// 从左往右遍历，如果遇到了就跳出循环，同时记录其target下标</span></span><br><span class="line"><span class="comment">// 接着从右往左遍历，如果遇到了就跳出循环，同时记录其target下标</span></span><br><span class="line"><span class="comment">// 都没找到就返回&#123;-1,-1&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] flag = &#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == target)&#123;</span><br><span class="line">                flag[<span class="number">0</span>] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果遍历完没发现，那么就返回&#123;-1,-1&#125;</span></span><br><span class="line">        <span class="keyword">if</span>(flag[<span class="number">0</span>] == -<span class="number">1</span>)&#123; <span class="comment">// 说明遍历一遍没找到target</span></span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = nums.length;j&gt;=<span class="number">0</span>;j--)&#123; <span class="comment">// 从右往左遍历</span></span><br><span class="line">            <span class="keyword">if</span>(nums[j] == target)&#123;</span><br><span class="line">                flag[<span class="number">1</span>] = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NO-69-Sqrt-x-E"><a href="#NO-69-Sqrt-x-E" class="headerlink" title="NO.69 Sqrt(x) E"></a>NO.69 Sqrt(x) E</h2><p>题目如下所示</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211229203538609.png" alt="image-20211229203538609"></p><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p>这题比较简单，考察的就是不用内嵌的函数求一个平方根的过程，可以采用二分查找来解题。</p><h3 id="代码如下所示-2"><a href="#代码如下所示-2" class="headerlink" title="代码如下所示"></a>代码如下所示</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 特殊值排除</span></span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>; <span class="comment">// 制定左边界</span></span><br><span class="line">        <span class="keyword">int</span> right = x/<span class="number">2</span>; <span class="comment">// 制定右边界,因为是取一个平方根，所以肯定比这个数字的一半还要小</span></span><br><span class="line">        <span class="keyword">int</span> middle;</span><br><span class="line">        <span class="comment">// 在[left,right]这个区间去查找目标元素</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            middle = left + (right - left + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(x/middle&lt;middle)  <span class="comment">// 防止middle * middle &gt; x 会造成溢出</span></span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = middle;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NO-367-有效的完全平方数-E"><a href="#NO-367-有效的完全平方数-E" class="headerlink" title="NO.367 有效的完全平方数 E"></a>NO.367 有效的完全平方数 E</h2><p>题目如下所示</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20220104095911104.png" alt="image-20220104095911104"></p><h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p>用二分查找</p><h3 id="代码如下所示-3"><a href="#代码如下所示-3" class="headerlink" title="代码如下所示"></a>代码如下所示</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>; <span class="comment">// 制定左边界</span></span><br><span class="line">        <span class="keyword">int</span> right = num; <span class="comment">// 制定右边界</span></span><br><span class="line">        <span class="keyword">int</span> middle;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            middle = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(middle * middle == num)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num/middle &lt; middle)&#123;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NO-27-移除元素-E"><a href="#NO-27-移除元素-E" class="headerlink" title="NO.27 移除元素 E"></a>NO.27 移除元素 E</h2><p>题目如下所示</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20220104101409507.png" alt="image-20220104101409507"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20220104105827224.png" alt="image-20220104105827224"></p><h3 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3><p>本题的关键是通过将<strong>要删除的元素的后面的元素向前移动，去覆盖掉要删除的元素，并且将要删除的元素每次都移动在最后面，</strong></p><p>有两种解决办法：</p><p>第一种是：<strong>暴力法</strong> ，通过两个for循环，第1个for循环负责遍历数组，第二个for循环负责更新数组。</p><p>第二种是： <code>双指针法（快慢指针法）</code>，通过一个快指针和慢指针在一个for循环下完成两个for循环的工作：</p><ol><li>循环时，快慢指针一起移动</li><li>查到了值，快指针继续移动，慢指针暂停移动一次</li><li>直到快指针指向数组末尾 返回慢指针的位置，就是数组中剩余的元素个数</li></ol><h3 id="代码如下所示-4"><a href="#代码如下所示-4" class="headerlink" title="代码如下所示"></a>代码如下所示</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暴力破解法，直接遍历，时间复杂度O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val)&#123; <span class="comment">// 如果遍历到的数=val，那么就跳过这次循环进入下一次，用continue。</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                nums[count] = nums[i];</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双指针法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过快慢指针来进行操作</span></span><br><span class="line">        <span class="keyword">int</span> slowIndex = <span class="number">0</span>; <span class="comment">// 定义一个慢指针</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> fastIndex = <span class="number">0</span>;fastIndex &lt; nums.length;fastIndex++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fastIndex] != val)&#123;  <span class="comment">// 如果不等，才是覆盖，移动，否则只有快指针移动</span></span><br><span class="line">                nums[slowIndex] = nums[fastIndex];</span><br><span class="line">                slowIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NO-26-删除排序数组中的重复项-E"><a href="#NO-26-删除排序数组中的重复项-E" class="headerlink" title="NO.26 删除排序数组中的重复项 E"></a>NO.26 删除排序数组中的重复项 E</h2><p>题目如下所示</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20220104103612793.png" alt="image-20220104103612793"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20220104105907185.png" alt="image-20220104105907185"></p><h3 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h3><p>给定的数组是有序的，那么重复的元素一定会相邻。</p><p>这里需要注意的点是：数组中元素是连续的，不能单独删除某个元素，只能通过覆盖来实现。</p><p>因此做法就是将不重复的值放在数组的左面，覆盖之前的元素。这可以通过双指针来实现。</p><p>快指针遍历整个数组；当快指针指的数值和慢指针不一样的时候，慢指针才向后移动，将快指针指到的元素覆盖到慢指针指到的元素上。</p><p>注意：要返回的是删除之后数组的长度。所以返回的数是慢指针值加一。</p><h3 id="代码如下所示-5"><a href="#代码如下所示-5" class="headerlink" title="代码如下所示"></a>代码如下所示</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双指针法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过快慢指针来进行操作</span></span><br><span class="line">        <span class="keyword">int</span> slowIndex = <span class="number">0</span>; <span class="comment">// 定义一个慢指针</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> fastIndex = <span class="number">0</span>;fastIndex &lt; nums.length;fastIndex++)&#123;</span><br><span class="line">            <span class="comment">// 当快指针和慢指针的值不相等时才进行判断</span></span><br><span class="line">            <span class="keyword">if</span>(nums[fastIndex] != nums[slowIndex])&#123;</span><br><span class="line">                nums[++slowIndex] = nums[fastIndex];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NO-283-移动零-E"><a href="#NO-283-移动零-E" class="headerlink" title="NO.283 移动零 E"></a>NO.283 移动零 E</h2><p>题目如下所示</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20220104145337665.png" alt="image-20220104145337665"></p><h3 id="代码如下所示-6"><a href="#代码如下所示-6" class="headerlink" title="代码如下所示"></a>代码如下所示</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暴力破解</span></span><br><span class="line"><span class="comment">// 双重for循环</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt; nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                    nums[i] = nums[j];</span><br><span class="line">                    nums[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> fastIndex = <span class="number">0</span>;fastIndex &lt; nums.length;fastIndex++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fastIndex] != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 如果快指针不等于0 就将快指针的值给慢指针 慢指针++</span></span><br><span class="line">                nums[slowIndex] = nums[fastIndex];</span><br><span class="line">                slowIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时遍历慢指针，将慢指针后面的值全部赋值为0即可</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = slowIndex;j &lt; nums.length;j++)&#123;</span><br><span class="line">            nums[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NO-844-比较含退格的字符串-E"><a href="#NO-844-比较含退格的字符串-E" class="headerlink" title="NO.844 比较含退格的字符串 E"></a>NO.844 比较含退格的字符串 E</h2><p>题目如下所示</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20220105094607532.png" alt="image-20220105094607532"></p><h3 id="题解-8"><a href="#题解-8" class="headerlink" title="题解"></a>题解</h3><p>可以通过栈来进行模拟，通过碰到 ‘#’ 来进行出栈，最后进行比较即可。</p><h3 id="代码如下所示-7"><a href="#代码如下所示-7" class="headerlink" title="代码如下所示"></a>代码如下所示</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backspaceCompare</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设计两个栈来进行操作</span></span><br><span class="line">        Stack&lt;Character&gt; stackS = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Character&gt; stackT = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] ArrayS = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] ArrayT = t.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ArrayS.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ArrayS[i] == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">// 遇到 # 就出栈,否则元素就进栈</span></span><br><span class="line">                <span class="keyword">if</span>(!stackS.isEmpty())&#123;</span><br><span class="line">                    <span class="comment">// 先判断栈是不是为空，如果遇到&#x27;#&#x27;,且栈不是空再出栈，否则不做干扰</span></span><br><span class="line">                    stackS.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                stackS.push(ArrayS[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; ArrayT.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ArrayT[j] == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!stackT.isEmpty())&#123;</span><br><span class="line">                    stackT.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                stackT.push(ArrayT[j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较两个栈里面的元素是否一样</span></span><br><span class="line">        <span class="comment">// peek()方法会比较两个栈栈顶元素大小，并且不会将元素弹出栈</span></span><br><span class="line">        <span class="keyword">while</span>(!stackS.isEmpty() &amp;&amp; !stackT.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span> (stackS.peek() != stackT.peek())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stackS.pop();</span><br><span class="line">                stackT.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stackS.isEmpty() &amp;&amp; stackT.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NO-977-有序数组的平方-E"><a href="#NO-977-有序数组的平方-E" class="headerlink" title="NO.977 有序数组的平方 E"></a>NO.977 有序数组的平方 E</h2><p>题目如下所示</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20220105101218192.png" alt="image-20220105101218192"></p><h3 id="代码如下所示-8"><a href="#代码如下所示-8" class="headerlink" title="代码如下所示"></a>代码如下所示</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先遍历一遍算出平方，接着通过冒泡排序算一下就行</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortedSquares(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            nums[i] = nums[i] * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; nums.length - i - <span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &gt; nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                    nums[j] = nums[j+<span class="number">1</span>];</span><br><span class="line">                    nums[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NO-209-长度最小的子数组-M"><a href="#NO-209-长度最小的子数组-M" class="headerlink" title="NO.209 长度最小的子数组 M"></a>NO.209 长度最小的子数组 M</h2><p>题目如下所示</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20220105103537541.png" alt="image-20220105103537541"></p><h3 id="题解-9"><a href="#题解-9" class="headerlink" title="题解"></a>题解</h3><p>本题用滑动窗口来解答，主要确定如下三点:</p><ul><li>窗口内是什么？</li><li>如何移动窗口的起始位置？</li><li>如何移动窗口的结束位置？</li></ul><p>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</p><p>窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。</p><p>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，窗口的起始位置设置为数组的起始位置就可以了。</p><p>滑动窗口的精妙之处就在于根据当前子序列和大小的情况，不断调节子序列的起始位置。</p><h3 id="代码如下所示-9"><a href="#代码如下所示-9" class="headerlink" title="代码如下所示"></a>代码如下所示</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>; <span class="comment">// 滑动窗口的左指针</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">// 窗口内的总和</span></span><br><span class="line">        <span class="keyword">int</span> len = Integer.MAX_VALUE; <span class="comment">// 定义一个最大的长度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> right = <span class="number">0</span>;right &lt; nums.length;right++)&#123;</span><br><span class="line">            sum += nums[right];   <span class="comment">// 右指针开始滑动,同时求出窗口内的和</span></span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123; <span class="comment">// 当滑动窗口内的和sum&gt;=target 的时候，开始滑动左指针,缩短长度</span></span><br><span class="line">                len = Math.min(len,right - left + <span class="number">1</span>);  <span class="comment">// 更新len值，取区间最小的</span></span><br><span class="line">                sum -= nums[left++]; <span class="comment">// 这段代码的精髓所在,此时left开始滑动，不断地去缩小这个值。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果跑到最后,发现len值还是最大长度,那就说明没有找到,返回0;否则返回对应的区间长度。</span></span><br><span class="line">        <span class="keyword">return</span> len == Integer.MAX_VALUE ? <span class="number">0</span> : len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NO-904-水果成篮-M"><a href="#NO-904-水果成篮-M" class="headerlink" title="NO.904 水果成篮 M"></a>NO.904 水果成篮 M</h2><p>题目如下所示</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20220105112547550.png" alt="image-20220105112547550"></p><h3 id="题解-10"><a href="#题解-10" class="headerlink" title="题解"></a>题解</h3><p>这个题目就是求一个只包含两个元素的最长子序列。</p><h3 id="代码如下所示-10"><a href="#代码如下所示-10" class="headerlink" title="代码如下所示"></a>代码如下所示</h3><h2 id="NO-59-螺旋矩阵-M"><a href="#NO-59-螺旋矩阵-M" class="headerlink" title="NO.59 螺旋矩阵|| M"></a>NO.59 螺旋矩阵|| M</h2><p>题目如下所示</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20220105155122224.png" alt="image-20220105155122224"></p><h3 id="题解-11"><a href="#题解-11" class="headerlink" title="题解"></a>题解</h3>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink</title>
      <link href="/2021/11/23/Flink/"/>
      <url>/2021/11/23/Flink/</url>
      
        <content type="html"><![CDATA[<h1 id="Flink简单学习"><a href="#Flink简单学习" class="headerlink" title="Flink简单学习"></a>Flink简单学习</h1><p><strong>Flink主要侧重于流处理，Spark主要侧重于批处理。因此在后续工作中，Flink应该会是主流。</strong></p><p>首先我们要了解流处理和批处理的区别。</p><table><thead><tr><th>流处理/实时计算</th><th>批处理/离线计算</th></tr></thead><tbody><tr><td>数据大小未知</td><td>数据大小固定</td></tr><tr><td>简单操作</td><td>复杂操作</td></tr><tr><td>及时响应</td><td>需要一段时间</td></tr><tr><td>数据到达次序独立</td><td></td></tr><tr><td>再次提取数据代价大</td><td>方便查询计算结果</td></tr></tbody></table><p><strong>那什么是Flink勒？</strong></p><blockquote><p>Apache Flink是一个框架和分布式处理引擎，用于对无界和有界数据流进行有状态计算。Flink设计为在所有常见的集群环境中运行，以内存速度和任何规模执行计算。</p></blockquote><h2 id="Flink的简单使用"><a href="#Flink的简单使用" class="headerlink" title="Flink的简单使用"></a>Flink的简单使用</h2><p><strong>WordCount——Flink</strong></p><p>这里我们是用本地模式直接在IDEA中去运行，用<strong>nc -lk</strong>来模拟输入的流。代码如下。</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fst.core</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Demo1WordCount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Flink的环境</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> environment: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置并行度</span></span><br><span class="line">    environment.setParallelism(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取socket数据</span></span><br><span class="line">    <span class="comment">// nc -lk 8888</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> linesDS: <span class="type">DataStream</span>[<span class="type">String</span>] = environment.socketTextStream(<span class="string">&quot;master&quot;</span>, <span class="number">8888</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将单词拆分出来</span></span><br><span class="line">    <span class="keyword">val</span> wordDS: <span class="type">DataStream</span>[<span class="type">String</span>] = linesDS.flatMap(line =&gt; line.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换成KV格式</span></span><br><span class="line">    <span class="keyword">val</span> kvDS: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = wordDS.map(word =&gt; (word, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照单词分组</span></span><br><span class="line">    <span class="keyword">val</span> keyByDS: <span class="type">KeyedStream</span>[(<span class="type">String</span>, <span class="type">Int</span>), ((<span class="type">String</span>, <span class="type">Int</span>), <span class="type">Int</span>)] = kvDS.keyBy(word =&gt; (word, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计单词的数量</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sum算子内部是有状态计算，累加统计 传入的是下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> countDS: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = keyByDS.sum(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    countDS.print()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动flink</span></span><br><span class="line">    environment.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211123203651880.png" alt="image-20211123203651880"></p><p>可以很直观的看到当我们用nc模拟的时候，只要有数据输入，那么控制台就会瞬间(几毫秒)输出结果。源源不断的数据输入，就会有源源不断的数据输出。这个也被称为 <strong>无界流</strong>。</p><p>当然了，在Flink中，上游task对下游task发送数据是有条件的</p><ul><li>数据达到32K(buffer)</li><li>时间达到200毫秒</li></ul><p>在Flink中，所有的task是一起启动的。</p><p><strong>Spark和Flink任务调度方式</strong>(Flink和Spark都是粗粒度调度资源，即一开始就将资源全部申请下来)</p><table><thead><tr><th>Spark任务调度</th><th>Flink任务调度</th></tr></thead><tbody><tr><td>1、构建DAG有向无环图</td><td>1、构建DataFlow</td></tr><tr><td>2、切分Stage</td><td>2、拆分成多个task</td></tr><tr><td>3、按照顺序将stage发送到taskScheduler</td><td>3、将所有task部署启动</td></tr><tr><td>4、taskScheduler将task发送到Executor中执行</td><td>4、等待数据流入并且处理数据</td></tr><tr><td>其中Spark是MapReduce模型</td><td>Flink是持续流模型</td></tr></tbody></table><h2 id="有界流和无界流"><a href="#有界流和无界流" class="headerlink" title="有界流和无界流"></a>有界流和无界流</h2><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211123214010094.png" alt="image-20211123214010094"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211123220828681.png" alt="image-20211123220828681"></p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><h3 id="基于本地集合构建DataStream"><a href="#基于本地集合构建DataStream" class="headerlink" title="基于本地集合构建DataStream"></a><strong>基于本地集合构建DataStream</strong></h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fst.sink</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Demo1Source</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Flink环境</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> environment: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置并行度</span></span><br><span class="line">    environment.setParallelism(<span class="number">2</span>)</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于本地集合构建DataStream  ----有界流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> listDS: <span class="type">DataStream</span>[<span class="type">Int</span>] = environment.fromCollection(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>))</span><br><span class="line">    listDS.print()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动flink</span></span><br><span class="line">    environment.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211123214352614.png" alt="image-20211123214352614"></p><p>可以看到运行完毕之后程序就被终止了，有界流。</p><h3 id="基于文件构建DataStream"><a href="#基于文件构建DataStream" class="headerlink" title="基于文件构建DataStream"></a>基于文件构建DataStream</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.fst.sink</span><br><span class="line"></span><br><span class="line">import org.apache.flink.streaming.api.scala._</span><br><span class="line"></span><br><span class="line">object Demo1Source &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建Flink环境</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    val environment: StreamExecutionEnvironment = StreamExecutionEnvironment.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line">    // 设置并行度</span><br><span class="line">    environment.setParallelism(2)</span><br><span class="line">    /**</span><br><span class="line">     * 基于文件构建DataStream     ----有界流</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    val studentDS: DataStream[String] = environment.readTextFile(&quot;data/students.txt&quot;)</span><br><span class="line"></span><br><span class="line">    studentDS</span><br><span class="line">      .map(line=&gt;(line.split(&quot;,&quot;)(4),1))</span><br><span class="line">      .keyBy(word=&gt;(word,1))</span><br><span class="line">      .sum(1)</span><br><span class="line">      .print()</span><br><span class="line"></span><br><span class="line">    // 启动flink</span><br><span class="line">    environment.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211123215548257.png" alt="image-20211123215548257"></p><p>可以很直观的看到班级人数已经统计出来了。</p><h3 id="基于Socket构建DataStream"><a href="#基于Socket构建DataStream" class="headerlink" title="基于Socket构建DataStream"></a>基于Socket构建DataStream</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.fst.sink</span><br><span class="line"></span><br><span class="line">import org.apache.flink.streaming.api.scala._</span><br><span class="line"></span><br><span class="line">object Demo1Source &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建Flink环境</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    val environment: StreamExecutionEnvironment = StreamExecutionEnvironment.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line">    // 设置并行度</span><br><span class="line">    environment.setParallelism(2)</span><br><span class="line">    /**</span><br><span class="line">     * 基于Socket构建DataStream   ----无界流</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    val socketDS: DataStream[String] = environment.socketTextStream(&quot;master&quot;, 8888)</span><br><span class="line">    socketDS.print()</span><br><span class="line"></span><br><span class="line">    // 启动flink</span><br><span class="line">    environment.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211123215813840.png" alt="image-20211123215813840"></p><p>可以很直观的看到，模拟端输入数据之后，控制台就会立即响应并且输出数据。</p><h3 id="自定义source"><a href="#自定义source" class="headerlink" title="自定义source"></a>自定义source</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fst.sink</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Demo1Source</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Flink环境</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> environment: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置并行度</span></span><br><span class="line">    environment.setParallelism(<span class="number">2</span>)</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义source，实现SourceFunction接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> myDS: <span class="type">DataStream</span>[<span class="type">Int</span>] = environment.addSource(<span class="keyword">new</span> <span class="type">MySource</span>)</span><br><span class="line"></span><br><span class="line">    myDS.print()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动flink</span></span><br><span class="line">    environment.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义source，实现SourceFunction接口</span></span><br><span class="line"><span class="comment">     * 实现run方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MySource</span> <span class="keyword">extends</span> <span class="title">SourceFunction</span>[<span class="type">Int</span>]</span>&#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(sourceContext: <span class="type">SourceFunction</span>.<span class="type">SourceContext</span>[<span class="type">Int</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;   <span class="comment">// 这边要是死循环就是无界流，要是有限循环就是有界流。</span></span><br><span class="line">          <span class="comment">// 将数据发送到下游</span></span><br><span class="line">          sourceContext.collect(i)</span><br><span class="line"></span><br><span class="line">          <span class="type">Thread</span>.sleep(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">          i += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 再任务取消的时候执行，用于回收资源</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">cancel</span></span>(): <span class="type">Unit</span> = &#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="自定义source读取mysql数据"><a href="#自定义source读取mysql数据" class="headerlink" title="自定义source读取mysql数据"></a>自定义source读取mysql数据</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fst.source</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.<span class="type">Configuration</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.&#123;<span class="type">RichSourceFunction</span>, <span class="type">SourceFunction</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala._</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.&#123;<span class="type">Connection</span>, <span class="type">DriverManager</span>, <span class="type">PreparedStatement</span>, <span class="type">ResultSet</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Demo2MysqlSource</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> environment: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line">    environment.setParallelism(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用自定义source</span></span><br><span class="line">    <span class="keyword">val</span> myDS: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">String</span>, <span class="type">String</span>, <span class="type">Int</span>)] = environment.addSource(<span class="keyword">new</span> <span class="type">MysqlSource</span>)</span><br><span class="line"></span><br><span class="line">    myDS.print()</span><br><span class="line"></span><br><span class="line">    environment.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义读取mysql  ----有界流</span></span><br><span class="line"><span class="comment"> * SourceFunction ----单一的source，run方法只会执行一次</span></span><br><span class="line"><span class="comment"> * ParallelSourceFunction  ----并行的source，有多少个并行度就会有多少个source</span></span><br><span class="line"><span class="comment"> * RichSourceFunction  多了open和close方法</span></span><br><span class="line"><span class="comment"> * RichParallelSourceFunction</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MysqlSource</span> <span class="keyword">extends</span> <span class="title">RichSourceFunction</span>[(<span class="type">String</span>, <span class="type">String</span>, <span class="type">String</span>, <span class="type">Int</span>)] </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> con: <span class="type">Connection</span> = _</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * open 方法会再run方法之前执行</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param parameters flink 配置文件对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">open</span></span>(parameters: <span class="type">Configuration</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//加载驱动</span></span><br><span class="line">    <span class="type">Class</span>.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、建立链接</span></span><br><span class="line">    con = <span class="type">DriverManager</span>.getConnection(<span class="string">&quot;jdbc:mysql://master:3306/tour&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在run方法之后执行</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//关闭链接</span></span><br><span class="line">    con.close()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(ctx: <span class="type">SourceFunction</span>.<span class="type">SourceContext</span>[(<span class="type">String</span>, <span class="type">String</span>, <span class="type">String</span>, <span class="type">Int</span>)]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//查询数据</span></span><br><span class="line">    <span class="keyword">val</span> stat: <span class="type">PreparedStatement</span> = con.prepareStatement(<span class="string">&quot;select * from usertag limit 2&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> resultSet: <span class="type">ResultSet</span> = stat.executeQuery()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析数据</span></span><br><span class="line">    <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> mdn: <span class="type">String</span> = resultSet.getString(<span class="string">&quot;mdn&quot;</span>)</span><br><span class="line">      <span class="keyword">val</span> name: <span class="type">String</span> = resultSet.getString(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">      <span class="keyword">val</span> gender: <span class="type">String</span> = resultSet.getString(<span class="string">&quot;gender&quot;</span>)</span><br><span class="line">      <span class="keyword">val</span> age: <span class="type">Int</span> = resultSet.getInt(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">      <span class="comment">//将数据发送到下游</span></span><br><span class="line">      ctx.collect((mdn, name, gender, age))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">cancel</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211124100217567.png" alt="image-20211124100217567"></p><h2 id="Flink中的算子"><a href="#Flink中的算子" class="headerlink" title="Flink中的算子"></a>Flink中的算子</h2><p>GitHub仓库地址: <a href="https://github.com/Fang-gg/Flink.git">https://github.com/Fang-gg/Flink.git</a></p><h2 id="Flink集群模式搭建"><a href="#Flink集群模式搭建" class="headerlink" title="Flink集群模式搭建"></a>Flink集群模式搭建</h2><h3 id="standallone-cluster"><a href="#standallone-cluster" class="headerlink" title="standallone cluster"></a>standallone cluster</h3><h4 id="上传解压并配置环境变量"><a href="#上传解压并配置环境变量" class="headerlink" title="上传解压并配置环境变量"></a>上传解压并配置环境变量</h4><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211125192813480.png" alt="image-20211125192813480"></p><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim conf/flink-conf.yaml</span><br><span class="line">jobmanager.rpc.address: master   主节点ip地址</span><br><span class="line">vim conf/masters  </span><br><span class="line">改成主节点ip</span><br></pre></td></tr></table></figure><p>由于我这里的集群条件是伪分布式，因此不需要分发节点。</p><h4 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h4><blockquote><p>start-cluster.sh</p></blockquote><h4 id="访问web界面"><a href="#访问web界面" class="headerlink" title="访问web界面"></a>访问web界面</h4><blockquote><p><a href="http://master:8081/">http://master:8081</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211125193517985.png" alt="image-20211125193517985"></p><h4 id="提交任务-–-将代码打包"><a href="#提交任务-–-将代码打包" class="headerlink" title="提交任务  – 将代码打包"></a>提交任务  – 将代码打包</h4><ul><li>在web界面提交<ul><li>将代码打包并且通过web界面上传，之后submit即可</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211125194133242.png" alt="image-20211125194133242"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211125194226248.png" alt="image-20211125194226248"></p><p>输入数据之后在web端的Task Managers处查看结果</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211125194758348.png" alt="image-20211125194758348"></p><ul><li>用flink命令提交任务<ul><li>flink run -c 类名 flink-1.0.jar </li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211125200050988.png" alt="image-20211125200050988"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211125200113427.png" alt="image-20211125200113427"></p><p>可以很明显的看到任务已经在运行了。</p><h3 id="flink-on-yarn"><a href="#flink-on-yarn" class="headerlink" title="flink on yarn"></a>flink on yarn</h3><h4 id="配置HADOOP-CONF-DIR"><a href="#配置HADOOP-CONF-DIR" class="headerlink" title="配置HADOOP_CONF_DIR"></a>配置HADOOP_CONF_DIR</h4><blockquote><p> vim /etc/profile</p><p> export HADOOP_CONF_DIR=/usr/local/soft/hadoop-2.7.6/etc/hadoop/</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211125200757086.png" alt="image-20211125200757086"></p><h4 id="上传依赖"><a href="#上传依赖" class="headerlink" title="上传依赖"></a>上传依赖</h4><blockquote><p>将hadoop依赖jar上传到flink  lib目录</p><p>flink-shaded-hadoop-2-uber-2.6.5-10.0</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211125201444705.png" alt="image-20211125201444705"></p><p>flink和spark一样都是粗粒度资源申请</p><h4 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h4><blockquote><p>yarn-session  在yarn里面启动一个flink集群 jobManager(ApplicationMaster)</p><p>先启动hadoop </p><p>yarn-session.sh -jm 1024m -tm 1096m</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211125202137982.png" alt="image-20211125202137982"></p><h4 id="任务提交"><a href="#任务提交" class="headerlink" title="任务提交"></a>任务提交</h4><p>和standallone一样。额外不同的是yarn中可以直接提交任务到yarn。命令如下</p><blockquote><p>flink run -m yarn-cluster  -yjm 1024m -ytm 1096m -c 任务名 上传的jar包</p><p>flink run -m yarn-cluster  -yjm 1024m -ytm 1096m -c com.fst.core.Demo1WordCount flink-1.0.jar</p></blockquote><ul><li><p>yarn-session先在yarn中启动一个jobMansager ,所有的任务共享一个jobmanager (提交任务更快，任务之间共享jobmanager ， 相互有影响)</p></li><li><p>直接提交任务模型，为每一个任务启动一个joibmanager （每一个任务独立jobmanager , 任务运行稳定）</p></li></ul><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><h3 id="Kafka的搭建"><a href="#Kafka的搭建" class="headerlink" title="Kafka的搭建"></a>Kafka的搭建</h3><ul><li>修改config/server.properties<ul><li>1、broker.id=0，每一个节点broker.id 要不一样<br>2、zookeeper.connect=master:2181,node1:2181,node2:2181<br>3、log.dirs=/usr/local/soft/kafka_2.11-1.0.0/data   消息存放的位置</li></ul></li><li>启动<ul><li>先启动zk，因为kafka需要建立在zookeeper上。</li><li>接着在每台节点启动broker，kafka是去中心化的架构   -daemon 后台启动   在所有节点启动<ul><li>kafka-server-start.sh -daemon  /usr/local/soft/kafka_2.11-1.0.0/config/server.properties</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211125221544600.png" alt="image-20211125221544600"></p><p>kafka是一个消息队列。其架构如下所示</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211125212237561.png" alt="image-20211125212237561"></p><h3 id="kafka的消息存储和生产消费模型"><a href="#kafka的消息存储和生产消费模型" class="headerlink" title="kafka的消息存储和生产消费模型"></a>kafka的消息存储和生产消费模型</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211125213016639.png" alt="image-20211125213016639"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211125213315146.png" alt="image-20211125213315146"></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211125214004375.png" alt="image-20211125214004375"></p>]]></content>
      
      
      <categories>
          
          <category> 大数据学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目--离线数仓</title>
      <link href="/2021/11/19/%E9%A1%B9%E7%9B%AE-%E7%A6%BB%E7%BA%BF%E6%95%B0%E4%BB%93/"/>
      <url>/2021/11/19/%E9%A1%B9%E7%9B%AE-%E7%A6%BB%E7%BA%BF%E6%95%B0%E4%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="大数据项目之旅游集市"><a href="#大数据项目之旅游集市" class="headerlink" title="大数据项目之旅游集市"></a>大数据项目之旅游集市</h1><p>实习期间做了一个与大数据相关的项目，想记录下来，因为项目用的是分布式集群，因此我用自己电脑重新做了一遍这个项目，顺带熟悉熟悉流程。</p><p>本项目是关于合肥市的一个旅游项目，通过对合肥市的分析，得出相应的指标与结果。</p><p>项目代码可以看我的GitHub仓库，地址: <a href="https://github.com/Fang-gg/CountingWarehouse.git">https://github.com/Fang-gg/CountingWarehouse.git</a></p><p><font color="red">这里我是用伪分布式进行操作的。</font></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211119193337383.png" alt="image-20211119193337383"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211119182736341.png" alt="image-20211119182736341"></p><h2 id="1-项目总流程图"><a href="#1-项目总流程图" class="headerlink" title="1.项目总流程图"></a>1.项目总流程图</h2><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B.png" alt="数据流程"></p><blockquote><p>由于我们只负责数据从flume端拉来处理，所以纵观整个项目的架构，可以将数据处理分为四层，分别为ods（贴源层）、dwi（整合层）、dal_tour（旅游集市层）、dim（维表层），最终由dal_tour的结果存储在数据库便于数据展示</p></blockquote><h2 id="2-前期准备"><a href="#2-前期准备" class="headerlink" title="2.前期准备"></a>2.前期准备</h2><h3 id="2-1-开启hadoop的权限验证"><a href="#2-1-开启hadoop的权限验证" class="headerlink" title="2.1 开启hadoop的权限验证"></a>2.1 开启hadoop的权限验证</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">关闭hadoop</span><br><span class="line">stop-all.sh</span><br><span class="line"></span><br><span class="line">修改hdfs-site.xml文件</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.permissions&lt;/name&gt;</span><br><span class="line">&lt;value&gt;true&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">启动hadoop</span><br><span class="line">start-all.sh</span><br></pre></td></tr></table></figure><h3 id="2-2-在hive中创建数据库-root"><a href="#2-2-在hive中创建数据库-root" class="headerlink" title="2.2 在hive中创建数据库(root)"></a>2.2 在hive中创建数据库(root)</h3><p>数据仓库分层中，每一个层对应hive中一个数据库，对应hdfs中一个目录</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">通过root用户先创建</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> database ods;</span><br><span class="line"><span class="keyword">create</span> database dwd;</span><br><span class="line"><span class="keyword">create</span> database dws;</span><br><span class="line"><span class="keyword">create</span> database dim;</span><br><span class="line"><span class="keyword">create</span> database ads;</span><br></pre></td></tr></table></figure><h3 id="2-3-在hdfs中创建5个目录-root"><a href="#2-3-在hdfs中创建5个目录-root" class="headerlink" title="2.3 在hdfs中创建5个目录(root)"></a>2.3 在hdfs中创建5个目录(root)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先用root用户创建</span><br><span class="line"></span><br><span class="line">hadoop dfs -mkdir -p /daas/motl/ods/</span><br><span class="line">hadoop dfs -mkdir -p /daas/motl/dim/</span><br><span class="line">hadoop dfs -mkdir -p /daas/motl/dwd/</span><br><span class="line">hadoop dfs -mkdir -p /daas/motl/dws/</span><br><span class="line">hadoop dfs -mkdir -p /daas/motl/ads/</span><br></pre></td></tr></table></figure><h3 id="2-4-在linux中创建5个用户-root"><a href="#2-4-在linux中创建5个用户-root" class="headerlink" title="2.4 在linux中创建5个用户(root)"></a>2.4 在linux中创建5个用户(root)</h3><blockquote><p>这是为了模拟在企业中的真实开发  每一个用户对应一个层</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">useradd ods</span><br><span class="line">passwd ods</span><br><span class="line"></span><br><span class="line">useradd dwd</span><br><span class="line">passwd dwd</span><br><span class="line"></span><br><span class="line">useradd dws</span><br><span class="line">passwd dws</span><br><span class="line"></span><br><span class="line">useradd dim</span><br><span class="line">passwd dim</span><br><span class="line"></span><br><span class="line">useradd ads</span><br><span class="line">passwd ads</span><br></pre></td></tr></table></figure><h3 id="2-5-分配权限-root"><a href="#2-5-分配权限-root" class="headerlink" title="2.5 分配权限(root)"></a>2.5 分配权限(root)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用root用户修改权限</span><br><span class="line"></span><br><span class="line">hadoop dfs -chown ods:ods /daas/motl/ods/</span><br><span class="line">hadoop dfs -chown dwd:dwd /daas/motl/dwd/</span><br><span class="line">hadoop dfs -chown dws:dws /daas/motl/dws/</span><br><span class="line">hadoop dfs -chown dim:dim /daas/motl/dim/</span><br><span class="line">hadoop dfs -chown ads:ads /daas/motl/ads/</span><br></pre></td></tr></table></figure><h3 id="2-6-修改hive权限"><a href="#2-6-修改hive权限" class="headerlink" title="2.6 修改hive权限"></a>2.6 修改hive权限</h3><blockquote><p>如果不对hive文件权限进行修改，那么后面几个模拟的用户可能访问不了</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">删除hive的tmp目录</span><br><span class="line">rm -rf /usr/local/soft/hive-1.2.1/tmp</span><br><span class="line"></span><br><span class="line">修改权限</span><br><span class="line">chmod 777 /usr/local/soft/hive-1.2.1</span><br></pre></td></tr></table></figure><h3 id="2-7-为每一个用户在HDFS中创建目录-root"><a href="#2-7-为每一个用户在HDFS中创建目录-root" class="headerlink" title="2.7 为每一个用户在HDFS中创建目录(root)"></a>2.7 为每一个用户在HDFS中创建目录(root)</h3><p>why？ 因为后续每一个用户在运行spark代码的时候都会在user下面创建各自的目录去存放临时文件或者日志，如果不创建且对各个用户进行权限分配，那么就会报错。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hadoop dfs -mkdir /user/dwd/</span><br><span class="line">hadoop dfs -chown dwd:dwd /user/dwd</span><br><span class="line"></span><br><span class="line">hadoop dfs -mkdir /user/dws/</span><br><span class="line">hadoop dfs -chown dws:dws /user/dws</span><br><span class="line"></span><br><span class="line">hadoop dfs -mkdir /user/dim/</span><br><span class="line">hadoop dfs -chown dim:dim /user/dim</span><br><span class="line"></span><br><span class="line">hadoop dfs -mkdir /user/ads/</span><br><span class="line">hadoop dfs -chown ads:ads /user/ads</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211119193415496.png" alt="image-20211119193415496"></p><h2 id="3-具体实现"><a href="#3-具体实现" class="headerlink" title="3.具体实现"></a>3.具体实现</h2><h3 id="3-1-开始在ODS贴源层上传数据"><a href="#3-1-开始在ODS贴源层上传数据" class="headerlink" title="3.1 开始在ODS贴源层上传数据"></a>3.1 开始在ODS贴源层上传数据</h3><h4 id="3-1-1-使用ODS用户登录，并且进入hive"><a href="#3-1-1-使用ODS用户登录，并且进入hive" class="headerlink" title="3.1.1 使用ODS用户登录，并且进入hive"></a>3.1.1 使用ODS用户登录，并且进入hive</h4><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211119182827517.png" alt="image-20211119182827517"></p><h4 id="3-1-2-创建ODS中的四张表-数据如下"><a href="#3-1-2-创建ODS中的四张表-数据如下" class="headerlink" title="3.1.2 创建ODS中的四张表(数据如下)"></a>3.1.2 创建ODS中的四张表(数据如下)</h4><p><strong>ods_ddr</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> ods.ods_ddr(</span><br><span class="line">    mdn string comment <span class="string">&#x27;手机号码&#x27;</span>  </span><br><span class="line">    ,start_time string comment <span class="string">&#x27;业务时间&#x27;</span>  </span><br><span class="line">    ,county_id string comment <span class="string">&#x27;区县编码&#x27;</span>  </span><br><span class="line">    ,longi string comment <span class="string">&#x27;经度&#x27;</span>  </span><br><span class="line">    ,lati string comment <span class="string">&#x27;纬度&#x27;</span>  </span><br><span class="line">    ,bsid string comment <span class="string">&#x27;基站标识&#x27;</span>  </span><br><span class="line">    ,grid_id string comment <span class="string">&#x27;网格号&#x27;</span>  </span><br><span class="line">    ,biz_type string comment <span class="string">&#x27;业务类型&#x27;</span>  </span><br><span class="line">    ,event_type string comment <span class="string">&#x27;事件类型&#x27;</span>  </span><br><span class="line">    ,data_source string comment <span class="string">&#x27;数据源&#x27;</span>  </span><br><span class="line">) </span><br><span class="line">comment  <span class="string">&#x27;ddr&#x27;</span></span><br><span class="line">PARTITIONED <span class="keyword">BY</span> (</span><br><span class="line">    day_id string comment <span class="string">&#x27;天分区&#x27;</span>  </span><br><span class="line">) </span><br><span class="line"><span class="type">ROW</span> FORMAT DELIMITED  FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\t&#x27;</span> </span><br><span class="line">STORED <span class="keyword">AS</span> INPUTFORMAT <span class="string">&#x27;org.apache.hadoop.mapred.TextInputFormat&#x27;</span> </span><br><span class="line">    OUTPUTFORMAT <span class="string">&#x27;org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat&#x27;</span>  </span><br><span class="line">location <span class="string">&#x27;/daas/motl/ods/ods_ddr&#x27;</span>; </span><br></pre></td></tr></table></figure><p><strong>ods_dpi</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> ods.ods_dpi(</span><br><span class="line">    mdn string comment <span class="string">&#x27;手机号码&#x27;</span>  </span><br><span class="line">    ,start_time string comment <span class="string">&#x27;业务开始时间&#x27;</span>  </span><br><span class="line">    ,county_id string comment <span class="string">&#x27;区县编码&#x27;</span>  </span><br><span class="line">    ,longi string comment <span class="string">&#x27;经度&#x27;</span>  </span><br><span class="line">    ,lati string comment <span class="string">&#x27;纬度&#x27;</span>  </span><br><span class="line">    ,bsid string comment <span class="string">&#x27;基站标识&#x27;</span>  </span><br><span class="line">    ,grid_id string comment <span class="string">&#x27;网格号&#x27;</span>  </span><br><span class="line">    ,biz_type string comment <span class="string">&#x27;业务类型&#x27;</span>  </span><br><span class="line">    ,event_type string comment <span class="string">&#x27;事件类型&#x27;</span>  </span><br><span class="line">    ,data_source string comment <span class="string">&#x27;数据源&#x27;</span>  </span><br><span class="line">) </span><br><span class="line">comment  <span class="string">&#x27;位置数据融合表&#x27;</span></span><br><span class="line">PARTITIONED <span class="keyword">BY</span> (</span><br><span class="line">    day_id string comment <span class="string">&#x27;天分区&#x27;</span>  </span><br><span class="line">) </span><br><span class="line"><span class="type">ROW</span> FORMAT DELIMITED </span><br><span class="line">    FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\t&#x27;</span> </span><br><span class="line">STORED <span class="keyword">AS</span> INPUTFORMAT <span class="string">&#x27;org.apache.hadoop.mapred.TextInputFormat&#x27;</span> </span><br><span class="line">    OUTPUTFORMAT <span class="string">&#x27;org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat&#x27;</span>  </span><br><span class="line">location <span class="string">&#x27;/daas/motl/ods/ods_dpi&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>ods_oidd</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> ods.ods_oidd(</span><br><span class="line">    mdn string comment <span class="string">&#x27;手机号码&#x27;</span>  </span><br><span class="line">    ,start_time string comment <span class="string">&#x27;业务开始时间&#x27;</span>  </span><br><span class="line">    ,county_id string comment <span class="string">&#x27;区县编码&#x27;</span>  </span><br><span class="line">    ,longi string comment <span class="string">&#x27;经度&#x27;</span>  </span><br><span class="line">    ,lati string comment <span class="string">&#x27;纬度&#x27;</span>  </span><br><span class="line">    ,bsid string comment <span class="string">&#x27;基站标识&#x27;</span>  </span><br><span class="line">    ,grid_id string comment <span class="string">&#x27;网格号&#x27;</span>  </span><br><span class="line">    ,biz_type string comment <span class="string">&#x27;业务类型&#x27;</span>  </span><br><span class="line">    ,event_type string comment <span class="string">&#x27;事件类型&#x27;</span>  </span><br><span class="line">    ,data_source string comment <span class="string">&#x27;数据源&#x27;</span>  </span><br><span class="line">) </span><br><span class="line">comment  <span class="string">&#x27;oidd&#x27;</span></span><br><span class="line">PARTITIONED <span class="keyword">BY</span> (</span><br><span class="line">    day_id string comment <span class="string">&#x27;天分区&#x27;</span>  </span><br><span class="line">) </span><br><span class="line"><span class="type">ROW</span> FORMAT DELIMITED </span><br><span class="line">    FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\t&#x27;</span> </span><br><span class="line">STORED <span class="keyword">AS</span> INPUTFORMAT <span class="string">&#x27;org.apache.hadoop.mapred.TextInputFormat&#x27;</span> </span><br><span class="line">    OUTPUTFORMAT <span class="string">&#x27;org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat&#x27;</span>  </span><br><span class="line">location <span class="string">&#x27;/daas/motl/ods/ods_oidd&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>ods_wcdr</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE EXTERNAL TABLE IF NOT EXISTS ods.ods_wcdr (</span><br><span class="line">    mdn string comment &#x27;手机号码&#x27;  </span><br><span class="line">    ,start_time string comment &#x27;业务开始时间&#x27;  </span><br><span class="line">    ,county_id string comment &#x27;区县编码&#x27;  </span><br><span class="line">    ,longi string comment &#x27;经度&#x27;  </span><br><span class="line">    ,lati string comment &#x27;纬度&#x27;  </span><br><span class="line">    ,bsid string comment &#x27;基站标识&#x27;  </span><br><span class="line">    ,grid_id string comment &#x27;网格号&#x27;  </span><br><span class="line">    ,biz_type string comment &#x27;业务类型&#x27;  </span><br><span class="line">    ,event_type string comment &#x27;事件类型&#x27;  </span><br><span class="line">    ,data_source string comment &#x27;数据源&#x27;  </span><br><span class="line">) </span><br><span class="line">comment  &#x27;wcdr&#x27;</span><br><span class="line">PARTITIONED BY (</span><br><span class="line">    day_id string comment &#x27;天分区&#x27;  </span><br><span class="line">) </span><br><span class="line">ROW FORMAT DELIMITED </span><br><span class="line">    FIELDS TERMINATED BY &#x27;\t&#x27; </span><br><span class="line">STORED AS INPUTFORMAT &#x27;org.apache.hadoop.mapred.TextInputFormat&#x27; </span><br><span class="line">    OUTPUTFORMAT &#x27;org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat&#x27;  </span><br><span class="line">location &#x27;/daas/motl/ods/ods_wcdr&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211119183217526.png" alt="image-20211119183217526"></p><h4 id="3-1-3-将四张表数据分别上传到HDFS中"><a href="#3-1-3-将四张表数据分别上传到HDFS中" class="headerlink" title="3.1.3 将四张表数据分别上传到HDFS中"></a>3.1.3 将四张表数据分别上传到HDFS中</h4><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211119183419236.png" alt="image-20211119183419236"></p><h4 id="3-1-4-增加分区形成映射"><a href="#3-1-4-增加分区形成映射" class="headerlink" title="3.1.4 增加分区形成映射"></a>3.1.4 增加分区形成映射</h4><p>此时数据已经上传到了HDFS中，但是要想在hive中查询到，则需要添加分区，因为创表的时候就已经做分区了。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table ods.ods_ddr add if not exists partition(day_id=&#x27;20180503&#x27;);</span><br><span class="line">alter table ods.ods_dpi add if not exists partition(day_id=&#x27;20180503&#x27;);</span><br><span class="line">alter table ods.ods_oidd add if not exists partition(day_id=&#x27;20180503&#x27;);</span><br><span class="line">alter table ods.ods_wcdr add if not exists partition(day_id=&#x27;20180503&#x27;);</span><br></pre></td></tr></table></figure><p>当然了做表修复也可以。当表与数据文件之间的映射关系没有建立起来时，可以对表进行修复，重新建立映射关系。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msck repair table xxx--你自己表的名称;</span><br></pre></td></tr></table></figure><h4 id="3-1-5-简单查询几条数据"><a href="#3-1-5-简单查询几条数据" class="headerlink" title="3.1.5 简单查询几条数据"></a>3.1.5 简单查询几条数据</h4><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211119184311745.png" alt="image-20211119184311745"></p><h3 id="此时ods数据已经导入，接下来进行DWD中的操作，也就是位置融合表"><a href="#此时ods数据已经导入，接下来进行DWD中的操作，也就是位置融合表" class="headerlink" title="此时ods数据已经导入，接下来进行DWD中的操作，也就是位置融合表"></a>此时ods数据已经导入，接下来进行DWD中的操作，也就是位置融合表</h3><h3 id="3-2-位置融合表-DWD层"><a href="#3-2-位置融合表-DWD层" class="headerlink" title="3.2 位置融合表(DWD层)"></a>3.2 位置融合表(DWD层)</h3><h4 id="3-2-1-创建相应项目"><a href="#3-2-1-创建相应项目" class="headerlink" title="3.2.1 创建相应项目"></a>3.2.1 创建相应项目</h4><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211119185033016.png" alt="image-20211119185033016"></p><h4 id="3-2-2-登录dwd用户并且创建融合表"><a href="#3-2-2-登录dwd用户并且创建融合表" class="headerlink" title="3.2.2 登录dwd用户并且创建融合表"></a>3.2.2 登录dwd用户并且创建融合表</h4><p><strong>dwd.dwd_res_regn_mergelocation_msk_d表结构如下所示</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> dwd.dwd_res_regn_mergelocation_msk_d (</span><br><span class="line">    mdn string comment <span class="string">&#x27;手机号码&#x27;</span>  </span><br><span class="line">    ,start_time string comment <span class="string">&#x27;业务时间&#x27;</span>  </span><br><span class="line">    ,county_id string comment <span class="string">&#x27;区县编码&#x27;</span>  </span><br><span class="line">    ,longi string comment <span class="string">&#x27;经度&#x27;</span>  </span><br><span class="line">    ,lati string comment <span class="string">&#x27;纬度&#x27;</span>  </span><br><span class="line">    ,bsid string comment <span class="string">&#x27;基站标识&#x27;</span>  </span><br><span class="line">    ,grid_id string comment <span class="string">&#x27;网格号&#x27;</span>  </span><br><span class="line">    ,biz_type string comment <span class="string">&#x27;业务类型&#x27;</span>  </span><br><span class="line">    ,event_type string comment <span class="string">&#x27;事件类型&#x27;</span>  </span><br><span class="line">    ,data_source string comment <span class="string">&#x27;数据源&#x27;</span>  </span><br><span class="line">) </span><br><span class="line">comment  <span class="string">&#x27;位置数据融合表&#x27;</span></span><br><span class="line">PARTITIONED <span class="keyword">BY</span> (</span><br><span class="line">    day_id string comment <span class="string">&#x27;天分区&#x27;</span>  </span><br><span class="line">) </span><br><span class="line"><span class="type">ROW</span> FORMAT DELIMITED </span><br><span class="line">    FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\t&#x27;</span> </span><br><span class="line">STORED <span class="keyword">AS</span> INPUTFORMAT <span class="string">&#x27;org.apache.hadoop.mapred.TextInputFormat&#x27;</span> </span><br><span class="line">    OUTPUTFORMAT <span class="string">&#x27;org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat&#x27;</span>  </span><br><span class="line">location <span class="string">&#x27;/daas/motl/dwd/dwd_res_regn_mergelocation_msk_d&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211119190755490.png" alt="image-20211119190755490"></p><h4 id="3-2-3-编写融合表代码-spark编写"><a href="#3-2-3-编写融合表代码-spark编写" class="headerlink" title="3.2.3 编写融合表代码(spark编写)"></a>3.2.3 编写融合表代码(spark编写)</h4><p>融合表就是将ods层中的四张表合在一起，因为之前的表都是分区表，所以融合表也需要有分区。具体代码如下</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fst.dwd</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">SparkSession</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DwdResRegnMergelocationMskD</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建spark环境</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> spark: <span class="type">SparkSession</span> = <span class="type">SparkSession</span></span><br><span class="line">      .builder()</span><br><span class="line">      .appName(<span class="string">&quot;DwdResRegnMergelocationMskD&quot;</span>)</span><br><span class="line">      .enableHiveSupport() <span class="comment">// 开启Hive支持</span></span><br><span class="line">      .getOrCreate()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取时间参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> day_id: <span class="type">String</span> = args(<span class="number">0</span>)   <span class="comment">// 需要我们自己传进来</span></span><br><span class="line">    <span class="comment">// union all不会去重，因此用union all</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> org.apache.spark.sql.functions.md5</span><br><span class="line"></span><br><span class="line">    spark.sql(</span><br><span class="line">      <span class="string">s&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        |</span></span><br><span class="line"><span class="string">        |insert overwrite table dwd.dwd_res_regn_mergelocation_msk_d partition(day_id=$day_id)</span></span><br><span class="line"><span class="string">        |</span></span><br><span class="line"><span class="string">        |select</span></span><br><span class="line"><span class="string">        | md5(mdn) as mdn,</span></span><br><span class="line"><span class="string">        | start_time,</span></span><br><span class="line"><span class="string">        | county_id,</span></span><br><span class="line"><span class="string">        | longi,</span></span><br><span class="line"><span class="string">        | lati,</span></span><br><span class="line"><span class="string">        | bsid,</span></span><br><span class="line"><span class="string">        | grid_id,</span></span><br><span class="line"><span class="string">        | biz_type,</span></span><br><span class="line"><span class="string">        | event_type,</span></span><br><span class="line"><span class="string">        | data_source</span></span><br><span class="line"><span class="string">        |</span></span><br><span class="line"><span class="string">        |from (</span></span><br><span class="line"><span class="string">        |(select * from ods.ods_ddr where day_id = $day_id)</span></span><br><span class="line"><span class="string">        |union all</span></span><br><span class="line"><span class="string">        |(select * from ods.ods_dpi where day_id = $day_id)</span></span><br><span class="line"><span class="string">        |union all</span></span><br><span class="line"><span class="string">        |(select * from ods.ods_wcdr where day_id = $day_id)</span></span><br><span class="line"><span class="string">        |union all</span></span><br><span class="line"><span class="string">        |(select * from ods.ods_oidd where day_id = $day_id)</span></span><br><span class="line"><span class="string">        |)</span></span><br><span class="line"><span class="string">        |&quot;</span><span class="string">&quot;&quot;</span>.stripMargin)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-4-打包并且上传运行-在dwd用户下运行"><a href="#3-2-4-打包并且上传运行-在dwd用户下运行" class="headerlink" title="3.2.4 打包并且上传运行(在dwd用户下运行)"></a>3.2.4 打包并且上传运行(在dwd用户下运行)</h4><p>在最外层的maven中进行打包，此时最外层的pom文件需要进行配置</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211119193903206.png" alt="image-20211119193903206"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211119193742475.png" alt="image-20211119193742475"></p><h4 id="3-2-5-运行指令"><a href="#3-2-5-运行指令" class="headerlink" title="3.2.5 运行指令"></a>3.2.5 运行指令</h4><blockquote><p>spark-submit –master yarn-client –class com.fst.dwd.DwdResRegnMergelocationMskD –num-executors 1 –executor-memory 6G –executor-cores 3 dwd-1.0.jar 20180503</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211119195025129.png" alt="image-20211119195025129"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211119195622808.png" alt="image-20211119195622808"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211119195837222.png" alt="image-20211119195837222"></p><p>可以看到已经成功了。</p><h4 id="3-2-6-查看数据"><a href="#3-2-6-查看数据" class="headerlink" title="3.2.6 查看数据"></a>3.2.6 查看数据</h4><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211119200002891.png" alt="image-20211119200002891"></p><p>至此，DWD层的融合表已经处理完毕了。接下来就是DWS层。</p><h3 id="3-3-停留表-DWS层"><a href="#3-3-停留表-DWS层" class="headerlink" title="3.3 停留表(DWS层)"></a>3.3 停留表(DWS层)</h3><p>融合表是点级别的，也就是说一条数据就是一个点;停留表是网格级别的，也就是说一条数据就是一个网格，是一个人在一个网格中的数据。</p><h4 id="3-3-1-使用DWS用户并且建立停留表"><a href="#3-3-1-使用DWS用户并且建立停留表" class="headerlink" title="3.3.1 使用DWS用户并且建立停留表"></a>3.3.1 使用DWS用户并且建立停留表</h4><p><strong>dws.dws_staypoint_msk_d停留表结构如下</strong></p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">CREATE</span> <span class="type">EXTERNAL</span> <span class="type">TABLE</span> <span class="type">IF</span> <span class="type">NOT</span> <span class="type">EXISTS</span> dws.dws_staypoint_msk_d (</span><br><span class="line">    mdn string comment &#x27;用户手机号码&#x27;  </span><br><span class="line">    ,longi string comment &#x27;网格中心点经度&#x27;  </span><br><span class="line">    ,lati string comment &#x27;网格中心点纬度&#x27;  </span><br><span class="line">    ,grid_id string comment &#x27;停留点所在电信内部网格号&#x27;  </span><br><span class="line">    ,county_id string comment &#x27;停留点区县&#x27;  </span><br><span class="line">    ,duration string comment &#x27;机主在停留点停留的时间长度（分钟）,lTime-eTime&#x27;  </span><br><span class="line">    ,grid_first_time string comment &#x27;网格第一个记录位置点时间（秒级）&#x27;  </span><br><span class="line">    ,grid_last_time string comment &#x27;网格最后一个记录位置点时间（秒级）&#x27;  </span><br><span class="line">) </span><br><span class="line">comment  &#x27;停留点表&#x27;</span><br><span class="line"><span class="type">PARTITIONED</span> <span class="type">BY</span> (</span><br><span class="line">    day_id string comment &#x27;天分区&#x27;  </span><br><span class="line">) </span><br><span class="line"><span class="type">ROW</span> <span class="type">FORMAT</span> <span class="type">DELIMITED</span> </span><br><span class="line">    <span class="type">FIELDS</span> <span class="type">TERMINATED</span> <span class="type">BY</span> &#x27;\t&#x27; </span><br><span class="line"><span class="type">STORED</span> <span class="type">AS</span> <span class="type">INPUTFORMAT</span> <span class="symbol">&#x27;org</span>.apache.hadoop.mapred.<span class="type">TextInputFormat</span>&#x27; </span><br><span class="line">    <span class="type">OUTPUTFORMAT</span> <span class="symbol">&#x27;org</span>.apache.hadoop.hive.ql.io.<span class="type">HiveIgnoreKeyTextOutputFormat</span>&#x27;</span><br><span class="line">location &#x27;/daas/motl/dws/dws_staypoint_msk_d&#x27;;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-在时间线上进行聚类操作-代码如下-spark编写"><a href="#3-3-2-在时间线上进行聚类操作-代码如下-spark编写" class="headerlink" title="3.3.2 在时间线上进行聚类操作,代码如下(spark编写)"></a>3.3.2 在时间线上进行聚类操作,代码如下(spark编写)</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fst.dws</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fst.common.<span class="type">SparkTool</span></span><br><span class="line"><span class="keyword">import</span> com.fst.grid.<span class="type">Grid</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.&#123;<span class="type">SaveMode</span>, <span class="type">SparkSession</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.expressions.&#123;<span class="type">UserDefinedFunction</span>, <span class="type">Window</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.geom.<span class="type">Point2D</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成停留表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DwsStaypointMskD</span> <span class="keyword">extends</span> <span class="title">SparkTool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(spark: <span class="type">SparkSession</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">import</span> spark.implicits._</span><br><span class="line">    <span class="keyword">import</span> org.apache.spark.sql.functions._</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> getLongi: <span class="type">UserDefinedFunction</span> = udf((grid: <span class="type">String</span>) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 通过网格编号获取网格中心点的经度</span></span><br><span class="line">      <span class="keyword">val</span> point: <span class="type">Point2D</span>.<span class="type">Double</span> = <span class="type">Grid</span>.getCenter(grid.toLong)</span><br><span class="line">      point.getX</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> getLati: <span class="type">UserDefinedFunction</span> = udf((grid: <span class="type">String</span>) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 通过网格编号获取网格中心点的纬度</span></span><br><span class="line">      <span class="keyword">val</span> point: <span class="type">Point2D</span>.<span class="type">Double</span> = <span class="type">Grid</span>.getCenter(grid.toLong)</span><br><span class="line">      point.getY</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用DSL写</span></span><br><span class="line">    spark</span><br><span class="line">      <span class="comment">// 读取融合表</span></span><br><span class="line">      .table(<span class="string">&quot;dwd.dwd_res_regn_mergelocation_msk_d&quot;</span>)</span><br><span class="line">      <span class="comment">// 取出指定分区的数据</span></span><br><span class="line">      .where($<span class="string">&quot;day_id&quot;</span> === day_id)</span><br><span class="line">      <span class="comment">// 取出开始时间和结束时间</span></span><br><span class="line">      .withColumn(<span class="string">&quot;start_date&quot;</span>, split($<span class="string">&quot;start_time&quot;</span>, <span class="string">&quot;,&quot;</span>)(<span class="number">1</span>))</span><br><span class="line">      .withColumn(<span class="string">&quot;end_date&quot;</span>, split($<span class="string">&quot;start_time&quot;</span>, <span class="string">&quot;,&quot;</span>)(<span class="number">0</span>))</span><br><span class="line">      <span class="comment">// 按照手机号分组，按照时间排序，取上一条数据的网格编号</span></span><br><span class="line">      .withColumn(<span class="string">&quot;s_grid&quot;</span>, lag($<span class="string">&quot;grid_id&quot;</span>, <span class="number">1</span>, <span class="string">&quot;&quot;</span>) over <span class="type">Window</span>.partitionBy($<span class="string">&quot;mdn&quot;</span>).orderBy($<span class="string">&quot;start_date&quot;</span>))</span><br><span class="line">      <span class="comment">// 判断当前网格编号和上一条数据的网格编号是否一致，划分边界</span></span><br><span class="line">      .withColumn(<span class="string">&quot;flag&quot;</span>, when($<span class="string">&quot;s_grid&quot;</span> === $<span class="string">&quot;grid_id&quot;</span>, <span class="number">0</span>).otherwise(<span class="number">1</span>))</span><br><span class="line">      <span class="comment">// 在同一个组的数据打上同样的标记</span></span><br><span class="line">      .withColumn(<span class="string">&quot;class&quot;</span>, sum($<span class="string">&quot;flag&quot;</span>) over <span class="type">Window</span>.partitionBy($<span class="string">&quot;mdn&quot;</span>).orderBy(<span class="string">&quot;start_date&quot;</span>))</span><br><span class="line">      <span class="comment">// 将同一个人在同一个网格中的数据分到同一个组</span></span><br><span class="line">      .groupBy($<span class="string">&quot;mdn&quot;</span>, $<span class="string">&quot;county_id&quot;</span>, $<span class="string">&quot;grid_id&quot;</span>, $<span class="string">&quot;class&quot;</span>)</span><br><span class="line">      <span class="comment">// 获取用户在网格中第一个点的时间和最后一个点的时间</span></span><br><span class="line">      .agg(min($<span class="string">&quot;start_date&quot;</span>) as <span class="string">&quot;grid_first_time&quot;</span>, max($<span class="string">&quot;end_date&quot;</span>) as <span class="string">&quot;grid_last_time&quot;</span>)</span><br><span class="line">      <span class="comment">// 计算用户在网格中的停留时间</span></span><br><span class="line">      .withColumn(<span class="string">&quot;duration&quot;</span>, unix_timestamp($<span class="string">&quot;grid_last_time&quot;</span>, <span class="string">&quot;yyyyMMddHHmmss&quot;</span>) - unix_timestamp($<span class="string">&quot;grid_first_time&quot;</span>, <span class="string">&quot;yyyyMMddHHmmss&quot;</span>))</span><br><span class="line">      <span class="comment">// 获取网格中心点的经纬度</span></span><br><span class="line">      .withColumn(<span class="string">&quot;longi&quot;</span>, getLongi($<span class="string">&quot;grid_id&quot;</span>))</span><br><span class="line">      .withColumn(<span class="string">&quot;lati&quot;</span>, getLati($<span class="string">&quot;grid_id&quot;</span>))</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 整理数据</span></span><br><span class="line">      .select($<span class="string">&quot;mdn&quot;</span>, round($<span class="string">&quot;longi&quot;</span>, <span class="number">4</span>) as <span class="string">&quot;longi&quot;</span>, round($<span class="string">&quot;lati&quot;</span>, <span class="number">4</span>) as <span class="string">&quot;lati&quot;</span>, $<span class="string">&quot;grid_id&quot;</span>, $<span class="string">&quot;county_id&quot;</span>, round($<span class="string">&quot;duration&quot;</span> / <span class="number">60</span>, <span class="number">4</span>), $<span class="string">&quot;grid_first_time&quot;</span>, $<span class="string">&quot;grid_last_time&quot;</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 保存数据</span></span><br><span class="line">      .write</span><br><span class="line">      .format(<span class="string">&quot;csv&quot;</span>)</span><br><span class="line">      .option(<span class="string">&quot;sep&quot;</span>, <span class="string">&quot;\t&quot;</span>)</span><br><span class="line">      .mode(<span class="type">SaveMode</span>.<span class="type">Overwrite</span>)</span><br><span class="line">      .save(<span class="string">&quot;/daas/motl/dws/dws_staypoint_msk_d/day_id=&quot;</span> + day_id)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加分区</span></span><br><span class="line">    spark.sql(<span class="string">s&quot;alter table dws.dws_staypoint_msk_d add if not exists partition(day_id=&#x27;<span class="subst">$day_id</span>&#x27;) &quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-3-打包上传并且查询数据"><a href="#3-3-3-打包上传并且查询数据" class="headerlink" title="3.3.3 打包上传并且查询数据"></a>3.3.3 打包上传并且查询数据</h4><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211120001153171.png" alt="image-20211120001153171"></p><p>此时数据已经弄好了，查询一下。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211120002017638.png" alt="image-20211120002017638"></p><h3 id="3-4-维度表-DIM层"><a href="#3-4-维度表-DIM层" class="headerlink" title="3.4 维度表(DIM层)"></a>3.4 维度表(DIM层)</h3><h4 id="3-4-1-现在mysql中创建三张原始表并且导入数据"><a href="#3-4-1-现在mysql中创建三张原始表并且导入数据" class="headerlink" title="3.4.1 现在mysql中创建三张原始表并且导入数据"></a>3.4.1 现在mysql中创建三张原始表并且导入数据</h4><p><strong>usertag用户画像表</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `usertag` (</span><br><span class="line">    mdn varchar(255) </span><br><span class="line">    ,name varchar(255) </span><br><span class="line">    ,gender varchar(255) </span><br><span class="line">    ,age int(10)</span><br><span class="line">    ,id_number varchar(255) </span><br><span class="line">    ,number_attr varchar(255) </span><br><span class="line">    ,trmnl_brand varchar(255) </span><br><span class="line">    ,trmnl_price varchar(255) </span><br><span class="line">    ,packg varchar(255) </span><br><span class="line">    ,conpot varchar(255)</span><br><span class="line">    ,resi_grid_id varchar(255)</span><br><span class="line">    ,resi_county_id varchar(255)</span><br><span class="line">)  ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line"># 导入数据</span><br><span class="line"> LOAD DATA LOCAL INFILE &#x27;C:\\Users\\18453\\Desktop\\usertag.txt&#x27; INTO TABLE usertag FIELDS TERMINATED BY &#x27;,&#x27; ;</span><br></pre></td></tr></table></figure><p><strong>scenic_boundary景区配置表</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE  scenic_boundary (</span><br><span class="line">    scenic_id varchar(255)   ,</span><br><span class="line">    scenic_name varchar(255)  ,</span><br><span class="line">    boundary text </span><br><span class="line">) ;</span><br><span class="line"></span><br><span class="line"># 导入数据</span><br><span class="line"> LOAD DATA LOCAL INFILE &#x27;C:\\Users\\18453\\Desktop\\scenic_boundary.txt&#x27; INTO TABLE scenic_boundary FIELDS TERMINATED BY &#x27;|&#x27; ;</span><br></pre></td></tr></table></figure><p><strong>admin_code行政区配置表</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE admin_code (</span><br><span class="line">    prov_id varchar(255)  </span><br><span class="line">    ,prov_name varchar(255)  </span><br><span class="line">    ,city_id varchar(255) </span><br><span class="line">    ,city_name varchar(255)  </span><br><span class="line">    ,county_id varchar(255)  </span><br><span class="line">    ,county_name varchar(255)  </span><br><span class="line">    ,city_level varchar(255)  </span><br><span class="line">    ,economic_belt varchar(255)   </span><br><span class="line">    ,city_feature1 varchar(255)  </span><br><span class="line">) ;</span><br><span class="line"></span><br><span class="line"># 导入数据</span><br><span class="line"> LOAD DATA LOCAL INFILE &#x27;C:\\Users\\18453\\Desktop\\ssxdx.txt&#x27; INTO TABLE admin_code FIELDS TERMINATED BY &#x27;,&#x27; ;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211120205134439.png" alt="image-20211120205134439"></p><h4 id="3-4-2-在ODS层中创建出3张维度表-ODS层"><a href="#3-4-2-在ODS层中创建出3张维度表-ODS层" class="headerlink" title="3.4.2 在ODS层中创建出3张维度表(ODS层)"></a>3.4.2 在ODS层中创建出3张维度表(ODS层)</h4><p><strong>ods.ods_admincode表结构</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE EXTERNAL TABLE IF NOT EXISTS ods.ods_admincode (</span><br><span class="line">    prov_id string comment &#x27;省id&#x27;  </span><br><span class="line">    ,prov_name string comment &#x27;省名称&#x27;  </span><br><span class="line">    ,city_id string comment &#x27;市id&#x27;  </span><br><span class="line">    ,city_name string comment &#x27;市名称&#x27;  </span><br><span class="line">    ,county_id string comment &#x27;区县id&#x27;  </span><br><span class="line">    ,county_name string comment &#x27;区县名称&#x27;  </span><br><span class="line">    ,city_level string comment &#x27;城市级别，一级为1；二级为2...依此类推&#x27;  </span><br><span class="line">    ,economic_belt string comment &#x27;BJ为首都经济带、ZSJ为珠三角经济带、CSJ为长三角经济带、DB为东北经济带、HZ为华中经济带、HB为华北经济带、HD为华东经济带、HN为华南经济带、XB为西北经济带、XN为西南经济带&#x27;  </span><br><span class="line">    ,city_feature1 string comment &#x27;NL代表内陆、YH代表沿海&#x27;  </span><br><span class="line">) </span><br><span class="line">comment  &#x27;行政区配置表&#x27;</span><br><span class="line">ROW FORMAT DELIMITED </span><br><span class="line">    FIELDS TERMINATED BY &#x27;\t&#x27; </span><br><span class="line">STORED AS INPUTFORMAT &#x27;org.apache.hadoop.mapred.TextInputFormat&#x27; </span><br><span class="line">    OUTPUTFORMAT &#x27;org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat&#x27;  </span><br><span class="line">location &#x27;/daas/motl/ods/ods_admincode&#x27;;</span><br></pre></td></tr></table></figure><p><strong>ods.ods_scenic_boundary表结构</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE EXTERNAL TABLE IF NOT EXISTS ods.ods_scenic_boundary (</span><br><span class="line">    scenic_id string comment &#x27;景区id&#x27;  </span><br><span class="line">    ,scenic_name string comment &#x27;景区名称&#x27;  </span><br><span class="line">    ,boundary string comment &#x27;景区边界&#x27;  </span><br><span class="line">) </span><br><span class="line">comment  &#x27;景区配置表&#x27;</span><br><span class="line">ROW FORMAT DELIMITED </span><br><span class="line">    FIELDS TERMINATED BY &#x27;\t&#x27; </span><br><span class="line">STORED AS INPUTFORMAT &#x27;org.apache.hadoop.mapred.TextInputFormat&#x27; </span><br><span class="line">    OUTPUTFORMAT &#x27;org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat&#x27;  </span><br><span class="line">location &#x27;/daas/motl/ods/ods_scenic_boundary&#x27;;</span><br></pre></td></tr></table></figure><p><strong>ods.ods_usertag_m表结构</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE EXTERNAL TABLE IF NOT EXISTS ods.ods_usertag_m (</span><br><span class="line">    mdn string comment &#x27;手机号大写MD5加密&#x27;  </span><br><span class="line">    ,name string comment &#x27;姓名&#x27;  </span><br><span class="line">    ,gender string comment &#x27;性别，1男2女&#x27;  </span><br><span class="line">    ,age string comment &#x27;年龄&#x27;  </span><br><span class="line">    ,id_number string comment &#x27;证件号码&#x27;  </span><br><span class="line">    ,number_attr string comment &#x27;号码归属地&#x27;  </span><br><span class="line">    ,trmnl_brand string comment &#x27;终端品牌&#x27;    </span><br><span class="line">    ,trmnl_price string comment &#x27;终端价格&#x27;</span><br><span class="line">    ,packg string comment &#x27;套餐&#x27;  </span><br><span class="line">    ,conpot string comment &#x27;消费潜力&#x27;  </span><br><span class="line">    ,resi_grid_id string comment &#x27;常住地网格&#x27;  </span><br><span class="line">    ,resi_county_id string comment &#x27;常住地区县&#x27;  </span><br><span class="line">) </span><br><span class="line">comment  &#x27;用户画像表&#x27;</span><br><span class="line">PARTITIONED BY (</span><br><span class="line">    month_id string comment &#x27;月分区&#x27;  </span><br><span class="line">) </span><br><span class="line">ROW FORMAT DELIMITED </span><br><span class="line">    FIELDS TERMINATED BY &#x27;\t&#x27; </span><br><span class="line">STORED AS INPUTFORMAT &#x27;org.apache.hadoop.mapred.TextInputFormat&#x27; </span><br><span class="line">    OUTPUTFORMAT &#x27;org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat&#x27;  </span><br><span class="line">location &#x27;/daas/motl/ods/ods_usertag_m&#x27;; </span><br><span class="line"></span><br><span class="line"># 增加分区</span><br><span class="line">alter table ods.ods_usertag_m add if not exists partition(month_id=&#x27;201805&#x27;) ;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211120210749870.png" alt="image-20211120210749870"></p><h4 id="3-4-3-使用dataX工具将MySQL中的数据导入到ODS中的3张表中"><a href="#3-4-3-使用dataX工具将MySQL中的数据导入到ODS中的3张表中" class="headerlink" title="3.4.3 使用dataX工具将MySQL中的数据导入到ODS中的3张表中"></a>3.4.3 使用dataX工具将MySQL中的数据导入到ODS中的3张表中</h4><p><strong>usertag_mysql_to_usertag_hive_ods.json代码</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;job&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;content&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;reader&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;mysqlreader&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;connection&quot;</span>: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;jdbcUrl&quot;</span>: [</span><br><span class="line">                                    <span class="string">&quot;jdbc:mysql://master:3306/tour&quot;</span></span><br><span class="line">                                ],</span><br><span class="line">                                <span class="attr">&quot;table&quot;</span>: [</span><br><span class="line">                                    <span class="string">&quot;usertag&quot;</span></span><br><span class="line">                                ],</span><br><span class="line">                            &#125;</span><br><span class="line">                        ],</span><br><span class="line">                        <span class="attr">&quot;column&quot;</span>: [<span class="string">&quot;*&quot;</span>],</span><br><span class="line">                        <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;root&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;writer&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;hdfswriter&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;defaultFS&quot;</span>: <span class="string">&quot;hdfs://master:9000&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;fileType&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;/daas/motl/ods/ods_usertag_m/month_id=$&#123;month_id&#125;&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;fileName&quot;</span>: <span class="string">&quot;data&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;column&quot;</span>: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;mdn&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;STRING&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;STRING&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;gender&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;STRING&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;age&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;INT&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;id_number&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;STRING&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;number_attr&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;STRING&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;trmnl_brand&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;STRING&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;trmnl_price&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;STRING&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;packg&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;STRING&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;conpot&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;STRING&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;resi_grid_id&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;STRING&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;resi_county_id&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;STRING&quot;</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ],</span><br><span class="line">                        <span class="attr">&quot;writeMode&quot;</span>: <span class="string">&quot;append&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;fieldDelimiter&quot;</span>: <span class="string">&quot;\t&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;setting&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;errorLimit&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;percentage&quot;</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">&quot;record&quot;</span>: <span class="number">0</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;speed&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;channel&quot;</span>: <span class="number">4</span>,</span><br><span class="line">                <span class="attr">&quot;record&quot;</span>: <span class="number">1000</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>scenic_boundary_mysql_to_scenic_boundary_hive_dim.json代码</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;job&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;content&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;reader&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;mysqlreader&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;connection&quot;</span>: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;jdbcUrl&quot;</span>: [</span><br><span class="line">                                    <span class="string">&quot;jdbc:mysql://master:3306/tour&quot;</span></span><br><span class="line">                                ],</span><br><span class="line">                                <span class="attr">&quot;table&quot;</span>: [</span><br><span class="line">                                    <span class="string">&quot;scenic_boundary&quot;</span></span><br><span class="line">                                ],</span><br><span class="line">                            &#125;</span><br><span class="line">                        ],</span><br><span class="line">                        <span class="attr">&quot;column&quot;</span>: [<span class="string">&quot;*&quot;</span>],</span><br><span class="line">                        <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;root&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;writer&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;hdfswriter&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;defaultFS&quot;</span>: <span class="string">&quot;hdfs://master:9000&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;fileType&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;/daas/motl/ods/ods_scenic_boundary&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;fileName&quot;</span>: <span class="string">&quot;data&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;column&quot;</span>: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;scenic_id&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;STRING&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;scenic_name&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;STRING&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;boundary&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;STRING&quot;</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ],</span><br><span class="line">                        <span class="attr">&quot;writeMode&quot;</span>: <span class="string">&quot;append&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;fieldDelimiter&quot;</span>: <span class="string">&quot;\t&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;setting&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;errorLimit&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;percentage&quot;</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">&quot;record&quot;</span>: <span class="number">0</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;speed&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;channel&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">&quot;record&quot;</span>: <span class="number">1000</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>admin_code_mysql_to_admin_code_hive_dim.json代码</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;job&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;content&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;reader&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;mysqlreader&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;connection&quot;</span>: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;jdbcUrl&quot;</span>: [</span><br><span class="line">                                    <span class="string">&quot;jdbc:mysql://master:3306/tour&quot;</span></span><br><span class="line">                                ],</span><br><span class="line">                                <span class="attr">&quot;table&quot;</span>: [</span><br><span class="line">                                    <span class="string">&quot;admin_code&quot;</span></span><br><span class="line">                                ],</span><br><span class="line">                            &#125;</span><br><span class="line">                        ],</span><br><span class="line">                        <span class="attr">&quot;column&quot;</span>: [<span class="string">&quot;*&quot;</span>],</span><br><span class="line">                        <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;root&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;writer&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;hdfswriter&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;defaultFS&quot;</span>: <span class="string">&quot;hdfs://master:9000&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;fileType&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;/daas/motl/ods/ods_admincode&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;fileName&quot;</span>: <span class="string">&quot;data&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;column&quot;</span>: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;prov_id&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;STRING&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;prov_name&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;STRING&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;city_id&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;STRING&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;city_name&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;STRING&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;county_id&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;STRING&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;county_name&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;STRING&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;city_level&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;STRING&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;economic_belt&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;STRING&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;city_feature1&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;STRING&quot;</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ],</span><br><span class="line">                        <span class="attr">&quot;writeMode&quot;</span>: <span class="string">&quot;append&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;fieldDelimiter&quot;</span>: <span class="string">&quot;\t&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;setting&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;errorLimit&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;percentage&quot;</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">&quot;record&quot;</span>: <span class="number">0</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;speed&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;channel&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">&quot;record&quot;</span>: <span class="number">1000</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-4-3-1-运行代码"><a href="#3-4-3-1-运行代码" class="headerlink" title="3.4.3.1 运行代码"></a>3.4.3.1 运行代码</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">datax.py -p &quot;-Dmonth_id=201805&quot; usertag_mysql_to_usertag_hive_ods.json</span><br><span class="line">datax.py scenic_boundary_mysql_to_scenic_boundary_hive_ods.json</span><br><span class="line">datax.py admin_code_mysql_to_admin_code_hive_ods.json</span><br></pre></td></tr></table></figure><h5 id="3-4-3-2-上传完毕并且查看一下"><a href="#3-4-3-2-上传完毕并且查看一下" class="headerlink" title="3.4.3.2 上传完毕并且查看一下"></a>3.4.3.2 上传完毕并且查看一下</h5><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211120212819450.png" alt="image-20211120212819450"></p><h4 id="3-4-4-数据从ODS层进入DIM层"><a href="#3-4-4-数据从ODS层进入DIM层" class="headerlink" title="3.4.4 数据从ODS层进入DIM层"></a>3.4.4 数据从ODS层进入DIM层</h4><h5 id="3-4-4-1-dim-usertag-msk-m代码如下-spark编写"><a href="#3-4-4-1-dim-usertag-msk-m代码如下-spark编写" class="headerlink" title="3.4.4.1 dim_usertag_msk_m代码如下(spark编写)"></a>3.4.4.1 dim_usertag_msk_m代码如下(spark编写)</h5><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fst.dim</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fst.common.<span class="type">SparkTool</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.&#123;<span class="type">SaveMode</span>, <span class="type">SparkSession</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理用户画像表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DimUsertagMskM</span> <span class="keyword">extends</span> <span class="title">SparkTool</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(spark: <span class="type">SparkSession</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">import</span> org.apache.spark.sql.functions._</span><br><span class="line">    <span class="keyword">import</span> spark.implicits._</span><br><span class="line">    spark</span><br><span class="line">      .table(<span class="string">&quot;ods.ods_usertag_m&quot;</span>)</span><br><span class="line">      .where($<span class="string">&quot;month_id&quot;</span> === month_id)</span><br><span class="line">      .select(</span><br><span class="line">        md5($<span class="string">&quot;mdn&quot;</span>) as <span class="string">&quot;mdn&quot;</span>,</span><br><span class="line">        md5($<span class="string">&quot;name&quot;</span>) as <span class="string">&quot;name&quot;</span>,</span><br><span class="line">        $<span class="string">&quot;gender&quot;</span> as <span class="string">&quot;gender&quot;</span>,</span><br><span class="line">        $<span class="string">&quot;age&quot;</span> as <span class="string">&quot;age&quot;</span>,</span><br><span class="line">        md5($<span class="string">&quot;id_number&quot;</span>) as <span class="string">&quot;id_number&quot;</span>,</span><br><span class="line">        $<span class="string">&quot;number_attr&quot;</span>,</span><br><span class="line">        $<span class="string">&quot;trmnl_brand&quot;</span>,</span><br><span class="line">        $<span class="string">&quot;trmnl_price&quot;</span>,</span><br><span class="line">        $<span class="string">&quot;packg&quot;</span>,</span><br><span class="line">        $<span class="string">&quot;conpot&quot;</span>,</span><br><span class="line">        $<span class="string">&quot;resi_grid_id&quot;</span>,</span><br><span class="line">        $<span class="string">&quot;resi_county_id&quot;</span></span><br><span class="line">      )</span><br><span class="line">      .write</span><br><span class="line">      .format(<span class="string">&quot;csv&quot;</span>)</span><br><span class="line">      .option(<span class="string">&quot;sep&quot;</span>, <span class="string">&quot;\t&quot;</span>)</span><br><span class="line">      .mode(<span class="type">SaveMode</span>.<span class="type">Overwrite</span>)</span><br><span class="line">      .save(<span class="string">s&quot;/daas/motl/dim/dim_usertag_msk_m/month=<span class="subst">$month_id</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加分区</span></span><br><span class="line">    spark.sql(</span><br><span class="line">      <span class="string">s&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        |</span></span><br><span class="line"><span class="string">        |alter table dim.dim_usertag_msk_m add if not exists partition(month_id=&#x27;$month_id&#x27;)</span></span><br><span class="line"><span class="string">        |&quot;</span><span class="string">&quot;&quot;</span>.stripMargin)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="3-4-4-1-1-在DIM层创建用户画像表"><a href="#3-4-4-1-1-在DIM层创建用户画像表" class="headerlink" title="3.4.4.1.1 在DIM层创建用户画像表"></a>3.4.4.1.1 在DIM层创建用户画像表</h6><p><strong>dim.dim_usertag_msk_m表结构如下</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE EXTERNAL TABLE IF NOT EXISTS dim.dim_usertag_msk_m (</span><br><span class="line">    mdn string comment &#x27;手机号大写MD5加密&#x27;  </span><br><span class="line">    ,name string comment &#x27;姓名&#x27;  </span><br><span class="line">    ,gender string comment &#x27;性别，1男2女&#x27;  </span><br><span class="line">    ,age string comment &#x27;年龄&#x27;  </span><br><span class="line">    ,id_number string comment &#x27;证件号码&#x27;  </span><br><span class="line">    ,number_attr string comment &#x27;号码归属地&#x27;  </span><br><span class="line">    ,trmnl_brand string comment &#x27;终端品牌&#x27;    </span><br><span class="line">    ,trmnl_price string comment &#x27;终端价格&#x27;</span><br><span class="line">    ,packg string comment &#x27;套餐&#x27;  </span><br><span class="line">    ,conpot string comment &#x27;消费潜力&#x27;  </span><br><span class="line">    ,resi_grid_id string comment &#x27;常住地网格&#x27;  </span><br><span class="line">    ,resi_county_id string comment &#x27;常住地区县&#x27;  </span><br><span class="line">) </span><br><span class="line">comment  &#x27;用户画像表&#x27;</span><br><span class="line">PARTITIONED BY (</span><br><span class="line">    month_id string comment &#x27;月分区&#x27;  </span><br><span class="line">) </span><br><span class="line">ROW FORMAT DELIMITED </span><br><span class="line">    FIELDS TERMINATED BY &#x27;\t&#x27; </span><br><span class="line">STORED AS INPUTFORMAT &#x27;org.apache.hadoop.mapred.TextInputFormat&#x27; </span><br><span class="line">    OUTPUTFORMAT &#x27;org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat&#x27;  </span><br><span class="line">location &#x27;/daas/motl/dim/dim_usertag_msk_m&#x27;;</span><br></pre></td></tr></table></figure><h6 id="3-4-4-1-2-打包上传并且运行"><a href="#3-4-4-1-2-打包上传并且运行" class="headerlink" title="3.4.4.1.2 打包上传并且运行"></a>3.4.4.1.2 打包上传并且运行</h6><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211121102415657.png" alt="image-20211121102415657"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211121102611775.png" alt="image-20211121102611775"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211121103123336.png" alt="image-20211121103123336"></p><h5 id="3-4-4-2-dim-dim-admincode代码如下-spark编写"><a href="#3-4-4-2-dim-dim-admincode代码如下-spark编写" class="headerlink" title="3.4.4.2 dim.dim_admincode代码如下(spark编写)"></a>3.4.4.2 dim.dim_admincode代码如下(spark编写)</h5><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fst.dim</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fst.common.<span class="type">SparkTool</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">SparkSession</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DimAdmincode</span> <span class="keyword">extends</span> <span class="title">SparkTool</span></span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(spark: <span class="type">SparkSession</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    spark.sql(</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">          |</span></span><br><span class="line"><span class="string">          |insert overwrite table dim.dim_admincode</span></span><br><span class="line"><span class="string">          |select * from ods.ods_admincode</span></span><br><span class="line"><span class="string">          |</span></span><br><span class="line"><span class="string">          |&quot;&quot;&quot;</span>.stripMargin)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="3-4-4-2-1-在DIM层创建行政区配置表"><a href="#3-4-4-2-1-在DIM层创建行政区配置表" class="headerlink" title="3.4.4.2.1 在DIM层创建行政区配置表"></a>3.4.4.2.1 在DIM层创建行政区配置表</h6><p><strong>dim.dim_admincode表结构如下</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> dim.dim_admincode (</span><br><span class="line">    prov_id string comment <span class="string">&#x27;省id&#x27;</span>  </span><br><span class="line">    ,prov_name string comment <span class="string">&#x27;省名称&#x27;</span>  </span><br><span class="line">    ,city_id string comment <span class="string">&#x27;市id&#x27;</span>  </span><br><span class="line">    ,city_name string comment <span class="string">&#x27;市名称&#x27;</span>  </span><br><span class="line">    ,county_id string comment <span class="string">&#x27;区县id&#x27;</span>  </span><br><span class="line">    ,county_name string comment <span class="string">&#x27;区县名称&#x27;</span>  </span><br><span class="line">    ,city_level string comment <span class="string">&#x27;城市级别，一级为1；二级为2...依此类推&#x27;</span>  </span><br><span class="line">    ,economic_belt string comment <span class="string">&#x27;BJ为首都经济带、ZSJ为珠三角经济带、CSJ为长三角经济带、DB为东北经济带、HZ为华中经济带、HB为华北经济带、HD为华东经济带、HN为华南经济带、XB为西北经济带、XN为西南经济带&#x27;</span>  </span><br><span class="line">    ,city_feature1 string comment <span class="string">&#x27;NL代表内陆、YH代表沿海&#x27;</span>  </span><br><span class="line">) </span><br><span class="line">comment  <span class="string">&#x27;行政区配置表&#x27;</span></span><br><span class="line"><span class="type">ROW</span> FORMAT DELIMITED </span><br><span class="line">    FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\t&#x27;</span> </span><br><span class="line">STORED <span class="keyword">AS</span> INPUTFORMAT <span class="string">&#x27;org.apache.hadoop.mapred.TextInputFormat&#x27;</span> </span><br><span class="line">    OUTPUTFORMAT <span class="string">&#x27;org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat&#x27;</span>  </span><br><span class="line">location <span class="string">&#x27;/daas/motl/dim/dim_admincode&#x27;</span>;</span><br></pre></td></tr></table></figure><h6 id="3-4-4-2-2-打包上传并且运行"><a href="#3-4-4-2-2-打包上传并且运行" class="headerlink" title="3.4.4.2.2 打包上传并且运行"></a>3.4.4.2.2 打包上传并且运行</h6><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211121105807530.png" alt="image-20211121105807530"></p><h5 id="3-4-4-3-dim-dim-scenic-boundary代码如下-spark编写"><a href="#3-4-4-3-dim-dim-scenic-boundary代码如下-spark编写" class="headerlink" title="3.4.4.3 dim.dim_scenic_boundary代码如下(spark编写)"></a>3.4.4.3 dim.dim_scenic_boundary代码如下(spark编写)</h5><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fst.dim</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fst.common.<span class="type">SparkTool</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">SparkSession</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DimScenicBoundary</span> <span class="keyword">extends</span> <span class="title">SparkTool</span></span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(spark: <span class="type">SparkSession</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    spark.sql(</span><br><span class="line">      <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        |insert overwrite table dim.dim_scenic_boundary</span></span><br><span class="line"><span class="string">        |select * from ods.ods_scenic_boundary</span></span><br><span class="line"><span class="string">        |&quot;&quot;&quot;</span>.stripMargin)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="3-4-4-3-1-在DIM层创建景区配置表"><a href="#3-4-4-3-1-在DIM层创建景区配置表" class="headerlink" title="3.4.4.3.1 在DIM层创建景区配置表"></a>3.4.4.3.1 在DIM层创建景区配置表</h6><p><strong>dim.dim_scenic_boundary表结构如下</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> dim.dim_scenic_boundary (</span><br><span class="line">    scenic_id string comment <span class="string">&#x27;景区id&#x27;</span>  </span><br><span class="line">    ,scenic_name string comment <span class="string">&#x27;景区名称&#x27;</span>  </span><br><span class="line">    ,boundary string comment <span class="string">&#x27;景区边界&#x27;</span>  </span><br><span class="line">) </span><br><span class="line">comment  <span class="string">&#x27;景区配置表&#x27;</span></span><br><span class="line"><span class="type">ROW</span> FORMAT DELIMITED </span><br><span class="line">    FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\t&#x27;</span> </span><br><span class="line">STORED <span class="keyword">AS</span> INPUTFORMAT <span class="string">&#x27;org.apache.hadoop.mapred.TextInputFormat&#x27;</span> </span><br><span class="line">    OUTPUTFORMAT <span class="string">&#x27;org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat&#x27;</span>  </span><br><span class="line">location <span class="string">&#x27;/daas/motl/dim/dim_scenic_boundary&#x27;</span>; </span><br></pre></td></tr></table></figure><h6 id="3-4-4-3-2-打包上传并且运行"><a href="#3-4-4-3-2-打包上传并且运行" class="headerlink" title="3.4.4.3.2 打包上传并且运行"></a>3.4.4.3.2 打包上传并且运行</h6><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211121111354924.png" alt="image-20211121111354924"></p><h3 id="3-5-ADS层"><a href="#3-5-ADS层" class="headerlink" title="3.5 ADS层"></a>3.5 ADS层</h3><p>至此前期数据都已计算完毕，接下来就计算ADS层的相关数据。</p><h4 id="3-5-1-计算省市游客代码如下"><a href="#3-5-1-计算省市游客代码如下" class="headerlink" title="3.5.1 计算省市游客代码如下"></a>3.5.1 计算省市游客代码如下</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fst.ads</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fst.common.<span class="type">SparkTool</span></span><br><span class="line"><span class="keyword">import</span> com.fst.grid.<span class="type">Geography</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.expressions.&#123;<span class="type">UserDefinedFunction</span>, <span class="type">Window</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.&#123;<span class="type">DataFrame</span>, <span class="type">SaveMode</span>, <span class="type">SparkSession</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算省游客</span></span><br><span class="line"><span class="comment"> * 1、停留时间大于3小时</span></span><br><span class="line"><span class="comment"> * 2、出游距离大于10KM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">AdsProvinceTouristMskD</span> <span class="keyword">extends</span> <span class="title">SparkTool</span></span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(spark: <span class="type">SparkSession</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">import</span> org.apache.spark.sql.functions._</span><br><span class="line">    <span class="keyword">import</span> spark.implicits._</span><br><span class="line">    <span class="comment">//1、读取停留表</span></span><br><span class="line">    <span class="keyword">val</span> staypoint: <span class="type">DataFrame</span> = spark</span><br><span class="line">      .table(<span class="type">STAYPOINT_TABLE_NAME</span>)</span><br><span class="line">      .where($<span class="string">&quot;day_id&quot;</span> === day_id)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、读取用户画像表</span></span><br><span class="line">    <span class="keyword">val</span> usertag: <span class="type">DataFrame</span> = spark</span><br><span class="line">      .table(<span class="type">DIM_USERTAG_TABLE_NAME</span>)</span><br><span class="line">      .where($<span class="string">&quot;month_id&quot;</span> === month_id)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、读取行政区配置表</span></span><br><span class="line">    <span class="keyword">val</span> admincode: <span class="type">DataFrame</span> = spark</span><br><span class="line">      .table(<span class="type">DIM_ADMINCODE_TABLE_NAME</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算两个网格距离的函数</span></span><br><span class="line">    <span class="keyword">val</span> calculateLength: <span class="type">UserDefinedFunction</span> = udf((p1: <span class="type">String</span>, p2: <span class="type">String</span>) =&gt; &#123;</span><br><span class="line">      <span class="type">Geography</span>.calculateLength(p1.toLong, p2.toLong)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    staypoint</span><br><span class="line">      <span class="comment">//4、关联停留表和行政区配置表 获取省的编号</span></span><br><span class="line">      .join(admincode.hint(<span class="string">&quot;broadcast&quot;</span>),<span class="string">&quot;county_id&quot;</span>)</span><br><span class="line">      <span class="comment">//5、计算用户在一个省内的停留时间</span></span><br><span class="line">      .withColumn(<span class="string">&quot;d_stay_time&quot;</span>,sum($<span class="string">&quot;duration&quot;</span>) over <span class="type">Window</span>.partitionBy($<span class="string">&quot;mdn&quot;</span>,$<span class="string">&quot;prov_id&quot;</span>))</span><br><span class="line">      <span class="comment">//6、停留时间大于3小时</span></span><br><span class="line">      .where($<span class="string">&quot;d_stay_time&quot;</span> &gt; <span class="number">180</span>)</span><br><span class="line">      <span class="comment">//7、关联用户画像表获取常住地</span></span><br><span class="line">      .join(usertag.hint(<span class="string">&quot;broadcast&quot;</span>),<span class="string">&quot;mdn&quot;</span>)</span><br><span class="line">      <span class="comment">//8、计算每个停留点到常住的距离</span></span><br><span class="line">      .withColumn(<span class="string">&quot;distance&quot;</span>,calculateLength($<span class="string">&quot;grid_id&quot;</span>,$<span class="string">&quot;resi_grid_id&quot;</span>))</span><br><span class="line">      <span class="comment">//9、获取一个人在一个省的最远距离</span></span><br><span class="line">      .withColumn(<span class="string">&quot;d_max_distance&quot;</span>,max($<span class="string">&quot;distance&quot;</span>) over <span class="type">Window</span>.partitionBy($<span class="string">&quot;mdn&quot;</span>,$<span class="string">&quot;prov_id&quot;</span>))</span><br><span class="line">      <span class="comment">//10、出游距离大于10KM</span></span><br><span class="line">      .where($<span class="string">&quot;d_max_distance&quot;</span> &gt; <span class="number">10000</span>)</span><br><span class="line">      <span class="comment">//11、整理数据</span></span><br><span class="line">      .select($<span class="string">&quot;mdn&quot;</span>,$<span class="string">&quot;resi_county_id&quot;</span> as <span class="string">&quot;source_county_id&quot;</span>,$<span class="string">&quot;prov_id&quot;</span> as <span class="string">&quot;d_province_id&quot;</span>,round($<span class="string">&quot;d_stay_time&quot;</span>/<span class="number">60</span>,<span class="number">4</span>),round($<span class="string">&quot;d_max_distance&quot;</span>/<span class="number">1000</span>,<span class="number">4</span>))</span><br><span class="line">      <span class="comment">//12、去除重复数据</span></span><br><span class="line">      .distinct()</span><br><span class="line">      <span class="comment">//保存数据</span></span><br><span class="line">      .write</span><br><span class="line">      .format(<span class="string">&quot;csv&quot;</span>)</span><br><span class="line">      .option(<span class="string">&quot;sep&quot;</span>,<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">      .mode(<span class="type">SaveMode</span>.<span class="type">Overwrite</span>)</span><br><span class="line">      .save(<span class="string">s&quot;<span class="subst">$&#123;ADS_PROVINCE_TOURIST_PATH&#125;</span>day_id=<span class="subst">$day_id</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加分区</span></span><br><span class="line">    spark.sql(</span><br><span class="line">      <span class="string">s&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        |</span></span><br><span class="line"><span class="string">        |alter table $ADS_PROVINCE_TOURIST_TABLE_NAME  add if not exists partition(day_id=&#x27;$day_id&#x27;)</span></span><br><span class="line"><span class="string">        |&quot;</span><span class="string">&quot;&quot;</span>.stripMargin)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>省市游客计算方式</p><ul><li>停留时间大于3小时</li><li>出游距离大于10KM</li></ul><h4 id="3-5-2-在ads层建立游客表"><a href="#3-5-2-在ads层建立游客表" class="headerlink" title="3.5.2 在ads层建立游客表"></a>3.5.2 在ads层建立游客表</h4><p><strong>ads.ads_province_tourist_msk_d字段如下</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> ads.ads_province_tourist_msk_d (</span><br><span class="line">    mdn string comment <span class="string">&#x27;手机号大写MD5加密&#x27;</span>  </span><br><span class="line">    ,source_county_id string comment <span class="string">&#x27;游客来源区县&#x27;</span>  </span><br><span class="line">    ,d_province_id string comment <span class="string">&#x27;旅游目的地省代码&#x27;</span>  </span><br><span class="line">    ,d_stay_time <span class="keyword">double</span> comment <span class="string">&#x27;游客在该省停留的时间长度（小时）&#x27;</span>  </span><br><span class="line">    ,d_max_distance <span class="keyword">double</span> comment <span class="string">&#x27;游客本次出游距离&#x27;</span>  </span><br><span class="line">) </span><br><span class="line">comment  <span class="string">&#x27;旅游应用专题数据省级别-天&#x27;</span></span><br><span class="line">PARTITIONED <span class="keyword">BY</span> (</span><br><span class="line">    day_id string comment <span class="string">&#x27;日分区&#x27;</span>  </span><br><span class="line">) </span><br><span class="line"><span class="type">ROW</span> FORMAT DELIMITED </span><br><span class="line">    FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\t&#x27;</span> </span><br><span class="line">STORED <span class="keyword">AS</span> INPUTFORMAT <span class="string">&#x27;org.apache.hadoop.mapred.TextInputFormat&#x27;</span> </span><br><span class="line">OUTPUTFORMAT <span class="string">&#x27;org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat&#x27;</span></span><br><span class="line">location <span class="string">&#x27;/daas/motl/ads/ads_province_tourist_msk_d&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211121165015057.png" alt="image-20211121165015057"></p><h4 id="3-5-3-打包上传并且运行"><a href="#3-5-3-打包上传并且运行" class="headerlink" title="3.5.3 打包上传并且运行"></a>3.5.3 打包上传并且运行</h4><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211121170125132.png" alt="image-20211121170125132"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211121171250192.png" alt="image-20211121171250192"></p><h3 id="3-6-任务调度工具"><a href="#3-6-任务调度工具" class="headerlink" title="3.6 任务调度工具"></a>3.6 任务调度工具</h3><p>因为在实际工作中需要定时将任务启动，因此就有了调度工具的产生。</p><h4 id="3-6-1-Azkaban安装"><a href="#3-6-1-Azkaban安装" class="headerlink" title="3.6.1 Azkaban安装"></a>3.6.1 Azkaban安装</h4><p>上传解压包解压即可，然后修改下配置信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、上传解压</span><br><span class="line">unzip azkaban-solo-server.zip</span><br><span class="line">2、修改配置文件</span><br><span class="line">vim conf/azkaban.properties</span><br><span class="line">修改时区</span><br><span class="line">default.timezone.id=Asia/Shanghai</span><br><span class="line">3、启动azkaban</span><br><span class="line">cd /usr/local/soft/azkaban-solo-server</span><br><span class="line">启动</span><br><span class="line">./bin/start-solo.sh </span><br><span class="line"></span><br><span class="line">4、访问azkaban</span><br><span class="line">http://master:8081</span><br><span class="line"></span><br><span class="line">用户名密码  azkaban/azkaban</span><br></pre></td></tr></table></figure><h4 id="3-6-2-示例"><a href="#3-6-2-示例" class="headerlink" title="3.6.2 示例"></a>3.6.2 示例</h4><p>调度之后就会出现如下界面</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211121210505544.png" alt="image-20211121210505544"></p><h3 id="3-7-宽表构建"><a href="#3-7-宽表构建" class="headerlink" title="3.7 宽表构建"></a>3.7 宽表构建</h3><p>由于在项目中需要查询很多个指标，例如查询下面几个指标，需要构建多次表关联，因此为了后期的便利以及减少表与表之间的关联，可以先做一张宽表，将所有需要的字段关联好，后续的指标需要什么字段直接选择即可。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211122192636020.png" alt="image-20211122192636020"></p><p>这里我们就统计省游客的宽表</p><p><strong>ads.ads_province_wide_msk_d宽表结构如下</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> ads.ads_province_wide_msk_d(</span><br><span class="line">     mdn string comment <span class="string">&#x27;手机号&#x27;</span>  </span><br><span class="line">    ,d_province_name string comment <span class="string">&#x27;旅游目的地省名&#x27;</span>  </span><br><span class="line">    ,o_city_name string comment <span class="string">&#x27;旅游来源地地市名&#x27;</span>  </span><br><span class="line">    ,o_province_name string comment <span class="string">&#x27;旅游来源地省名&#x27;</span>  </span><br><span class="line">    ,number_attr string comment <span class="string">&#x27;号码归属地&#x27;</span>  </span><br><span class="line">    ,d_distance_section string comment <span class="string">&#x27;出游距离,分段处理&#x27;</span></span><br><span class="line">    ,d_stay_time string comment <span class="string">&#x27;停留时间 分段处理&#x27;</span></span><br><span class="line">    ,gender string comment <span class="string">&#x27;性别&#x27;</span></span><br><span class="line">    ,trmnl_brand string comment <span class="string">&#x27;终端品牌&#x27;</span></span><br><span class="line">    ,pckg_price <span class="type">int</span> comment <span class="string">&#x27;套餐&#x27;</span></span><br><span class="line">    ,conpot <span class="type">int</span> comment <span class="string">&#x27;消费潜力&#x27;</span></span><br><span class="line">    ,age string comment <span class="string">&#x27;年龄,分段处理&#x27;</span></span><br><span class="line">) </span><br><span class="line">comment  <span class="string">&#x27;旅游应用专题数据省级别-天-宽表&#x27;</span></span><br><span class="line">PARTITIONED <span class="keyword">BY</span> (</span><br><span class="line">    day_id string comment <span class="string">&#x27;日分区&#x27;</span>  </span><br><span class="line">) </span><br><span class="line"><span class="type">ROW</span> FORMAT DELIMITED </span><br><span class="line">    FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\t&#x27;</span> </span><br><span class="line">STORED <span class="keyword">AS</span> INPUTFORMAT <span class="string">&#x27;org.apache.hadoop.mapred.TextInputFormat&#x27;</span> </span><br><span class="line">OUTPUTFORMAT <span class="string">&#x27;org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat&#x27;</span></span><br><span class="line">location <span class="string">&#x27;/daas/motl/ads/ads_province_wide_msk_d&#x27;</span>;</span><br></pre></td></tr></table></figure><p>代码构建如下</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fst.ads</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fst.common.<span class="type">SparkTool</span></span><br><span class="line"><span class="keyword">import</span> com.fst.grid.<span class="type">Geography</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.expressions.&#123;<span class="type">UserDefinedFunction</span>, <span class="type">Window</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.&#123;<span class="type">Column</span>, <span class="type">DataFrame</span>, <span class="type">Dataset</span>, <span class="type">Row</span>, <span class="type">SaveMode</span>, <span class="type">SparkSession</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算省游客宽表</span></span><br><span class="line"><span class="comment"> * 从省游客表、用户画像表，行政区配置表中</span></span><br><span class="line"><span class="comment"> * 提取出指标需要的所有字段构建成宽表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">AdsProvinceTouristMskWideD</span> <span class="keyword">extends</span> <span class="title">SparkTool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(spark: <span class="type">SparkSession</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> spark.implicits._</span><br><span class="line">    <span class="keyword">import</span> org.apache.spark.sql.functions._</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取省游客表</span></span><br><span class="line">    <span class="keyword">val</span> province: <span class="type">DataFrame</span> = spark.table(<span class="type">ADS_PROVINCE_TOURIST_TABLE_NAME</span>).where($<span class="string">&quot;day_id&quot;</span> === day_id)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取用户画像表</span></span><br><span class="line">    <span class="keyword">val</span> usertag: <span class="type">DataFrame</span> = spark.table(<span class="type">DIM_USERTAG_TABLE_NAME</span>).where($<span class="string">&quot;month_id&quot;</span> === month_id)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取行政区配置表</span></span><br><span class="line">    <span class="keyword">val</span> admincode: <span class="type">DataFrame</span> = spark.table(<span class="type">DIM_ADMINCODE_TABLE_NAME</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 年龄段</span></span><br><span class="line">    <span class="keyword">val</span> ages: <span class="type">Column</span> = when($<span class="string">&quot;age&quot;</span> &gt; <span class="number">0</span> and $<span class="string">&quot;age&quot;</span> &lt; <span class="number">20</span>, <span class="string">&quot;(0,20)&quot;</span>)</span><br><span class="line">      .when($<span class="string">&quot;age&quot;</span> &gt;= <span class="number">20</span> and $<span class="string">&quot;age&quot;</span> &lt; <span class="number">25</span>, <span class="string">&quot;[20,25)&quot;</span>)</span><br><span class="line">      .when($<span class="string">&quot;age&quot;</span> &gt;= <span class="number">25</span> and $<span class="string">&quot;age&quot;</span> &lt; <span class="number">30</span>, <span class="string">&quot;[25,30)&quot;</span>)</span><br><span class="line">      .when($<span class="string">&quot;age&quot;</span> &gt;= <span class="number">30</span> and $<span class="string">&quot;age&quot;</span> &lt; <span class="number">35</span>, <span class="string">&quot;[30,35)&quot;</span>)</span><br><span class="line">      .when($<span class="string">&quot;age&quot;</span> &gt;= <span class="number">35</span> and $<span class="string">&quot;age&quot;</span> &lt; <span class="number">40</span>, <span class="string">&quot;[35,40)&quot;</span>)</span><br><span class="line">      .when($<span class="string">&quot;age&quot;</span> &gt;= <span class="number">40</span> and $<span class="string">&quot;age&quot;</span> &lt; <span class="number">45</span>, <span class="string">&quot;[40,45)&quot;</span>)</span><br><span class="line">      .when($<span class="string">&quot;age&quot;</span> &gt;= <span class="number">45</span> and $<span class="string">&quot;age&quot;</span> &lt; <span class="number">50</span>, <span class="string">&quot;[45,50)&quot;</span>)</span><br><span class="line">      .when($<span class="string">&quot;age&quot;</span> &gt;= <span class="number">50</span> and $<span class="string">&quot;age&quot;</span> &lt; <span class="number">55</span>, <span class="string">&quot;[50,55)&quot;</span>)</span><br><span class="line">      .when($<span class="string">&quot;age&quot;</span> &gt;= <span class="number">55</span> and $<span class="string">&quot;age&quot;</span> &lt; <span class="number">60</span>, <span class="string">&quot;[55,60)&quot;</span>)</span><br><span class="line">      .otherwise(<span class="string">&quot;[60,~)&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//距离分段</span></span><br><span class="line">    <span class="keyword">val</span> d_distance_section: <span class="type">Column</span> =</span><br><span class="line">      when($<span class="string">&quot;d_max_distance&quot;</span> &gt;= <span class="number">10</span> and $<span class="string">&quot;d_max_distance&quot;</span> &lt; <span class="number">50</span>, <span class="string">&quot;[10,50)&quot;</span>)</span><br><span class="line">        .when($<span class="string">&quot;d_max_distance&quot;</span> &gt;= <span class="number">50</span> and $<span class="string">&quot;d_max_distance&quot;</span> &lt; <span class="number">80</span>, <span class="string">&quot;[50,80)&quot;</span>)</span><br><span class="line">        .when($<span class="string">&quot;d_max_distance&quot;</span> &gt;= <span class="number">80</span> and $<span class="string">&quot;d_max_distance&quot;</span> &lt; <span class="number">120</span>, <span class="string">&quot;[80,120)&quot;</span>)</span><br><span class="line">        .when($<span class="string">&quot;d_max_distance&quot;</span> &gt;= <span class="number">120</span> and $<span class="string">&quot;d_max_distance&quot;</span> &lt; <span class="number">200</span>, <span class="string">&quot;[120,200)&quot;</span>)</span><br><span class="line">        .when($<span class="string">&quot;d_max_distance&quot;</span> &gt;= <span class="number">200</span> and $<span class="string">&quot;d_max_distance&quot;</span> &lt; <span class="number">400</span>, <span class="string">&quot;[200,400)&quot;</span>)</span><br><span class="line">        .when($<span class="string">&quot;d_max_distance&quot;</span> &gt;= <span class="number">400</span> and $<span class="string">&quot;d_max_distance&quot;</span> &lt; <span class="number">800</span>, <span class="string">&quot;[400,800)&quot;</span>)</span><br><span class="line">        .otherwise(<span class="string">&quot;[800,~)&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//停留时间分段</span></span><br><span class="line">    <span class="keyword">val</span> d_stay_time: <span class="type">Column</span> = when($<span class="string">&quot;d_stay_time&quot;</span> &gt;= <span class="number">3</span> and $<span class="string">&quot;d_stay_time&quot;</span> &lt; <span class="number">6</span>, <span class="string">&quot;[3,6)&quot;</span>)</span><br><span class="line">      .when($<span class="string">&quot;d_stay_time&quot;</span> &gt;= <span class="number">6</span> and $<span class="string">&quot;d_stay_time&quot;</span> &lt; <span class="number">9</span>, <span class="string">&quot;[6,9)&quot;</span>)</span><br><span class="line">      .when($<span class="string">&quot;d_stay_time&quot;</span> &gt;= <span class="number">9</span> and $<span class="string">&quot;d_stay_time&quot;</span> &lt; <span class="number">12</span>, <span class="string">&quot;[6,12)&quot;</span>)</span><br><span class="line">      .when($<span class="string">&quot;d_stay_time&quot;</span> &gt;= <span class="number">12</span> and $<span class="string">&quot;d_stay_time&quot;</span> &lt; <span class="number">15</span>, <span class="string">&quot;[12,15)&quot;</span>)</span><br><span class="line">      .when($<span class="string">&quot;d_stay_time&quot;</span> &gt;= <span class="number">15</span> and $<span class="string">&quot;d_stay_time&quot;</span> &lt; <span class="number">18</span>, <span class="string">&quot;[15,18)&quot;</span>)</span><br><span class="line">      .when($<span class="string">&quot;d_stay_time&quot;</span> &gt;= <span class="number">18</span> and $<span class="string">&quot;d_stay_time&quot;</span> &lt; <span class="number">24</span>, <span class="string">&quot;[18,24)&quot;</span>)</span><br><span class="line">      .otherwise(<span class="string">&quot;[24,~)&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对多次使用的rdd进行缓存</span></span><br><span class="line">    admincode.cache()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出省编号和省名称，去重</span></span><br><span class="line">    <span class="keyword">val</span> proIdAndName: <span class="type">Dataset</span>[<span class="type">Row</span>] = admincode.select($<span class="string">&quot;prov_id&quot;</span> as <span class="string">&quot;d_province_id&quot;</span>, $<span class="string">&quot;prov_name&quot;</span> as <span class="string">&quot;d_province_name&quot;</span>).distinct()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关联用户画像表</span></span><br><span class="line">    province</span><br><span class="line">      .join(usertag.hint(<span class="string">&quot;broadcast&quot;</span>),<span class="string">&quot;mdn&quot;</span>)</span><br><span class="line">      <span class="comment">// 对年龄进行分段</span></span><br><span class="line">      .withColumn(<span class="string">&quot;age&quot;</span>,ages)</span><br><span class="line">      <span class="comment">// 对出游距离进行分段</span></span><br><span class="line">      .withColumn(<span class="string">&quot;d_distance_section&quot;</span>,d_distance_section)</span><br><span class="line">      <span class="comment">// 停留时间分段</span></span><br><span class="line">      .withColumn(<span class="string">&quot;d_stay_time&quot;</span>,d_stay_time)</span><br><span class="line">      <span class="comment">// 关联行政分区表获取省名</span></span><br><span class="line">      .join(proIdAndName.hint(<span class="string">&quot;broadcast&quot;</span>),<span class="string">&quot;d_province_id&quot;</span>)</span><br><span class="line">      <span class="comment">// 通过来源地区县关联行政区配置表获取来源的省和市</span></span><br><span class="line">      .join(admincode.hint(<span class="string">&quot;broadcast&quot;</span>),$<span class="string">&quot;source_county_id&quot;</span>===$<span class="string">&quot;county_id&quot;</span>)</span><br><span class="line">      <span class="comment">// 整理数据</span></span><br><span class="line">      .select(</span><br><span class="line">        $<span class="string">&quot;mdn&quot;</span>,</span><br><span class="line">        $<span class="string">&quot;d_province_name&quot;</span>,</span><br><span class="line">        $<span class="string">&quot;city_name&quot;</span> as <span class="string">&quot;o_city_name&quot;</span>,</span><br><span class="line">        $<span class="string">&quot;prov_name&quot;</span> as <span class="string">&quot;o_province_name&quot;</span>,</span><br><span class="line">        $<span class="string">&quot;number_attr&quot;</span>,</span><br><span class="line">        $<span class="string">&quot;d_distance_section&quot;</span>,</span><br><span class="line">        $<span class="string">&quot;d_stay_time&quot;</span> ,</span><br><span class="line">        $<span class="string">&quot;gender&quot;</span>,</span><br><span class="line">        $<span class="string">&quot;trmnl_brand&quot;</span>,</span><br><span class="line">        $<span class="string">&quot;packg&quot;</span> as <span class="string">&quot;pckg_price&quot;</span>,</span><br><span class="line">        $<span class="string">&quot;conpot&quot;</span>,</span><br><span class="line">        $<span class="string">&quot;age&quot;</span></span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 保存数据</span></span><br><span class="line">      .write</span><br><span class="line">      .format(<span class="string">&quot;csv&quot;</span>)</span><br><span class="line">      .option(<span class="string">&quot;sep&quot;</span>,<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">      .mode(<span class="type">SaveMode</span>.<span class="type">Overwrite</span>)</span><br><span class="line">      .save(<span class="string">s&quot;/daas/motl/ads/ads_province_wide_msk_d/day_id=<span class="subst">$day_id</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加分区</span></span><br><span class="line">    spark.sql(</span><br><span class="line">      <span class="string">s&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        |</span></span><br><span class="line"><span class="string">        |alter table ads.ads_province_wide_msk_d add if not exists partition(day_id=&#x27;$day_id&#x27;) ;</span></span><br><span class="line"><span class="string">        |&quot;</span><span class="string">&quot;&quot;</span>.stripMargin)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打包上传。至此宽表已经建立完毕，后续需要什么数据，直接可以从宽表里面获取。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211122204220629.png" alt="image-20211122204220629"></p><h3 id="3-8-Kylin工具"><a href="#3-8-Kylin工具" class="headerlink" title="3.8 Kylin工具"></a>3.8 Kylin工具</h3><p>因为宽表数据量大，延迟要低。</p><blockquote><p>mr hive  慢</p><p>spark sql  快, 当数据量不断累积会出问题</p><p>mysql  快，数据量只能支撑百万级别</p><p>hbase 不能做聚合</p><p>impala 和hive类似的一个工具，基于内存计算</p><p>kylin 预计算（提前计算好，需要时间），提交将所有的可能都计算出来</p></blockquote><p>对于宽表想要实现随意查询的话，以往的数据库是没办法存储的，因此引入一个新的数据库工具 Kylin。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211122205108969.png" alt="image-20211122205108969"></p><h4 id="3-8-1-Kylin安装"><a href="#3-8-1-Kylin安装" class="headerlink" title="3.8.1 Kylin安装"></a>3.8.1 Kylin安装</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、上传解压配置环境变量</span><br><span class="line">tar -zxvf apache-kylin-2.5.0-bin-hbase1x.tar.gz</span><br><span class="line">mv apache-kylin-2.5.0-bin-hbase1x kylin-2.5.0</span><br><span class="line"></span><br><span class="line">在/etc/profile中增加</span><br><span class="line">export HIVE_CONF=/usr/local/soft/hive-1.2.1/conf</span><br><span class="line"></span><br><span class="line">删除kafka环境变量</span><br><span class="line">unset KAFKA_HOME</span><br><span class="line"></span><br><span class="line">在master启动jobhistory</span><br><span class="line">mr-jobhistory-daemon.sh start historyserver</span><br><span class="line"></span><br><span class="line">启动zookeeper</span><br><span class="line">zkServer.sh start </span><br><span class="line"></span><br><span class="line">启动hbase</span><br><span class="line">start-hbase.sh</span><br><span class="line"></span><br><span class="line">2、验证环境是否可行</span><br><span class="line">check-env.sh</span><br><span class="line"></span><br><span class="line">3、启动kylin</span><br><span class="line">kylin.sh start</span><br><span class="line"></span><br><span class="line">4、访问kylin</span><br><span class="line">http://master:7070/kylin</span><br><span class="line"></span><br><span class="line">初始用户名和密码是 ADMIN/KYLIN</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211122210839464.png" alt="image-20211122210839464"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211122210916322.png" alt="image-20211122210916322"></p><p>至此，Kylin就已经部署完成了。</p><h4 id="3-8-2-简单使用"><a href="#3-8-2-简单使用" class="headerlink" title="3.8.2 简单使用"></a>3.8.2 简单使用</h4><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211122214423284.png" alt="image-20211122214423284"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211122215644817.png" alt="image-20211122215644817"></p><h3 id="3-9-FineBI的使用"><a href="#3-9-FineBI的使用" class="headerlink" title="3.9 FineBI的使用"></a>3.9 FineBI的使用</h3><h4 id="3-9-1-安装"><a href="#3-9-1-安装" class="headerlink" title="3.9.1 安装"></a>3.9.1 安装</h4><p>上传解压</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211122221049927.png" alt="image-20211122221049927"></p><p>详细操作可以查看官方文档。<a href="https://help.fanruan.com/finebi/">https://help.fanruan.com/finebi/</a></p><h4 id="3-9-2-web-UI查看"><a href="#3-9-2-web-UI查看" class="headerlink" title="3.9.2 web UI查看"></a>3.9.2 web UI查看</h4><blockquote><p>登录 <a href="http://ip:37799/webroot/decision">http://IP:37799/webroot/decision</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211122222127246.png" alt="image-20211122222127246"></p><p>接着连接自己的数据库。这里我连接的是我的Kylin。具体连接步骤请查看官方文档。</p><h4 id="3-9-3-简单实用输出大屏"><a href="#3-9-3-简单实用输出大屏" class="headerlink" title="3.9.3 简单实用输出大屏"></a>3.9.3 简单实用输出大屏</h4><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211122224730655.png" alt="image-20211122224730655"></p><h2 id="本项目代码精简规范"><a href="#本项目代码精简规范" class="headerlink" title="本项目代码精简规范"></a>本项目代码精简规范</h2><p>最终成型代码请见我的开源仓库:<a href="https://github.com/Fang-gg/CountingWarehouse.git">https://github.com/Fang-gg/CountingWarehouse.git</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 注释</span><br><span class="line"># \表示换行</span><br><span class="line"># --master 指定什么模式</span><br><span class="line"># --class 指定类</span><br><span class="line"># --num-executors 指定运行的executor数量</span><br><span class="line"># --executor-memory 指定任务运行内存</span><br><span class="line"># --executor-cores  指定核数</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大数据学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark学习</title>
      <link href="/2021/11/08/Spark%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/11/08/Spark%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>官网概述：<br>Spark是一个基于内存的开源计算框架，于2009年诞生于加州大学伯克利分校AMPLab（AMP：Algorithms，Machines，People），它最初属于伯克利大学的研究性项目，后来在2010年正式开源，并于 2013 年成为了 Apache 基金项目，到2014年便成为 Apache 基金的顶级项目，该项目整个发展历程刚过六年时间，但其发展速度非常惊人。<br>正由于Spark来自于大学，其整个发展过程都充满了学术研究的标记，是学术带动Spark核心架构的发展，如弹性分布式数据集（RDD，resilient distributed datasets）、流处理（Spark streaming）、机器学习（MLlib）、SQL分析（Spark SQL）和图计算（GraphX），本节将主要介绍Spark发展历程和特点。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211109203608005.png" alt="image-20211109203608005"></p><h2 id="SparkWordCount"><a href="#SparkWordCount" class="headerlink" title="SparkWordCount"></a>SparkWordCount</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fst</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Demo1WordCount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Spark配置文件对象</span></span><br><span class="line">    <span class="keyword">val</span> conf: <span class="type">SparkConf</span> = <span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置Spark程序的名字</span></span><br><span class="line">    conf.setAppName(<span class="string">&quot;Demo1WordCount&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置运行模式为Local模式  即在IDEA本地运行</span></span><br><span class="line">    conf.setMaster(<span class="string">&quot;local&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spark的上下文环境，相当于是Spark的入口</span></span><br><span class="line">    <span class="keyword">val</span> sc: <span class="type">SparkContext</span> = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 词频统计</span></span><br><span class="line">    <span class="comment">// 1、读取文件</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * RDD:弹性分布式数据集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> linesRDD: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(<span class="string">&quot;Spark/data/words.txt&quot;</span>)</span><br><span class="line"><span class="comment">//    linesRDD.foreach(println) // 打印出来看看</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、将每一行的单词切分出来</span></span><br><span class="line">    <span class="comment">// flatMap: 在Spark中称为  算子</span></span><br><span class="line">    <span class="comment">// 算子一般情况下都会返回另外一个RDD</span></span><br><span class="line">    <span class="keyword">val</span> wordsRDD: <span class="type">RDD</span>[<span class="type">String</span>] = linesRDD.flatMap(line =&gt; line.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line"><span class="comment">//    wordsRDD.foreach(println)  // 打印出来看看</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、按照单词分组</span></span><br><span class="line">    <span class="keyword">val</span> groupRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Iterable</span>[<span class="type">String</span>])] = wordsRDD.groupBy(word =&gt; word)</span><br><span class="line"><span class="comment">//    groupRDD.foreach(println)  // 打印出来看看</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、统计每个单词的数量</span></span><br><span class="line">    <span class="keyword">val</span> countRDD: <span class="type">RDD</span>[<span class="type">String</span>] = groupRDD.map(kv =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> word: <span class="type">String</span> = kv._1</span><br><span class="line">      <span class="keyword">val</span> words: <span class="type">Iterable</span>[<span class="type">String</span>] = kv._2</span><br><span class="line"></span><br><span class="line">      <span class="comment">// words.size 直接获取迭代器的大小</span></span><br><span class="line">      <span class="comment">// 因为相同分组的所有的单词都会到迭代器中</span></span><br><span class="line">      <span class="comment">// 所以迭代器的大小就是单词的数量</span></span><br><span class="line">      word + <span class="string">&quot;,&quot;</span> + words.size</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="comment">//5.将结果进行保存</span></span><br><span class="line">    countRDD.saveAsTextFile(<span class="string">&quot;Scala/data/wordCount&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211108211303061.png" alt="image-20211108211303061"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211108211313806.png" alt="image-20211108211313806"></p><p>可以很清楚的看到已经统计出来了。</p><h2 id="RDD五大特性"><a href="#RDD五大特性" class="headerlink" title="RDD五大特性"></a>RDD五大特性</h2><ul><li>RDD是由一系列分区组成的，默认一个切片对应一个分区</li><li>方法(算子)是作用在每一个分区上的，每个分区对应一个Task</li><li>RDD之间是有一系列依赖关系的，依赖关系可以分为两种:宽依赖(有shuffle)、窄依赖(没有shuffle)，可以按照宽依赖切分Stage(一组可以并行计算的task，可以看出Map任务或Reduce任务)，shuffle之前是Map，shuffle之后是Reduce</li><li>分区类算子只能作用在一个k-v格式的RDD上</li><li>Spark给每个task提供最佳的计算位置，移动计算，不移动数据</li></ul><p>RDD是不存储数据的，它只是一个编程模型，在这之上可以使用各种算子去完成数据分析需求。</p><p><font color="red">RDD中分区的数量默认等于上一个RDD分区的数量</font></p><p><font color="red">实际上Spark并没有自己读取HDFS文件的方法，底层默认使用的是MR的方式(切片的方式、格式化数据的方式)去将文件读进来</font></p><h2 id="Standalone模式搭建"><a href="#Standalone模式搭建" class="headerlink" title="Standalone模式搭建"></a>Standalone模式搭建</h2><p>在公司一般不适用standalone模式，因为公司一般已经有yarn 不需要搞两个资源管理框架，但这里还是搭建一下。</p><h3 id="上传，解压并且重命名"><a href="#上传，解压并且重命名" class="headerlink" title="上传，解压并且重命名"></a>上传，解压并且重命名</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211108221143596.png" alt="image-20211108221143596"></p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211108221422972.png" alt="image-20211108221422972"></p><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211108221542114.png" alt="image-20211108221542114"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211108221635847.png" alt="image-20211108221635847"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export SPARK_MASTER_IP=master</span><br><span class="line">export SPARK_MASTER_PORT=7077</span><br><span class="line">export SPARK_WORKER_CORES=2</span><br><span class="line">export SPARK_WORKER_INSTANCES=1</span><br><span class="line">export SPARK_WORKER_MEMORY=2g</span><br><span class="line">export JAVA_HOME=/usr/local/soft/jdk1.8.0_171</span><br></pre></td></tr></table></figure><h3 id="增加从节点文件"><a href="#增加从节点文件" class="headerlink" title="增加从节点文件"></a>增加从节点文件</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211108221757819.png" alt="image-20211108221757819"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211108221909721.png" alt="image-20211108221909721"></p><h3 id="复制到其他节点"><a href="#复制到其他节点" class="headerlink" title="复制到其他节点"></a>复制到其他节点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp -r spark-2.4.5 node1:`pwd`</span><br><span class="line">scp -r spark-2.4.5 node2:`pwd`</span><br></pre></td></tr></table></figure><h3 id="在主节点执行启动命令"><a href="#在主节点执行启动命令" class="headerlink" title="在主节点执行启动命令"></a>在主节点执行启动命令</h3><blockquote><p>./sbin/start-all.sh     在spark目录下输入</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211108222723042.png" alt="image-20211108222723042"></p><h3 id="访问web界面"><a href="#访问web界面" class="headerlink" title="访问web界面"></a>访问web界面</h3><blockquote><p><a href="http://master:8080/">http://master:8080/</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211108222912642.png" alt="image-20211108222912642"></p><h3 id="官方示例演示"><a href="#官方示例演示" class="headerlink" title="官方示例演示"></a>官方示例演示</h3><h4 id="standalone-client模式-日志在本地输出，一般用于上线前测试-bin-下执行"><a href="#standalone-client模式-日志在本地输出，一般用于上线前测试-bin-下执行" class="headerlink" title="standalone client模式   日志在本地输出，一般用于上线前测试(bin/下执行)"></a>standalone client模式   日志在本地输出，一般用于上线前测试(bin/下执行)</h4><blockquote><p>需要进入到spark-examples_2.11-2.4.5.jar 包所在的目录下执行<br>cd /usr/local/soft/spark-2.4.5/examples/jars</p><p>spark-submit –class org.apache.spark.examples.SparkPi –master spark://master:7077 –executor-memory 512m –total-executor-cores 1 spark-examples_2.11-2.4.5.jar 100</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211108223807687.png" alt="image-20211108223807687"></p><h4 id="standalone-cluster模式-上线使用，不会再本地打印日志"><a href="#standalone-cluster模式-上线使用，不会再本地打印日志" class="headerlink" title="standalone cluster模式   上线使用，不会再本地打印日志"></a>standalone cluster模式   上线使用，不会再本地打印日志</h4><blockquote><p>spark-submit –class org.apache.spark.examples.SparkPi –master spark://master:7077 –driver-memory 512m –deploy-mode cluster –supervise –executor-memory 512M –total-executor-cores 1 spark-examples_2.11-2.4.5.jar 100</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211108223837093.png" alt="image-20211108223837093"></p><p>可以很明显的看到两者的区别。</p><h4 id="spark-shell-spark-提供的一个交互式的命令行，可以直接写代码"><a href="#spark-shell-spark-提供的一个交互式的命令行，可以直接写代码" class="headerlink" title="spark-shell   spark 提供的一个交互式的命令行，可以直接写代码"></a>spark-shell   spark 提供的一个交互式的命令行，可以直接写代码</h4><blockquote><p>spark-shell master spark://master:7077</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211108224415534.png" alt="image-20211108224415534"></p><h2 id="整合Yarn"><a href="#整合Yarn" class="headerlink" title="整合Yarn"></a>整合Yarn</h2><blockquote><p>停止spark集群<br>在spark sbin目录下执行  ./stop-all.sh</p><p>spark整合yarn只需要在一个节点整合, 可以删除node1 和node2中所有的spark 文件</p></blockquote><h3 id="增加hadoop-配置文件地址"><a href="#增加hadoop-配置文件地址" class="headerlink" title="增加hadoop 配置文件地址"></a>增加hadoop 配置文件地址</h3><blockquote><p>vim spark-env.sh<br>增加<br>export HADOOP_CONF_DIR=/usr/local/soft/hadoop-2.7.6/etc/hadoop</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211108225204986.png" alt="image-20211108225204986"></p><h3 id="往yarn提交任务需要增加两个配置"><a href="#往yarn提交任务需要增加两个配置" class="headerlink" title="往yarn提交任务需要增加两个配置"></a>往yarn提交任务需要增加两个配置</h3><p>往yarn提交任务需要增加两个配置  yarn-site.xml(/usr/local/soft/hadoop-2.7.6/etc/hadoop/yarn-site.xml)</p><p>修改之前先关闭yarn  stop-yarn.sh</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">       &lt;name&gt;yarn.nodemanager.pmem-check-enabled&lt;/name&gt;</span><br><span class="line">       &lt;value&gt;false&lt;/value&gt;</span><br><span class="line">   &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">   &lt;property&gt;</span><br><span class="line">       &lt;name&gt;yarn.nodemanager.vmem-check-enabled&lt;/name&gt;</span><br><span class="line">       &lt;value&gt;false&lt;/value&gt;</span><br><span class="line">   &lt;/property&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211108225553531.png" alt="image-20211108225553531"></p><h3 id="同步到其他节点，重启yarn"><a href="#同步到其他节点，重启yarn" class="headerlink" title="同步到其他节点，重启yarn"></a>同步到其他节点，重启yarn</h3><blockquote><p>scp -r yarn-site.xml node1:<code>pwd</code><br>scp -r yarn-site.xml node2:<code>pwd</code></p></blockquote><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><blockquote><p>cd /usr/local/soft/spark-2.4.5/examples/jars</p></blockquote><h4 id="spark-on-yarn-client模式-日志在本地输出，一般用于上线前测试"><a href="#spark-on-yarn-client模式-日志在本地输出，一般用于上线前测试" class="headerlink" title="spark on yarn client模式   日志在本地输出，一般用于上线前测试"></a>spark on yarn client模式   日志在本地输出，一般用于上线前测试</h4><blockquote><p>spark-submit –class org.apache.spark.examples.SparkPi –master yarn-client –executor-memory 512M –num-executors 2 spark-examples_2.11-2.4.5.jar 100</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211108230440007.png" alt="image-20211108230440007"></p><h4 id="spark-on-yarn-cluster模式-上线使用，不会再本地打印日志-减少io"><a href="#spark-on-yarn-cluster模式-上线使用，不会再本地打印日志-减少io" class="headerlink" title="spark on yarn cluster模式   上线使用，不会再本地打印日志   减少io"></a>spark on yarn cluster模式   上线使用，不会再本地打印日志   减少io</h4><blockquote><p>spark-submit –class org.apache.spark.examples.SparkPi –master yarn-cluster –executor-memory 512m –num-executors 2 –executor-cores 1 spark-examples_2.11-2.4.5.jar 100</p></blockquote><h4 id="获取yarn程序执行日志-执行成功之后才能获取到"><a href="#获取yarn程序执行日志-执行成功之后才能获取到" class="headerlink" title="获取yarn程序执行日志  执行成功之后才能获取到"></a>获取yarn程序执行日志  执行成功之后才能获取到</h4><blockquote><p>yarn logs -applicationId 你自己的ID</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211108230912123.png" alt="image-20211108230912123"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211108230802439.png" alt="image-20211108230802439"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211108230652667.png" alt="image-20211108230652667"></p><h2 id="在集群上运行自己写的Spark代码"><a href="#在集群上运行自己写的Spark代码" class="headerlink" title="在集群上运行自己写的Spark代码"></a>在集群上运行自己写的Spark代码</h2><h3 id="写好代码并且打包成jar包上传到虚拟机"><a href="#写好代码并且打包成jar包上传到虚拟机" class="headerlink" title="写好代码并且打包成jar包上传到虚拟机"></a>写好代码并且打包成jar包上传到虚拟机</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fst</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.<span class="type">Configuration</span></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.&#123;<span class="type">FileSystem</span>, <span class="type">Path</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Demo2WordCountSubmit</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将代码提交到集群上运行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1、去除setMaster(&quot;&quot;local)</span></span><br><span class="line"><span class="comment">     * 2、修改文件的输入输出路径(因为提交到集群默认是从HDFS中获取数据,需要改成HDFS中的路径)</span></span><br><span class="line"><span class="comment">     * 3、在HDFS中创建目录</span></span><br><span class="line"><span class="comment">     * hadoop dfs -mkdir -p /spark/data/words/</span></span><br><span class="line"><span class="comment">     * 5、将程序打成jar包</span></span><br><span class="line"><span class="comment">     *  4、将数据上传至HDFS</span></span><br><span class="line"><span class="comment">     * hadoop dfs -put /usr/local/data/words.txt /spark/data/words/</span></span><br><span class="line"><span class="comment">     * 6、将jar包上传至虚拟机，然后通过spark-submit提交任务</span></span><br><span class="line"><span class="comment">     * spark-submit --class com.fst.Demo2WordCountSubmit --master yarn-client Spark-1.0-SNAPSHOT.jar</span></span><br><span class="line"><span class="comment">     * spark-submit --class com.fst.Demo2WordCountSubmit --master yarn-cluster Spark-1.0-SNAPSHOT.jar</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Spark配置文件对象</span></span><br><span class="line">    <span class="keyword">val</span> conf: <span class="type">SparkConf</span> = <span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置Spark程序的名字</span></span><br><span class="line">    conf.setAppName(<span class="string">&quot;Demo2WordCountSubmit&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置运行模式为Local模式  即在IDEA本地运行</span></span><br><span class="line"><span class="comment">//    conf.setMaster(&quot;local&quot;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spark的上下文环境，相当于是Spark的入口</span></span><br><span class="line">    <span class="keyword">val</span> sc: <span class="type">SparkContext</span> = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 词频统计</span></span><br><span class="line">    <span class="comment">// 1、读取文件</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * RDD:弹性分布式数据集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> linesRDD: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(<span class="string">&quot;/spark/data/words&quot;</span>)</span><br><span class="line"><span class="comment">//    linesRDD.foreach(println) // 打印出来看看</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、将每一行的单词切分出来</span></span><br><span class="line">    <span class="comment">// flatMap: 在Spark中称为  算子</span></span><br><span class="line">    <span class="comment">// 算子一般情况下都会返回另外一个RDD</span></span><br><span class="line">    <span class="keyword">val</span> wordsRDD: <span class="type">RDD</span>[<span class="type">String</span>] = linesRDD.flatMap(line =&gt; line.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line"><span class="comment">//    wordsRDD.foreach(println)  // 打印出来看看</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、按照单词分组</span></span><br><span class="line">    <span class="keyword">val</span> groupRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Iterable</span>[<span class="type">String</span>])] = wordsRDD.groupBy(word =&gt; word)</span><br><span class="line"><span class="comment">//    groupRDD.foreach(println)  // 打印出来看看</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、统计每个单词的数量</span></span><br><span class="line">    <span class="keyword">val</span> countRDD: <span class="type">RDD</span>[<span class="type">String</span>] = groupRDD.map(kv =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> word: <span class="type">String</span> = kv._1</span><br><span class="line">      <span class="keyword">val</span> words: <span class="type">Iterable</span>[<span class="type">String</span>] = kv._2</span><br><span class="line"></span><br><span class="line">      <span class="comment">// words.size 直接获取迭代器的大小</span></span><br><span class="line">      <span class="comment">// 因为相同分组的所有的单词都会到迭代器中</span></span><br><span class="line">      <span class="comment">// 所以迭代器的大小就是单词的数量</span></span><br><span class="line">      word + <span class="string">&quot;,&quot;</span> + words.size</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用HDFS的JAVA API判断输出路径是否已经存在，存在即删除</span></span><br><span class="line">    <span class="keyword">val</span> hdfsConf: <span class="type">Configuration</span> = <span class="keyword">new</span> <span class="type">Configuration</span>()</span><br><span class="line">    hdfsConf.set(<span class="string">&quot;fs.defaultFs&quot;</span>,<span class="string">&quot;hdfs://master:9000&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> fs: <span class="type">FileSystem</span> = <span class="type">FileSystem</span>.get(hdfsConf)</span><br><span class="line">    <span class="comment">//判断输出路径是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(fs.exists(<span class="keyword">new</span> <span class="type">Path</span>(<span class="string">&quot;/spark/data/wordCount&quot;</span>)))&#123;</span><br><span class="line">      fs.delete(<span class="keyword">new</span> <span class="type">Path</span>(<span class="string">&quot;/spark/data/wordCount&quot;</span>),<span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">//5.将结果进行保存</span></span><br><span class="line">    countRDD.saveAsTextFile(<span class="string">&quot;/spark/data/wordCount&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><blockquote><p>格式: spark-submit –class 主类名 –master yarn的模式(下面展示client模式) 刚上传的jar包</p></blockquote><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">spark-submit --<span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">fst</span>.<span class="title">Demo2WordCountSubmit</span> <span class="title">--master</span> <span class="title">yarn-client</span> <span class="title">Spark-1</span>.0<span class="title">-SNAPSHOT</span>.<span class="title">jar</span></span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211109224300023.png" alt="image-20211109224300023"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211109224311528.png" alt="image-20211109224311528"></p><p>可以看到已经是运行完毕了。此时有个小疑问，我们输入的是一个文件，为什么输出会有2个文件勒？这是因为在底层代码逻辑上面，默认有2个并行度，因此会有2个分区，故会有2个文件。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211109230536689.png" alt="image-20211109230536689"></p><h2 id="On-Yarn两种模式对比"><a href="#On-Yarn两种模式对比" class="headerlink" title="On Yarn两种模式对比"></a>On Yarn两种模式对比</h2><p>在yarn上有两种模式 <strong>client模式</strong>(会自动打印日志)，<strong>cluster模式</strong>(不会自动打印日志，需要用命令去查看) </p><blockquote><p>yarn logs -applicationId 你自己的任务ID</p></blockquote><h3 id="Yarn-client模式"><a href="#Yarn-client模式" class="headerlink" title="Yarn-client模式"></a>Yarn-client模式</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/yarn-client.png" alt="yarn-client"></p><p>上图解释:只要提交到集群，那么就会在本地启动JAVA程序。然后就会向ResourceManger发送请求。</p><h3 id="Yarn-cluster模式"><a href="#Yarn-cluster模式" class="headerlink" title="Yarn-cluster模式"></a>Yarn-cluster模式</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/yarn-cluster.png" alt="yarn-cluster"></p><h2 id="Spark常用算子介绍"><a href="#Spark常用算子介绍" class="headerlink" title="Spark常用算子介绍"></a>Spark常用算子介绍</h2><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211110111139472.png" alt="image-20211110111139472"></p><p>转换算子:将一个RDD变成另一个RDD，RDD之间的转换，懒执行，需要操作算子触发执行</p><p>操作算子(行为算子):不能将一个RDD变成另一个RDD，每一个操作算子都会触发一个job</p><p>一个Spark程序中可以包含很多个job</p><p>可以通过算子的返回值去判断该算子是转换算子还是操作算子</p><p>转换算子必须要带上一个操作算子。</p><h2 id="相关代码请看我的GitHub个人仓库"><a href="#相关代码请看我的GitHub个人仓库" class="headerlink" title="相关代码请看我的GitHub个人仓库"></a><strong>相关代码请看我的GitHub个人仓库</strong></h2><p><a href="https://github.com/Fang-gg/Spark.git">https://github.com/Fang-gg/Spark.git</a></p><h2 id="Cache缓存"><a href="#Cache缓存" class="headerlink" title="Cache缓存"></a>Cache缓存</h2><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211111195952229.png" alt="image-20211111195952229"></p><ul><li>通常情况下，缓存策略的选择<ul><li>数据量不大，内存充足的情况下，选择 MEMORY_ONLY</li><li>数据量有点大，内存不能完全放下，选择 MEMORY_AND_DISK_SER，尽可能要将数据缓存到内存中，这样的效率是最高的</li></ul></li></ul><h2 id="CheckPoint"><a href="#CheckPoint" class="headerlink" title="CheckPoint"></a>CheckPoint</h2><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/checkpoint.png" alt="checkpoint"></p><blockquote><p>因为checkpoint需要重新启动一个任务进行计算并写入HDFS<br>可以在checkpoint之前 先做一次cache 可以省略计算过程 直接写入HDFS</p></blockquote><h2 id="累加器和广播变量"><a href="#累加器和广播变量" class="headerlink" title="累加器和广播变量"></a>累加器和广播变量</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fst</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.util.<span class="type">LongAccumulator</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Demo17Acc</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 累加器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> conf: <span class="type">SparkConf</span> = <span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line">      .setMaster(<span class="string">&quot;local&quot;</span>)</span><br><span class="line">      .setAppName(<span class="string">&quot;Demo17Acc&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> sc: <span class="type">SparkContext</span> = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取学生数据构建RDD</span></span><br><span class="line">    <span class="keyword">val</span> stuRDD: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(<span class="string">&quot;spark/data/students.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    println(<span class="string">&quot;i is &quot;</span> + i)</span><br><span class="line">    <span class="comment">// 算子内部的代码 使用了外部变量i</span></span><br><span class="line">    <span class="comment">// 实际上最终封装到task中的是i的一个副本</span></span><br><span class="line">    stuRDD.foreach(line =&gt; &#123;</span><br><span class="line">      i += <span class="number">1</span></span><br><span class="line">      println(line)</span><br><span class="line">    &#125;)</span><br><span class="line">    println(<span class="string">&quot;i is &quot;</span> + i)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果想在算子内部 对外部的变量做一个累加操作</span></span><br><span class="line">    <span class="comment">// 累加器</span></span><br><span class="line">    <span class="comment">// 在算子外面 即Driver端 通过累加器创建一个变量l</span></span><br><span class="line">    <span class="keyword">val</span> l: <span class="type">LongAccumulator</span> = sc.longAccumulator</span><br><span class="line">    stuRDD.foreach(line =&gt; &#123;</span><br><span class="line">      <span class="comment">// 在算子内部使用累加器进行累加</span></span><br><span class="line">      l.add(<span class="number">1</span>)</span><br><span class="line">      println(line)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 在算子外面 即Driver端 获取累加器最终的结果</span></span><br><span class="line">    println(l.value)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RDD内部不能再套RDD</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 首先RDD是一种抽象的编程模型，并没有实现序列化所以不能进行网络传输</span></span><br><span class="line"><span class="comment">     * 其次就算RDD能够进行网络传输，那如果RDD中还有RDD，</span></span><br><span class="line"><span class="comment">     * 那么需要再task再去申请资源启动Driver、Executor？</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果RDD中套了RDD 就要去整理一下思路，是不是可以转换为其他方式去实现你的逻辑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//    stuRDD.foreach(line=&gt;&#123;</span></span><br><span class="line">    <span class="comment">//      stuRDD.foreach(l2=&gt;&#123;</span></span><br><span class="line">    <span class="comment">//        println(l2)</span></span><br><span class="line">    <span class="comment">//      &#125;)</span></span><br><span class="line">    <span class="comment">//    &#125;)</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E7%B4%AF%E5%8A%A0%E5%99%A8%E5%92%8C%E5%B9%BF%E6%92%AD%E5%8F%98%E9%87%8F.png" alt="累加器和广播变量"></p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fst</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.broadcast.<span class="type">Broadcast</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Demo18Broadcast</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 广播变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> conf: <span class="type">SparkConf</span> = <span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line">      .setMaster(<span class="string">&quot;local&quot;</span>)</span><br><span class="line">      .setAppName(<span class="string">&quot;Demo18Broadcast&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> sc: <span class="type">SparkContext</span> = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取学生数据构建RDD</span></span><br><span class="line">    <span class="keyword">val</span> stuRDD: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(<span class="string">&quot;spark/data/students.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以学生id构成的List</span></span><br><span class="line">    <span class="keyword">val</span> stuIDs: <span class="type">List</span>[<span class="type">String</span>] = <span class="type">List</span>(<span class="string">&quot;1500100003&quot;</span>, <span class="string">&quot;1500100013&quot;</span>, <span class="string">&quot;1500100023&quot;</span>, <span class="string">&quot;1500100033&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据stuIDs在stuRDD中过滤出这些学生的信息</span></span><br><span class="line">    <span class="comment">// 算子内部的代码会被封装成task</span></span><br><span class="line">    <span class="comment">// 相当于每个task中都有一份stuIDs 很明显造成了资源浪费</span></span><br><span class="line">    stuRDD.filter(line =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> id: <span class="type">String</span> = line.split(<span class="string">&quot;,&quot;</span>)(<span class="number">0</span>)</span><br><span class="line">      stuIDs.contains(id)</span><br><span class="line">    &#125;).foreach(println)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用广播变量</span></span><br><span class="line">    <span class="comment">// 在Driver端 将stuIDs广播到每一个Executor中</span></span><br><span class="line">    <span class="keyword">val</span> stuIDsBro: <span class="type">Broadcast</span>[<span class="type">List</span>[<span class="type">String</span>]] = sc.broadcast(stuIDs)</span><br><span class="line">    stuRDD.filter(line =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> id: <span class="type">String</span> = line.split(<span class="string">&quot;,&quot;</span>)(<span class="number">0</span>)</span><br><span class="line">      <span class="comment">// 从Executor中获取广播的变量</span></span><br><span class="line">      <span class="keyword">val</span> stuIDsV: <span class="type">List</span>[<span class="type">String</span>] = stuIDsBro.value</span><br><span class="line">      stuIDsV.contains(id)</span><br><span class="line">    &#125;).foreach(println)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="资源调度和任务调度"><a href="#资源调度和任务调度" class="headerlink" title="资源调度和任务调度"></a>资源调度和任务调度</h2><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6%E5%92%8C%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6.png" alt="资源调度和任务调度"></p><h2 id="Shuffle寻址过程"><a href="#Shuffle寻址过程" class="headerlink" title="Shuffle寻址过程"></a>Shuffle寻址过程</h2><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/shuffle%E5%AF%BB%E5%9D%80%E8%BF%87%E7%A8%8B.png" alt="shuffle寻址过程"></p>]]></content>
      
      
      <categories>
          
          <category> 大数据学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scala学习</title>
      <link href="/2021/11/05/Scala%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/11/05/Scala%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h1><h2 id="Scala与Java的区别和共性"><a href="#Scala与Java的区别和共性" class="headerlink" title="Scala与Java的区别和共性"></a>Scala与Java的区别和共性</h2><h3 id="Scala特性"><a href="#Scala特性" class="headerlink" title="Scala特性"></a>Scala特性</h3><blockquote><p>Scala可拓展<br>面向对象<br><strong>函数式编程</strong><br><strong>兼容JAVA</strong><br>类库调用<br>互操作<br>语法简洁<br>代码行短<br>类型推断<br>抽象控制<br>静态类型化（不能随便改变类型，var和val只能改变值）<br>可检验<br>安全重构<br><strong>支持并发控制</strong><br>强计算能力<br>自定义其他控制结构</p></blockquote><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>Java中<br>Scala中非常兼容Java，这里我们简单定义一个Java类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1Java</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打印java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo1Java demo1Java = <span class="keyword">new</span> Demo1Java();</span><br><span class="line">        demo1Java.print();<span class="comment">//这是通过类的对象调用的方法</span></span><br><span class="line"></span><br><span class="line">        Demo1Java.main(args);<span class="comment">//这是通过类对象调用的方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        new Demo2Scala().print_scala();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Java中可以直接调用Scala中的类</span></span><br><span class="line">        <span class="keyword">new</span> Demo4ScalaStu().print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里我们可以看到，在Java中，<strong>如果类中的一个方法不加上static的话，那它就只是一个普通的成员方法，必须通过类的对象调用</strong>，也就是下面这样：（这里面我们的print方法没有static修饰，只是一个简单的方法，调用的时候就需要创建一个类的对象来进行调用）</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211105232003855.png" alt="image-20211105232003855"></p><p>而<strong>只有static修饰的方法，才能通过类对象（类名）的方式直接调用</strong>，也就是下面这样：（因为Java中的main方法是由虚拟机调用的，也就是通过类对象这种方式调用的，类对象就是代码经过编译生成的.class字节码文件加载到内存的一个对象，主函数里面有一个static修饰，去掉static会报错，也就是说，<strong>主函数需要通过类对象的方式进行调用</strong>）<br><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211105232128659.png" alt="image-20211105232128659"></p><h2 id="Scala运行方式"><a href="#Scala运行方式" class="headerlink" title="Scala运行方式"></a>Scala运行方式</h2><p>Scala中的main方法只能放在object中运行，也就是说，object修饰的类相当于就是一个静态类，也就是相当于代码加载到虚拟机中的“类对象”，类中的方法和属性，相当于自动加上了static，可以直接通过“类对象”（类名）的方式直接调用，是一种单例模式</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Demo2Scala</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> i = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Scala中的main方法</span></span><br><span class="line"><span class="comment">    * 在Scala中的方法不可以用static修饰</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * def 定义一个函数的关键字</span></span><br><span class="line"><span class="comment">    * main 方法名</span></span><br><span class="line"><span class="comment">    * args: Array[String] 参数名：参数类型</span></span><br><span class="line"><span class="comment">    * Unit 返回值类型 相当于Java中的void</span></span><br><span class="line"><span class="comment">    * &#123;&#125; 方法体</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">print_scala</span></span>(): <span class="type">Unit</span> =&#123;</span><br><span class="line">    print(<span class="string">&quot;scala&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">print_s</span></span>: <span class="type">String</span> =&#123;</span><br><span class="line">    <span class="keyword">val</span> s = <span class="string">&quot;S&quot;</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    print(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">    <span class="type">Demo2Scala</span>.print_scala()</span><br><span class="line">    print(<span class="type">Demo2Scala</span>.i)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="共性"><a href="#共性" class="headerlink" title="共性"></a>共性</h2><p>Java中可以直接调用Scala中的类，并使用里面的方法</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211105232356180.png" alt="image-20211105232356180"></p><p>Scala中的类：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo4ScalaStu</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">print</span></span>(): <span class="type">Unit</span> =&#123;</span><br><span class="line">    println(<span class="string">&quot;Scala Stu&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区别（一些使用的区别）"><a href="#区别（一些使用的区别）" class="headerlink" title="区别（一些使用的区别）"></a>区别（一些使用的区别）</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.&#123;<span class="type">BufferedReader</span>, <span class="type">FileReader</span>&#125;</span><br><span class="line"><span class="keyword">import</span> java.util</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.io.&#123;<span class="type">BufferedSource</span>, <span class="type">Source</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Demo5ScalaBase</span> </span>&#123;</span><br><span class="line">  <span class="comment">//scala的基本语法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 变量</span></span><br><span class="line"><span class="comment">      * 可以使用val 和 var 来定义变量，定义的时候不需要指定类型，但是最好指定类型</span></span><br><span class="line"><span class="comment">      * 用val修饰的变量，不能进行修饰，相当于常量</span></span><br><span class="line"><span class="comment">      * 用var修饰的变量，可以进行修改</span></span><br><span class="line"><span class="comment">      * 能使用val就使用val</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">val</span> i = <span class="number">100</span></span><br><span class="line">    <span class="keyword">var</span> j = <span class="number">200</span></span><br><span class="line">    j = <span class="number">300</span></span><br><span class="line">    println(i+<span class="number">1</span>)<span class="comment">//这样不算是修改变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//自动推断类型</span></span><br><span class="line">    <span class="keyword">val</span> k = <span class="number">100</span></span><br><span class="line">    <span class="comment">//最好手动加上类型</span></span><br><span class="line">    <span class="keyword">val</span> kk : <span class="type">Int</span> = <span class="number">200</span></span><br><span class="line">    <span class="comment">//不知道是什么类型就使用object类型</span></span><br><span class="line">    <span class="keyword">val</span> k1 :<span class="type">Object</span> = <span class="string">&quot;100&quot;</span></span><br><span class="line">    println(k)</span><br><span class="line">    println(kk)</span><br><span class="line">    println(k1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//类型转换</span></span><br><span class="line">    <span class="comment">//Java中的类型转换</span></span><br><span class="line">    <span class="keyword">val</span> str1 = <span class="string">&quot;123&quot;</span></span><br><span class="line">    println(<span class="type">Integer</span>.parseInt(str1))</span><br><span class="line">    <span class="comment">//scala中的类型转换：只要数据符合要求，就可以直接to+类型</span></span><br><span class="line">    <span class="keyword">val</span> i1 = str1.toInt</span><br><span class="line">    println(i1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//String类型</span></span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="keyword">val</span> str:<span class="type">String</span> = <span class="string">&quot;Hello,World&quot;</span></span><br><span class="line">    println(str.getClass.getSimpleName)</span><br><span class="line">    <span class="keyword">val</span> strings = str.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    strings.foreach(println) <span class="comment">//这样就可以直接输出遍历了</span></span><br><span class="line">    println(strings&#123;<span class="number">0</span>&#125;) <span class="comment">//这里输出需要用&#123;&#125;括号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> str2:<span class="type">String</span> = <span class="string">&quot;abc&quot;</span>+<span class="string">&quot;def&quot;</span></span><br><span class="line">    println(str2)</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="keyword">val</span> builder: <span class="type">StringBuilder</span> = <span class="keyword">new</span> <span class="type">StringBuilder</span>()</span><br><span class="line">    builder.append(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    builder.append(<span class="string">&quot;bc&quot;</span>)</span><br><span class="line">    println(builder)</span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    <span class="comment">//可以通过 $变量名 在字符串中去变量的值 底层是StringBuilder</span></span><br><span class="line">    <span class="keyword">val</span> str3:<span class="type">String</span> = <span class="string">&quot;abc&quot;</span></span><br><span class="line">    <span class="keyword">val</span> str4:<span class="type">String</span> = <span class="string">&quot;def&quot;</span></span><br><span class="line">    <span class="keyword">val</span> str5:<span class="type">String</span> = <span class="string">&quot;hij&quot;</span></span><br><span class="line">    println(<span class="string">s&quot;<span class="subst">$str3</span>,<span class="subst">$str4</span>,<span class="subst">$str5</span>&quot;</span>)<span class="comment">//前面用上s</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//文件读写</span></span><br><span class="line">    <span class="comment">//Java方式</span></span><br><span class="line">    <span class="keyword">val</span> br = <span class="keyword">new</span> <span class="type">BufferedReader</span>(<span class="keyword">new</span> <span class="type">FileReader</span>(<span class="string">&quot;data/students.txt&quot;</span>))</span><br><span class="line">    <span class="keyword">var</span> line:<span class="type">String</span> = br.readLine()</span><br><span class="line">    <span class="keyword">while</span> (line!=<span class="literal">null</span>)&#123;</span><br><span class="line">      println(line)</span><br><span class="line">      line = br.readLine()</span><br><span class="line">    &#125;</span><br><span class="line">    br.close()</span><br><span class="line">    println(<span class="string">&quot;*&quot;</span> * <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//scala读取文件</span></span><br><span class="line">    <span class="keyword">val</span> source: <span class="type">BufferedSource</span> = <span class="type">Source</span>.fromFile(<span class="string">&quot;data/students.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> iter: <span class="type">Iterator</span>[<span class="type">String</span>] = source.getLines() <span class="comment">//返回一个迭代器，但是迭代器只能遍历一次</span></span><br><span class="line">    <span class="comment">//scala中的foreach</span></span><br><span class="line">    <span class="keyword">for</span> (elem &lt;- iter) &#123;</span><br><span class="line">      println(elem)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;*&quot;</span> * <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一种简化</span></span><br><span class="line">    <span class="keyword">for</span>(elem&lt;-<span class="type">Source</span></span><br><span class="line">    .fromFile(<span class="string">&quot;data/students.txt&quot;</span>)</span><br><span class="line">    .getLines())&#123;</span><br><span class="line">      println(elem)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;*&quot;</span> * <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种简化：链式调用</span></span><br><span class="line">    <span class="type">Source</span></span><br><span class="line">      .fromFile(<span class="string">&quot;data/students.txt&quot;</span>)</span><br><span class="line">      .getLines()</span><br><span class="line">      .foreach(println)</span><br><span class="line">    println(<span class="string">&quot;*&quot;</span> * <span class="number">50</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="scala面向对象编程"><a href="#scala面向对象编程" class="headerlink" title="scala面向对象编程"></a>scala面向对象编程</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">id:<span class="type">String</span>,name:<span class="type">String</span>,age:<span class="type">Int</span></span>)</span>&#123;</span><br><span class="line">  println(<span class="string">&quot;默认的构造函数&quot;</span>)</span><br><span class="line">  <span class="comment">//直接定义类的属性</span></span><br><span class="line">  <span class="keyword">val</span> _id:<span class="type">String</span> = id</span><br><span class="line">  <span class="keyword">val</span> _name:<span class="type">String</span> = name</span><br><span class="line">  <span class="keyword">val</span> _age:<span class="type">Int</span> = age</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Demo6ScalaClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> stu: <span class="type">Student</span> = <span class="keyword">new</span> <span class="type">Student</span>(<span class="string">&quot;001&quot;</span>,<span class="string">&quot;张三&quot;</span>,<span class="number">21</span>)</span><br><span class="line">    println(stu._id)</span><br><span class="line">    println(stu._name)</span><br><span class="line">    println(stu._age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造方法的重载"><a href="#构造方法的重载" class="headerlink" title="构造方法的重载"></a>构造方法的重载</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">id:<span class="type">String</span>,name:<span class="type">String</span>,age:<span class="type">Int</span></span>)</span>&#123;</span><br><span class="line">  println(<span class="string">&quot;默认的构造函数&quot;</span>)</span><br><span class="line">  <span class="comment">//直接定义类的属性</span></span><br><span class="line">  <span class="keyword">val</span> _id:<span class="type">String</span> = id</span><br><span class="line">  <span class="keyword">val</span> _name:<span class="type">String</span> = name</span><br><span class="line">  <span class="keyword">val</span> _age:<span class="type">Int</span> = age</span><br><span class="line">  <span class="keyword">var</span> _clazz:<span class="type">String</span> = _</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  构造方法的重载 需要重新实现this方法</span></span><br><span class="line"><span class="comment">//  第一行代码必须调用默认的构造方法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(id:<span class="type">String</span>,name:<span class="type">String</span>,age:<span class="type">Int</span>,clazz:<span class="type">String</span>)&#123;</span><br><span class="line">    <span class="comment">//调用默认的构造方法</span></span><br><span class="line">    <span class="keyword">this</span>(id,name,age)</span><br><span class="line">    _clazz = clazz</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Demo6ScalaClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> stu: <span class="type">Student</span> = <span class="keyword">new</span> <span class="type">Student</span>(<span class="string">&quot;001&quot;</span>,<span class="string">&quot;张三&quot;</span>,<span class="number">21</span>)</span><br><span class="line">    println(stu._id)</span><br><span class="line">    println(stu._name)</span><br><span class="line">    println(stu._age)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> stu2:<span class="type">Student</span> = <span class="keyword">new</span> <span class="type">Student</span>(<span class="string">&quot;002&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="number">22</span>,<span class="string">&quot;文科一班&quot;</span>)</span><br><span class="line">    println(stu2._id)</span><br><span class="line">    println(stu2._name)</span><br><span class="line">    println(stu2._age)</span><br><span class="line">    println(stu2._clazz)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<br>// 如果变量名以下划线开头 需要用花括号括起来<br>// 如果想调用变量的某个方法 也需要用花括号括起来<br>// return 可以省略 最后一行代码默认是返回的值</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">id:<span class="type">String</span>,name:<span class="type">String</span></span>)</span>&#123;</span><br><span class="line">  println(<span class="string">&quot;A的构造方法&quot;</span>)</span><br><span class="line">  <span class="comment">//定义即赋值</span></span><br><span class="line">  <span class="keyword">val</span> _id:<span class="type">String</span> = id</span><br><span class="line">  <span class="keyword">val</span> _name:<span class="type">String</span> = name</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>= <span class="string">s&quot;A(<span class="subst">$&#123;_id&#125;</span>, <span class="subst">$&#123;_name&#125;</span>)&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 继承还是使用extends关键字</span></span><br><span class="line"><span class="comment">  * 但是在继承的时候，需要调用父类的构造方法</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">id:<span class="type">String</span>,name:<span class="type">String</span>,age:<span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">A</span>(<span class="params">id,name</span>)</span>&#123;</span><br><span class="line">  println(<span class="string">&quot;B中的构造方法&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> _age:<span class="type">Int</span> = age</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>= <span class="string">s&quot;B(<span class="subst">$&#123;_id&#125;</span>, <span class="subst">$&#123;_name&#125;</span>,<span class="subst">$&#123;_age&#125;</span>)&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Demo7ScalaExtend</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> b: <span class="type">A</span> = <span class="keyword">new</span> <span class="type">B</span>(<span class="string">&quot;001&quot;</span>,<span class="string">&quot;张三&quot;</span>,<span class="number">21</span>)</span><br><span class="line">    println(b.toString)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="样例类"><a href="#样例类" class="headerlink" title="样例类"></a>样例类</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Demo8CaseClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//创建样例类对象的时候，new关键字可以省略</span></span><br><span class="line">    <span class="keyword">val</span> stu: <span class="type">Stu</span> = <span class="type">Stu</span>(<span class="string">&quot;001&quot;</span>,<span class="string">&quot;张三&quot;</span>,<span class="number">21</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;文科一班&quot;</span>)</span><br><span class="line">    println(stu.id)</span><br><span class="line">    println(stu.name)</span><br><span class="line">    println(stu.age)</span><br><span class="line">    println(stu.gender)</span><br><span class="line">    println(stu.clazz)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//样例类中的参数 就是该类的属性</span></span><br><span class="line">    <span class="comment">//默认是以val赋值的，如果想要修改，就需要手动修改成var</span></span><br><span class="line">    stu.age = <span class="number">22</span></span><br><span class="line">    println(stu.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 样例类：会给每一个属性在编译的时候自动加上“get、set”方法，还会实现序列化接口</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Stu</span>(<span class="params">id:<span class="type">String</span>,name:<span class="type">String</span>,var age:<span class="type">Int</span>,gender:<span class="type">String</span>,clazz:<span class="type">String</span></span>)</span></span><br></pre></td></tr></table></figure><h2 id="循环、选择结构"><a href="#循环、选择结构" class="headerlink" title="循环、选择结构"></a>循环、选择结构</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Demo9Supply</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * scala中的数据类型</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="comment">//基本数据类型</span></span><br><span class="line">    <span class="keyword">val</span> byte:<span class="type">Byte</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">val</span> short:<span class="type">Short</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">val</span> int:<span class="type">Int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">val</span> long:<span class="type">Long</span> = <span class="number">100</span></span><br><span class="line">    <span class="keyword">val</span> float:<span class="type">Float</span> = <span class="number">1.1</span>F</span><br><span class="line">    <span class="keyword">val</span> double:<span class="type">Double</span> = <span class="number">1.2</span>D</span><br><span class="line">    <span class="keyword">val</span> boolean:<span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">val</span> char:<span class="type">Char</span> = &#x27;c&#x27;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Any 好比是Java中的Object</span></span><br><span class="line">    <span class="comment">//AnyRef 是所有引用类型的基类</span></span><br><span class="line">    <span class="comment">//AnyVal 是所有基本类型的基类</span></span><br><span class="line">    <span class="keyword">val</span> str:<span class="type">AnyRef</span> = <span class="string">&quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 循环</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="comment">//while循环计算1-100的和</span></span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (i&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">      sum=sum+i</span><br><span class="line">      i+=<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(sum)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//do while循环计算1-100的和</span></span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">100</span></span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">200</span></span><br><span class="line">    <span class="keyword">var</span> x_y = <span class="number">0</span></span><br><span class="line">    do&#123;</span><br><span class="line">      x_y = x+y</span><br><span class="line">    &#125; <span class="keyword">while</span> (x&gt;y)</span><br><span class="line">    println(x_y)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for循环</span></span><br><span class="line">    <span class="comment">//实际上scala中的for循环和Python类似，只有for each</span></span><br><span class="line">    <span class="comment">//也有range函数</span></span><br><span class="line">    <span class="comment">//计算1-100的和</span></span><br><span class="line">    <span class="keyword">val</span> list = <span class="keyword">new</span> util.<span class="type">ArrayList</span>[<span class="type">Int</span>]()</span><br><span class="line">    <span class="keyword">var</span> sum2 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (elem &lt;- <span class="type">Range</span>(<span class="number">1</span>, <span class="number">101</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">      sum2+=elem</span><br><span class="line">    &#125;</span><br><span class="line">    println(sum2)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//选择结构</span></span><br><span class="line">    <span class="keyword">val</span> age = <span class="number">18</span></span><br><span class="line">    <span class="keyword">if</span>(age&gt;=<span class="number">18</span>)&#123;</span><br><span class="line">      println(<span class="string">&quot;成年&quot;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(age&lt;<span class="number">0</span>)&#123;</span><br><span class="line">      println(<span class="string">&quot;年龄输入不正确&quot;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(age&lt;<span class="number">18</span>)&#123;</span><br><span class="line">      println(<span class="string">&quot;未成年&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="样例类-1"><a href="#样例类-1" class="headerlink" title="样例类"></a>样例类</h2><h3 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h3><blockquote><p>//object B1和class B1互为伴生对象和伴生类，<br>//创建对象的时候，可以new一个B1类来创建对象<br>//也可以用伴生对象的apply方法创建对象或者直接省略，直接创建<br>val lisi: B1 = B1.apply(“002”,“李四”)<br>val wangwu: B1 = B1(“003”,“王五”)<br>B1.fun()</p></blockquote><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Demo10Apply</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> a: <span class="type">A1</span> = <span class="keyword">new</span> <span class="type">A1</span>(<span class="string">&quot;001&quot;</span>,<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> b: <span class="type">B1</span> = <span class="keyword">new</span> <span class="type">B1</span>(<span class="string">&quot;001&quot;</span>,<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span>(<span class="params">id:<span class="type">String</span>,name:<span class="type">String</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">val</span> _id:<span class="type">String</span> = id</span><br><span class="line">  <span class="keyword">val</span> _name:<span class="type">String</span> = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span>(<span class="params">id:<span class="type">String</span>,name:<span class="type">String</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">val</span> _id:<span class="type">String</span> = id</span><br><span class="line">  <span class="keyword">val</span> _name:<span class="type">String</span> = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//称之为B1的伴生对象</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">B1</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fun</span></span>(): <span class="type">Unit</span> =&#123;</span><br><span class="line">    println(<span class="string">&quot;fun&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//这里会返回一个对象，该对象的类型是跟object同名的一个类</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(id:<span class="type">String</span>,name:<span class="type">String</span>): <span class="type">B1</span> =&#123;</span><br><span class="line">    <span class="keyword">val</span> b1 = <span class="keyword">new</span> <span class="type">B1</span>(id,name)</span><br><span class="line">    b1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数可以定义在Scala中的 <strong>类中、object中、函数中</strong></p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Demo11Func1</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 函数可以定义在</span></span><br><span class="line"><span class="comment">    * 类中、object中、函数中</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fun</span></span>() =&#123;</span><br><span class="line">    println(<span class="string">&quot;fun&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//函数的最后一行代码默认作为返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun1</span></span>(): <span class="type">Unit</span> =&#123;</span><br><span class="line">      println(<span class="string">&quot;hello &quot;</span> + fun2())</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun2</span></span>(): <span class="type">Unit</span> =&#123;</span><br><span class="line">      <span class="string">&quot;world&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函数的省略</span></span><br><span class="line"><span class="comment">  * 1、return 关键字可以省略 默认最后一行代码作为返回值</span></span><br><span class="line"><span class="comment">  * 2、返回值类型可以省略 可以根据返回值自动推断</span></span><br><span class="line"><span class="comment">  * 3、只有一行代码的时候 花括号可以省略</span></span><br><span class="line"><span class="comment">  * 4、如果函数没有参数 括号可以省略</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun3</span></span>(str:<span class="type">String</span>): <span class="type">Int</span> =&#123;</span><br><span class="line">  <span class="keyword">return</span> str.toInt + <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.函数return关键字可以省略</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun4</span></span>(str:<span class="type">String</span>):<span class="type">Int</span> = &#123;</span><br><span class="line">  str.toInt + <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.返回值类型可以省略</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun5</span></span>(str:<span class="type">String</span>) =&#123;</span><br><span class="line">  str.toInt + <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.花括号可以省略</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun6</span></span>(str:<span class="type">String</span>) = str.toInt + <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.括号可以省略</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun7</span> </span>= <span class="string">&quot;hello world&quot;</span> <span class="comment">//这是一个函数</span></span><br></pre></td></tr></table></figure><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>Java中是面向对象编程，是把对象传来传去，对象作为参数传入时会有类型限制，对象作为返回值时也会有类型限制</p><p>Scala函数式编程，把函数传来传去，函数作为参数传入时会有类型限制，函数作为返回值时也会有类型限制</p><p>有两类，一类是以函数作为参数，一类是以函数作为返回值</p><h2 id="函数的类型"><a href="#函数的类型" class="headerlink" title="函数的类型"></a>函数的类型</h2><p>什么是函数的类型：<br><strong>跟def关键字无关<br>跟函数名无关<br>跟函数实现的功能无关<br>跟函数的参数名无关</strong></p><p>函数的类型由 <strong>参数的类型（类型、个数、顺序）以及返回值的类型共同决定</strong></p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 函数类型</span></span><br><span class="line"><span class="comment">    * @param str</span></span><br><span class="line"><span class="comment">    * @return</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="comment">//fun1是一个有一个参数，参数类型为string，返回值类型为int类型的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fun1</span></span>(str: <span class="type">String</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    str.toInt + <span class="number">100</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//fun2是一个有一个参数，参数类型为string，返回值类型为int类型的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fun2</span></span>(str: <span class="type">String</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    str.toInt + <span class="number">100</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//fun3是一个有一个参数，参数类型为int，返回值类型为int类型的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fun3</span></span>(i: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    i + <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//这里fun1和fun2为同类型函数，fun3不属于</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="lambda表达式用以简化"><a href="#lambda表达式用以简化" class="headerlink" title="lambda表达式用以简化"></a>lambda表达式用以简化</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *f:String=&gt;Int</span></span><br><span class="line"><span class="comment">    *f：是funX函数所需要的参数的参数名</span></span><br><span class="line"><span class="comment">    *String=&gt;Int：是funX所需要的参数的类型</span></span><br><span class="line"><span class="comment">    *=&gt; 左边的部分 表示 所传进来的函数 的 参数类型</span></span><br><span class="line"><span class="comment">    *=&gt; 右边的部分 表示 所传进来的函数 的 返回值类型</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="comment">//这里定义了一个函数，它可以接收一个函数</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">funX</span></span>(f:<span class="type">String</span>=&gt;<span class="type">Int</span>) = &#123;</span><br><span class="line">    <span class="keyword">val</span> i:<span class="type">Int</span> = f(<span class="string">&quot;200&quot;</span>)</span><br><span class="line">    println(i)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * lambda表达式 匿名函数 用以简化函数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">//定义了一个有两个参数 类型分别是string 和 int，返回值类型为int这样的匿名函数</span></span><br><span class="line">  (str:<span class="type">String</span>,int:<span class="type">Int</span>) =&gt; &#123;</span><br><span class="line">    str.toInt + int</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//使用lambda简化fun1</span></span><br><span class="line">  <span class="keyword">val</span> i :<span class="type">String</span> =&gt; <span class="type">Int</span> =(str:<span class="type">String</span>)=&gt;str.toInt + <span class="number">100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(fun1(<span class="string">&quot;200&quot;</span>))</span><br><span class="line">    println(fun2(<span class="string">&quot;200&quot;</span>))</span><br><span class="line"></span><br><span class="line">    funX(fun1)</span><br><span class="line">    funX(fun2)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//lambda简化</span></span><br><span class="line">    funX((str1:<span class="type">String</span>)=&gt;&#123;</span><br><span class="line">      str1.toInt + <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//lambda的简化</span></span><br><span class="line">    <span class="comment">//1.如果代码只有一行 花括号可以省略</span></span><br><span class="line">    <span class="comment">//2.参数的类型可以省略 括号也可以顺便省略</span></span><br><span class="line">    <span class="comment">//3.如果参数只被调用了一次，则可以使用_下划线替代</span></span><br><span class="line">    funX((str1: <span class="type">String</span>) =&gt; str1.toInt + <span class="number">1</span>)</span><br><span class="line">    funX(str1 =&gt; str1.toInt + <span class="number">1</span>)</span><br><span class="line">    funX(_.toInt + <span class="number">1</span>)</span><br><span class="line">    funX(i)</span><br><span class="line">    println(i(<span class="string">&quot;100&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h2><p>这里面函数作为map函数的参数</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Demo13Func3</span> </span>&#123;</span><br><span class="line">  <span class="comment">//函数作为参数的应用</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> array: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>[<span class="type">Int</span>](<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line">    println(array) <span class="comment">//打印出来一个地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定一个分隔符，将数组中的元素依次拼接，最后得到一个string</span></span><br><span class="line">    <span class="comment">//同split相反，split是将一个string分割，最后得到一个数组</span></span><br><span class="line">    println(array.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对array中的每个元素加1</span></span><br><span class="line">    <span class="comment">//以函数式编程的思想来做，需要用到map函数，map函数可以对里面的元素做变化</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(i:<span class="type">Int</span>):<span class="type">Int</span> = &#123;</span><br><span class="line">      i+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    array.map(add).foreach(println)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    array.map(_ + 1).foreach(println)</span></span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 以函数作为返回值，也有类型的限制</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">//在以函数作为返回值时，需要手动给定类型 自动推断会有问题</span></span><br><span class="line"><span class="comment">//这里定义了一个以函数作为返回值的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun1</span></span>(str1: <span class="type">String</span>):<span class="type">String</span>=&gt;<span class="type">Int</span>=&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fun2</span></span>(str2:<span class="type">String</span>):<span class="type">Int</span>=&#123;</span><br><span class="line">    str1.toInt + str2.toInt</span><br><span class="line">  &#125;</span><br><span class="line">  fun2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里定义一个函数，可以传入两个参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun3</span></span>(str1:<span class="type">String</span>,str2:<span class="type">String</span>): <span class="type">Int</span> =&#123;</span><br><span class="line">  str1.toInt + str2.toInt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数的柯里化：将一个有N个参数的函数 变成 N个只有一个参数的函数；也就是把括号拆开来罢了</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun4</span></span>(str1:<span class="type">String</span>)(str2:<span class="type">String</span>):<span class="type">Int</span>=&#123;</span><br><span class="line">  str1.toInt + str2.toInt</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//偏函数：将一个含有N个参数的函数，变成含有N-X个参数的函数 X表示固定的参数；也就是把其中一个变量固定罢了</span></span><br><span class="line"><span class="comment">//计算a的b次方</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun5</span></span>(a:<span class="type">Int</span>,b:<span class="type">Int</span> = <span class="number">3</span>):<span class="type">Double</span> = &#123;</span><br><span class="line">  <span class="type">Math</span>.pow(a,b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更多详细代码，请访问我的GitHub仓库地址:<a href="https://github.com/Fang-gg/Scala.git">https://github.com/Fang-gg/Scala.git</a></p>]]></content>
      
      
      <categories>
          
          <category> 大数据学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法</title>
      <link href="/2021/10/25/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2021/10/25/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="十大经典排序算法"><a href="#十大经典排序算法" class="headerlink" title="十大经典排序算法"></a>十大经典排序算法</h1><h2 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h2><h3 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h3><p>十种常见排序算法可以分为两大类：</p><ul><li><strong>比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</li><li><strong>非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 </li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/849589-20190306165258970-1789860540.png" alt="img"></p><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/849589-20180402133438219-1946132192.png" alt="img"></p><p><strong>相关概念</strong></p><ul><li><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li><li><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li><li><strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li><li><strong>空间复杂度：</strong>是指算法在计算机</li></ul><p>内执行时所需存储空间的度量，它也是数据规模n的函数。 </p><h2 id="1、冒泡排序（Bubble-Sort）"><a href="#1、冒泡排序（Bubble-Sort）" class="headerlink" title="1、冒泡排序（Bubble Sort）"></a>1、冒泡排序（Bubble Sort）</h2><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 </p><h3 id="1-1-算法描述"><a href="#1-1-算法描述" class="headerlink" title="1.1 算法描述"></a>1.1 算法描述</h3><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul><p><strong>1.2 动图演示</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/849589-20171015223238449-2146169197.gif" alt="img"></p><h3 id="1-3-代码实现"><a href="#1-3-代码实现" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function bubbleSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    for (var i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">        for (var j = 0; j &lt; len - 1 - i; j++) &#123;</span><br><span class="line">            if (arr[j] &gt; arr[j+1]) &#123;        // 相邻元素两两对比</span><br><span class="line">                var temp = arr[j+1];        // 元素交换</span><br><span class="line">                arr[j+1] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、选择排序（Selection-Sort）"><a href="#2、选择排序（Selection-Sort）" class="headerlink" title="2、选择排序（Selection Sort）"></a>2、选择排序（Selection Sort）</h2><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><h3 id="2-1-算法描述"><a href="#2-1-算法描述" class="headerlink" title="2.1 算法描述"></a>2.1 算法描述</h3><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><h3 id="2-2-动图演示"><a href="#2-2-动图演示" class="headerlink" title="2.2 动图演示"></a><strong>2.2 动图演示</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/849589-20171015224719590-1433219824.gif" alt="img">　　</p><h4 id="2-3-代码实现"><a href="#2-3-代码实现" class="headerlink" title="2.3 代码实现"></a>2.3 代码实现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function selectionSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    var minIndex, temp;</span><br><span class="line">    for (var i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        for (var j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">            if (arr[j] &lt; arr[minIndex]) &#123;     // 寻找最小的数</span><br><span class="line">                minIndex = j;                 // 将最小数的索引保存</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-算法分析"><a href="#2-4-算法分析" class="headerlink" title="2.4 算法分析"></a>2.4 算法分析</h3><p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p><h2 id="3、插入排序（Insertion-Sort）"><a href="#3、插入排序（Insertion-Sort）" class="headerlink" title="3、插入排序（Insertion Sort）"></a>3、插入排序（Insertion Sort）</h2><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><h3 id="3-1-算法描述"><a href="#3-1-算法描述" class="headerlink" title="3.1 算法描述"></a>3.1 算法描述</h3><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul><h3 id="3-2-动图演示"><a href="#3-2-动图演示" class="headerlink" title="3.2 动图演示"></a>3.2 动图演示</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/849589-20171015225645277-1151100000.gif" alt="img"></p><h3 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a>3.2 代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function insertionSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    var preIndex, current;</span><br><span class="line">    for (var i = 1; i &lt; len; i++) &#123;</span><br><span class="line">        preIndex = i - 1;</span><br><span class="line">        current = arr[i];</span><br><span class="line">        while (preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">            arr[preIndex + 1] = arr[preIndex];</span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex + 1] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-算法分析"><a href="#3-4-算法分析" class="headerlink" title="3.4 算法分析"></a>3.4 算法分析</h3><p>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h2 id="4、希尔排序（Shell-Sort）"><a href="#4、希尔排序（Shell-Sort）" class="headerlink" title="4、希尔排序（Shell Sort）"></a>4、希尔排序（Shell Sort）</h2><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p><h3 id="4-1-算法描述"><a href="#4-1-算法描述" class="headerlink" title="4.1 算法描述"></a>4.1 算法描述</h3><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><h3 id="4-2-动图演示"><a href="#4-2-动图演示" class="headerlink" title="4.2 动图演示"></a>4.2 动图演示</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/849589-20180331170017421-364506073.gif" alt="img"></p><h3 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function shellSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    for (var gap = Math.floor(len / 2); gap &gt; 0; gap = Math.floor(gap / 2)) &#123;</span><br><span class="line">        // 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行</span><br><span class="line">        for (var i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            var j = i;</span><br><span class="line">            var current = arr[i];</span><br><span class="line">            while (j - gap &gt;= 0 &amp;&amp; current &lt; arr[j - gap]) &#123;</span><br><span class="line">                 arr[j] = arr[j - gap];</span><br><span class="line">                 j = j - gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-算法分析"><a href="#4-4-算法分析" class="headerlink" title="4.4 算法分析"></a>4.4 算法分析</h3><p>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。　</p><h2 id="5、归并排序（Merge-Sort）"><a href="#5、归并排序（Merge-Sort）" class="headerlink" title="5、归并排序（Merge Sort）"></a>5、归并排序（Merge Sort）</h2><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p><h3 id="5-1-算法描述"><a href="#5-1-算法描述" class="headerlink" title="5.1 算法描述"></a>5.1 算法描述</h3><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><h3 id="5-2-动图演示"><a href="#5-2-动图演示" class="headerlink" title="5.2 动图演示"></a>5.2 动图演示</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/849589-20171015230557043-37375010.gif" alt="img"></p><h3 id="5-3-代码实现"><a href="#5-3-代码实现" class="headerlink" title="5.3 代码实现"></a>5.3 代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function mergeSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    if (len &lt; 2) &#123;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">    var middle = Math.floor(len / 2),</span><br><span class="line">        left = arr.slice(0, middle),</span><br><span class="line">        right = arr.slice(middle);</span><br><span class="line">    return merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function merge(left, right) &#123;</span><br><span class="line">    var result = [];</span><br><span class="line"> </span><br><span class="line">    while (left.length&gt;0 &amp;&amp; right.length&gt;0) &#123;</span><br><span class="line">        if (left[0] &lt;= right[0]) &#123;</span><br><span class="line">            result.push(left.shift());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    while (left.length)</span><br><span class="line">        result.push(left.shift());</span><br><span class="line"> </span><br><span class="line">    while (right.length)</span><br><span class="line">        result.push(right.shift());</span><br><span class="line"> </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-算法分析"><a href="#5-4-算法分析" class="headerlink" title="5.4 算法分析"></a>5.4 算法分析</h3><p>归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。</p><h2 id="6、快速排序（Quick-Sort）"><a href="#6、快速排序（Quick-Sort）" class="headerlink" title="6、快速排序（Quick Sort）"></a>6、快速排序（Quick Sort）</h2><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h3 id="6-1-算法描述"><a href="#6-1-算法描述" class="headerlink" title="6.1 算法描述"></a>6.1 算法描述</h3><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><h3 id="6-2-动图演示"><a href="#6-2-动图演示" class="headerlink" title="6.2 动图演示"></a>6.2 动图演示</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/849589-20171015230936371-1413523412.gif" alt="img"></p><h3 id="6-3-代码实现"><a href="#6-3-代码实现" class="headerlink" title="6.3 代码实现"></a>6.3 代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function quickSort(arr, left, right) &#123;</span><br><span class="line">    var len = arr.length,</span><br><span class="line">        partitionIndex,</span><br><span class="line">        left = typeof left != &#x27;number&#x27; ? 0 : left,</span><br><span class="line">        right = typeof right != &#x27;number&#x27; ? len - 1 : right;</span><br><span class="line"> </span><br><span class="line">    if (left &lt; right) &#123;</span><br><span class="line">        partitionIndex = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, partitionIndex-1);</span><br><span class="line">        quickSort(arr, partitionIndex+1, right);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function partition(arr, left ,right) &#123;     // 分区操作</span><br><span class="line">    var pivot = left,                      // 设定基准值（pivot）</span><br><span class="line">        index = pivot + 1;</span><br><span class="line">    for (var i = index; i &lt;= right; i++) &#123;</span><br><span class="line">        if (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">            swap(arr, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, pivot, index - 1);</span><br><span class="line">    return index-1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function swap(arr, i, j) &#123;</span><br><span class="line">    var temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、堆排序（Heap-Sort）"><a href="#7、堆排序（Heap-Sort）" class="headerlink" title="7、堆排序（Heap Sort）"></a>7、堆排序（Heap Sort）</h2><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h3 id="7-1-算法描述"><a href="#7-1-算法描述" class="headerlink" title="7.1 算法描述"></a>7.1 算法描述</h3><ul><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ul><h3 id="7-2-动图演示"><a href="#7-2-动图演示" class="headerlink" title="7.2 动图演示"></a>7.2 动图演示</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/849589-20171015231308699-356134237.gif" alt="img"></p><h3 id="7-3-代码实现"><a href="#7-3-代码实现" class="headerlink" title="7.3 代码实现"></a>7.3 代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量</span><br><span class="line"> </span><br><span class="line">function buildMaxHeap(arr) &#123;   // 建立大顶堆</span><br><span class="line">    len = arr.length;</span><br><span class="line">    for (var i = Math.floor(len/2); i &gt;= 0; i--) &#123;</span><br><span class="line">        heapify(arr, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function heapify(arr, i) &#123;     // 堆调整</span><br><span class="line">    var left = 2 * i + 1,</span><br><span class="line">        right = 2 * i + 2,</span><br><span class="line">        largest = i;</span><br><span class="line"> </span><br><span class="line">    if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (largest != i) &#123;</span><br><span class="line">        swap(arr, i, largest);</span><br><span class="line">        heapify(arr, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function swap(arr, i, j) &#123;</span><br><span class="line">    var temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function heapSort(arr) &#123;</span><br><span class="line">    buildMaxHeap(arr);</span><br><span class="line"> </span><br><span class="line">    for (var i = arr.length - 1; i &gt; 0; i--) &#123;</span><br><span class="line">        swap(arr, 0, i);</span><br><span class="line">        len--;</span><br><span class="line">        heapify(arr, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、计数排序（Counting-Sort）"><a href="#8、计数排序（Counting-Sort）" class="headerlink" title="8、计数排序（Counting Sort）"></a>8、计数排序（Counting Sort）</h2><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><h3 id="8-1-算法描述"><a href="#8-1-算法描述" class="headerlink" title="8.1 算法描述"></a>8.1 算法描述</h3><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ul><h3 id="8-2-动图演示"><a href="#8-2-动图演示" class="headerlink" title="8.2 动图演示"></a>8.2 动图演示</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/849589-20171015231740840-6968181.gif" alt="img"></p><h3 id="8-3-代码实现"><a href="#8-3-代码实现" class="headerlink" title="8.3 代码实现"></a>8.3 代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function countingSort(arr, maxValue) &#123;</span><br><span class="line">    var bucket = new Array(maxValue + 1),</span><br><span class="line">        sortedIndex = 0;</span><br><span class="line">        arrLen = arr.length,</span><br><span class="line">        bucketLen = maxValue + 1;</span><br><span class="line"> </span><br><span class="line">    for (var i = 0; i &lt; arrLen; i++) &#123;</span><br><span class="line">        if (!bucket[arr[i]]) &#123;</span><br><span class="line">            bucket[arr[i]] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        bucket[arr[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    for (var j = 0; j &lt; bucketLen; j++) &#123;</span><br><span class="line">        while(bucket[j] &gt; 0) &#123;</span><br><span class="line">            arr[sortedIndex++] = j;</span><br><span class="line">            bucket[j]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-4-算法分析"><a href="#8-4-算法分析" class="headerlink" title="8.4 算法分析"></a>8.4 算法分析</h3><p>计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</p><h2 id="9、桶排序（Bucket-Sort）"><a href="#9、桶排序（Bucket-Sort）" class="headerlink" title="9、桶排序（Bucket Sort）"></a>9、桶排序（Bucket Sort）</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p><h3 id="9-1-算法描述"><a href="#9-1-算法描述" class="headerlink" title="9.1 算法描述"></a>9.1 算法描述</h3><ul><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序；</li><li>从不是空的桶里把排好序的数据拼接起来。 </li></ul><h3 id="9-2-图片演示"><a href="#9-2-图片演示" class="headerlink" title="9.2 图片演示"></a>9.2 图片演示</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/849589-20171015232107090-1920702011.png" alt="img"></p><h3 id="9-3-代码实现"><a href="#9-3-代码实现" class="headerlink" title="9.3 代码实现"></a>9.3 代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function bucketSort(arr, bucketSize) &#123;</span><br><span class="line">    if (arr.length === 0) &#123;</span><br><span class="line">      return arr;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    var i;</span><br><span class="line">    var minValue = arr[0];</span><br><span class="line">    var maxValue = arr[0];</span><br><span class="line">    for (i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">      if (arr[i] &lt; minValue) &#123;</span><br><span class="line">          minValue = arr[i];                // 输入数据的最小值</span><br><span class="line">      &#125; else if (arr[i] &gt; maxValue) &#123;</span><br><span class="line">          maxValue = arr[i];                // 输入数据的最大值</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 桶的初始化</span><br><span class="line">    var DEFAULT_BUCKET_SIZE = 5;            // 设置桶的默认数量为5</span><br><span class="line">    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;</span><br><span class="line">    var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;  </span><br><span class="line">    var buckets = new Array(bucketCount);</span><br><span class="line">    for (i = 0; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        buckets[i] = [];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 利用映射函数将数据分配到各个桶中</span><br><span class="line">    for (i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    arr.length = 0;</span><br><span class="line">    for (i = 0; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        insertionSort(buckets[i]);                      // 对每个桶进行排序，这里使用了插入排序</span><br><span class="line">        for (var j = 0; j &lt; buckets[i].length; j++) &#123;</span><br><span class="line">            arr.push(buckets[i][j]);                     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-4-算法分析"><a href="#9-4-算法分析" class="headerlink" title="9.4 算法分析"></a>9.4 算法分析</h3><p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 </p><h2 id="10、基数排序（Radix-Sort）"><a href="#10、基数排序（Radix-Sort）" class="headerlink" title="10、基数排序（Radix Sort）"></a>10、基数排序（Radix Sort）</h2><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><h3 id="10-1-算法描述"><a href="#10-1-算法描述" class="headerlink" title="10.1 算法描述"></a>10.1 算法描述</h3><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li></ul><h3 id="10-2-动图演示"><a href="#10-2-动图演示" class="headerlink" title="10.2 动图演示"></a>10.2 动图演示</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/849589-20171015232453668-1397662527.gif" alt="img"> </p><h3 id="10-3-代码实现"><a href="#10-3-代码实现" class="headerlink" title="10.3 代码实现"></a>10.3 代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var counter = [];</span><br><span class="line">function radixSort(arr, maxDigit) &#123;</span><br><span class="line">    var mod = 10;</span><br><span class="line">    var dev = 1;</span><br><span class="line">    for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123;</span><br><span class="line">        for(var j = 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">            var bucket = parseInt((arr[j] % mod) / dev);</span><br><span class="line">            if(counter[bucket]==null) &#123;</span><br><span class="line">                counter[bucket] = [];</span><br><span class="line">            &#125;</span><br><span class="line">            counter[bucket].push(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        var pos = 0;</span><br><span class="line">        for(var j = 0; j &lt; counter.length; j++) &#123;</span><br><span class="line">            var value = null;</span><br><span class="line">            if(counter[j]!=null) &#123;</span><br><span class="line">                while ((value = counter[j].shift()) != null) &#123;</span><br><span class="line">                      arr[pos++] = value;</span><br><span class="line">                &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-4-算法分析"><a href="#10-4-算法分析" class="headerlink" title="10.4 算法分析"></a>10.4 算法分析</h3><p>基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。</p><p>基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kettle学习小结</title>
      <link href="/2021/10/24/Kettle%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
      <url>/2021/10/24/Kettle%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Kettle"><a href="#Kettle" class="headerlink" title="Kettle"></a>Kettle</h1><h2 id="一、kettle概述"><a href="#一、kettle概述" class="headerlink" title="一、kettle概述"></a>一、kettle概述</h2><p><strong>1、什么是kettle</strong></p><p>Kettle是一款开源的ETL工具，纯java编写，可以在Window、Linux、Unix上运行，绿色无需安装，数据抽取高效稳定。</p><p><strong>2、Kettle工程存储方式</strong></p><p>（1）以XML形式存储</p><p>（2）以资源库方式存储(数据库资源库和文件资源库)</p><p><strong>3、Kettle的两种设计</strong></p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/XkJ4tWSaHODLgAI.png" alt="image.png" style="zoom:67%;"><p><strong>4、Kettle的组成</strong></p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/1J2IGPXYFuSWtqa.png" alt="image.png" style="zoom: 80%;"><p><strong>5、kettle特点</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/A6u91dh4oEbZmnN.png" alt="image.png"></p><h2 id="二、kettle安装部署和使用"><a href="#二、kettle安装部署和使用" class="headerlink" title="二、kettle安装部署和使用"></a>二、kettle安装部署和使用</h2><p>（1）概述</p><p>在实际企业开发中，都是在本地环境下进行kettle的job和Transformation开发的，可以在本地运行，也可以连接远程机器运行</p><p>（2）安装步骤</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、安装jdk</span><br><span class="line"></span><br><span class="line">2、下载kettle压缩包，因kettle为绿色软件，解压缩到任意本地路径即可</span><br><span class="line"></span><br><span class="line">3、双击Spoon.bat，启动图形化界面工具，就可以直接使用了</span><br></pre></td></tr></table></figure><h3 id="案例1：MySQL-to-MySQL"><a href="#案例1：MySQL-to-MySQL" class="headerlink" title="案例1：MySQL to MySQL"></a>案例1：MySQL to MySQL</h3><blockquote><p>把stu1的数据按id同步到stu2，stu2有相同id则更新数据</p></blockquote><p><strong>1、在mysql中创建testkettle数据库，并创建两张表</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database testkettle;</span><br><span class="line"></span><br><span class="line">use testkettle;</span><br><span class="line"></span><br><span class="line">create table stu1(id int,name varchar(20),age int);</span><br><span class="line"></span><br><span class="line">create table stu2(id int,name varchar(20));</span><br></pre></td></tr></table></figure><p><strong>2、往两张表中插入一些数据</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into stu1 values(1001,&#x27;zhangsan&#x27;,20),(1002,&#x27;lisi&#x27;,18), (1003,&#x27;wangwu&#x27;,23);</span><br><span class="line"></span><br><span class="line">insert into stu2 values(1001,&#x27;wukong&#x27;);</span><br></pre></td></tr></table></figure><p><strong>3、把pdi-ce-8.2.0.0-342.zip文件拷贝到win环境中指定文件目录，解压后双击Spoon.bat，启动图形化界面工具，就可以使用了</strong></p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/jRrZ7BMvkpbL4du.png" alt="image.png" style="zoom: 67%;"><p><strong>主界面：</strong></p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/cyRCbSehvJkMa18.png" alt="image.png" style="zoom:50%;"><p><strong>在kettle中新建转换—&gt;输入—&gt;表输入–&gt;表输入双击</strong></p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/nVSMPNI6hdc7iCt.png" alt="image.png" style="zoom:50%;"><p><strong>在data-integration\lib文件下添加mysql驱动</strong></p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/XRM1Uc78OABQaZf.png" alt="image.png" style="zoom:50%;"><p><strong>在数据库连接栏目点击</strong>新建<strong>，填入mysql相关配置，并测试连接</strong></p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/eTmn5ojxAZiXV1H.png" alt="image.png" style="zoom:50%;"><p><strong>建立连接后，选择刚刚建好的连接，填入SQL，并预览数据：</strong></p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/Gmwd8gFXIkuOzAa.png" alt="image.png" style="zoom:50%;"><p><strong>以上说明stu1的数据输入ok的，现在我们需要把输入stu1的数据同步到stu2输出的数据</strong></p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/skb2gld3tRrUxvu.png" alt="image.png" style="zoom:50%;"><p><strong>注意：拖出来的线条必须是深灰色才关联成功，若是浅灰色表示关联失败</strong></p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/zdZUErPOueTDxYb.png" alt="image.png" style="zoom:50%;"><p><strong>转换之前，需要做保存</strong></p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/gEeplVvfMxs7bjP.png" alt="image.png" style="zoom:50%;"><p><strong>执行成功之后，可以在mysql查看，stu2的数据</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from stu2;</span><br><span class="line">+------+----------+</span><br><span class="line">| id   | name     |</span><br><span class="line">+------+----------+</span><br><span class="line">| 1001 | zhangsan |</span><br><span class="line">| 1002 | lisi     |</span><br><span class="line">| 1003 | wangwu   |</span><br><span class="line">+------+----------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="案例2：使用作业执行上述转换，并且额外在表stu2中添加一条数据"><a href="#案例2：使用作业执行上述转换，并且额外在表stu2中添加一条数据" class="headerlink" title="案例2：使用作业执行上述转换，并且额外在表stu2中添加一条数据"></a>案例2：使用作业执行上述转换，并且额外在表stu2中添加一条数据</h3><p><strong>1、新建一个作业</strong></p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/RaqMg8Yf2vQ9AIk.png" alt="image.png" style="zoom: 50%;"><p><strong>2、按图示拉取组件</strong></p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/FKpInCJ89QUjilm.png" alt="image.png" style="zoom:50%;"><p><strong>3、双击Start编辑Start</strong></p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/rs18iKgezdFyTnL.png" alt="image.png" style="zoom: 67%;"><p><strong>4、双击转换，选择案例1保存的文件</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211024130132952.png" alt="image-20211024130132952"></p><p><strong>5、双击SQL脚本编辑</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211024131656327.png" alt="image-20211024131656327"></p><p><strong>6、保存并执行</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211024131830220.png" alt="image-20211024131830220"></p><p><strong>7、在mysql数据库查看stu2表的数据</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211024132004117.png" alt="image-20211024132004117"></p><h3 id="案例3：将hive表的数据输出到hdfs"><a href="#案例3：将hive表的数据输出到hdfs" class="headerlink" title="案例3：将hive表的数据输出到hdfs"></a>案例3：将hive表的数据输出到hdfs</h3><p><strong>1、因为涉及到hive和hbase（后续案例）的读写，需要修改相关配置文件</strong></p><blockquote><p>修改解压目录下的data-integration\plugins\pentaho-big-data-plugin下的plugin.properties，设置active.hadoop.configuration=hdp26，并将如下配置文件拷贝到data-integration\plugins\pentaho-big-data-plugin\hadoop-configurations\hdp26下</p></blockquote><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/ShtJGwBdjO7N1Vn.png" alt="image.png" style="zoom: 67%;"><p><strong>2、启动hadoop集群、hiveserver2服务</strong></p><p><strong>3、进入hive shell，创建kettle数据库，并创建dept、emp表</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database kettle;</span><br><span class="line"></span><br><span class="line">use kettle;</span><br><span class="line"></span><br><span class="line">CREATE TABLE dept(</span><br><span class="line">    deptno int,</span><br><span class="line">    dname string,</span><br><span class="line">    loc string</span><br><span class="line">) ROW FORMAT DELIMITED FIELDS TERMINATED BY &#x27;\t&#x27;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE emp(</span><br><span class="line">    empno int,</span><br><span class="line">    ename string,</span><br><span class="line">    job string,</span><br><span class="line">    mgr int,</span><br><span class="line">    hiredate string,</span><br><span class="line">    sal double,</span><br><span class="line">    comm int,</span><br><span class="line">    deptno int</span><br><span class="line">) ROW FORMAT DELIMITED FIELDS TERMINATED BY &#x27;\t&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211024133805958.png" alt="image-20211024133805958"></p><p><strong>4、插入数据</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into dept values(10,&#x27;accounting&#x27;,&#x27;NEW YORK&#x27;),(20,&#x27;RESEARCH&#x27;,&#x27;DALLAS&#x27;),(30,&#x27;SALES&#x27;,&#x27;CHICAGO&#x27;),(40,&#x27;OPERATIONS&#x27;,&#x27;BOSTON&#x27;);</span><br><span class="line"></span><br><span class="line">insert into emp values(7369,&#x27;SMITH&#x27;,&#x27;CLERK&#x27;,7902,&#x27;1980-12-17&#x27;,800,NULL,20),(7499,&#x27;ALLEN&#x27;,&#x27;SALESMAN&#x27;,7698,&#x27;1980-12-17&#x27;,1600,300,30),(7521,&#x27;WARD&#x27;,&#x27;SALESMAN&#x27;,7698,&#x27;1980-12-17&#x27;,1250,500,30),(7566,&#x27;JONES&#x27;,&#x27;MANAGER&#x27;,7839,&#x27;1980-12-17&#x27;,2975,NULL,20);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211024134025695.png" alt="image-20211024134025695"></p><p><strong>5、按下图建立流程图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/FgGvqAH7kbhET8N.png" alt="image.png"></p><ul><li>表输入</li></ul><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/qtDu1AC438mEUfJ.png" alt="image.png" style="zoom: 67%;"><ul><li>表输入2</li></ul><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/ajFZOpXoi4IG238.png" alt="image.png" style="zoom:67%;"><ul><li>排序记录</li></ul><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/gNseW8wbMdEl56Q.png" alt="image.png" style="zoom:67%;"><ul><li>记录集连接</li></ul><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/QdueFYv53pRoWGr.png" alt="image.png" style="zoom:67%;"><ul><li>字段选择</li></ul><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/tCfa5dgk6lXeF7N.png" alt="image.png" style="zoom:67%;"><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/RGHDjJ8IxvMyh5C.png" alt="image.png" style="zoom:67%;"><ul><li>文本文件输出</li></ul><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/BrNGp8R6zKUwmoD.png" alt="image.png" style="zoom: 50%;"><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211024141506769.png" alt="image-20211024141506769"></p><p><strong>6、保存并运行查看hdfs</strong></p><ul><li>运行</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211024150629696.png" alt="image-20211024150629696"></p><ul><li>查看HDFS文件</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211024151022618.png" alt="image-20211024151022618"></p><h3 id="案例4：读取hdfs文件并将sal大于1000的数据保存到hbase中"><a href="#案例4：读取hdfs文件并将sal大于1000的数据保存到hbase中" class="headerlink" title="案例4：读取hdfs文件并将sal大于1000的数据保存到hbase中"></a>案例4：读取hdfs文件并将sal大于1000的数据保存到hbase中</h3><p><strong>1、在HBase中创建一张people表</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hbase(main):004:0&gt; create &#x27;people&#x27;,&#x27;info&#x27;</span><br></pre></td></tr></table></figure><p><strong>2、按下图建立流程图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/JyMbCNwSP1oAI9O.png" alt="image.png"></p><ul><li>文本文件输入</li></ul><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/2Lsa96hqXJQfZur.png" alt="image.png" style="zoom:50%;"><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/BaA7wGXzmh4HgQY.png" alt="image.png" style="zoom:50%;"><ul><li>设置过滤记录</li></ul><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/2RQBZx1eo3fXa4l.png" alt="image.png" style="zoom: 67%;"><ul><li><p>设置HBase output</p><blockquote><p>编辑hadoop连接，并配置zookeeper地址</p></blockquote></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211024153758021.png" alt="image-20211024153758021"></p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/Eef4S8KJM6cBRPp.png" alt="image.png" style="zoom:67%;"><ul><li>执行转换</li></ul><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/FOncu7ie5Rjmf93.png" alt="image.png" style="zoom: 50%;"><ul><li><p>查看hbase people表的数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scan &#x27;people&#x27;</span><br></pre></td></tr></table></figure><blockquote><p>注意：若报错没有权限往hdfs写文件，在Spoon.bat中第119行添加参数</p><p>“-DHADOOP_USER_NAME=root” “-Dfile.encoding=UTF-8”</p></blockquote></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211024154301031.png" alt="image-20211024154301031"></p><p>可以看到已经有数据了。</p><h2 id="三、创建资源库"><a href="#三、创建资源库" class="headerlink" title="三、创建资源库"></a>三、创建资源库</h2><h3 id="1、数据库资源库"><a href="#1、数据库资源库" class="headerlink" title="1、数据库资源库"></a>1、数据库资源库</h3><blockquote><p>数据库资源库是将作业和转换相关的信息存储在数据库中，执行的时候直接去数据库读取信息，方便跨平台使用</p></blockquote><ul><li><p>在MySQL中创建kettle数据库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create database kettle;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br></pre></td></tr></table></figure></li><li><p>点击右上角connect，选择Other Resporitory</p></li></ul><img src="https://i.loli.net/2021/01/29/CfKbmcaOA1dwU3R.png" alt="image.png" style="zoom: 50%;"><ul><li>选择Database Repository</li></ul><img src="https://i.loli.net/2021/01/29/g7XamIui6YAfOPv.png" alt="image.png" style="zoom:50%;"><ul><li>建立新连接</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211024160716899.png" alt="image-20211024160716899"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211024160741497.png" alt="image-20211024160741497"></p><img src="https://i.loli.net/2021/01/29/kCdnIOaheNKYZFc.png" alt="image.png" style="zoom:50%;"><ul><li>填好之后，点击finish，会在指定的库中创建很多表，至此数据库资源库创建完成</li></ul><img src="https://i.loli.net/2021/01/29/jlEU7aFM6ACuKZs.png" alt="image.png" style="zoom: 50%;"><ul><li><p>连接资源库</p><blockquote><p>默认账号密码为admin</p></blockquote></li></ul><img src="https://i.loli.net/2021/01/29/6KWeNnFJSy2iItC.png" alt="image.png" style="zoom: 50%;"><ul><li><p>将之前做过的转换导入资源库</p><ul><li><p>选择从xml文件导入</p><img src="https://i.loli.net/2021/01/29/Ahmza7y2i69Q1rO.png" alt="image.png" style="zoom:50%;"></li><li><p>点击保存，选择存储位置及文件名</p></li></ul><img src="https://i.loli.net/2021/01/29/dmEc6NaGiol7TIf.png" alt="image.png" style="zoom: 50%;"><ul><li><p>查看MySQL中kettle库中的R_TRANSFORMATION表，观察转换是否保存</p><img src="https://i.loli.net/2021/01/29/J9EH7lSVL2UDBGp.png" alt="image.png" style="zoom:50%;"></li></ul></li></ul><h3 id="2、文件资源库"><a href="#2、文件资源库" class="headerlink" title="2、文件资源库"></a>2、文件资源库</h3><blockquote><p>将作业和转换相关的信息存储在指定的目录中，其实和XML的方式一样创建方式跟创建数据库资源库步骤类似，只是不需要用户密码就可以访问，跨平台使用比较麻烦</p></blockquote><ul><li><p>选择connect</p></li><li><p>点击add后点击Other Repositories</p></li><li><p>选择File Repository</p></li><li><p>填写信息</p></li></ul><img src="https://i.loli.net/2021/01/29/FWuIGv5p9egUZqw.png" alt="image.png" style="zoom:50%;"><hr><h2 id="四、-Linux下安装使用"><a href="#四、-Linux下安装使用" class="headerlink" title="四、 Linux下安装使用"></a>四、 Linux下安装使用</h2><h3 id="1、单机"><a href="#1、单机" class="headerlink" title="1、单机"></a>1、单机</h3><ul><li><p>jdk安装</p></li><li><p>安装包上传到服务器，并解压</p><blockquote><p>注意：</p><ol><li><p>把mysql驱动拷贝到lib目录下</p></li><li><p>将windows本地用户家目录下的隐藏目录C:\Users\自己用户名\.kettle 目录，</p><p>整个上传到linux的用户的家目录下，root用户的家目录为/root/</p></li></ol></blockquote></li><li><p>运行数据库资源库中的转换：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/soft/data-integration</span><br><span class="line">./pan.sh -rep=my_repo -user=admin -pass=admin -trans=tran1</span><br></pre></td></tr></table></figure><blockquote><p>参数说明：</p><p>​    -rep 资源库名称</p><p>​    -user 资源库用户名</p><p>​    -pass 资源库密码</p><p>​    -trans 要启动的转换名称</p><p>​    -dir 目录(不要忘了前缀 /)（如果是以ktr文件运行时，需要指定ktr文件的路径）</p></blockquote></li></ul><img src="https://i.loli.net/2021/01/29/uHIFcLPvrp5oyU3.png" alt="image.png" style="zoom:50%;"><ul><li><p>运行资源库里的作业：</p><blockquote><p>记得把作业里的转换变成资源库中的资源</p><p>记得把作业也变成资源库中的资源</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/soft/data-integration</span><br><span class="line">mkdir logs</span><br><span class="line">./kitchen.sh -rep=my_repo -user=admin -pass=admin -job=job1 -logfile=./logs/log.txt</span><br></pre></td></tr></table></figure><blockquote><p>参数说明：</p><pre><code>-rep - 资源库名-user - 资源库用户名-pass – 资源库密码-job – job名-dir – job路径（当直接运行kjb文件的时候需要指定）-logfile – 日志目录</code></pre></blockquote><img src="https://i.loli.net/2021/01/29/5hdJRFwnlApDkZM.png" alt="image.png" style="zoom:50%;"></li></ul><h3 id="2、-集群模式"><a href="#2、-集群模式" class="headerlink" title="2、 集群模式"></a>2、 集群模式</h3><ul><li><p>准备三台服务器</p><blockquote><p>master作为Kettle主服务器，服务器端口号为8080，</p><p>node1和node2作为两个子服务器，端口号分别为8081和8082。</p></blockquote></li><li><p>安装部署jdk</p></li><li><p>hadoop完全分布式环境搭建</p></li><li><p>上传并解压kettle的安装包至<code>/usr/local/soft/</code>目录下</p></li><li><p>进到/usr/local/soft/data-integration/pwd目录，修改配置文件</p><ul><li><p>修改主服务器配置文件carte-config-master-8080.xml</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;slaveserver&gt;</span><br><span class="line">    &lt;name&gt;master&lt;/name&gt;</span><br><span class="line">    &lt;hostname&gt;master&lt;/hostname&gt;</span><br><span class="line">    &lt;port&gt;8080&lt;/port&gt;</span><br><span class="line">    &lt;master&gt;Y&lt;/master&gt;</span><br><span class="line">    &lt;username&gt;cluster&lt;/username&gt;</span><br><span class="line">    &lt;password&gt;cluster&lt;/password&gt;</span><br><span class="line">&lt;/slaveserver&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211024165658395.png" alt="image-20211024165658395"></p></li><li><p>修改从服务器配置文件carte-config-8081.xml</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;masters&gt;</span><br><span class="line">    &lt;slaveserver&gt;</span><br><span class="line">      &lt;name&gt;master&lt;/name&gt;</span><br><span class="line">      &lt;hostname&gt;master&lt;/hostname&gt;</span><br><span class="line">      &lt;port&gt;8080&lt;/port&gt;</span><br><span class="line">      &lt;username&gt;cluster&lt;/username&gt;</span><br><span class="line">      &lt;password&gt;cluster&lt;/password&gt;</span><br><span class="line">      &lt;master&gt;Y&lt;/master&gt;</span><br><span class="line">    &lt;/slaveserver&gt;</span><br><span class="line">&lt;/masters&gt;</span><br><span class="line">&lt;report_to_masters&gt;Y&lt;/report_to_masters&gt;</span><br><span class="line">&lt;slaveserver&gt;</span><br><span class="line">    &lt;name&gt;slave1&lt;/name&gt;</span><br><span class="line">    &lt;hostname&gt;node1&lt;/hostname&gt;</span><br><span class="line">    &lt;port&gt;8081&lt;/port&gt;</span><br><span class="line">    &lt;username&gt;cluster&lt;/username&gt;</span><br><span class="line">    &lt;password&gt;cluster&lt;/password&gt;</span><br><span class="line">    &lt;master&gt;N&lt;/master&gt;</span><br><span class="line">&lt;/slaveserver&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211024165607035.png" alt="image-20211024165607035"></p></li><li><p>修改从配置文件carte-config-8082.xml</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;masters&gt;</span><br><span class="line">    &lt;slaveserver&gt;</span><br><span class="line">      &lt;name&gt;master&lt;/name&gt;</span><br><span class="line">      &lt;hostname&gt;master&lt;/hostname&gt;</span><br><span class="line">      &lt;port&gt;8080&lt;/port&gt;</span><br><span class="line">      &lt;username&gt;cluster&lt;/username&gt;</span><br><span class="line">      &lt;password&gt;cluster&lt;/password&gt;</span><br><span class="line">      &lt;master&gt;Y&lt;/master&gt;</span><br><span class="line">    &lt;/slaveserver&gt;</span><br><span class="line">&lt;/masters&gt;</span><br><span class="line">&lt;report_to_masters&gt;Y&lt;/report_to_masters&gt;</span><br><span class="line">&lt;slaveserver&gt;</span><br><span class="line">    &lt;name&gt;slave2&lt;/name&gt;</span><br><span class="line">    &lt;hostname&gt;node2&lt;/hostname&gt;</span><br><span class="line">    &lt;port&gt;8082&lt;/port&gt;</span><br><span class="line">    &lt;username&gt;cluster&lt;/username&gt;</span><br><span class="line">    &lt;password&gt;cluster&lt;/password&gt;</span><br><span class="line">    &lt;master&gt;N&lt;/master&gt;</span><br><span class="line">&lt;/slaveserver&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211024165811173.png" alt="image-20211024165811173"></p></li></ul></li><li><p>分发整个kettle的安装目录，通过scp命令</p></li><li><p>分发/root/.kettle目录到node1、node2</p></li><li><p>启动相关进程，在master,node1,node2上分别执行</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@master]# ./carte.sh master 8080</span><br><span class="line">[root@node1]# ./carte.sh node1 8081</span><br><span class="line">[root@node2]# ./carte.sh node2 8082</span><br></pre></td></tr></table></figure><ul><li>访问web页面</li></ul><p><a href>http://master:8080</a></p><hr><h3 id="案例：读取hive中的emp表，根据id进行排序，并将结果输出到hdfs上"><a href="#案例：读取hive中的emp表，根据id进行排序，并将结果输出到hdfs上" class="headerlink" title="案例：读取hive中的emp表，根据id进行排序，并将结果输出到hdfs上"></a>案例：读取hive中的emp表，根据id进行排序，并将结果输出到hdfs上</h3><p>注意：因为涉及到hive和hbase的读写，需要修改相关配置文件。</p><blockquote><p>修改解压目录下的data-integration\plugins\pentaho-big-data-plugin下的plugin.properties，设置active.hadoop.configuration=hdp26，并将如下配置文件拷贝到data-integration\plugins\pentaho-big-data-plugin\hadoop-configurations\hdp26下</p></blockquote><img src="https://i.loli.net/2021/01/29/ShtJGwBdjO7N1Vn.png" alt="image.png" style="zoom: 67%;"><ul><li><p>创建转换，编辑步骤，填好相关配置</p><blockquote><p>直接使用trans1</p></blockquote></li><li><p>创建子服务器，填写相关配置，跟集群上的配置相同</p></li></ul><img src="https://i.loli.net/2021/01/30/Qz1uPT9yq5N7Ubo.png" alt="image.png" style="zoom:50%;"><img src="https://i.loli.net/2021/01/30/QGDlEKM9vUI7aSt.png" alt="image.png" style="zoom: 50%;"><img src="https://i.loli.net/2021/01/30/fascX1rAET9Z5iv.png" alt="image.png" style="zoom:50%;"><ul><li><p>创建集群schema，选中上一步的几个服务器</p><img src="https://i.loli.net/2021/01/30/K3CMqI12PsWihAO.png" alt="image.png" style="zoom: 50%;"></li><li><p>对于要在集群上执行的步骤，右键选择集群，选中上一步创建的集群schema</p><img src="https://i.loli.net/2021/01/30/W3gN87xGwMcqQUH.png" alt="image.png" style="zoom:50%;"></li><li><p>创建Run Configuration,选择集群模式</p><img src="https://i.loli.net/2021/01/30/pdxvhHZ975bNJ1w.png" alt="image.png" style="zoom: 50%;"></li><li><p>直接运行，选择集群模式运行</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211024181015122.png" alt="image-20211024181015122"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211024180950230.png" alt="image-20211024180950230"></p></li></ul><hr><h2 id="五、调优"><a href="#五、调优" class="headerlink" title="五、调优"></a>五、调优</h2><p>1、调整JVM大小进行性能优化，修改Kettle根目录下的Spoon脚本。</p><p><img src="https://pic3.zhimg.com/80/v2-e6b99ed4da1101cbb257c91365867902_720w.png" alt="img"></p><p>参数参考：</p><p>-Xmx2048m：设置JVM最大可用内存为2048M。</p><p>-Xms1024m：设置JVM促使内存为1024m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</p><p>-Xmn2g：设置年轻代大小为2G。整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</p><p>-Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</p><p>2、 调整提交（Commit）记录数大小进行优化，Kettle默认Commit数量为：1000，可以根据数据量大小来设置Commitsize：1000~50000</p><p>3、尽量使用数据库连接池；</p><p>4、尽量提高批处理的commit size；</p><p>5、尽量使用缓存，缓存尽量大一些（主要是文本文件和数据流）；</p><p>6、Kettle是Java做的，尽量用大一点的内存参数启动Kettle；</p><p>7、可以使用sql来做的一些操作尽量用sql；</p><p>Group , merge , stream lookup,split field这些操作都是比较慢的，想办法避免他们.，能用sql就用sql；</p><p>8、插入大量数据的时候尽量把索引删掉；</p><p>9、尽量避免使用update , delete操作，尤其是update,如果可以把update变成先delete, 后insert；</p><p>10、能使用truncate table的时候，就不要使用deleteall row这种类似sql合理的分区，如果删除操作是基于某一个分区的，就不要使用delete row这种方式（不管是deletesql还是delete步骤）,直接把分区drop掉，再重新创建；</p><p>11、尽量缩小输入的数据集的大小（增量更新也是为了这个目的）；</p><p>12、尽量使用数据库原生的方式装载文本文件(Oracle的sqlloader, mysql的bulk loader步骤)。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flume学习小结</title>
      <link href="/2021/10/22/Flume%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
      <url>/2021/10/22/Flume%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Flume学习小结"><a href="#Flume学习小结" class="headerlink" title="Flume学习小结"></a>Flume学习小结</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>flume是一个分布式、可靠、和高可用的海量日志采集、聚合和传输的系统。支持在日志系统中定制各类数据发送方，用于收集数据;同时，Flume提供对数据进行简单处理，并写到各种数据接受方(比如文本、HDFS、Hbase等)的能力 。flume的数据流由事件(Event)贯穿始终。事件是Flume的基本数据单位，它携带日志数据(字节数组形式)并且携带有头信息，这些Event由Agent外部的Source生成，当Source捕获事件后会进行特定的格式化，然后Source会把事件推入(单个或多个)Channel中。你可以把Channel看作是一个缓冲区，它将保存事件直到Sink处理完该事件。Sink负责持久化日志或者把事件推向另一个Source。</p></blockquote><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>Flume 运行的核心是 Agent。Flume以agent为最小的独立运行单位。一个agent就是一个JVM。它是一个完整的数据收集工具，含有三个核心组件，分别是　 source、 channel、 sink。通过这些组件， Event 可以从一个地方流向另一个地方，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211022180605240.png" alt="image-20211022180605240"></p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><blockquote><p>Client：Client生产数据，运行在一个独立的线程。 Event： 一个数据单元，消息头和消息体组成。（Events可以是日志记录、 avro 对象等。） Flow： Event从源点到达目的点的迁移的抽象。 Agent： 一个独立的Flume进程，包含组件Source、 Channel、 Sink。（Agent使用JVM 运行Flume。每台机器运行一个agent，但是可以在一个agent中包含多个sources和sinks。） Source： 数据收集组件。（source从Client收集数据，传递给Channel） Channel： 中转Event的一个临时存储，保存由Source组件传递过来的Event。（Channel连接 sources 和 sinks ，这个有点像一个队列。） Sink： 从Channel中读取并移除Event， 将Event传递到FlowPipeline中的下一个Agent（如果有的话）（Sink从Channel收集数据，运行在一个独立线程。）</p></blockquote><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>Source是数据的收集端，负责将数据捕获后进行特殊的格式化，将数据封装到事件（event） 里，然后将事件推入Channel中。 Flume提供了很多内置的Source， 支持 Avro， log4j， syslog 和 http post(body为json格式)。可以让应用程序同已有的Source直接打交道，如AvroSource 如果内置的Source无法满足需要， Flume还支持自定义Source。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211022180737504.png" alt="image-20211022180737504"></p><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>Channel是连接Source和Sink的组件，大家可以将它看做一个数据的缓冲区（数据队列），它可以将事件暂存到内存中也可以持久化到本地磁盘上， 直到Sink处理完该事件。介绍两个较为常用的Channel， MemoryChannel和FileChannel。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211022180806478.png" alt="image-20211022180806478"></p><h3 id="Sink"><a href="#Sink" class="headerlink" title="Sink"></a>Sink</h3><p>Sink从Channel中取出事件，然后将数据发到别处，可以向文件系统、数据库、 hadoop存数据， 也可以是其他agent的Source。在日志数据较少时，可以将数据存储在文件系统中，并且设定一定的时间间隔保存数据。</p><h2 id="Flume数据流"><a href="#Flume数据流" class="headerlink" title="Flume数据流"></a>Flume数据流</h2><p>Flume 的核心是把数据从数据源收集过来，再送到目的地。为了保证输送一定成功，在送到目的地之前，会先缓存数据，待数据真正到达目的地后，删除自己缓存的数据 。</p><p>Flume 传输的数据的基本单位是 Event，如果是文本文件，通常是一行记录，这也是事务的基本单位。 Event 从 Source，流向 Channel，再到 Sink，本身为一个 byte 数组，并可携带 headers 信息。 Event 代表着一个数据流的最小完整单元，从外部数据源来，向外部的目的地去。 </p><p>值得注意的是，Flume提供了大量内置的Source、Channel和Sink类型。不同类型的Source,Channel和Sink可以自由组合。组合方式基于用户设置的配置文件，非常灵活。 </p><ul><li>比如：Channel可以把事件暂存在内存里，也可以持久化到本地硬盘上。Sink可以把日志写入HDFS, HBase，甚至是另外一个Source等等。Flume支持用户建立多级流， </li><li>也就是说，多个agent可以协同工作。</li></ul><h2 id="Flume可靠性"><a href="#Flume可靠性" class="headerlink" title="Flume可靠性"></a>Flume可靠性</h2><blockquote><p>Flume 使用事务性的方式保证传送Event整个过程的可靠性。 Sink 必须在Event 已经被传达到下一站agent里，又或者，已经被存入外部数据目的地之后，才能把 Event 从 Channel 中 remove 掉。这样数据流里的 event 无论是在一个 agent 里还是多个 agent 之间流转，都能保证可靠，因为以上的事务保证了 event 会被成功存储起来。比如 Flume支持在本地保存一份channel文件作为备份，而memory channel 将event存在内存 queue 里，速度快，但丢失的话无法恢复。</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="1、上传至虚拟机，并解压"><a href="#1、上传至虚拟机，并解压" class="headerlink" title="1、上传至虚拟机，并解压"></a>1、上传至虚拟机，并解压</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-flume-1.9.0-bin.tar.gz -C /usr/local/soft/</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211022190749379.png" alt="image-20211022190749379"></p><h3 id="2、重命名目录，并配置环境变量"><a href="#2、重命名目录，并配置环境变量" class="headerlink" title="2、重命名目录，并配置环境变量"></a>2、重命名目录，并配置环境变量</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv apache-flume-1.9.0-bin/ flume-1.9.0</span><br><span class="line">vim /etc/profile</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211022191118837.png" alt="image-20211022191118837"></p><h3 id="3、查看flume版本"><a href="#3、查看flume版本" class="headerlink" title="3、查看flume版本"></a>3、查看flume版本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flume-ng version</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211022191207419.png" alt="image-20211022191207419"></p><h2 id="Flume的使用"><a href="#Flume的使用" class="headerlink" title="Flume的使用"></a>Flume的使用</h2><h3 id="1、测试flume"><a href="#1、测试flume" class="headerlink" title="1、测试flume"></a>1、测试flume</h3><p>所有的参数都能在Flume官网查看到。<a href="https://flume.apache.org/%E3%80%82%E8%BF%99%E9%87%8C%E6%B5%8B%E8%AF%95%E4%B8%80%E4%B8%AA%E7%9B%91%E6%8E%A7%E7%9B%AE%E5%BD%95%E3%80%82">https://flume.apache.org/。这里测试一个监控目录。</a></p><p>监控一个目录，将数据打印出来</p><ul><li>配置文件 spoolTest.conf</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 首先先给agent起一个名字 这里我叫做 a1</span><br><span class="line"># 一个agent里面可能会包含很多个source，channel，sink</span><br><span class="line"># 分别给source，channel，sink取名字</span><br><span class="line">a1.sources = r1</span><br><span class="line">a1.channels = c1</span><br><span class="line">a1.sinks = k1</span><br><span class="line"></span><br><span class="line"># 分别对source，channel，sink进行配置</span><br><span class="line"># 配置source</span><br><span class="line"># 将source的类型指定为 spooldir，用于监听一个目录下文件的变化</span><br><span class="line"># 因为每一个组件可能会出现相同的属性名称，所以在对每个组件进行配置的时候</span><br><span class="line"># 需要加上 agent的名字.sources.组件的名字.属性 = 属性值</span><br><span class="line">a1.sources.r1.type = spooldir</span><br><span class="line"># 这里我们来监听 root目录下面的data文件变化 用到的source是 Spooling Directory Source</span><br><span class="line">a1.sources.r1.spoolDir = /root/data/</span><br><span class="line"></span><br><span class="line"># 配置sink</span><br><span class="line"># 使用logger作为sink组件，可以将收集到的数据直接打印到控制台</span><br><span class="line">a1.sinks.k1.type = logger</span><br><span class="line"></span><br><span class="line"># 配置channel</span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line"></span><br><span class="line"># 组装</span><br><span class="line"># 将sources的channels属性指定为c1</span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line"></span><br><span class="line"># 将sinks的channel属性指定为c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure><p>至此，我们一个小的测试已经写好了。</p><ul><li>启动agent</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 格式</span><br><span class="line">flume-ng agent -n 指定agent的名字 -f 刚刚创建的conf文件 -Dflume.root.logger=DEBUG,console</span><br><span class="line"></span><br><span class="line"># 例如我这里就是</span><br><span class="line">flume-ng agent -n a1 -f spoolingTest.conf -Dflume.root.logger=DEBUG,console</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211022195349132.png" alt="image-20211022195349132"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211022195406001.png" alt="image-20211022195406001"></p><p>可以看到已经在监控了</p><ul><li>在/root/data/目录下新建文件，输入内容，观察flume进程打印的日志。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 随意在a.txt中加入一些内容</span><br><span class="line">vim /root/data/a.txt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211022195519675.png" alt="image-20211022195519675"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211022201005055.png" alt="image-20211022201005055"></p><p>可以很直观地看到已经监控到了。</p><h3 id="上述案例添加更多的参数"><a href="#上述案例添加更多的参数" class="headerlink" title="上述案例添加更多的参数"></a>上述案例添加更多的参数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 首先先给agent起一个名字 叫a1</span><br><span class="line"># 分别给source channel sink取名字</span><br><span class="line">a1.sources = r1</span><br><span class="line">a1.channels = c1</span><br><span class="line">a1.sinks = k1</span><br><span class="line"></span><br><span class="line"># 分别对source、channel、sink进行配置</span><br><span class="line"></span><br><span class="line"># 配置source</span><br><span class="line"># 将source的类型指定为 spooldir 用于监听一个目录下文件的变化</span><br><span class="line"># 因为每个组件可能会出现相同的属性名称，所以在对每个组件进行配置的时候 </span><br><span class="line"># 需要加上 agent的名字.sources.组件的名字.属性 = 属性值</span><br><span class="line">a1.sources.r1.type = spooldir</span><br><span class="line">a1.sources.r1.spoolDir = /root/data/</span><br><span class="line"># 指定采集之后的文件后缀是 .ok</span><br><span class="line">a1.sources.r1.fileSuffix = .ok</span><br><span class="line"># 记录采集的文件的绝对路径</span><br><span class="line">a1.sources.r1.fileHeader = true</span><br><span class="line"></span><br><span class="line"># 给r1这个souces配置一个拦截器并取名为 i1</span><br><span class="line">a1.sources.r1.interceptors = i1</span><br><span class="line"># 将拦截器i1的类型设置为timestamp 会将处理数据的时间以毫秒的格式插入event的header中</span><br><span class="line"># a1.sources.r1.interceptors.i1.type = timestamp</span><br><span class="line"># 将拦截器i1的类型设置为regex_filter 会根据正则表达式过滤数据</span><br><span class="line">a1.sources.r1.interceptors.i1.type = regex_filter</span><br><span class="line"># 配置正则表达式</span><br><span class="line">a1.sources.r1.interceptors.i1.regex = \\d&#123;3,6&#125;</span><br><span class="line"># excludeEvents = true 表示将匹配到的过滤，未匹配到的放行</span><br><span class="line">a1.sources.r1.interceptors.i1.excludeEvents = true</span><br><span class="line"></span><br><span class="line"># 配置sink</span><br><span class="line"># 使用logger作为sink组件，可以将收集到数据直接打印到控制台</span><br><span class="line">a1.sinks.k1.type = logger</span><br><span class="line"></span><br><span class="line"># 配置channel</span><br><span class="line"># 将channel的类型设置为memory，表示将event缓存在内存中</span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line"></span><br><span class="line"># 组装</span><br><span class="line"># 将sources的channels属性指定为c1</span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line"></span><br><span class="line"># 将sinks的channel属性指定为c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure><h3 id="spoolingToHDFS"><a href="#spoolingToHDFS" class="headerlink" title="spoolingToHDFS"></a>spoolingToHDFS</h3><ul><li>配置文件 spoolingToHDFS.conf</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 首先定义一个agent的名字 a1</span><br><span class="line"># 定义三个组件名字</span><br><span class="line">a1.sources = r1</span><br><span class="line">a1.channels = c1</span><br><span class="line">a1.sinks = k1</span><br><span class="line"></span><br><span class="line"># 配置source</span><br><span class="line">a1.sources.r1.type = spooldir</span><br><span class="line">a1.sources.r1.spoolDir = /root/data/</span><br><span class="line"></span><br><span class="line"># 配置sink</span><br><span class="line">a1.sinks.k1.type = hdfs</span><br><span class="line">a1.sinks.k1.hdfs.path = /flume/input1/</span><br><span class="line"></span><br><span class="line"># 指定文件类型为 流 来什么输出什么</span><br><span class="line">a1.sinks.k1.hdfs.fileType = DataStream</span><br><span class="line"></span><br><span class="line"># 指定文件输出格式 为text</span><br><span class="line">a1.sinks.k1.hdfs.writeFormat = Text</span><br><span class="line"></span><br><span class="line"># 指定多少秒刷新一次文件</span><br><span class="line">a1.sinks.k1.hdfs.rollInterval = 60</span><br><span class="line"></span><br><span class="line"># 指定达到多少数据量写一次文件 单位：bytes</span><br><span class="line">a1.sinks.k1.hdfs.rollSize = 10240</span><br><span class="line"></span><br><span class="line"># 指定多少条写一次文件</span><br><span class="line">a1.sinks.k1.hdfs.rollCount = 1000</span><br><span class="line"></span><br><span class="line"># 配置channel</span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line"></span><br><span class="line"># 组装</span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure><ul><li>在 /root/data/目录下准备数据</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211022212413155.png" alt="image-20211022212413155"></p><ul><li>启动agent</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flume-ng agent -n a -f ./spoolingToHDFS.conf -Dflume.root.logger=DEBUG,console</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211022215054120.png" alt="image-20211022215054120"></p><p>可以很清楚的看到已经上传到HDFS上了。将数据下载下来可以很直接的看到数据。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211022215145674.png" alt="image-20211022215145674"></p><h3 id="HBaseLogToHDFS"><a href="#HBaseLogToHDFS" class="headerlink" title="HBaseLogToHDFS"></a>HBaseLogToHDFS</h3><ul><li>配置文件 HBaseLogToHDFS.conf</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># a表示给agent命名为a</span><br><span class="line"># 给source组件命名为r1</span><br><span class="line">a.sources = r1</span><br><span class="line"># 给sink组件命名为k1</span><br><span class="line">a.sinks = k1 </span><br><span class="line"># 给channel组件命名为c1</span><br><span class="line">a.channels = c1</span><br><span class="line">#指定exec的属性</span><br><span class="line">a.sources.r1.type = exec </span><br><span class="line"># 相当于监控这个日志并且输出到HDFS上</span><br><span class="line">a.sources.r1.command = tail -f /usr/local/soft/hbase-1.4.6/logs/hbase-root-master-master.log</span><br><span class="line">#指定sink的类型</span><br><span class="line">a.sinks.k1.type = hdfs</span><br><span class="line">a.sinks.k1.hdfs.path = /flume/data/dir2</span><br><span class="line"># 指定文件名前缀</span><br><span class="line">a.sinks.k1.hdfs.filePrefix = hbaselog</span><br><span class="line"># 指定达到多少数据量写一次文件 单位：bytes</span><br><span class="line">a.sinks.k1.hdfs.rollSize = 102400</span><br><span class="line"># 指定多少条写一次文件</span><br><span class="line">a.sinks.k1.hdfs.rollCount = 1000</span><br><span class="line"># 指定文件类型为 流 来什么输出什么</span><br><span class="line">a.sinks.k1.hdfs.fileType = DataStream</span><br><span class="line"># 指定文件输出格式 为text</span><br><span class="line">a.sinks.k1.hdfs.writeFormat = text</span><br><span class="line"># 指定文件名后缀</span><br><span class="line">a.sinks.k1.hdfs.fileSuffix = .txt</span><br><span class="line"></span><br><span class="line">#指定channel</span><br><span class="line">a.channels.c1.type = memory </span><br><span class="line">a.channels.c1.capacity = 1000</span><br><span class="line"># 表示sink每次会从channel里取多少数据</span><br><span class="line">a.channels.c1.transactionCapacity = 100</span><br><span class="line"># 组装</span><br><span class="line">a.sources.r1.channels = c1 </span><br><span class="line">a.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure><h3 id="HBaselogToHBase"><a href="#HBaselogToHBase" class="headerlink" title="HBaselogToHBase"></a>HBaselogToHBase</h3><ul><li>在hbase中创建log表</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create &#x27;log&#x27;,&#x27;cf1&#x27;</span><br></pre></td></tr></table></figure><ul><li>配置文件</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># a表示给agent命名为a</span><br><span class="line"># 给source组件命名为r1</span><br><span class="line">a.sources = r1</span><br><span class="line"># 给sink组件命名为k1</span><br><span class="line">a.sinks = k1 </span><br><span class="line"># 给channel组件命名为c1</span><br><span class="line">a.channels = c1</span><br><span class="line">#指定exec的属性</span><br><span class="line">a.sources.r1.type = exec </span><br><span class="line">a.sources.r1.command = cat /usr/local/soft/hbase-1.4.6/logs/hbase-root-master-master.log</span><br><span class="line">#指定sink的类型</span><br><span class="line">a.sinks.k1.type = hbase</span><br><span class="line">a.sinks.k1.table = log</span><br><span class="line">a.sinks.k1.columnFamily = cf1</span><br><span class="line"></span><br><span class="line">#指定channel</span><br><span class="line">a.channels.c1.type = memory </span><br><span class="line">a.channels.c1.capacity = 100000</span><br><span class="line"># 表示sink每次会从channel里取多少数据</span><br><span class="line">a.channels.c1.transactionCapacity = 100</span><br><span class="line"># 组装</span><br><span class="line">a.sources.r1.channels = c1 </span><br><span class="line">a.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure><h3 id="netcatLogger"><a href="#netcatLogger" class="headerlink" title="netcatLogger"></a>netcatLogger</h3><p>监听telnet端口</p><ul><li>安装telnet</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install telnet</span><br></pre></td></tr></table></figure><ul><li>配置文件 netcatToLogger.conf</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># a表示给agent命名为a</span><br><span class="line"># 给source组件命名为r1</span><br><span class="line">a.sources = r1</span><br><span class="line"># 给sink组件命名为k1</span><br><span class="line">a.sinks = k1 </span><br><span class="line"># 给channel组件命名为c1</span><br><span class="line">a.channels = c1</span><br><span class="line">#指定netcat的属性</span><br><span class="line">a.sources.r1.type = netcat </span><br><span class="line">a.sources.r1.bind = 0.0.0.0 </span><br><span class="line">a.sources.r1.port = 8888 </span><br><span class="line"></span><br><span class="line">#指定sink的类型</span><br><span class="line">a.sinks.k1.type = logger</span><br><span class="line">#指定channel</span><br><span class="line">a.channels.c1.type = memory </span><br><span class="line">a.channels.c1.capacity = 1000</span><br><span class="line"># 表示sink每次会从channel里取多少数据</span><br><span class="line">a.channels.c1.transactionCapacity = 100</span><br><span class="line"># 组装</span><br><span class="line">a.sources.r1.channels = c1 </span><br><span class="line">a.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure><ul><li><p>启动</p><ul><li>先启动agent</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flume-ng agent -n a -f netcatToLogger.conf -Dflume.root.logger=DEBUG,console</span><br></pre></td></tr></table></figure><ul><li>在启动telnet</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">telnet master 8888</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211022215944188.png" alt="image-20211022215944188"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211022220001892.png" alt="image-20211022220001892"></p><h3 id="httpToLogger"><a href="#httpToLogger" class="headerlink" title="httpToLogger"></a>httpToLogger</h3><ul><li>配置文件 httpToLogger.conf</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># a表示给agent命名为a</span><br><span class="line"># 给source组件命名为r1</span><br><span class="line">a.sources = r1</span><br><span class="line"># 给sink组件命名为k1</span><br><span class="line">a.sinks = k1 </span><br><span class="line"># 给channel组件命名为c1</span><br><span class="line">a.channels = c1</span><br><span class="line">#指定http的属性</span><br><span class="line">a.sources.r1.type = http</span><br><span class="line">a.sources.r1.port = 8888 </span><br><span class="line"></span><br><span class="line">#指定sink的类型</span><br><span class="line">a.sinks.k1.type = logger</span><br><span class="line">#指定channel</span><br><span class="line">a.channels.c1.type = memory </span><br><span class="line">a.channels.c1.capacity = 1000</span><br><span class="line"># 表示sink每次会从channel里取多少数据</span><br><span class="line">a.channels.c1.transactionCapacity = 100</span><br><span class="line"># 组装</span><br><span class="line">a.sources.r1.channels = c1 </span><br><span class="line">a.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure><ul><li><p>启动</p><ul><li>先启动agent</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flume-ng agent -n a -f ./httpToLogger.conf -Dflume.root.logger=DEBUG,console</span><br></pre></td></tr></table></figure><ul><li>再使用curl发起一个http请求</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -X POST -d &#x27;[&#123; &quot;headers&quot; :&#123;&quot;a&quot; : &quot;a1&quot;,&quot;b&quot; : &quot;b1&quot;&#125;,&quot;body&quot; : &quot;hello~http~flume~&quot;&#125;]&#x27; http://master:8888</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 大数据学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ETL工具学习</title>
      <link href="/2021/10/21/ETL%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/10/21/ETL%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="ETL工具"><a href="#ETL工具" class="headerlink" title="ETL工具"></a>ETL工具</h1><h2 id="DataX"><a href="#DataX" class="headerlink" title="DataX"></a>DataX</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>DataX 是阿里巴巴集团内被广泛使用的离线数据同步工具/平台，实现包括 MySQL、Oracle、SqlServer、Postgre、HDFS、Hive、ADS、HBase、TableStore(OTS)、MaxCompute(ODPS)、DRDS 等各种异构数据源之间高效的数据同步功能。 DataX本身作为数据同步框架，将不同数据源的同步抽象为从源头数据源读取数据的Reader插件，以及向目标端写入数据的Writer插件，理论上DataX框架可以支持任意数据源类型的数据同步工作。同时DataX插件体系作为一套生态系统, 每接入一套新数据源该新加入的数据源即可实现和现有的数据源互通。</p><h3 id="支持的数据源"><a href="#支持的数据源" class="headerlink" title="支持的数据源"></a>支持的数据源</h3><table><thead><tr><th>类型</th><th>数据源</th><th>Reader(读)</th><th>Writer(写)</th><th align="center">文档</th></tr></thead><tbody><tr><td>RDBMS 关系型数据库</td><td>MySQL</td><td>√</td><td>√</td><td align="center"><a href="https://github.com/alibaba/DataX/blob/master/mysqlreader/doc/mysqlreader.md">读</a> 、<a href="https://github.com/alibaba/DataX/blob/master/mysqlwriter/doc/mysqlwriter.md">写</a></td></tr><tr><td></td><td>Oracle</td><td>√</td><td>√</td><td align="center"><a href="https://github.com/alibaba/DataX/blob/master/oraclereader/doc/oraclereader.md">读</a> 、<a href="https://github.com/alibaba/DataX/blob/master/oraclewriter/doc/oraclewriter.md">写</a></td></tr><tr><td></td><td>OceanBase</td><td>√</td><td>√</td><td align="center"><a href="https://open.oceanbase.com/docs/community/oceanbase-database/V3.1.0/use-datax-to-full-migration-data-to-oceanbase">读</a> 、<a href="https://open.oceanbase.com/docs/community/oceanbase-database/V3.1.0/use-datax-to-full-migration-data-to-oceanbase">写</a></td></tr><tr><td></td><td>SQLServer</td><td>√</td><td>√</td><td align="center"><a href="https://github.com/alibaba/DataX/blob/master/sqlserverreader/doc/sqlserverreader.md">读</a> 、<a href="https://github.com/alibaba/DataX/blob/master/sqlserverwriter/doc/sqlserverwriter.md">写</a></td></tr><tr><td></td><td>PostgreSQL</td><td>√</td><td>√</td><td align="center"><a href="https://github.com/alibaba/DataX/blob/master/postgresqlreader/doc/postgresqlreader.md">读</a> 、<a href="https://github.com/alibaba/DataX/blob/master/postgresqlwriter/doc/postgresqlwriter.md">写</a></td></tr><tr><td></td><td>DRDS</td><td>√</td><td>√</td><td align="center"><a href="https://github.com/alibaba/DataX/blob/master/drdsreader/doc/drdsreader.md">读</a> 、<a href="https://github.com/alibaba/DataX/blob/master/drdswriter/doc/drdswriter.md">写</a></td></tr><tr><td></td><td>通用RDBMS(支持所有关系型数据库)</td><td>√</td><td>√</td><td align="center"><a href="https://github.com/alibaba/DataX/blob/master/rdbmsreader/doc/rdbmsreader.md">读</a> 、<a href="https://github.com/alibaba/DataX/blob/master/rdbmswriter/doc/rdbmswriter.md">写</a></td></tr><tr><td>阿里云数仓数据存储</td><td>ODPS</td><td>√</td><td>√</td><td align="center"><a href="https://github.com/alibaba/DataX/blob/master/odpsreader/doc/odpsreader.md">读</a> 、<a href="https://github.com/alibaba/DataX/blob/master/odpswriter/doc/odpswriter.md">写</a></td></tr><tr><td></td><td>ADS</td><td></td><td>√</td><td align="center"><a href="https://github.com/alibaba/DataX/blob/master/adswriter/doc/adswriter.md">写</a></td></tr><tr><td></td><td>OSS</td><td>√</td><td>√</td><td align="center"><a href="https://github.com/alibaba/DataX/blob/master/ossreader/doc/ossreader.md">读</a> 、<a href="https://github.com/alibaba/DataX/blob/master/osswriter/doc/osswriter.md">写</a></td></tr><tr><td></td><td>OCS</td><td>√</td><td>√</td><td align="center"><a href="https://github.com/alibaba/DataX/blob/master/ocsreader/doc/ocsreader.md">读</a> 、<a href="https://github.com/alibaba/DataX/blob/master/ocswriter/doc/ocswriter.md">写</a></td></tr><tr><td>NoSQL数据存储</td><td>OTS</td><td>√</td><td>√</td><td align="center"><a href="https://github.com/alibaba/DataX/blob/master/otsreader/doc/otsreader.md">读</a> 、<a href="https://github.com/alibaba/DataX/blob/master/otswriter/doc/otswriter.md">写</a></td></tr><tr><td></td><td>Hbase0.94</td><td>√</td><td>√</td><td align="center"><a href="https://github.com/alibaba/DataX/blob/master/hbase094xreader/doc/hbase094xreader.md">读</a> 、<a href="https://github.com/alibaba/DataX/blob/master/hbase094xwriter/doc/hbase094xwriter.md">写</a></td></tr><tr><td></td><td>Hbase1.1</td><td>√</td><td>√</td><td align="center"><a href="https://github.com/alibaba/DataX/blob/master/hbase11xreader/doc/hbase11xreader.md">读</a> 、<a href="https://github.com/alibaba/DataX/blob/master/hbase11xwriter/doc/hbase11xwriter.md">写</a></td></tr><tr><td></td><td>Phoenix4.x</td><td>√</td><td>√</td><td align="center"><a href="https://github.com/alibaba/DataX/blob/master/hbase11xsqlreader/doc/hbase11xsqlreader.md">读</a> 、<a href="https://github.com/alibaba/DataX/blob/master/hbase11xsqlwriter/doc/hbase11xsqlwriter.md">写</a></td></tr><tr><td></td><td>Phoenix5.x</td><td>√</td><td>√</td><td align="center"><a href="https://github.com/alibaba/DataX/blob/master/hbase20xsqlreader/doc/hbase20xsqlreader.md">读</a> 、<a href="https://github.com/alibaba/DataX/blob/master/hbase20xsqlwriter/doc/hbase20xsqlwriter.md">写</a></td></tr><tr><td></td><td>MongoDB</td><td>√</td><td>√</td><td align="center"><a href="https://github.com/alibaba/DataX/blob/master/mongodbreader/doc/mongodbreader.md">读</a> 、<a href="https://github.com/alibaba/DataX/blob/master/mongodbwriter/doc/mongodbwriter.md">写</a></td></tr><tr><td></td><td>Hive</td><td>√</td><td>√</td><td align="center"><a href="https://github.com/alibaba/DataX/blob/master/hdfsreader/doc/hdfsreader.md">读</a> 、<a href="https://github.com/alibaba/DataX/blob/master/hdfswriter/doc/hdfswriter.md">写</a></td></tr><tr><td></td><td>Cassandra</td><td>√</td><td>√</td><td align="center"><a href="https://github.com/alibaba/DataX/blob/master/cassandrareader/doc/cassandrareader.md">读</a> 、<a href="https://github.com/alibaba/DataX/blob/master/cassandrawriter/doc/cassandrawriter.md">写</a></td></tr><tr><td>无结构化数据存储</td><td>TxtFile</td><td>√</td><td>√</td><td align="center"><a href="https://github.com/alibaba/DataX/blob/master/txtfilereader/doc/txtfilereader.md">读</a> 、<a href="https://github.com/alibaba/DataX/blob/master/txtfilewriter/doc/txtfilewriter.md">写</a></td></tr><tr><td></td><td>FTP</td><td>√</td><td>√</td><td align="center"><a href="https://github.com/alibaba/DataX/blob/master/ftpreader/doc/ftpreader.md">读</a> 、<a href="https://github.com/alibaba/DataX/blob/master/ftpwriter/doc/ftpwriter.md">写</a></td></tr><tr><td></td><td>HDFS</td><td>√</td><td>√</td><td align="center"><a href="https://github.com/alibaba/DataX/blob/master/hdfsreader/doc/hdfsreader.md">读</a> 、<a href="https://github.com/alibaba/DataX/blob/master/hdfswriter/doc/hdfswriter.md">写</a></td></tr><tr><td></td><td>Elasticsearch</td><td></td><td>√</td><td align="center"><a href="https://github.com/alibaba/DataX/blob/master/elasticsearchwriter/doc/elasticsearchwriter.md">写</a></td></tr><tr><td>时间序列数据库</td><td>OpenTSDB</td><td>√</td><td></td><td align="center"><a href="https://github.com/alibaba/DataX/blob/master/opentsdbreader/doc/opentsdbreader.md">读</a></td></tr><tr><td></td><td>TSDB</td><td>√</td><td>√</td><td align="center"><a href="https://github.com/alibaba/DataX/blob/master/tsdbreader/doc/tsdbreader.md">读</a> 、<a href="https://github.com/alibaba/DataX/blob/master/tsdbwriter/doc/tsdbhttpwriter.md">写</a></td></tr></tbody></table><p><strong>开源仓库地址:<a href="https://github.com/alibaba/DataX">https://github.com/alibaba/DataX</a></strong></p><h3 id="DataX的安装"><a href="#DataX的安装" class="headerlink" title="DataX的安装"></a>DataX的安装</h3><blockquote><p>DataX不需要依赖其他服务，直接上传、解压、安装、配置环境变量即可</p><p>也可以直接在windows上解压</p></blockquote><h4 id="上传并解压"><a href="#上传并解压" class="headerlink" title="上传并解压"></a>上传并解压</h4><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211021185849077.png" alt="image-20211021185849077"></p><h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211021191033349.png" alt="image-20211021191033349"></p><p><strong>至此DataX插件安装完毕。</strong></p><h3 id="DataX使用"><a href="#DataX使用" class="headerlink" title="DataX使用"></a>DataX使用</h3><h4 id="官方案例"><a href="#官方案例" class="headerlink" title="官方案例"></a>官方案例</h4><p>官方这里给我们提供了一个案例，拿来查看一下。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;job&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;content&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;reader&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;streamreader&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;sliceRecordCount&quot;</span>: <span class="number">10</span>,</span><br><span class="line">                        <span class="attr">&quot;column&quot;</span>: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;long&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;10&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;hello，你好，世界-DataX&quot;</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;writer&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;streamwriter&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;encoding&quot;</span>: <span class="string">&quot;UTF-8&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;print&quot;</span>: <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;setting&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;speed&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;channel&quot;</span>: <span class="number">5</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行同步任务</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">datax.py StreamToStream.json</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211021191804971.png" alt="image-20211021191804971"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211021191831535.png" alt="image-20211021191831535"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211021191840010.png" alt="image-20211021191840010"></p><p>可以看到已经运行完毕。</p><h4 id="可以去官方文档查看相应操作，需要什么数据库的读或者插组件，就点击哪个数据库。"><a href="#可以去官方文档查看相应操作，需要什么数据库的读或者插组件，就点击哪个数据库。" class="headerlink" title="可以去官方文档查看相应操作，需要什么数据库的读或者插组件，就点击哪个数据库。"></a>可以去官方文档查看相应操作，需要什么数据库的读或者插组件，就点击哪个数据库。</h4><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211021194213540.png" alt="image-20211021194213540"></p><h4 id="MySQLToMySQL"><a href="#MySQLToMySQL" class="headerlink" title="MySQLToMySQL"></a>MySQLToMySQL</h4><blockquote><p>需要新建student2数据库，并创建student表</p></blockquote><h5 id="编写配置文件MySQLToMySQL-json"><a href="#编写配置文件MySQLToMySQL-json" class="headerlink" title="编写配置文件MySQLToMySQL.json"></a>编写配置文件MySQLToMySQL.json</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;job&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;content&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;reader&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;mysqlreader&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;column&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;id&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;name&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;age&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;gender&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;clazz&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;last_mod&quot;</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="attr">&quot;splitPk&quot;</span>: <span class="string">&quot;age&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;connection&quot;</span>: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;table&quot;</span>: [</span><br><span class="line">                                    <span class="string">&quot;student&quot;</span></span><br><span class="line">                                ],</span><br><span class="line">                                <span class="attr">&quot;jdbcUrl&quot;</span>: [</span><br><span class="line">                                    <span class="string">&quot;jdbc:mysql://master:3306/student&quot;</span></span><br><span class="line">                                ]</span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;writer&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;mysqlwriter&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;writeMode&quot;</span>: <span class="string">&quot;insert&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;column&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;id&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;name&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;age&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;gender&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;clazz&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;last_mod&quot;</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="attr">&quot;preSql&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;truncate student2&quot;</span></span><br><span class="line">                        ],                        </span><br><span class="line">                        <span class="attr">&quot;connection&quot;</span>: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;jdbcUrl&quot;</span>: <span class="string">&quot;jdbc:mysql://master:3306/student2?useUnicode=true&amp;characterEncoding=utf8&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;table&quot;</span>: [</span><br><span class="line">                                    <span class="string">&quot;student2&quot;</span></span><br><span class="line">                                ]</span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;setting&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;speed&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;channel&quot;</span>: <span class="number">6</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211021202258806.png" alt="image-20211021202258806"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211021202321494.png" alt="image-20211021202321494"></p><p>可以看到写入成功了。</p><h4 id="MySQLToHDFS"><a href="#MySQLToHDFS" class="headerlink" title="MySQLToHDFS"></a>MySQLToHDFS</h4><blockquote><p>写hive跟hdfs时一样的</p></blockquote><h5 id="编写配置文件MySQLToHDFS-json"><a href="#编写配置文件MySQLToHDFS-json" class="headerlink" title="编写配置文件MySQLToHDFS.json"></a>编写配置文件MySQLToHDFS.json</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;job&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;content&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;reader&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;mysqlreader&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;column&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;id&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;name&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;age&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;gender&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;clazz&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;last_mod&quot;</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="attr">&quot;splitPk&quot;</span>: <span class="string">&quot;age&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;connection&quot;</span>: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;table&quot;</span>: [</span><br><span class="line">                                    <span class="string">&quot;student&quot;</span></span><br><span class="line">                                ],</span><br><span class="line">                                <span class="attr">&quot;jdbcUrl&quot;</span>: [</span><br><span class="line">                                    <span class="string">&quot;jdbc:mysql://master:3306/student&quot;</span></span><br><span class="line">                                ]</span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;writer&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;hdfswriter&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;defaultFS&quot;</span>: <span class="string">&quot;hdfs://master:9000&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;fileType&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;/user/hive/warehouse/datax.db/students&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;fileName&quot;</span>: <span class="string">&quot;student&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;column&quot;</span>: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;id&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;bigint&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;age&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;INT&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;gender&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;clazz&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;last_mod&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ],</span><br><span class="line">                        <span class="attr">&quot;writeMode&quot;</span>: <span class="string">&quot;append&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;fieldDelimiter&quot;</span>: <span class="string">&quot;,&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;setting&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;speed&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;channel&quot;</span>: <span class="number">6</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211021203405282.png" alt="image-20211021203405282"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211021203420358.png" alt="image-20211021203420358"></p><p>可以看到写入成功了。</p><h4 id="HBaseToMySQL"><a href="#HBaseToMySQL" class="headerlink" title="HBaseToMySQL"></a>HBaseToMySQL</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;job&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;content&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;reader&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;hbase11xreader&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;hbaseConfig&quot;</span>: &#123;</span><br><span class="line">                            <span class="attr">&quot;hbase.zookeeper.quorum&quot;</span>: <span class="string">&quot;master:2181&quot;</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="attr">&quot;table&quot;</span>: <span class="string">&quot;student&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;encoding&quot;</span>: <span class="string">&quot;utf-8&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;mode&quot;</span>: <span class="string">&quot;normal&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;column&quot;</span>: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;rowkey&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;cf1:name&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;cf1:age&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;cf1:gender&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;cf1:clazz&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ],</span><br><span class="line">                        <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">                            <span class="attr">&quot;startRowkey&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                            <span class="attr">&quot;endRowkey&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                            <span class="attr">&quot;isBinaryRowkey&quot;</span>: <span class="literal">false</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;writer&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;mysqlwriter&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;writeMode&quot;</span>: <span class="string">&quot;insert&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;column&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;id&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;name&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;age&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;gender&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;clazz&quot;</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="attr">&quot;preSql&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;truncate student2&quot;</span></span><br><span class="line">                        ],                        </span><br><span class="line">                        <span class="attr">&quot;connection&quot;</span>: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;jdbcUrl&quot;</span>: <span class="string">&quot;jdbc:mysql://master:3306/student2?useUnicode=true&amp;characterEncoding=utf8&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;table&quot;</span>: [</span><br><span class="line">                                    <span class="string">&quot;student2&quot;</span></span><br><span class="line">                                ]</span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;setting&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;speed&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;channel&quot;</span>: <span class="number">6</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MySQLToHBase"><a href="#MySQLToHBase" class="headerlink" title="MySQLToHBase"></a>MySQLToHBase</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;job&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;content&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;reader&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;mysqlreader&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;column&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;student_id&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;course_id&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;score&quot;</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="attr">&quot;splitPk&quot;</span>: <span class="string">&quot;course_id&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;connection&quot;</span>: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;table&quot;</span>: [</span><br><span class="line">                                    <span class="string">&quot;score&quot;</span></span><br><span class="line">                                ],</span><br><span class="line">                                <span class="attr">&quot;jdbcUrl&quot;</span>: [</span><br><span class="line">                                    <span class="string">&quot;jdbc:mysql://master:3306/student&quot;</span></span><br><span class="line">                                ]</span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;writer&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;hbase11xwriter&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">                      <span class="attr">&quot;hbaseConfig&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;hbase.zookeeper.quorum&quot;</span>: <span class="string">&quot;master:2181&quot;</span></span><br><span class="line">                      &#125;,</span><br><span class="line">                      <span class="attr">&quot;table&quot;</span>: <span class="string">&quot;score&quot;</span>,</span><br><span class="line">                      <span class="attr">&quot;mode&quot;</span>: <span class="string">&quot;normal&quot;</span>,</span><br><span class="line">                      <span class="attr">&quot;rowkeyColumn&quot;</span>: [</span><br><span class="line">                          &#123;</span><br><span class="line">                            <span class="attr">&quot;index&quot;</span>:<span class="number">0</span>,</span><br><span class="line">                            <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;string&quot;</span></span><br><span class="line">                          &#125;,</span><br><span class="line">                          &#123;</span><br><span class="line">                            <span class="attr">&quot;index&quot;</span>:<span class="number">-1</span>,</span><br><span class="line">                            <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;string&quot;</span>,</span><br><span class="line">                            <span class="attr">&quot;value&quot;</span>:<span class="string">&quot;_&quot;</span></span><br><span class="line">                          &#125;,</span><br><span class="line">                          &#123;</span><br><span class="line">                            <span class="attr">&quot;index&quot;</span>:<span class="number">1</span>,</span><br><span class="line">                            <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;string&quot;</span></span><br><span class="line">                          &#125;</span><br><span class="line">                      ],</span><br><span class="line">                      <span class="attr">&quot;column&quot;</span>: [</span><br><span class="line">                        &#123;</span><br><span class="line">                          <span class="attr">&quot;index&quot;</span>:<span class="number">2</span>,</span><br><span class="line">                          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;cf1:score&quot;</span>,</span><br><span class="line">                          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;int&quot;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                      ],</span><br><span class="line">                      <span class="attr">&quot;encoding&quot;</span>: <span class="string">&quot;utf-8&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;setting&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;speed&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;channel&quot;</span>: <span class="number">6</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MySQLToPhoenix"><a href="#MySQLToPhoenix" class="headerlink" title="MySQLToPhoenix"></a>MySQLToPhoenix</h4><h5 id="在Phoenix中创建STUDENT表"><a href="#在Phoenix中创建STUDENT表" class="headerlink" title="在Phoenix中创建STUDENT表"></a>在Phoenix中创建STUDENT表</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> STUDENT (</span><br><span class="line"> ID <span class="type">VARCHAR</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY, </span><br><span class="line"> NAME <span class="type">VARCHAR</span>,</span><br><span class="line"> AGE <span class="type">BIGINT</span>, </span><br><span class="line"> GENDER <span class="type">VARCHAR</span> ,</span><br><span class="line"> CLAZZ <span class="type">VARCHAR</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="编写配置文件MySQLToPhoenix-json"><a href="#编写配置文件MySQLToPhoenix-json" class="headerlink" title="编写配置文件MySQLToPhoenix.json"></a>编写配置文件MySQLToPhoenix.json</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;job&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;setting&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;speed&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;channel&quot;</span>: <span class="number">3</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;errorLimit&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;record&quot;</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">&quot;percentage&quot;</span>: <span class="number">0.02</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;content&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;reader&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;mysqlreader&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;column&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;id&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;name&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;age&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;gender&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;clazz&quot;</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="attr">&quot;splitPk&quot;</span>: <span class="string">&quot;id&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;connection&quot;</span>: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;table&quot;</span>: [</span><br><span class="line">                                    <span class="string">&quot;student&quot;</span></span><br><span class="line">                                ],</span><br><span class="line">                                <span class="attr">&quot;jdbcUrl&quot;</span>: [</span><br><span class="line">                                    <span class="string">&quot;jdbc:mysql://master:3306/student?useSSL=false&quot;</span></span><br><span class="line">                                ]</span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;writer&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;hbase11xsqlwriter&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;batchSize&quot;</span>: <span class="string">&quot;256&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;column&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;ID&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;NAME&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;AGE&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;GENDER&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;CLAZZ&quot;</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="attr">&quot;hbaseConfig&quot;</span>: &#123;</span><br><span class="line">                            <span class="attr">&quot;hbase.zookeeper.quorum&quot;</span>: <span class="string">&quot;master,node1,node2&quot;</span>,</span><br><span class="line">                            <span class="attr">&quot;zookeeper.znode.parent&quot;</span>: <span class="string">&quot;/hbase&quot;</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="attr">&quot;nullMode&quot;</span>: <span class="string">&quot;skip&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;table&quot;</span>: <span class="string">&quot;STUDENT&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HDFSToHBase"><a href="#HDFSToHBase" class="headerlink" title="HDFSToHBase"></a>HDFSToHBase</h4><blockquote><p>将students.txt数据上传至HDFS的<code>/data/student1/</code>目录</p><p>在HBase中创建datax表：<code>create &#39;datax&#39;,&#39;cf1&#39;</code></p></blockquote><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;job&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;setting&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;speed&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;channel&quot;</span>: <span class="number">3</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;errorLimit&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;record&quot;</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">&quot;percentage&quot;</span>: <span class="number">0.02</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;content&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;reader&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;hdfsreader&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;/data/student1/&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;defaultFS&quot;</span>: <span class="string">&quot;hdfs://master:9000&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;column&quot;</span>: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;index&quot;</span>: <span class="number">0</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;index&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;index&quot;</span>: <span class="number">2</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;index&quot;</span>: <span class="number">3</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;index&quot;</span>: <span class="number">4</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;index&quot;</span>: <span class="number">5</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ],</span><br><span class="line">                        <span class="attr">&quot;fileType&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;encoding&quot;</span>: <span class="string">&quot;UTF-8&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;fieldDelimiter&quot;</span>: <span class="string">&quot;,&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;writer&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;hbase11xwriter&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;hbaseConfig&quot;</span>: &#123;</span><br><span class="line">                            <span class="attr">&quot;hbase.zookeeper.quorum&quot;</span>: <span class="string">&quot;master,node1,node2&quot;</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="attr">&quot;table&quot;</span>: <span class="string">&quot;datax&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;mode&quot;</span>: <span class="string">&quot;normal&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;rowkeyColumn&quot;</span>: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;index&quot;</span>: <span class="number">0</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;index&quot;</span>: <span class="number">-1</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;_&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;index&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ],</span><br><span class="line">                        <span class="attr">&quot;column&quot;</span>: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;index&quot;</span>: <span class="number">2</span>,</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;cf1:age&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;index&quot;</span>: <span class="number">3</span>,</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;cf1:gender&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;index&quot;</span>: <span class="number">4</span>,</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;cf1:clazz&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;index&quot;</span>: <span class="number">5</span>,</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;cf1:ts&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ],</span><br><span class="line">                        <span class="attr">&quot;versionColumn&quot;</span>: &#123;</span><br><span class="line">                            <span class="attr">&quot;index&quot;</span>: <span class="number">5</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="attr">&quot;encoding&quot;</span>: <span class="string">&quot;utf-8&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FlinkX"><a href="#FlinkX" class="headerlink" title="FlinkX"></a>FlinkX</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211021212008597.png" alt="image-20211021212008597"></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote><p>安装unzip：yum install unzip</p></blockquote><p>1、上传并解压</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unzip flinkx-1.10.zip -d /usr/local/soft/</span><br></pre></td></tr></table></figure><p>2、配置环境变量</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211021213607430.png" alt="image-20211021213607430"></p><p>3、给bin/flinkx这个文件加上执行权限</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod a+x flinkx</span><br></pre></td></tr></table></figure><p>4、修改配置文件，设置运行端口</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim flinkconf/flink-conf.yaml</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## web服务端口，不指定的话会随机生成一个</span><br><span class="line">rest.bind-port: 8888</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211021213532460.png" alt="image-20211021213532460"></p><h3 id="FlinkX使用"><a href="#FlinkX使用" class="headerlink" title="FlinkX使用"></a>FlinkX使用</h3><h4 id="MySQLToHDFS-1"><a href="#MySQLToHDFS-1" class="headerlink" title="MySQLToHDFS"></a>MySQLToHDFS</h4><ul><li>配置文件</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;job&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;content&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;reader&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;connection&quot;</span>: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;jdbcUrl&quot;</span>: [</span><br><span class="line">                                    <span class="string">&quot;jdbc:mysql://master:3306/student?characterEncoding=utf8&quot;</span></span><br><span class="line">                                ],</span><br><span class="line">                                <span class="attr">&quot;table&quot;</span>: [</span><br><span class="line">                                    <span class="string">&quot;student&quot;</span></span><br><span class="line">                                ]</span><br><span class="line">                            &#125;</span><br><span class="line">                        ],</span><br><span class="line">                        <span class="attr">&quot;column&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;*&quot;</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="attr">&quot;customSql&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;where&quot;</span>: <span class="string">&quot;clazz = &#x27;理科二班&#x27;&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;splitPk&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;queryTimeOut&quot;</span>: <span class="number">1000</span>,</span><br><span class="line">                        <span class="attr">&quot;requestAccumulatorInterval&quot;</span>: <span class="number">2</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;mysqlreader&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;writer&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;hdfswriter&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;hdfs://master:9000/data/flinkx/student&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;defaultFS&quot;</span>: <span class="string">&quot;hdfs://master:9000&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;column&quot;</span>: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;col1&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;index&quot;</span>: <span class="number">0</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;col2&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;index&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;col3&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;index&quot;</span>: <span class="number">2</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;col4&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;index&quot;</span>: <span class="number">3</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;col5&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;index&quot;</span>: <span class="number">4</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;col6&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;index&quot;</span>: <span class="number">5</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ],</span><br><span class="line">                        <span class="attr">&quot;fieldDelimiter&quot;</span>: <span class="string">&quot;,&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;fileType&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;writeMode&quot;</span>: <span class="string">&quot;overwrite&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;setting&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;restore&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;isRestore&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">&quot;isStream&quot;</span>: <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;errorLimit&quot;</span>: &#123;&#125;,</span><br><span class="line">            <span class="attr">&quot;speed&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;channel&quot;</span>: <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动任务</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flinkx -mode local -job /usr/local/soft/flinkx-1.10/job/MySQLToHDFS.json -pluginRoot /usr/local/soft/flinkx-1.10/syncplugins/ -flinkconf /usr/local/soft/flinkx-1.10/flinkconf/</span><br></pre></td></tr></table></figure><ul><li>监听日志</li></ul><blockquote><p>flinkx 任务启动后，会在执行命令的目录下生成一个nohup.out文件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tail -f nohup.out</span><br></pre></td></tr></table></figure><ul><li>通过web界面查看任务运行情况</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://master:8888</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211021220136418.png" alt="image-20211021220136418"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211021220301997.png" alt="image-20211021220301997"></p><h4 id="MySQLToHive"><a href="#MySQLToHive" class="headerlink" title="MySQLToHive"></a>MySQLToHive</h4><ul><li>配置文件</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;job&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;content&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;reader&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;connection&quot;</span>: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;jdbcUrl&quot;</span>: [</span><br><span class="line">                                    <span class="string">&quot;jdbc:mysql://master:3306/student?characterEncoding=utf8&quot;</span></span><br><span class="line">                                ],</span><br><span class="line">                                <span class="attr">&quot;table&quot;</span>: [</span><br><span class="line">                                    <span class="string">&quot;student&quot;</span></span><br><span class="line">                                ]</span><br><span class="line">                            &#125;</span><br><span class="line">                        ],</span><br><span class="line">                        <span class="attr">&quot;column&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;*&quot;</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="attr">&quot;customSql&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;where&quot;</span>: <span class="string">&quot;clazz = &#x27;文科二班&#x27;&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;splitPk&quot;</span>: <span class="string">&quot;id&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;queryTimeOut&quot;</span>: <span class="number">1000</span>,</span><br><span class="line">                        <span class="attr">&quot;requestAccumulatorInterval&quot;</span>: <span class="number">2</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;mysqlreader&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;writer&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;hivewriter&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;jdbcUrl&quot;</span>: <span class="string">&quot;jdbc:hive2://master:10000/testflinkx&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;fileType&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;fieldDelimiter&quot;</span>: <span class="string">&quot;,&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;writeMode&quot;</span>: <span class="string">&quot;overwrite&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;compress&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;charsetName&quot;</span>: <span class="string">&quot;UTF-8&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;maxFileSize&quot;</span>: <span class="number">1073741824</span>,</span><br><span class="line">                        <span class="attr">&quot;tablesColumn&quot;</span>: <span class="string">&quot;&#123;\&quot;student\&quot;:[&#123;\&quot;key\&quot;:\&quot;id\&quot;,\&quot;type\&quot;:\&quot;string\&quot;&#125;,&#123;\&quot;key\&quot;:\&quot;name\&quot;,\&quot;type\&quot;:\&quot;string\&quot;&#125;,&#123;\&quot;key\&quot;:\&quot;age\&quot;,\&quot;type\&quot;:\&quot;string\&quot;&#125;]&#125;&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;defaultFS&quot;</span>: <span class="string">&quot;hdfs://master:9000&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;setting&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;restore&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;isRestore&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">&quot;isStream&quot;</span>: <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;errorLimit&quot;</span>: &#123;&#125;,</span><br><span class="line">            <span class="attr">&quot;speed&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;channel&quot;</span>: <span class="number">3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在hive中创建testflinkx数据库，并创建student分区表</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database testflinkx;</span><br><span class="line">use testflinkx;</span><br><span class="line">CREATE TABLE `student`(</span><br><span class="line">  `id` string, </span><br><span class="line">  `name` string, </span><br><span class="line">  `age` string)</span><br><span class="line">PARTITIONED BY ( </span><br><span class="line">  `pt` string)</span><br><span class="line">ROW FORMAT DELIMITED </span><br><span class="line">  FIELDS TERMINATED BY &#x27;,&#x27;</span><br></pre></td></tr></table></figure><ul><li>启动hiveserver2</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 第一种方式：</span><br><span class="line">hiveserver2</span><br><span class="line"># 第二种方式:</span><br><span class="line">hive --service hiveserver2</span><br></pre></td></tr></table></figure><ul><li>启动任务</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flinkx -mode local -job /usr/local/soft/flinkx-1.10/job/MySQLToHive.json -pluginRoot /usr/local/soft/flinkx-1.10/syncplugins/ -flinkconf /usr/local/soft/flinkx-1.10/flinkconf/</span><br></pre></td></tr></table></figure><ul><li>查看日志及运行情况同上</li></ul><h4 id="MySQLToHBase-1"><a href="#MySQLToHBase-1" class="headerlink" title="MySQLToHBase"></a>MySQLToHBase</h4><ul><li>配置文件</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;job&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;content&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;reader&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;connection&quot;</span>: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;jdbcUrl&quot;</span>: [</span><br><span class="line">                                    <span class="string">&quot;jdbc:mysql://master:3306/student?characterEncoding=utf8&quot;</span></span><br><span class="line">                                ],</span><br><span class="line">                                <span class="attr">&quot;table&quot;</span>: [</span><br><span class="line">                                    <span class="string">&quot;score&quot;</span></span><br><span class="line">                                ]</span><br><span class="line">                            &#125;</span><br><span class="line">                        ],</span><br><span class="line">                        <span class="attr">&quot;column&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;*&quot;</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="attr">&quot;customSql&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;splitPk&quot;</span>: <span class="string">&quot;student_id&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;queryTimeOut&quot;</span>: <span class="number">1000</span>,</span><br><span class="line">                        <span class="attr">&quot;requestAccumulatorInterval&quot;</span>: <span class="number">2</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;mysqlreader&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;writer&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;hbasewriter&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;hbaseConfig&quot;</span>: &#123;</span><br><span class="line">                            <span class="attr">&quot;hbase.zookeeper.property.clientPort&quot;</span>: <span class="string">&quot;2181&quot;</span>,</span><br><span class="line">                            <span class="attr">&quot;hbase.rootdir&quot;</span>: <span class="string">&quot;hdfs://master:9000/hbase&quot;</span>,</span><br><span class="line">                            <span class="attr">&quot;hbase.cluster.distributed&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                            <span class="attr">&quot;hbase.zookeeper.quorum&quot;</span>: <span class="string">&quot;master,node1,node2&quot;</span>,</span><br><span class="line">                            <span class="attr">&quot;zookeeper.znode.parent&quot;</span>: <span class="string">&quot;/hbase&quot;</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="attr">&quot;table&quot;</span>: <span class="string">&quot;testFlinkx&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;rowkeyColumn&quot;</span>: <span class="string">&quot;$(cf1:student_id)_$(cf1:course_id)&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;column&quot;</span>: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;cf1:student_id&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;cf1:course_id&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;cf1:score&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;setting&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;restore&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;isRestore&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">&quot;isStream&quot;</span>: <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;errorLimit&quot;</span>: &#123;&#125;,</span><br><span class="line">            <span class="attr">&quot;speed&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;channel&quot;</span>: <span class="number">3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动hbase 并创建testflinkx表</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create &#x27;testFlinkx&#x27;,&#x27;cf1&#x27;</span><br></pre></td></tr></table></figure><ul><li>启动任务</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flinkx -mode local -job /usr/local/soft/flinkx-1.10/job/MySQLToHBase.json -pluginRoot /usr/local/soft/flinkx-1.10/syncplugins/ -flinkconf /usr/local/soft/flinkx-1.10/flinkconf/</span><br></pre></td></tr></table></figure><ul><li>查看日志及运行情况同上</li></ul><h4 id="MySQLToMySQL-1"><a href="#MySQLToMySQL-1" class="headerlink" title="MySQLToMySQL"></a>MySQLToMySQL</h4><ul><li>配置文件</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;job&quot;: &#123;</span><br><span class="line">      &quot;content&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;reader&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: &quot;mysqlreader&quot;,</span><br><span class="line">            &quot;parameter&quot;: &#123;</span><br><span class="line">              &quot;column&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;name&quot;: &quot;id&quot;,</span><br><span class="line">                  &quot;type&quot;: &quot;int&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;name&quot;: &quot;name&quot;,</span><br><span class="line">                  &quot;type&quot;: &quot;string&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;name&quot;: &quot;age&quot;,</span><br><span class="line">                  &quot;type&quot;: &quot;int&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;name&quot;: &quot;gender&quot;,</span><br><span class="line">                  &quot;type&quot;: &quot;string&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;name&quot;: &quot;clazz&quot;,</span><br><span class="line">                  &quot;type&quot;: &quot;string&quot;</span><br><span class="line">                &#125;</span><br><span class="line">              ],</span><br><span class="line">              &quot;username&quot;: &quot;root&quot;,</span><br><span class="line">              &quot;password&quot;: &quot;123456&quot;,</span><br><span class="line">              &quot;connection&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;jdbcUrl&quot;: [</span><br><span class="line">                    &quot;jdbc:mysql://master:3306/student?useSSL=false&quot;</span><br><span class="line">                  ],</span><br><span class="line">                  &quot;table&quot;: [</span><br><span class="line">                    &quot;student&quot;</span><br><span class="line">                  ]</span><br><span class="line">                &#125;</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;writer&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: &quot;mysqlwriter&quot;,</span><br><span class="line">            &quot;parameter&quot;: &#123;</span><br><span class="line">              &quot;username&quot;: &quot;root&quot;,</span><br><span class="line">              &quot;password&quot;: &quot;123456&quot;,</span><br><span class="line">              &quot;connection&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;jdbcUrl&quot;: &quot;jdbc:mysql://master:3306/student?useSSL=false&quot;,</span><br><span class="line">                  &quot;table&quot;: [</span><br><span class="line">                    &quot;student2&quot;</span><br><span class="line">                  ]</span><br><span class="line">                &#125;</span><br><span class="line">              ],</span><br><span class="line">              &quot;writeMode&quot;: &quot;insert&quot;,</span><br><span class="line">              &quot;column&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;name&quot;: &quot;id&quot;,</span><br><span class="line">                    &quot;type&quot;: &quot;int&quot;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  &#123;</span><br><span class="line">                    &quot;name&quot;: &quot;name&quot;,</span><br><span class="line">                    &quot;type&quot;: &quot;string&quot;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  &#123;</span><br><span class="line">                    &quot;name&quot;: &quot;age&quot;,</span><br><span class="line">                    &quot;type&quot;: &quot;int&quot;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  &#123;</span><br><span class="line">                    &quot;name&quot;: &quot;gender&quot;,</span><br><span class="line">                    &quot;type&quot;: &quot;string&quot;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  &#123;</span><br><span class="line">                    &quot;name&quot;: &quot;clazz&quot;,</span><br><span class="line">                    &quot;type&quot;: &quot;string&quot;</span><br><span class="line">                  &#125;</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;setting&quot;: &#123;</span><br><span class="line">        &quot;speed&quot;: &#123;</span><br><span class="line">          &quot;channel&quot;: 1,</span><br><span class="line">          &quot;bytes&quot;: 0</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大数据学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sqoop学习小结</title>
      <link href="/2021/10/19/Sqoop%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
      <url>/2021/10/19/Sqoop%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Sqoop学习小结"><a href="#Sqoop学习小结" class="headerlink" title="Sqoop学习小结"></a>Sqoop学习小结</h1><h2 id="数据集成工具相关了解"><a href="#数据集成工具相关了解" class="headerlink" title="数据集成工具相关了解"></a>数据集成工具相关了解</h2><ul><li>离线采集(批量采集)<ul><li>Sqoop</li><li>DataX</li><li>Kettle</li></ul></li><li>实时采集(增量采集)<ul><li>Flume</li><li>Canal</li><li>OGG</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211019195157310.png" alt="image-20211019195157310"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211019195234423.png" alt="image-20211019195234423"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211019195342897.png" alt="image-20211019195342897"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211019195854447.png" alt="image-20211019195854447"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211019195936352.png" alt="image-20211019195936352"></p><h2 id="Sqoop简介"><a href="#Sqoop简介" class="headerlink" title="Sqoop简介"></a>Sqoop简介</h2><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211019200743491.png" alt="image-20211019200743491"></p><h2 id="Sqoop安装"><a href="#Sqoop安装" class="headerlink" title="Sqoop安装"></a>Sqoop安装</h2><h3 id="1、上传并解压"><a href="#1、上传并解压" class="headerlink" title="1、上传并解压"></a>1、上传并解压</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf sqoop-1.4.6.bin__hadoop-2.0.4.tar.gz -C /usr/local/soft/</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211019202332899.png" alt="image-20211019202332899"></p><h3 id="2、修改文件夹名字"><a href="#2、修改文件夹名字" class="headerlink" title="2、修改文件夹名字"></a>2、修改文件夹名字</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv sqoop-1.4.6.bin__hadoop-2.6.0/ sqoop-1.4.6</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211019202435163.png" alt="image-20211019202435163"></p><h3 id="3、修改配置文件"><a href="#3、修改配置文件" class="headerlink" title="3、修改配置文件"></a>3、修改配置文件</h3><h4 id="切换到sqoop配置文件目录"><a href="#切换到sqoop配置文件目录" class="headerlink" title="切换到sqoop配置文件目录"></a>切换到sqoop配置文件目录</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/soft/sqoop-1.4.6/conf</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211019203939613.png" alt="image-20211019203939613"></p><h4 id="复制配置文件并重命名"><a href="#复制配置文件并重命名" class="headerlink" title="复制配置文件并重命名"></a>复制配置文件并重命名</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp sqoop-env-template.sh sqoop-env.sh</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211019204031672.png" alt="image-20211019204031672"></p><h4 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim sqoop-env.sh</span><br><span class="line"></span><br><span class="line">export HADOOP_COMMON_HOME=/usr/local/soft/hadoop-2.7.6</span><br><span class="line">export HADOOP_MAPRED_HOME=/usr/local/soft/hadoop-2.7.6/share/hadoop/mapreduce</span><br><span class="line">export HBASE_HOME=/usr/local/soft/hbase-1.4.6</span><br><span class="line">export HIVE_HOME=/usr/local/soft/hive-1.2.1</span><br><span class="line">export ZOOCFGDIR=/usr/local/soft/zookeeper-3.4.6/conf</span><br><span class="line">export ZOOKEEPER_HOME=/usr/local/soft/zookeeper-3.4.6</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211019204238696.png" alt="image-20211019204238696"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211019204418535.png" alt="image-20211019204418535"></p><p>此时可以很直观的看到sqoop已经配置成功。但是上面还会有两个警告，我们来消除一下。</p><h4 id="切换到bin目录"><a href="#切换到bin目录" class="headerlink" title="切换到bin目录"></a>切换到bin目录</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/soft/sqoop-1.4.6/bin</span><br></pre></td></tr></table></figure><h4 id="修改配置文件，注释掉没用的内容（就是为了去掉警告信息）"><a href="#修改配置文件，注释掉没用的内容（就是为了去掉警告信息）" class="headerlink" title="修改配置文件，注释掉没用的内容（就是为了去掉警告信息）"></a>修改配置文件，注释掉没用的内容（就是为了去掉警告信息）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim configure-sqoop</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211019204853630.png" alt="image-20211019204853630"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211019204916864.png" alt="image-20211019204916864"></p><p>可以看到警告已经去除。</p><h3 id="4、修改环境变量-将sqoop的目录加入环境变量"><a href="#4、修改环境变量-将sqoop的目录加入环境变量" class="headerlink" title="4、修改环境变量,将sqoop的目录加入环境变量"></a>4、修改环境变量,将sqoop的目录加入环境变量</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211019205225045.png" alt="image-20211019205225045"></p><h3 id="5、添加MySQL连接驱动"><a href="#5、添加MySQL连接驱动" class="headerlink" title="5、添加MySQL连接驱动"></a>5、添加MySQL连接驱动</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 从HIVE中复制MySQL连接驱动到$SQOOP_HOME/lib</span><br><span class="line">cp /usr/local/soft/hive-1.2.1/lib/mysql-connector-java-5.1.49.jar /usr/local/soft/sqoop-1.4.6/lib/</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211019205437365.png" alt="image-20211019205437365"></p><h3 id="6、测试"><a href="#6、测试" class="headerlink" title="6、测试"></a>6、测试</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 打印sqoop版本</span><br><span class="line">sqoop version</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211019205511639.png" alt="image-20211019205511639"></p><h4 id="测试MySQL连通性"><a href="#测试MySQL连通性" class="headerlink" title="测试MySQL连通性"></a>测试MySQL连通性</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqoop list-databases -connect jdbc:mysql://master:3306?useSSL=false -username root -password 123456</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211019205559601.png" alt="image-20211019205559601"></p><p>至此，sqoop已经搭建成功。</p><h2 id="Sqoop学习"><a href="#Sqoop学习" class="headerlink" title="Sqoop学习"></a>Sqoop学习</h2><h3 id="准备MySQL数据"><a href="#准备MySQL数据" class="headerlink" title="准备MySQL数据"></a>准备MySQL数据</h3><h4 id="登录MySQL数据库"><a href="#登录MySQL数据库" class="headerlink" title="登录MySQL数据库"></a>登录MySQL数据库</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u root -p123456;</span><br></pre></td></tr></table></figure><h4 id="创建student数据库"><a href="#创建student数据库" class="headerlink" title="创建student数据库"></a>创建student数据库</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database student;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211019205900319.png" alt="image-20211019205900319"></p><h4 id="切换数据库并导入数据"><a href="#切换数据库并导入数据" class="headerlink" title="切换数据库并导入数据"></a>切换数据库并导入数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mysql shell中执行 两张表的数据我放在了GitHub上面。</span><br><span class="line">use student;</span><br><span class="line">source /usr/local/data/student.sql;</span><br><span class="line">source /usr/local/data/score.sql;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211019210146280.png" alt="image-20211019210146280"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211019210332366.png" alt="image-20211019210332366"></p><h4 id="另外一种导入数据的方式"><a href="#另外一种导入数据的方式" class="headerlink" title="另外一种导入数据的方式"></a>另外一种导入数据的方式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># linux shell中执行</span><br><span class="line">mysql -u root -p123456 student&lt;/usr/local/data/student.sql</span><br><span class="line">mysql -u root -p123456 student&lt;/usr/local/data/score.sql</span><br></pre></td></tr></table></figure><h4 id="使用Navicat运行SQL文件"><a href="#使用Navicat运行SQL文件" class="headerlink" title="使用Navicat运行SQL文件"></a>使用Navicat运行SQL文件</h4><blockquote><p>也可以通过Navicat导入</p></blockquote><h4 id="导出MySQL数据库"><a href="#导出MySQL数据库" class="headerlink" title="导出MySQL数据库"></a>导出MySQL数据库</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqldump -u root -p123456 数据库名&gt;任意一个文件名.sql</span><br></pre></td></tr></table></figure><hr><h3 id="Sqoop-import"><a href="#Sqoop-import" class="headerlink" title="Sqoop import"></a>Sqoop import</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211019221009012.png" alt="image-20211019221009012"></p><blockquote><p>从传统的关系型数据库导入HDFS、HIVE、HBASE……</p></blockquote><p><strong>在sqoop下面创建一个文件夹，以后的脚本都会放在里面。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211019212030085.png" alt="image-20211019212030085"></p><h4 id="MySQLToHDFS"><a href="#MySQLToHDFS" class="headerlink" title="MySQLToHDFS"></a>MySQLToHDFS</h4><h5 id="编写脚本，保存为MySQLToHDFS-conf"><a href="#编写脚本，保存为MySQLToHDFS-conf" class="headerlink" title="编写脚本，保存为MySQLToHDFS.conf"></a>编写脚本，保存为MySQLToHDFS.conf</h5><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211019212253510.png" alt="image-20211019212253510"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import</span><br><span class="line">--connect</span><br><span class="line">jdbc:mysql://master:3306/student?useSSL=false&amp;characterEncoding=UTF-8</span><br><span class="line">--username</span><br><span class="line">root</span><br><span class="line">--password</span><br><span class="line">123456</span><br><span class="line">--table</span><br><span class="line">student</span><br><span class="line">--m</span><br><span class="line">2</span><br><span class="line">--split-by</span><br><span class="line">age</span><br><span class="line">--target-dir</span><br><span class="line">/sqoop/data/student1</span><br><span class="line">--fields-terminated-by</span><br><span class="line">&#x27;,&#x27;</span><br><span class="line">--direct</span><br><span class="line"># 说明  --direct可加可不加</span><br><span class="line">首先说明是导入数据 import</span><br><span class="line">接下来就是指定用户名，密码，连接的表</span><br><span class="line">--m中的m即map，参数2。表示有2个map</span><br><span class="line">--split-by切割，参数age。表示数据指定以age作为切割</span><br><span class="line">--target-dir目录，表示指定以xx为存储数据的路径。数据最终会放在HDFS上。即指定HDFS路径</span><br><span class="line">--fields-terminated-by，表示以xx做为划分。</span><br><span class="line">--direct。可以使得这个更快运行。This transfer can be faster! Use the --direct</span><br></pre></td></tr></table></figure><h5 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqoop --options-file MySQLToHDFS.conf</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211019213516341.png" alt="image-20211019213516341"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211019213630001.png" alt="image-20211019213630001"></p><p>可以很清楚的看到Mysql中的数据已经上传成功了。</p><h5 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h5><p>1、–m 表示指定生成多少个Map任务，不是越多越好，因为MySQL Server的承载能力有限</p><p>2、当指定的Map任务数&gt;1，那么需要结合<code>--split-by</code>参数，指定分割键，以确定每个map任务到底读取哪一部分数据，最好指定数值型的列，最好指定主键（或者分布均匀的列=&gt;避免每个map任务处理的数据量差别过大）</p><p>3、如果指定的分割键数据分布不均，可能导致数据倾斜问题</p><p>4、分割的键最好指定数值型的，而且字段的类型为int、bigint这样的数值型</p><p>5、编写脚本的时候，注意：例如：<code>--username</code>参数，参数值不能和参数名同一行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--username root  // 错误的</span><br><span class="line"></span><br><span class="line">// 应该分成两行</span><br><span class="line">--username</span><br><span class="line">root</span><br></pre></td></tr></table></figure><p>6、运行的时候会报错<strong>InterruptedException</strong>，hadoop2.7.6自带的问题，忽略即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">21/01/25 14:32:32 WARN hdfs.DFSClient: Caught exception </span><br><span class="line">java.lang.InterruptedException</span><br><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line">at java.lang.Thread.join(Thread.java:1252)</span><br><span class="line">at java.lang.Thread.join(Thread.java:1326)</span><br><span class="line">at org.apache.hadoop.hdfs.DFSOutputStream$DataStreamer.closeResponder(DFSOutputStream.java:716)</span><br><span class="line">at org.apache.hadoop.hdfs.DFSOutputStream$DataStreamer.endBlock(DFSOutputStream.java:476)</span><br><span class="line">at org.apache.hadoop.hdfs.DFSOutputStream$DataStreamer.run(DFSOutputStream.java:652)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>7、实际上sqoop在读取mysql数据的时候，用的是JDBC的方式，所以当数据量大的时候，效率不是很高</p><p>8、sqoop底层通过MapReduce完成数据导入导出，只需要Map任务，不需要Reduce任务</p><p>9、每个Map任务会生成一个文件</p><h4 id="MySQLToHive"><a href="#MySQLToHive" class="headerlink" title="MySQLToHive"></a>MySQLToHive</h4><blockquote><p>先会将MySQL的数据导出来并在HDFS上找个目录临时存放，默认为：/user/用户名/表名</p><p>然后再将数据加载到Hive中，加载完成后，会将临时存放的目录删除</p></blockquote><h5 id="编写脚本，并保存为MySQLToHIVE-conf文件"><a href="#编写脚本，并保存为MySQLToHIVE-conf文件" class="headerlink" title="编写脚本，并保存为MySQLToHIVE.conf文件"></a>编写脚本，并保存为MySQLToHIVE.conf文件</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import </span><br><span class="line">--connect</span><br><span class="line">jdbc:mysql://master:3306/student?useSSL=false</span><br><span class="line">--username</span><br><span class="line">root</span><br><span class="line">--password</span><br><span class="line">123456</span><br><span class="line">--table</span><br><span class="line">score</span><br><span class="line">--fields-terminated-by</span><br><span class="line">&quot;\t&quot;</span><br><span class="line">--lines-terminated-by </span><br><span class="line">&quot;\n&quot;</span><br><span class="line">--m</span><br><span class="line">3</span><br><span class="line">--split-by</span><br><span class="line">student_id</span><br><span class="line">--hive-import</span><br><span class="line">--hive-overwrite</span><br><span class="line">--create-hive-table</span><br><span class="line">--hive-database</span><br><span class="line">testsqoop</span><br><span class="line">--hive-table</span><br><span class="line">score</span><br><span class="line">--delete-target-dir</span><br><span class="line"></span><br><span class="line"># 说明</span><br><span class="line">--hive-import 表示导hive的表</span><br><span class="line">--create-hive-table 表示创建hive的表</span><br><span class="line">--hive-database 参数testsqoop 表示选择导入到hive的哪一个数据库中，参数表示表名table_name</span><br></pre></td></tr></table></figure><h5 id="在Hive中创建testsqoop库"><a href="#在Hive中创建testsqoop库" class="headerlink" title="在Hive中创建testsqoop库"></a>在Hive中创建testsqoop库</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database testsqoop;</span><br></pre></td></tr></table></figure><h5 id="将HADOOP-CLASSPATH加入环境变量中"><a href="#将HADOOP-CLASSPATH加入环境变量中" class="headerlink" title="将HADOOP_CLASSPATH加入环境变量中"></a>将HADOOP_CLASSPATH加入环境变量中</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"># 加入如下内容</span><br><span class="line">export HADOOP_CLASSPATH=$HADOOP_HOME/lib:$HIVE_HOME/lib/*</span><br><span class="line"></span><br><span class="line"># 重新加载环境变量</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h5 id="将hive-site-xml放入SQOOP-HOME-conf"><a href="#将hive-site-xml放入SQOOP-HOME-conf" class="headerlink" title="将hive-site.xml放入SQOOP_HOME/conf/"></a>将hive-site.xml放入SQOOP_HOME/conf/</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp /usr/local/soft/hive-1.2.1/conf/hive-site.xml /usr/local/soft/sqoop-1.4.6/conf/</span><br></pre></td></tr></table></figure><h5 id="执行脚本-1"><a href="#执行脚本-1" class="headerlink" title="执行脚本"></a>执行脚本</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqoop --options-file MySQLToHIVE.conf</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211019223210901.png" alt="image-20211019223210901"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211019223414971.png" alt="image-20211019223414971"></p><p>可以很清楚的看到数据已经导入到hive中了。</p><h5 id="–direct"><a href="#–direct" class="headerlink" title="–direct"></a>–direct</h5><blockquote><p>加上这个参数，可以在导出MySQL数据的时候，使用MySQL提供的导出工具mysqldump，加快导出速度，提高效率</p></blockquote><p>需要将master上的/usr/bin/mysqldump分发至 node1、node2的/usr/bin目录下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp /usr/bin/mysqldump node1:/usr/bin/</span><br><span class="line">scp /usr/bin/mysqldump node2:/usr/bin/</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211019220853587.png" alt="image-20211019220853587"></p><h5 id="e参数的使用-execute执行"><a href="#e参数的使用-execute执行" class="headerlink" title="-e参数的使用(execute执行)"></a>-e参数的使用(execute执行)</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import </span><br><span class="line">--connect </span><br><span class="line">jdbc:mysql://master:3306/student </span><br><span class="line">--username </span><br><span class="line">root </span><br><span class="line">--password </span><br><span class="line">123456 </span><br><span class="line">--fields-terminated-by </span><br><span class="line">&quot;\t&quot; </span><br><span class="line">--lines-terminated-by </span><br><span class="line">&quot;\n&quot; </span><br><span class="line">--m </span><br><span class="line">2 </span><br><span class="line">--split-by </span><br><span class="line">student_id </span><br><span class="line">--e </span><br><span class="line">&quot;select * from score where student_id=1500100011 and $CONDITIONS&quot; </span><br><span class="line">--target-dir </span><br><span class="line">/testQ </span><br><span class="line">--hive-import </span><br><span class="line">--hive-overwrite </span><br><span class="line">--create-hive-table </span><br><span class="line">--hive-database </span><br><span class="line">testsqoop </span><br><span class="line">--hive-table </span><br><span class="line">score2</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211019224618368.png" alt="image-20211019224618368"></p><h4 id="MySQLTOHBase"><a href="#MySQLTOHBase" class="headerlink" title="MySQLTOHBase"></a>MySQLTOHBase</h4><h5 id="编写脚本，并保存为MySQLToHBase-conf"><a href="#编写脚本，并保存为MySQLToHBase-conf" class="headerlink" title="编写脚本，并保存为MySQLToHBase.conf"></a>编写脚本，并保存为MySQLToHBase.conf</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import </span><br><span class="line">--connect </span><br><span class="line">jdbc:mysql://master:3306/student?useSSL=false</span><br><span class="line">--username </span><br><span class="line">root </span><br><span class="line">--password </span><br><span class="line">123456</span><br><span class="line">--table </span><br><span class="line">student</span><br><span class="line">--hbase-table </span><br><span class="line">student</span><br><span class="line">--hbase-create-table</span><br><span class="line">--hbase-row-key </span><br><span class="line">id </span><br><span class="line">--m </span><br><span class="line">1</span><br><span class="line">--column-family </span><br><span class="line">cf1</span><br></pre></td></tr></table></figure><h5 id="在HBase中创建student表"><a href="#在HBase中创建student表" class="headerlink" title="在HBase中创建student表"></a>在HBase中创建student表</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create &#x27;student&#x27;,&#x27;cf1&#x27;</span><br></pre></td></tr></table></figure><h5 id="执行脚本-2"><a href="#执行脚本-2" class="headerlink" title="执行脚本"></a>执行脚本</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqoop --options-file MySQLToHBase.conf</span><br></pre></td></tr></table></figure><h3 id="Sqoop-export"><a href="#Sqoop-export" class="headerlink" title="Sqoop export"></a>Sqoop export</h3><h4 id="HDFSToMySQL"><a href="#HDFSToMySQL" class="headerlink" title="HDFSToMySQL"></a>HDFSToMySQL</h4><h5 id="编写脚本，并保存为HDFSToMySQL-conf"><a href="#编写脚本，并保存为HDFSToMySQL-conf" class="headerlink" title="编写脚本，并保存为HDFSToMySQL.conf"></a>编写脚本，并保存为HDFSToMySQL.conf</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export</span><br><span class="line">--connect</span><br><span class="line">jdbc:mysql://master:3306/student?useSSL=false</span><br><span class="line">--username</span><br><span class="line">root</span><br><span class="line">--password</span><br><span class="line">123456</span><br><span class="line">--table</span><br><span class="line">student</span><br><span class="line">-m</span><br><span class="line">1</span><br><span class="line">--columns</span><br><span class="line">id,name,age,gender,clazz</span><br><span class="line">--export-dir</span><br><span class="line">/sqoop/data/student1/</span><br><span class="line">--fields-terminated-by </span><br><span class="line">&#x27;,&#x27;</span><br></pre></td></tr></table></figure><h5 id="先清空MySQL-student表中的数据，不然会造成主键冲突"><a href="#先清空MySQL-student表中的数据，不然会造成主键冲突" class="headerlink" title="先清空MySQL student表中的数据，不然会造成主键冲突"></a>先清空MySQL student表中的数据，不然会造成主键冲突</h5><h5 id="执行脚本-3"><a href="#执行脚本-3" class="headerlink" title="执行脚本"></a>执行脚本</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqoop --options-file HDFSToMySQL.conf</span><br></pre></td></tr></table></figure><h5 id="查看sqoop-help"><a href="#查看sqoop-help" class="headerlink" title="查看sqoop help"></a>查看sqoop help</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqoop help</span><br><span class="line"></span><br><span class="line">21/04/26 15:50:36 INFO sqoop.Sqoop: Running Sqoop version: 1.4.6</span><br><span class="line">usage: sqoop COMMAND [ARGS]</span><br><span class="line"></span><br><span class="line">Available commands:</span><br><span class="line">  codegen            Generate code to interact with database records</span><br><span class="line">  create-hive-table  Import a table definition into Hive</span><br><span class="line">  eval               Evaluate a SQL statement and display the results</span><br><span class="line">  export             Export an HDFS directory to a database table</span><br><span class="line">  help               List available commands</span><br><span class="line">  import             Import a table from a database to HDFS</span><br><span class="line">  import-all-tables  Import tables from a database to HDFS</span><br><span class="line">  import-mainframe   Import datasets from a mainframe server to HDFS</span><br><span class="line">  job                Work with saved jobs</span><br><span class="line">  list-databases     List available databases on a server</span><br><span class="line">  list-tables        List available tables in a database</span><br><span class="line">  merge              Merge results of incremental imports</span><br><span class="line">  metastore          Run a standalone Sqoop metastore</span><br><span class="line">  version            Display version information</span><br><span class="line"></span><br><span class="line">See &#x27;sqoop help COMMAND&#x27; for information on a specific command.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看import的详细帮助</span><br><span class="line">sqoop import --help</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大数据学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HBase的RowKey设计</title>
      <link href="/2021/10/18/HBase%E7%9A%84RowKeyy%E8%AE%BE%E8%AE%A1/"/>
      <url>/2021/10/18/HBase%E7%9A%84RowKeyy%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="HBase的RowKey设计"><a href="#HBase的RowKey设计" class="headerlink" title="HBase的RowKey设计"></a>HBase的RowKey设计</h1><p>HBase是三维有序存储的，通过rowkey（行键），column key（column family和qualifier）和TimeStamp（时间戳）这个三个维度可以对HBase中的数据进行快速定位。</p><p>HBase中rowkey可以唯一标识一行记录，在HBase查询的时候，有三种方式：</p><ol><li><p>通过get方式，指定rowkey获取唯一一条记录</p></li><li><p>通过scan方式，设置startRow和stopRow参数进行范围匹配</p></li><li><p>全表扫描，即直接扫描整张表中所有行记录</p></li></ol><h2 id="rowkey长度原则"><a href="#rowkey长度原则" class="headerlink" title="rowkey长度原则"></a>rowkey长度原则</h2><p>rowkey是一个二进制码流，可以是任意字符串，最大长度 <em>64kb</em> ，实际应用中一般为10-100bytes，以 byte[] 形式保存，一般设计成定长。</p><p>建议越短越好，不要超过16个字节，原因如下：</p><p>数据的持久化文件HFile中是按照KeyValue存储的，如果rowkey过长，比如超过100字节，1000w行数据，光rowkey就要占用100*1000w=10亿个字节，将近1G数据，这样会极大影响HFile的存储效率；</p><p>MemStore将缓存部分数据到内存，如果rowkey字段过长，内存的有效利用率就会降低，系统不能缓存更多的数据，这样会降低检索效率。</p><h2 id="rowkey散列原则"><a href="#rowkey散列原则" class="headerlink" title="rowkey散列原则"></a>rowkey散列原则</h2><p>如果rowkey按照时间戳的方式递增，不要将时间放在二进制码的前面，建议将rowkey的高位作为散列字段，由程序随机生成，低位放时间字段，这样将提高数据均衡分布在每个RegionServer，以实现负载均衡的几率。如果没有散列字段，首字段直接是时间信息，所有的数据都会集中在一个RegionServer上，这样在数据检索的时候负载会集中在个别的RegionServer上，造成热点问题，会降低查询效率。</p><h2 id="rowkey唯一原则"><a href="#rowkey唯一原则" class="headerlink" title="rowkey唯一原则"></a>rowkey唯一原则</h2><p>必须在设计上保证其唯一性，rowkey是按照字典顺序排序存储的，因此，设计rowkey的时候，要充分利用这个排序的特点，将经常读取的数据存储到一块，将最近可能会被访问的数据放到一块。</p><h2 id="热点问题"><a href="#热点问题" class="headerlink" title="热点问题"></a>热点问题</h2><p>HBase中的行是按照rowkey的字典顺序排序的，这种设计优化了scan操作，可以将相关的行以及会被一起读取的行存取在临近位置，便于scan。然而糟糕的rowkey设计是热点的源头。 热点发生在大量的client直接访问集群的一个或极少数个节点（访问可能是读，写或者其他操作）。大量访问会使热点region所在的单个机器超出自身承受能力，引起性能下降甚至region不可用，这也会影响同一个RegionServer上的其他region，由于主机无法服务其他region的请求。 设计良好的数据访问模式以使集群被充分，均衡的利用。</p><p>为了避免写热点，设计rowkey使得不同行在同一个region，但是在更多数据情况下，数据应该被写入集群的多个region，而不是一个。</p><p>下面是一些常见的避免热点的方法以及它们的优缺点：</p><h3 id="加盐"><a href="#加盐" class="headerlink" title="加盐"></a>加盐</h3><p>这里所说的加盐不是密码学中的加盐，而是在rowkey的前面增加随机数，具体就是给rowkey分配一个随机前缀以使得它和之前的rowkey的开头不同。分配的前缀种类数量应该和你想使用数据分散到不同的region的数量一致。加盐之后的rowkey就会根据随机生成的前缀分散到各个region上，以避免热点。</p><h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><p>哈希会使同一行永远用一个前缀加盐。哈希也可以使负载分散到整个集群，但是读却是可以预测的。使用确定的哈希可以让客户端重构完整的rowkey，可以使用get操作准确获取某一个行数据</p><h3 id="反转"><a href="#反转" class="headerlink" title="反转"></a>反转</h3><p>第三种防止热点的方法时反转固定长度或者数字格式的rowkey。这样可以使得rowkey中经常改变的部分（最没有意义的部分）放在前面。这样可以有效的随机rowkey，但是牺牲了rowkey的有序性。</p><p>反转rowkey的例子以手机号为rowkey，可以将手机号反转后的字符串作为rowkey，这样的就避免了以手机号那样比较固定开头导致热点问题</p><h3 id="时间戳反转"><a href="#时间戳反转" class="headerlink" title="时间戳反转"></a>时间戳反转</h3><p>一个常见的数据处理问题是快速获取数据的最近版本，使用反转的时间戳作为rowkey的一部分对这个问题十分有用，可以用 Long.Max_Value - timestamp 追加到key的末尾，例如[key][reverse_timestamp] , [key] 的最新值可以通过scan [key]获得[key]的第一条记录，因为HBase中rowkey是有序的，第一条记录是最后录入的数据。</p><p>比如需要保存一个用户的操作记录，按照操作时间倒序排序，在设计rowkey的时候，可以这样设计</p><p>[userId反转][Long.Max_Value - timestamp]，在查询用户的所有操作记录数据的时候，直接指定反转后的userId，startRow是[userId反转][000000000000],stopRow是[userId反转][Long.Max_Value - timestamp]</p><p>如果需要查询某段时间的操作记录，startRow是[user反转][Long.Max_Value - 起始时间]，stopRow是[userId反转][Long.Max_Value - 结束时间]</p><h2 id="其他一些建议"><a href="#其他一些建议" class="headerlink" title="其他一些建议"></a>其他一些建议</h2><p>尽量减少rowkey和列的大小，当具体的值在系统间传输时，它的rowkey，列簇、列名，时间戳也会一起传输。如果你的rowkey、列簇名、列名很大，甚至可以和具体的值相比较，那么将会造成大量的冗余，不利于数据的储存与传输</p><p>列族尽可能越短越好，最好是一个字符</p><p>列名也尽可能越短越好，冗长的列名虽然可读性好，但是更短的列名存储在HBase中会更好</p>]]></content>
      
      
      <categories>
          
          <category> 大数据学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Phoenix学习小结</title>
      <link href="/2021/10/14/Phoenix%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
      <url>/2021/10/14/Phoenix%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Phoenix"><a href="#Phoenix" class="headerlink" title="Phoenix"></a>Phoenix</h1><blockquote><p>Hbase适合存储大量的对关系运算要求低的NOSQL数据，受Hbase 设计上的限制不能直接使用原生的API执行在关系数据库中普遍使用的条件判断和聚合等操作。Hbase很优秀，一些团队寻求在Hbase之上提供一种更面向普通开发人员的操作方式，Apache Phoenix即是。</p></blockquote><blockquote><p>Phoenix 基于Hbase给面向业务的开发人员提供了以标准SQL的方式对Hbase进行查询操作，并支持标准SQL中大部分特性:条件运算,分组，分页，等高级查询语法。</p></blockquote><h2 id="Phoenix搭建"><a href="#Phoenix搭建" class="headerlink" title="Phoenix搭建"></a>Phoenix搭建</h2><p>Phoenix 4.15  HBase 1.4.6 hadoop 2.7.6</p><h3 id="关闭hbase集群，在master中执行"><a href="#关闭hbase集群，在master中执行" class="headerlink" title="关闭hbase集群，在master中执行"></a>关闭hbase集群，在master中执行</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">stop-hbase.sh</span><br></pre></td></tr></table></figure><h3 id="上传解压配置环境变量"><a href="#上传解压配置环境变量" class="headerlink" title="上传解压配置环境变量"></a>上传解压配置环境变量</h3><p><strong>解压</strong></p><p><code>tar -zxvf apache-phoenix-4.15.0-HBase-1.4-bin.tar.gz -C /usr/local/soft/</code></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211014224844961.png" alt="image-20211014224844961"></p><p><strong>改名</strong></p><p><code>mv apache-phoenix-4.15.0-HBase-1.4-bin phoenix-4.15.0</code></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211014230324217.png" alt="image-20211014230324217"></p><h3 id="将phoenix-4-15-0-HBase-1-4-server-jar复制到所有节点的hbase-lib目录下"><a href="#将phoenix-4-15-0-HBase-1-4-server-jar复制到所有节点的hbase-lib目录下" class="headerlink" title="将phoenix-4.15.0-HBase-1.4-server.jar复制到所有节点的hbase lib目录下"></a>将phoenix-4.15.0-HBase-1.4-server.jar复制到所有节点的hbase lib目录下</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211014231845929.png" alt="image-20211014231845929"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp /usr/local/soft/phoenix-4.15.0/phoenix-4.15.0-HBase-1.4-server.jar master:/usr/local/soft/hbase-1.4.6/lib/</span><br><span class="line"></span><br><span class="line">scp /usr/local/soft/phoenix-4.15.0/phoenix-4.15.0-HBase-1.4-server.jar node1:/usr/local/soft/hbase-1.4.6/lib/</span><br><span class="line"></span><br><span class="line">scp /usr/local/soft/phoenix-4.15.0/phoenix-4.15.0-HBase-1.4-server.jar node2:/usr/local/soft/hbase-1.4.6/lib/</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="启动hbase-，-在master中执行"><a href="#启动hbase-，-在master中执行" class="headerlink" title="启动hbase ， 在master中执行"></a>启动hbase ， 在master中执行</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start-hbase.sh</span><br></pre></td></tr></table></figure><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211014231739911.png" alt="image-20211014231739911"></p><h2 id="Phoenix使用"><a href="#Phoenix使用" class="headerlink" title="Phoenix使用"></a>Phoenix使用</h2><h3 id="连接sqlline"><a href="#连接sqlline" class="headerlink" title="连接sqlline"></a>连接sqlline</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sqlline.py master,node1,node2</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 出现</span></span><br><span class="line">163/163 (100%) Done</span><br><span class="line">Done</span><br><span class="line">sqlline version 1.5.0</span><br><span class="line">0: jdbc:phoenix:master,node1,node2&gt; </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211017095529858.png" alt="image-20211017095529858"></p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="显示所有表"><a href="#显示所有表" class="headerlink" title="显示所有表"></a>显示所有表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">!</span><span class="keyword">table</span></span><br></pre></td></tr></table></figure><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> STUDENT (</span><br><span class="line"> id <span class="type">VARCHAR</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY, </span><br><span class="line"> name <span class="type">VARCHAR</span>,</span><br><span class="line"> age <span class="type">BIGINT</span>, </span><br><span class="line"> gender <span class="type">VARCHAR</span> ,</span><br><span class="line"> clazz <span class="type">VARCHAR</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211017100035490.png" alt="image-20211017100035490"></p><h4 id="往表中插入数据"><a href="#往表中插入数据" class="headerlink" title="往表中插入数据"></a>往表中插入数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">upsert <span class="keyword">into</span> STUDENT <span class="keyword">values</span>(<span class="string">&#x27;1500100004&#x27;</span>,<span class="string">&#x27;葛德曜&#x27;</span>,<span class="number">24</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;理科三班&#x27;</span>);</span><br><span class="line">upsert <span class="keyword">into</span> STUDENT <span class="keyword">values</span>(<span class="string">&#x27;1500100005&#x27;</span>,<span class="string">&#x27;宣谷芹&#x27;</span>,<span class="number">24</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;理科六班&#x27;</span>);</span><br><span class="line">upsert <span class="keyword">into</span> STUDENT <span class="keyword">values</span>(<span class="string">&#x27;1500100006&#x27;</span>,<span class="string">&#x27;羿彦昌&#x27;</span>,<span class="number">24</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;理科三班&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="查询数据，支持大部分sql语法"><a href="#查询数据，支持大部分sql语法" class="headerlink" title="查询数据，支持大部分sql语法"></a>查询数据，支持大部分sql语法</h4><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211017100303054.png" alt="image-20211017100303054"></p><p><strong>实际上本质就是scan+filter。扫描+过滤器。</strong></p><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> table_name 条件;</span><br></pre></td></tr></table></figure><h4 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> table_name;</span><br></pre></td></tr></table></figure><h4 id="退出命令行"><a href="#退出命令行" class="headerlink" title="退出命令行"></a>退出命令行</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">!</span>quit</span><br></pre></td></tr></table></figure><p>更多语法参照官网<br><a href="https://phoenix.apache.org/language/index.html#upsert_select">https://phoenix.apache.org/language/index.html#upsert_select</a></p><h3 id="phoenix表映射"><a href="#phoenix表映射" class="headerlink" title="phoenix表映射"></a>phoenix表映射</h3><blockquote><p> 默认情况下，直接在hbase中创建的表，通过phoenix是查看不到的</p></blockquote><blockquote><p>如果需要在phoenix中操作直接在hbase中创建的表，则需要在phoenix中进行表的映射。映射方式有两种：视图映射和表映射</p></blockquote><h4 id="视图映射"><a href="#视图映射" class="headerlink" title="视图映射"></a>视图映射</h4><blockquote><p> Phoenix创建的视图是只读的，所以只能用来做查询，无法通过视图对源数据进行修改等操作</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># hbase shell 进入hbase命令行</span><br><span class="line">hbase shell </span><br><span class="line"></span><br><span class="line"># 创建hbase表</span><br><span class="line"><span class="keyword">create</span> <span class="string">&#x27;test&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;company&#x27;</span> </span><br><span class="line"></span><br><span class="line"># 插入数据</span><br><span class="line">put <span class="string">&#x27;test&#x27;</span>,<span class="string">&#x27;001&#x27;</span>,<span class="string">&#x27;name:firstname&#x27;</span>,<span class="string">&#x27;zhangsan1&#x27;</span></span><br><span class="line">put <span class="string">&#x27;test&#x27;</span>,<span class="string">&#x27;001&#x27;</span>,<span class="string">&#x27;name:lastname&#x27;</span>,<span class="string">&#x27;zhangsan2&#x27;</span></span><br><span class="line">put <span class="string">&#x27;test&#x27;</span>,<span class="string">&#x27;001&#x27;</span>,<span class="string">&#x27;company:name&#x27;</span>,<span class="string">&#x27;lisi1&#x27;</span></span><br><span class="line">put <span class="string">&#x27;test&#x27;</span>,<span class="string">&#x27;001&#x27;</span>,<span class="string">&#x27;company:address&#x27;</span>,<span class="string">&#x27;lisi2&#x27;</span></span><br><span class="line"></span><br><span class="line"># 在phoenix创建视图， <span class="keyword">primary</span> key 对应到hbase中的rowkey</span><br><span class="line"># 创建的<span class="keyword">view</span>的名字得和之前创建的表名一致，并且是&quot;&quot;，双引号。</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> &quot;test&quot;(</span><br><span class="line">empid <span class="type">varchar</span> <span class="keyword">primary</span> key,</span><br><span class="line">&quot;name&quot;.&quot;firstname&quot; <span class="type">varchar</span>,</span><br><span class="line">&quot;name&quot;.&quot;lastname&quot;  <span class="type">varchar</span>,</span><br><span class="line">&quot;company&quot;.&quot;name&quot;  <span class="type">varchar</span>,</span><br><span class="line">&quot;company&quot;.&quot;address&quot; <span class="type">varchar</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 在phoenix查询数据，表名通过双引号引起来</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> &quot;test&quot;;</span><br><span class="line"></span><br><span class="line"># 删除视图</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> &quot;test&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="表映射"><a href="#表映射" class="headerlink" title="表映射"></a>表映射</h4><p>使用Apache Phoenix创建对HBase的表映射，有两类：</p><p>1） 当HBase中已经存在表时，可以以类似创建视图的方式创建关联表，只需要将create view改为create table即可。</p><p>2）当HBase中不存在表时，可以直接使用create table指令创建需要的表，并且在创建指令中可以根据需要对HBase表结构进行显示的说明。</p><p>第1）种情况下，如在之前的基础上已经存在了test表，则表映射的语句如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> &quot;test&quot; (</span><br><span class="line">empid <span class="type">varchar</span> <span class="keyword">primary</span> key,</span><br><span class="line">&quot;name&quot;.&quot;firstname&quot; <span class="type">varchar</span>,</span><br><span class="line">&quot;name&quot;.&quot;lastname&quot;<span class="type">varchar</span>,</span><br><span class="line">&quot;company&quot;.&quot;name&quot;  <span class="type">varchar</span>,</span><br><span class="line">&quot;company&quot;.&quot;address&quot; <span class="type">varchar</span></span><br><span class="line">)column_encoded_bytes<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">upsert <span class="keyword">into</span>  &quot;test&quot;  <span class="keyword">values</span>(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>);</span><br></pre></td></tr></table></figure><p>使用create table创建的关联表，如果对表进行了修改，源数据也会改变，同时如果关联表被删除，源表也会被删除。但是视图就不会，如果删除视图，源数据不会发生改变。</p><h2 id="Phoenix二级索引"><a href="#Phoenix二级索引" class="headerlink" title="Phoenix二级索引"></a>Phoenix二级索引</h2><blockquote><p>对于Hbase，如果想精确定位到某行记录，唯一的办法就是通过rowkey查询。如果不通过rowkey查找数据，就必须逐行比较每一行的值，对于较大的表，全表扫描的代价是不可接受的。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211017170029629.png" alt="image-20211017170029629"></p><h3 id="开启索引支持"><a href="#开启索引支持" class="headerlink" title="开启索引支持"></a>开启索引支持</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># 关闭hbase集群</span><br><span class="line">stop-hbase.sh</span><br><span class="line"></span><br><span class="line"># 在/usr/local/soft/hbase-1.4.6/conf/hbase-site.xml中增加如下配置</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.regionserver.wal.codec<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.hbase.regionserver.wal.IndexedWALEditCodec<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rpc.timeout<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>60000000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.client.scanner.timeout.period<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>60000000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>phoenix.query.timeoutMs<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>60000000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 同步到所有节点</span><br><span class="line">scp hbase-site.xml node1:`pwd`</span><br><span class="line">scp hbase-site.xml node2:`pwd`</span><br><span class="line"></span><br><span class="line"># 修改phoenix目录下的bin目录中的hbase-site.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rpc.timeout<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>60000000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.client.scanner.timeout.period<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>60000000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>phoenix.query.timeoutMs<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>60000000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 启动hbase</span><br><span class="line">start-hbase.sh</span><br><span class="line"># 重新进入phoenix客户端</span><br><span class="line">sqlline.sql master,node1,node2</span><br></pre></td></tr></table></figure><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><h4 id="全局索引"><a href="#全局索引" class="headerlink" title="全局索引"></a>全局索引</h4><blockquote><p>全局索引适合读多写少的场景。如果使用全局索引，读数据基本不损耗性能，所有的性能损耗都来源于写数据。数据表的添加、删除和修改都会更新相关的索引表（数据删除了，索引表中的数据也会删除；数据增加了，索引表的数据也会增加）</p></blockquote><blockquote><p>注意: 对于全局索引在默认情况下，在查询语句中检索的列如果不在索引表中，Phoenix不会使用索引表将，除非使用hint。</p></blockquote><p>以下所有操作均在数据为DIANXIN下操作。</p><h5 id="创建DIANXIN-sql"><a href="#创建DIANXIN-sql" class="headerlink" title="创建DIANXIN.sql"></a>创建DIANXIN.sql</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 创建DIANXIN.sql</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> DIANXIN (</span><br><span class="line">     mdn <span class="type">VARCHAR</span> ,</span><br><span class="line">     start_date <span class="type">VARCHAR</span> ,</span><br><span class="line">     end_date <span class="type">VARCHAR</span> ,</span><br><span class="line">     county <span class="type">VARCHAR</span>,</span><br><span class="line">     x <span class="keyword">DOUBLE</span> ,</span><br><span class="line">     y  <span class="keyword">DOUBLE</span>,</span><br><span class="line">     bsid <span class="type">VARCHAR</span>,</span><br><span class="line">     grid_id  <span class="type">VARCHAR</span>,</span><br><span class="line">     biz_type <span class="type">VARCHAR</span>, </span><br><span class="line">     event_type <span class="type">VARCHAR</span> , </span><br><span class="line">     data_source <span class="type">VARCHAR</span> ,</span><br><span class="line">     <span class="keyword">CONSTRAINT</span> PK <span class="keyword">PRIMARY</span> KEY (mdn,start_date)</span><br><span class="line">) column_encoded_bytes<span class="operator">=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure><h5 id="上传数据"><a href="#上传数据" class="headerlink" title="上传数据"></a>上传数据</h5><p>通过xftp上传。DIANXIN.CSV</p><h5 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">psql.py master,node1,node2 DIANXIN.sql DIANXIN.csv</span><br></pre></td></tr></table></figure><h5 id="创建全局索引"><a href="#创建全局索引" class="headerlink" title="创建全局索引"></a>创建全局索引</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 创建全局索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX DIANXIN_INDEX <span class="keyword">ON</span> DIANXIN ( end_date );</span><br><span class="line"># 解释：<span class="keyword">CREATE</span> INDEX 名字 <span class="keyword">on</span> 表名 (指定的列)</span><br></pre></td></tr></table></figure><h5 id="查询数据-索引未生效"><a href="#查询数据-索引未生效" class="headerlink" title="查询数据 ( 索引未生效)"></a>查询数据 ( 索引未生效)</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> DIANXIN <span class="keyword">where</span> end_date <span class="operator">=</span> <span class="string">&#x27;20180503154014&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211017223654486.png" alt="image-20211017223654486"></p><h5 id="强制使用索引-（索引生效）-hint"><a href="#强制使用索引-（索引生效）-hint" class="headerlink" title="强制使用索引 （索引生效） hint"></a>强制使用索引 （索引生效） hint</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="comment">/*+ INDEX(DIANXIN DIANXIN_INDEX) */</span>  <span class="operator">*</span> <span class="keyword">from</span> DIANXIN <span class="keyword">where</span> end_date <span class="operator">=</span> <span class="string">&#x27;20180503154014&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211017223814636.png" alt="image-20211017223814636"></p><p>可以很直观地看到，当使用全局索引之后，查询时间为0.12，比起之前的时间大大缩短了。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 取索引列，（索引生效）</span><br><span class="line"><span class="keyword">select</span> end_date <span class="keyword">from</span> DIANXIN <span class="keyword">where</span> end_date <span class="operator">=</span> <span class="string">&#x27;20180503154014&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 创建多列索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX DIANXIN_INDEX1 <span class="keyword">ON</span> DIANXIN ( end_date,COUNTY );</span><br><span class="line"></span><br><span class="line"># 多条件查询 （索引生效）</span><br><span class="line"><span class="keyword">select</span> end_date,MDN,COUNTY <span class="keyword">from</span> DIANXIN <span class="keyword">where</span> end_date <span class="operator">=</span> <span class="string">&#x27;20180503154014&#x27;</span> <span class="keyword">and</span> COUNTY <span class="operator">=</span> <span class="string">&#x27;8340104&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 查询所有列 (索引未生效)</span><br><span class="line"><span class="keyword">select</span>  <span class="operator">*</span> <span class="keyword">from</span> DIANXIN <span class="keyword">where</span> end_date <span class="operator">=</span> <span class="string">&#x27;20180503154014&#x27;</span>  <span class="keyword">and</span> COUNTY <span class="operator">=</span> <span class="string">&#x27;8340104&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 查询所有列 （索引生效）</span><br><span class="line"><span class="keyword">select</span> <span class="comment">/*+ INDEX(DIANXIN DIANXIN_INDEX1) */</span> <span class="operator">*</span> <span class="keyword">from</span> DIANXIN <span class="keyword">where</span> end_date <span class="operator">=</span> <span class="string">&#x27;20180503154014&#x27;</span> <span class="keyword">and</span> COUNTY <span class="operator">=</span> <span class="string">&#x27;8340104&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 单条件  (索引未生效)</span><br><span class="line"><span class="keyword">select</span> end_date <span class="keyword">from</span> DIANXIN <span class="keyword">where</span>  COUNTY <span class="operator">=</span> <span class="string">&#x27;8340103&#x27;</span>;</span><br><span class="line"># 单条件  (索引生效) end_date在后</span><br><span class="line"><span class="keyword">select</span> COUNTY <span class="keyword">from</span> DIANXIN <span class="keyword">where</span> end_date <span class="operator">=</span> <span class="string">&#x27;20180503154014&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> index 你刚创建的索引 <span class="keyword">on</span> table_name;</span><br></pre></td></tr></table></figure><h4 id="本地索引"><a href="#本地索引" class="headerlink" title="本地索引"></a>本地索引</h4><blockquote><p>本地索引适合写多读少的场景，或者存储空间有限的场景。和全局索引一样，Phoenix也会在查询的时候自动选择是否使用本地索引。本地索引因为索引数据和原数据存储在同一台机器上，避免网络数据传输的开销，所以更适合写多的场景。由于无法提前确定数据在哪个Region上，所以在读数据的时候，需要检查每个Region上的数据从而带来一些性能损耗。</p></blockquote><blockquote><p>注意:对于本地索引，查询中无论是否指定hint或者是查询的列是否都在索引表中，都会使用索引表。</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 创建本地索引</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">LOCAL</span> INDEX DIANXIN_LOCAL_IDEX <span class="keyword">ON</span> DIANXIN(grid_id);</span><br><span class="line"># 注释：<span class="keyword">CREATE</span> <span class="keyword">LOCAL</span> INDEX 索引名称 <span class="keyword">ON</span> table_name(字段名);</span><br><span class="line"></span><br><span class="line"># 索引生效</span><br><span class="line"><span class="keyword">select</span> grid_id <span class="keyword">from</span> dianxin <span class="keyword">where</span> grid_id<span class="operator">=</span><span class="string">&#x27;117285031820040&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 索引生效</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dianxin <span class="keyword">where</span> grid_id<span class="operator">=</span><span class="string">&#x27;117285031820040&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211018195233850.png" alt="image-20211018195233850"></p><p>可以很直观的查看到，搜索出1000多条数据只花了零点几秒。</p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><blockquote><p>覆盖索引是把原数据存储在索引数据表中，这样在查询时不需要再去HBase的原表获取数据就，直接返回查询结果。</p></blockquote><blockquote><p>注意：查询是 select 的列和 where 的列都需要在索引中出现。</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 创建覆盖索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX DIANXIN_INDEX_COVER <span class="keyword">ON</span> DIANXIN ( x,y ) INCLUDE ( county );</span><br><span class="line"></span><br><span class="line"># 查询所有列 (索引未生效)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dianxin <span class="keyword">where</span> x<span class="operator">=</span><span class="number">117.288</span> <span class="keyword">and</span> y <span class="operator">=</span><span class="number">31.822</span>;</span><br><span class="line"></span><br><span class="line"># 强制使用索引 (索引生效)</span><br><span class="line"><span class="keyword">select</span> <span class="comment">/*+ INDEX(DIANXIN DIANXIN_INDEX_COVER) */</span> <span class="operator">*</span> <span class="keyword">from</span> dianxin <span class="keyword">where</span> x<span class="operator">=</span><span class="number">117.288</span> <span class="keyword">and</span> y <span class="operator">=</span><span class="number">31.822</span>;</span><br><span class="line"></span><br><span class="line"># 查询索引中的列 (索引生效) mdn是DIANXIN表的RowKey中的一部分</span><br><span class="line"><span class="keyword">select</span> x,y,county <span class="keyword">from</span> dianxin <span class="keyword">where</span> x<span class="operator">=</span><span class="number">117.288</span> <span class="keyword">and</span> y <span class="operator">=</span><span class="number">31.822</span>;</span><br><span class="line"><span class="keyword">select</span> mdn,x,y,county <span class="keyword">from</span> dianxin <span class="keyword">where</span> x<span class="operator">=</span><span class="number">117.288</span> <span class="keyword">and</span> y <span class="operator">=</span><span class="number">31.822</span>;</span><br><span class="line"></span><br><span class="line"># 查询条件必须放在索引中  <span class="keyword">select</span> 中的列可以放在INCLUDE （将数据保存在索引中）</span><br><span class="line"><span class="keyword">select</span> <span class="comment">/*+ INDEX(DIANXIN DIANXIN_INDEX_COVER) */</span> x,y,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> dianxin <span class="keyword">group</span> <span class="keyword">by</span> x,y;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Phoenix-JDBC"><a href="#Phoenix-JDBC" class="headerlink" title="Phoenix JDBC"></a>Phoenix JDBC</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># 导入依赖</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.phoenix<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>phoenix-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.15.0-HBase-1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Connection conn = DriverManager.getConnection(&quot;jdbc:phoenix:master,node1,node2:2181&quot;);</span><br><span class="line">        PreparedStatement ps = conn.prepareStatement(&quot;select /*+ INDEX(DIANXIN DIANXIN_INDEX) */ * from DIANXIN where end_date=?&quot;);</span><br><span class="line">        ps.setString(1, &quot;20180503212649&quot;);</span><br><span class="line">        ResultSet rs = ps.executeQuery();</span><br><span class="line">        while (rs.next()) &#123;</span><br><span class="line">            String mdn = rs.getString(&quot;mdn&quot;);</span><br><span class="line">            String start_date = rs.getString(&quot;start_date&quot;);</span><br><span class="line">            String end_date = rs.getString(&quot;end_date&quot;);</span><br><span class="line">            String x = rs.getString(&quot;x&quot;);</span><br><span class="line">            String y = rs.getString(&quot;y&quot;);</span><br><span class="line">            String county = rs.getString(&quot;county&quot;);</span><br><span class="line">            System.out.println(mdn + &quot;\t&quot; + start_date + &quot;\t&quot; + end_date + &quot;\t&quot; + x + &quot;\t&quot; + y + &quot;\t&quot; + county);</span><br><span class="line">        &#125;</span><br><span class="line">        ps.close();</span><br><span class="line">        conn.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大数据学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HBase过滤器学习</title>
      <link href="/2021/10/14/HBase%E8%BF%87%E6%BB%A4%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/10/14/HBase%E8%BF%87%E6%BB%A4%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="HBase过滤器"><a href="#HBase过滤器" class="headerlink" title="HBase过滤器"></a>HBase过滤器</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>过滤器的作用是在<strong>服务端</strong>判断数据是否满足条件，然后只将满足条件的数据返回给<strong>客户端</strong></li><li>过滤器的类型很多，但是可以分为两大类：<ul><li>比较过滤器：可应用于rowkey、列簇、列、列值过滤器</li><li>专用过滤器：只能适用于特定的过滤器</li></ul></li></ul><h2 id="比较过滤器"><a href="#比较过滤器" class="headerlink" title="比较过滤器"></a>比较过滤器</h2><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><ul><li><p>LESS  &lt;</p></li><li><p>LESS_OR_EQUAL &lt;=</p></li><li><p>EQUAL =</p></li><li><p>NOT_EQUAL &lt;&gt;</p></li><li><p>GREATER_OR_EQUAL &gt;=</p></li><li><p>GREATER &gt;</p></li><li><p>NO_OP 排除所有</p></li></ul><h3 id="常见的六大比较过滤器"><a href="#常见的六大比较过滤器" class="headerlink" title="常见的六大比较过滤器"></a>常见的六大比较过滤器</h3><h4 id="BinaryComparator"><a href="#BinaryComparator" class="headerlink" title="BinaryComparator"></a>BinaryComparator</h4><blockquote><p>按字节索引顺序比较指定字节数组，采用Bytes.compareTo(byte[])</p></blockquote><h4 id="BinaryPrefixComparator"><a href="#BinaryPrefixComparator" class="headerlink" title="BinaryPrefixComparator"></a>BinaryPrefixComparator</h4><blockquote><p>通BinaryComparator，只是比较左端前缀的数据是否相同</p></blockquote><h4 id="NullComparator"><a href="#NullComparator" class="headerlink" title="NullComparator"></a>NullComparator</h4><blockquote><p>判断给定的是否为空</p></blockquote><h4 id="BitComparator"><a href="#BitComparator" class="headerlink" title="BitComparator"></a>BitComparator</h4><blockquote><p>按位比较</p></blockquote><h4 id="RegexStringComparator"><a href="#RegexStringComparator" class="headerlink" title="RegexStringComparator"></a>RegexStringComparator</h4><blockquote><p>提供一个正则的比较器，仅支持 EQUAL 和非EQUAL</p></blockquote><h4 id="SubstringComparator"><a href="#SubstringComparator" class="headerlink" title="SubstringComparator"></a>SubstringComparator</h4><blockquote><p>判断提供的子串是否出现在中</p></blockquote><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><h5 id="rowKey过滤器：RowFilter"><a href="#rowKey过滤器：RowFilter" class="headerlink" title="rowKey过滤器：RowFilter"></a>rowKey过滤器：RowFilter</h5><blockquote><p>通过RowFilter与BinaryComparator过滤比rowKey 1500100010小的所有值出来</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">// 通过RowFilter过滤比rowKey 1500100010 小的所有值出来</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BinaryComparatorFilter</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Table students = conn.getTable(TableName.valueOf(<span class="string">&quot;students&quot;</span>));</span><br><span class="line">    BinaryComparator binaryComparator = <span class="keyword">new</span> BinaryComparator(Bytes.toBytes(<span class="number">1500100010</span>));</span><br><span class="line">    RowFilter rowFilter = <span class="keyword">new</span> RowFilter(CompareFilter.CompareOp.LESS, binaryComparator);</span><br><span class="line">    Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line">    scan.setFilter(rowFilter);</span><br><span class="line">    ResultScanner scanner = students.getScanner(scan);</span><br><span class="line">    Result rs = scanner.next();</span><br><span class="line">    <span class="keyword">while</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String id = Bytes.toString(rs.getRow());</span><br><span class="line">        String name = Bytes.toString(rs.getValue(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;name&quot;</span>.getBytes()));</span><br><span class="line">        <span class="keyword">int</span> age = Bytes.toInt(rs.getValue(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;age&quot;</span>.getBytes()));</span><br><span class="line">        String gender = Bytes.toString(rs.getValue(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;gender&quot;</span>.getBytes()));</span><br><span class="line">        String clazz = Bytes.toString(rs.getValue(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;clazz&quot;</span>.getBytes()));</span><br><span class="line"></span><br><span class="line">        System.out.println(id + <span class="string">&quot;\t&quot;</span> + name + <span class="string">&quot;\t&quot;</span> + age + <span class="string">&quot;\t&quot;</span> + gender + <span class="string">&quot;\t&quot;</span> + clazz + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">        rs = scanner.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="列簇过滤器：FamilyFilter"><a href="#列簇过滤器：FamilyFilter" class="headerlink" title="列簇过滤器：FamilyFilter"></a>列簇过滤器：FamilyFilter</h5><blockquote><p>通过FamilyFilter与SubstringComparator查询列簇名包含in的所有列簇下面的数据</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">// 通过FamilyFilter查询列簇名包含in的所有列簇下面的数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SubstringComparatorFilter</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Table students = conn.getTable(TableName.valueOf(<span class="string">&quot;students&quot;</span>));</span><br><span class="line">    SubstringComparator substringComparator = <span class="keyword">new</span> SubstringComparator(<span class="string">&quot;in&quot;</span>);</span><br><span class="line">    FamilyFilter familyFilter = <span class="keyword">new</span> FamilyFilter(CompareFilter.CompareOp.EQUAL, substringComparator);</span><br><span class="line">    Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line">    scan.setFilter(familyFilter);</span><br><span class="line">    ResultScanner scanner = students.getScanner(scan);</span><br><span class="line">    Result rs = scanner.next();</span><br><span class="line">    <span class="keyword">while</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String id = Bytes.toString(rs.getRow());</span><br><span class="line">        String name = Bytes.toString(rs.getValue(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;name&quot;</span>.getBytes()));</span><br><span class="line">        <span class="keyword">int</span> age = Bytes.toInt(rs.getValue(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;age&quot;</span>.getBytes()));</span><br><span class="line">        String gender = Bytes.toString(rs.getValue(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;gender&quot;</span>.getBytes()));</span><br><span class="line">        String clazz = Bytes.toString(rs.getValue(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;clazz&quot;</span>.getBytes()));</span><br><span class="line"></span><br><span class="line">        System.out.println(id + <span class="string">&quot;\t&quot;</span> + name + <span class="string">&quot;\t&quot;</span> + age + <span class="string">&quot;\t&quot;</span> + gender + <span class="string">&quot;\t&quot;</span> + clazz + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">        rs = scanner.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过FamilyFilter与 BinaryPrefixComparator 过滤出列簇以info开头的列簇下的所有数据</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过FamilyFilter与 BinaryPrefixComparator 过滤出列簇以info开头的所有列簇下的所有数据</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BinaryPrefixComparatorFilter</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Table students = conn.getTable(TableName.valueOf(<span class="string">&quot;students&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 二进制前缀比较器</span></span><br><span class="line">        BinaryPrefixComparator binaryPrefixComparator = <span class="keyword">new</span> BinaryPrefixComparator(<span class="string">&quot;info&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">// FamilyFilter 作用于列簇的过滤器</span></span><br><span class="line">        FamilyFilter familyFilter = <span class="keyword">new</span> FamilyFilter(CompareFilter.CompareOp.EQUAL, binaryPrefixComparator);</span><br><span class="line"></span><br><span class="line">        Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line"></span><br><span class="line">        scan.withStartRow(<span class="string">&quot;1500100001&quot;</span>.getBytes());</span><br><span class="line">        scan.withStopRow(<span class="string">&quot;1500100011&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">// 通过setFilter方法设置过滤器</span></span><br><span class="line">        scan.setFilter(familyFilter);</span><br><span class="line"></span><br><span class="line">        ResultScanner scanner = students.getScanner(scan);</span><br><span class="line"></span><br><span class="line">        printRS(scanner);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="列过滤器：QualifierFilter"><a href="#列过滤器：QualifierFilter" class="headerlink" title="列过滤器：QualifierFilter"></a>列过滤器：QualifierFilter</h5><blockquote><p>通过QualifierFilter与SubstringComparator查询列名包含in的列的值</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printRS</span><span class="params">(ResultScanner scanner)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Result rs : scanner) &#123;</span><br><span class="line">        String rowkey = Bytes.toString(rs.getRow());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前行的rowkey为：&quot;</span> + rowkey);</span><br><span class="line">        <span class="keyword">for</span> (Cell cell : rs.listCells()) &#123;</span><br><span class="line">            String family = Bytes.toString(CellUtil.cloneFamily(cell));</span><br><span class="line">            String qualifier = Bytes.toString(CellUtil.cloneQualifier(cell));</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = CellUtil.cloneValue(cell);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;age&quot;</span>.equals(qualifier)) &#123;</span><br><span class="line">                <span class="keyword">int</span> value = Bytes.toInt(bytes);</span><br><span class="line">                System.out.println(family + <span class="string">&quot;:&quot;</span> + qualifier + <span class="string">&quot;的值为&quot;</span> + value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                String value = Bytes.toString(bytes);</span><br><span class="line">                System.out.println(family + <span class="string">&quot;:&quot;</span> + qualifier + <span class="string">&quot;的值为&quot;</span> + value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">// 通过FamilyFilter查询列簇名包含in的所有列簇下面的数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SubstringComparatorFilter</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Table students = conn.getTable(TableName.valueOf(<span class="string">&quot;students&quot;</span>));</span><br><span class="line">    SubstringComparator substringComparator = <span class="keyword">new</span> SubstringComparator(<span class="string">&quot;in&quot;</span>);</span><br><span class="line">    FamilyFilter familyFilter = <span class="keyword">new</span> FamilyFilter(CompareFilter.CompareOp.EQUAL, substringComparator);</span><br><span class="line">    Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line">    scan.setFilter(familyFilter);</span><br><span class="line">    ResultScanner scanner = students.getScanner(scan);</span><br><span class="line">    Result rs = scanner.next();</span><br><span class="line">    <span class="keyword">while</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String id = Bytes.toString(rs.getRow());</span><br><span class="line">        String name = Bytes.toString(rs.getValue(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;name&quot;</span>.getBytes()));</span><br><span class="line">        <span class="keyword">int</span> age = Bytes.toInt(rs.getValue(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;age&quot;</span>.getBytes()));</span><br><span class="line">        String gender = Bytes.toString(rs.getValue(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;gender&quot;</span>.getBytes()));</span><br><span class="line">        String clazz = Bytes.toString(rs.getValue(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;clazz&quot;</span>.getBytes()));</span><br><span class="line"></span><br><span class="line">        System.out.println(id + <span class="string">&quot;\t&quot;</span> + name + <span class="string">&quot;\t&quot;</span> + age + <span class="string">&quot;\t&quot;</span> + gender + <span class="string">&quot;\t&quot;</span> + clazz + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">        rs = scanner.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>过滤出 列的名字 中 包含 “am” 所有的列 及列的值</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 过滤出 列的名字 中 包含 &quot;am&quot; 所有的列 及列的值</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SubstringComparatorQualifierFilter</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Table students = conn.getTable(TableName.valueOf(<span class="string">&quot;students&quot;</span>));</span><br><span class="line"></span><br><span class="line">    SubstringComparator substringComparator = <span class="keyword">new</span> SubstringComparator(<span class="string">&quot;am&quot;</span>);</span><br><span class="line">    <span class="comment">// 作用在列名上的过滤器</span></span><br><span class="line">    QualifierFilter qualifierFilter = <span class="keyword">new</span> QualifierFilter(CompareFilter.CompareOp.EQUAL, substringComparator);</span><br><span class="line">    Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line"></span><br><span class="line">    scan.withStartRow(<span class="string">&quot;1500100001&quot;</span>.getBytes());</span><br><span class="line">    scan.withStopRow(<span class="string">&quot;1500100011&quot;</span>.getBytes());</span><br><span class="line">    <span class="comment">// 通过setFilter方法设置过滤器</span></span><br><span class="line">    scan.setFilter(qualifierFilter);</span><br><span class="line"></span><br><span class="line">    ResultScanner scanner = students.getScanner(scan);</span><br><span class="line"></span><br><span class="line">    printRS(scanner);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="列值过滤器：ValueFilter"><a href="#列值过滤器：ValueFilter" class="headerlink" title="列值过滤器：ValueFilter"></a>列值过滤器：ValueFilter</h5><blockquote><p>通过ValueFilter与BinaryPrefixComparator过滤出所有的cell中值以 “张” 开头的学生</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">// 通过ValueFilter与BinaryPrefixComparator过滤出所有的cell中值以 &quot;张&quot; 开头的学生</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BinaryPrefixComparatorFilter</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Table students = conn.getTable(TableName.valueOf(<span class="string">&quot;students&quot;</span>));</span><br><span class="line">    BinaryPrefixComparator binaryPrefixComparator = <span class="keyword">new</span> BinaryPrefixComparator(<span class="string">&quot;张&quot;</span>.getBytes());</span><br><span class="line">    ValueFilter valueFilter = <span class="keyword">new</span> ValueFilter(CompareFilter.CompareOp.EQUAL, binaryPrefixComparator);</span><br><span class="line">    Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line">    scan.setFilter(valueFilter);</span><br><span class="line">    ResultScanner scanner = students.getScanner(scan);</span><br><span class="line"></span><br><span class="line">    printRS(scanner);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>过滤出文科的学生，只会返回clazz列，其他列的数据不符合条件，不会返回</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 过滤出文科的学生</span></span><br><span class="line"><span class="comment">// 只会返回clazz列，其他列的数据不符合条件，不会返回</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RegexStringComparatorFilter</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Table students = conn.getTable(TableName.valueOf(<span class="string">&quot;students&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用正则表达式比较器</span></span><br><span class="line">    RegexStringComparator regexStringComparator = <span class="keyword">new</span> RegexStringComparator(<span class="string">&quot;^文科.*&quot;</span>);</span><br><span class="line">    <span class="comment">// ValueFilter 会返回符合条件的cell，并不会返回整条数据</span></span><br><span class="line">    ValueFilter valueFilter = <span class="keyword">new</span> ValueFilter(CompareFilter.CompareOp.EQUAL, regexStringComparator);</span><br><span class="line"></span><br><span class="line">    Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line"></span><br><span class="line">    scan.withStartRow(<span class="string">&quot;1500100001&quot;</span>.getBytes());</span><br><span class="line">    scan.withStopRow(<span class="string">&quot;1500100011&quot;</span>.getBytes());</span><br><span class="line">    <span class="comment">// 通过setFilter方法设置过滤器</span></span><br><span class="line">    scan.setFilter(valueFilter);</span><br><span class="line"></span><br><span class="line">    ResultScanner scanner = students.getScanner(scan);</span><br><span class="line"></span><br><span class="line">    printRS(scanner);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="专用过滤器"><a href="#专用过滤器" class="headerlink" title="专用过滤器"></a>专用过滤器</h4><h5 id="单列值过滤器：SingleColumnValueFilter"><a href="#单列值过滤器：SingleColumnValueFilter" class="headerlink" title="单列值过滤器：SingleColumnValueFilter"></a>单列值过滤器：SingleColumnValueFilter</h5><blockquote><p>SingleColumnValueFilter会返回满足条件的cell所在行的所有cell的值（即会返回一行数据）</p><p>通过SingleColumnValueFilter与查询文科班所有学生信息</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">// 通过SingleColumnValueFilter与查询文科班所有学生信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RegexStringComparatorFilter</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Table students = conn.getTable(TableName.valueOf(<span class="string">&quot;students&quot;</span>));</span><br><span class="line">    SingleColumnValueFilter singleColumnValueFilter = <span class="keyword">new</span> SingleColumnValueFilter(</span><br><span class="line">            <span class="string">&quot;info&quot;</span>.getBytes(),</span><br><span class="line">            <span class="string">&quot;clazz&quot;</span>.getBytes(),</span><br><span class="line">            CompareFilter.CompareOp.EQUAL,</span><br><span class="line">            <span class="keyword">new</span> RegexStringComparator(<span class="string">&quot;^文科.*&quot;</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line">    scan.setFilter(singleColumnValueFilter);</span><br><span class="line">    ResultScanner scanner = students.getScanner(scan);</span><br><span class="line"></span><br><span class="line">    Result rs = scanner.next();</span><br><span class="line">    <span class="keyword">while</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String id = Bytes.toString(rs.getRow());</span><br><span class="line">        String name = Bytes.toString(rs.getValue(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;name&quot;</span>.getBytes()));</span><br><span class="line">        <span class="keyword">int</span> age = Bytes.toInt(rs.getValue(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;age&quot;</span>.getBytes()));</span><br><span class="line">        String gender = Bytes.toString(rs.getValue(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;gender&quot;</span>.getBytes()));</span><br><span class="line">        String clazz = Bytes.toString(rs.getValue(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;clazz&quot;</span>.getBytes()));</span><br><span class="line"></span><br><span class="line">        System.out.println(id + <span class="string">&quot;\t&quot;</span> + name + <span class="string">&quot;\t&quot;</span> + age + <span class="string">&quot;\t&quot;</span> + gender + <span class="string">&quot;\t&quot;</span> + clazz + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">        rs = scanner.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="列值排除过滤器：SingleColumnValueExcludeFilter"><a href="#列值排除过滤器：SingleColumnValueExcludeFilter" class="headerlink" title="列值排除过滤器：SingleColumnValueExcludeFilter"></a>列值排除过滤器：SingleColumnValueExcludeFilter</h5><blockquote><p>与SingleColumnValueFilter相反，会排除掉指定的列，其他的列全部返回</p><p>通过SingleColumnValueExcludeFilter与BinaryComparator查询文科一班所有学生信息，最终不返回clazz列</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">// 通过SingleColumnValueExcludeFilter与BinaryComparator查询文科一班所有学生信息，最终不返回clazz列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RegexStringComparatorExcludeFilter</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Table students = conn.getTable(TableName.valueOf(<span class="string">&quot;students&quot;</span>));</span><br><span class="line">    SingleColumnValueExcludeFilter singleColumnValueExcludeFilter = <span class="keyword">new</span> SingleColumnValueExcludeFilter(</span><br><span class="line">            <span class="string">&quot;info&quot;</span>.getBytes(),</span><br><span class="line">            <span class="string">&quot;clazz&quot;</span>.getBytes(),</span><br><span class="line">            CompareFilter.CompareOp.EQUAL,</span><br><span class="line">            <span class="keyword">new</span> BinaryComparator(<span class="string">&quot;文科一班&quot;</span>.getBytes())</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line">    scan.setFilter(singleColumnValueExcludeFilter);</span><br><span class="line">    ResultScanner scanner = students.getScanner(scan);</span><br><span class="line"></span><br><span class="line">    Result rs = scanner.next();</span><br><span class="line">    <span class="keyword">while</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String id = Bytes.toString(rs.getRow());</span><br><span class="line">        String name = Bytes.toString(rs.getValue(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;name&quot;</span>.getBytes()));</span><br><span class="line">        <span class="keyword">int</span> age = Bytes.toInt(rs.getValue(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;age&quot;</span>.getBytes()));</span><br><span class="line">        String gender = Bytes.toString(rs.getValue(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;gender&quot;</span>.getBytes()));</span><br><span class="line">        <span class="comment">// clazz列为空</span></span><br><span class="line">        String clazz = Bytes.toString(rs.getValue(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;clazz&quot;</span>.getBytes()));</span><br><span class="line"></span><br><span class="line">        System.out.println(id + <span class="string">&quot;\t&quot;</span> + name + <span class="string">&quot;\t&quot;</span> + age + <span class="string">&quot;\t&quot;</span> + gender + <span class="string">&quot;\t&quot;</span> + clazz + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">        rs = scanner.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="rowkey前缀过滤器：PrefixFilter"><a href="#rowkey前缀过滤器：PrefixFilter" class="headerlink" title="rowkey前缀过滤器：PrefixFilter"></a>rowkey前缀过滤器：PrefixFilter</h5><blockquote><p>通过PrefixFilter查询以150010008开头的所有前缀的rowkey</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">// 通过PrefixFilter查询以150010008开头的所有前缀的rowkey</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrefixFilterFilter</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Table students = conn.getTable(TableName.valueOf(<span class="string">&quot;students&quot;</span>));</span><br><span class="line">    PrefixFilter prefixFilter = <span class="keyword">new</span> PrefixFilter(<span class="string">&quot;150010008&quot;</span>.getBytes());</span><br><span class="line">    Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line">    scan.setFilter(prefixFilter);</span><br><span class="line">    ResultScanner scanner = students.getScanner(scan);</span><br><span class="line">    Result rs = scanner.next();</span><br><span class="line">    <span class="keyword">while</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String id = Bytes.toString(rs.getRow());</span><br><span class="line">        String name = Bytes.toString(rs.getValue(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;name&quot;</span>.getBytes()));</span><br><span class="line">        <span class="keyword">int</span> age = Bytes.toInt(rs.getValue(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;age&quot;</span>.getBytes()));</span><br><span class="line">        String gender = Bytes.toString(rs.getValue(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;gender&quot;</span>.getBytes()));</span><br><span class="line">        <span class="comment">// clazz列为空</span></span><br><span class="line">        String clazz = Bytes.toString(rs.getValue(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;clazz&quot;</span>.getBytes()));</span><br><span class="line"></span><br><span class="line">        System.out.println(id + <span class="string">&quot;\t&quot;</span> + name + <span class="string">&quot;\t&quot;</span> + age + <span class="string">&quot;\t&quot;</span> + gender + <span class="string">&quot;\t&quot;</span> + clazz + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">        rs = scanner.next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="分页过滤器PageFilter"><a href="#分页过滤器PageFilter" class="headerlink" title="分页过滤器PageFilter"></a>分页过滤器PageFilter</h5><blockquote><p>通过PageFilter查询第三页的数据，每页10条</p><p>使用PageFilter分页效率比较低，每次都需要扫描前面的数据，直到扫描到所需要查的数据</p><p>可设计一个合理的rowkey来实现分页需求</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">// 通过PageFilter查询第三页的数据，每页10条</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PageFilter</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Table students = conn.getTable(TableName.valueOf(<span class="string">&quot;students&quot;</span>));</span><br><span class="line">    <span class="keyword">int</span> PageNum = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> PageSize = <span class="number">10</span>;</span><br><span class="line">    Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line">    <span class="keyword">if</span> (PageNum == <span class="number">1</span>) &#123;</span><br><span class="line">        scan.withStartRow(<span class="string">&quot;&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">//使用分页过滤器，实现数据的分页</span></span><br><span class="line">        PageFilter pageFilter = <span class="keyword">new</span> PageFilter(PageSize);</span><br><span class="line">        scan.setFilter(pageFilter);</span><br><span class="line">        ResultScanner scanner = students.getScanner(scan);</span><br><span class="line">        printRS(scanner);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String current_page_start_rows = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> scanDatas = (PageNum - <span class="number">1</span>) * PageSize + <span class="number">1</span>;</span><br><span class="line">        PageFilter pageFilter = <span class="keyword">new</span> PageFilter(scanDatas);</span><br><span class="line">        scan.setFilter(pageFilter);</span><br><span class="line">        ResultScanner scanner = students.getScanner(scan);</span><br><span class="line">        <span class="keyword">for</span> (Result rs : scanner) &#123;</span><br><span class="line">            current_page_start_rows = Bytes.toString(rs.getRow());</span><br><span class="line">        &#125;</span><br><span class="line">        scan.withStartRow(current_page_start_rows.getBytes());</span><br><span class="line">        PageFilter pageFilter1 = <span class="keyword">new</span> PageFilter(PageSize);</span><br><span class="line">        scan.setFilter(pageFilter1);</span><br><span class="line">        ResultScanner scanner1 = students.getScanner(scan);</span><br><span class="line">        printRS(scanner1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过合理的设置rowkey来实现分页功能</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">// 通过合理的设置rowkey来实现分页功能，提高效率</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PageFilterTest2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Table students = conn.getTable(TableName.valueOf(<span class="string">&quot;students&quot;</span>));</span><br><span class="line">    <span class="keyword">int</span> PageSize = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> PageNum = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> baseId = <span class="number">1500100000</span>;</span><br><span class="line">    <span class="keyword">int</span> start_row = baseId + (PageNum - <span class="number">1</span>) * PageSize + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> end_row = start_row + PageSize;</span><br><span class="line">    Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line">    scan.withStartRow(String.valueOf(start_row).getBytes());</span><br><span class="line">    scan.withStopRow(String.valueOf(end_row).getBytes());</span><br><span class="line"></span><br><span class="line">    ResultScanner scanner = students.getScanner(scan);</span><br><span class="line"></span><br><span class="line">    printRS(scanner);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多过滤器综合查询"><a href="#多过滤器综合查询" class="headerlink" title="多过滤器综合查询"></a>多过滤器综合查询</h4><blockquote><p>查询文科班中的学生中学号以150010008开头并且年龄小于23的学生信息</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">// 查询文科班中的学生中学号以150010008开头并且年龄小于23的学生信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FilterListFilter</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Table students = conn.getTable(TableName.valueOf(<span class="string">&quot;students&quot;</span>));</span><br><span class="line">    Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line">    SingleColumnValueFilter singleColumnValueFilter = <span class="keyword">new</span> SingleColumnValueFilter(</span><br><span class="line">            <span class="string">&quot;info&quot;</span>.getBytes()</span><br><span class="line">            , <span class="string">&quot;clazz&quot;</span>.getBytes()</span><br><span class="line">            , CompareFilter.CompareOp.EQUAL</span><br><span class="line">            , <span class="keyword">new</span> RegexStringComparator(<span class="string">&quot;^文科.*&quot;</span>));</span><br><span class="line">    PrefixFilter prefixFilter = <span class="keyword">new</span> PrefixFilter(<span class="string">&quot;150010008&quot;</span>.getBytes());</span><br><span class="line">    SingleColumnValueFilter singleColumnValueFilter1 = <span class="keyword">new</span> SingleColumnValueFilter(</span><br><span class="line">            <span class="string">&quot;info&quot;</span>.getBytes()</span><br><span class="line">            , <span class="string">&quot;age&quot;</span>.getBytes()</span><br><span class="line">            , CompareFilter.CompareOp.LESS</span><br><span class="line">            , <span class="keyword">new</span> BinaryComparator(Bytes.toBytes(<span class="number">23</span>)));</span><br><span class="line"></span><br><span class="line">    FilterList filterList = <span class="keyword">new</span> FilterList();</span><br><span class="line">    filterList.addFilter(singleColumnValueFilter);</span><br><span class="line">    filterList.addFilter(prefixFilter);</span><br><span class="line">    filterList.addFilter(singleColumnValueFilter1);</span><br><span class="line">    scan.setFilter(filterList);</span><br><span class="line">    ResultScanner scanner = students.getScanner(scan);</span><br><span class="line">    printRS(scanner);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大数据学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HBase学习小结</title>
      <link href="/2021/10/09/HBase%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
      <url>/2021/10/09/HBase%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>HBase是一种分布式，可扩展，支持海量数据存储的NoSQL数据库。</p><h2 id="HBase数据模型"><a href="#HBase数据模型" class="headerlink" title="HBase数据模型"></a>HBase数据模型</h2><p>逻辑上，HBase的数据模型同关系型数据库很类似，数据存储在一张表中，有行有列。但从HBase的底层物理存储结构(k-v)来看，HBase更像是一个<font color="red">multi-dimensional map</font></p><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211010202851346.png" alt="image-20211010202851346"></p><p>Row Key中是字典升序排列。</p><p>Region是一张表中横向的切片。如上图，有3个Region。</p><p>store是存储的，将来数据都会放在HDFS上。</p><p><font color="red">另外值得注意的是，HBase的元数据放在zookeeper中，Hive的元数据放在MySQL中。</font></p><h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211010205230072.png" alt="image-20211010205230072"></p><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p><strong>1）Name Space</strong></p><p>命名空间，类似于关系型数据库的 DatabBase 概念，每个命名空间下有多个表。HBase</p><p>有两个自带的命名空间，分别是 hbase 和 default，hbase 中存放的是 HBase 内置的表，</p><p>default 表是用户默认使用的命名空间。</p><p><strong>2）Region</strong></p><p>类似于关系型数据库的表概念。不同的是，HBase 定义表时只需要声明列族即可，不需</p><p>要声明具体的列。这意味着，往 HBase 写入数据时，<font color="red">字段可以动态、按需指定</font>。因此，和关</p><p>系型数据库相比，HBase 能够轻松应对字段变更的场景。</p><p><strong>3）Row</strong></p><p>HBase 表中的每行数据都由一个 <strong>RowKey</strong> 和多个 <strong>Column</strong>（列）组成，数据是按照 RowKey</p><p>的<font color="red">字典顺序存储</font>的，并且查询数据时只能根据 RowKey 进行检索，所以 RowKey 的设计十分重</p><p>要。</p><p><strong>4）Column</strong></p><p>HBase 中的每个列都由 Column Family(列族)和 Column Qualifier（列限定符）进行限</p><p>定，例如 info：name，info：age。建表时，只需指明列族，而列限定符无需预先定义。</p><p><strong>5）Time Stamp</strong></p><p>用于标识数据的不同版本（version），每条数据写入时，如果不指定时间戳，系统会</p><p>自动为其加上该字段，其值为写入 HBase 的时间。</p><p><strong>6）Cell</strong></p><p>由{rowkey, column Family：column Qualifier, time Stamp} 唯一确定的单元。cell 中的数</p><p>据是没有类型的，全部是字节码形式存贮。</p><h2 id="HBase基本架构"><a href="#HBase基本架构" class="headerlink" title="HBase基本架构"></a>HBase基本架构</h2><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211010220551524.png" alt="image-20211010220551524"></p><p><strong>架构角色：</strong> </p><p><strong>1）Region Server</strong> </p><p>Region Server 为 Region 的管理者，其实现类为 HRegionServer，主要作用如下:</p><p>对于数据的操作：get, put, delete；</p><p>对于 Region 的操作：splitRegion、compactRegion。 </p><p><strong>2）Master</strong> </p><p>Master 是所有 Region Server 的管理者，其实现类为 HMaster，主要作用如下：</p><p>对于表的操作：create, delete, alter</p><p>对于 RegionServer的操作：分配 regions到每个RegionServer，监控每个 RegionServer</p><p>的状态，负载均衡和故障转移。</p><p><strong>3）Zookeeper</strong> </p><p>HBase 通过 Zookeeper 来做 Master 的高可用、RegionServer 的监控、元数据的入口以及</p><p>集群配置的维护等工作。</p><p><strong>4）HDFS</strong> </p><p>HDFS 为 HBase 提供最终的底层数据存储服务，同时为 HBase 提供高可用的支持。</p><h2 id="HBase-Shell操作"><a href="#HBase-Shell操作" class="headerlink" title="HBase Shell操作"></a>HBase Shell操作</h2><p><strong>进入 HBase 客户端命令行</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hbase shell</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211011192202257.png" alt="image-20211011192202257"></p><p><strong>查看当前数据库中有哪些表</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">list</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211011193250375.png" alt="image-20211011193250375"></p><p><strong>创建表</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create <span class="string">&#x27;表名&#x27;</span>,<span class="string">&#x27;列簇名&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>查看表信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">describe <span class="string">&#x27;表名&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211011194338375.png" alt="image-20211011194338375"></p><p>如上图所示，能看到很多信息。比如列簇名字，布隆过滤器，存放版本，过期时间等等。</p><p><strong>变更表信息</strong></p><p>将 info 列族中的数据存放 3 个版本：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alter <span class="string">&#x27;表名&#x27;</span>，&#123;NAME=&gt;<span class="string">&#x27;info&#x27;</span>,VERSIONS=&gt;3&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211011194624200.png" alt="image-20211011194624200"></p><p><strong>删除表</strong></p><p><strong>首先需要先让该表为 disable 状态：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">disable</span> <span class="string">&#x27;表名&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>然后才能 drop 这个表：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">drop <span class="string">&#x27;表名&#x27;</span></span><br></pre></td></tr></table></figure><p>提示：如果直接 drop 表，会报错：ERROR: Table student is enabled. Disable it first.</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211011194844382.png" alt="image-20211011194844382"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211011194735489.png" alt="image-20211011194735489"></p><p>可以看到表已经删除了。</p><p><strong>插入数据到表中put</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">put <span class="string">&#x27;表名&#x27;</span>,<span class="string">&#x27;rowkey&#x27;</span>,<span class="string">&#x27;列(注意，写法是 列簇:列名)&#x27;</span>,<span class="string">&#x27;value&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211011201354228.png" alt="image-20211011201354228"></p><p><strong>查询数据</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scan <span class="string">&#x27;表名&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211011203202274.png" alt="image-20211011203202274"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">get <span class="string">&#x27;表名&#x27;</span>,<span class="string">&#x27;rowkey&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211011203605658.png" alt="image-20211011203605658"></p><p><strong>修改数据</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">put <span class="string">&#x27;表名&#x27;</span>,<span class="string">&#x27;rowkey&#x27;</span>,<span class="string">&#x27;列簇:你要修改的列明列名&#x27;</span>,<span class="string">&#x27;你要修改的数值&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>删除数据</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">delete <span class="string">&#x27;表名&#x27;</span>,<span class="string">&#x27;rowkey&#x27;</span>,<span class="string">&#x27;列名&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211011205634488.png" alt="image-20211011205634488"></p><h2 id="HBase进阶"><a href="#HBase进阶" class="headerlink" title="HBase进阶"></a>HBase进阶</h2><h3 id="HBase详细架构图"><a href="#HBase详细架构图" class="headerlink" title="HBase详细架构图"></a>HBase详细架构图</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211012201400499.png" alt="image-20211012201400499"></p><p><strong>StoreFile</strong> </p><p>保存实际数据的物理文件，StoreFile 以 HFile 的形式存储在 HDFS 上。每个 Store 会有一个或多个 StoreFile（HFile），数据在每个 StoreFile 中都是有序的。</p><p><strong>MemStore</strong> </p><p>写缓存，由于 HFile 中的数据要求是有序的，所以数据是先存储在 MemStore 中，排好序后，等到达刷写时机才会刷写到 HFile，每次刷写都会形成一个新的 HFile。 </p><p><strong>WAL</strong> </p><p>由于数据要经 MemStore 排序后才能刷写到 HFile，但把数据保存在内存中会有很高的概率导致数据丢失，为了解决这个问题，数据会先写在一个叫做 Write-Ahead logfile 的文件中，然后再写入 MemStore 中。所以在系统出现故障的时候，数据可以通过这个日志文件(HLog)重建。</p><h3 id="HBase写流程"><a href="#HBase写流程" class="headerlink" title="HBase写流程"></a>HBase写流程</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211012204131202.png" alt="image-20211012204131202"></p><p><strong>写流程：</strong></p><p>1）Client 先访问 zookeeper，获取 hbase:meta 表位于哪个 Region Server。 </p><p>2）访问对应的 Region Server，获取 hbase:meta 表，根据读请求的 namespace:table/rowkey，</p><p>查询出目标数据位于哪个 Region Server 中的哪个 Region 中。并将该 table 的 region 信息以</p><p>及 meta 表的位置信息缓存在客户端的 meta cache，方便下次访问。</p><p>3）与目标 Region Server 进行通讯；</p><p>4）将数据顺序写入（追加）到 WAL； </p><p>5）将数据写入对应的 MemStore，数据会在 MemStore 进行排序； </p><p>6）向客户端发送 ack； </p><p>7）等达到 MemStore 的刷写时机后，将数据刷写到 HFile。</p><h3 id="HBase读流程"><a href="#HBase读流程" class="headerlink" title="HBase读流程"></a>HBase读流程</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211012204229181.png" alt="image-20211012204229181"></p><p><strong>读流程</strong></p><p>1）Client 先访问 zookeeper，获取 hbase:meta 表位于哪个 Region Server。 </p><p>2）访问对应的 Region Server，获取 hbase:meta 表，根据读请求的 namespace:table/rowkey，</p><p>查询出目标数据位于哪个 Region Server 中的哪个 Region 中。并将该 table 的 region 信息以</p><p>及 meta 表的位置信息缓存在客户端的 meta cache，方便下次访问。</p><p>3）与目标 Region Server 进行通讯；</p><p>4）分别在 Block Cache（读缓存），MemStore 和 Store File（HFile）中查询目标数据，并将</p><p>查到的所有数据进行合并。此处所有数据是指同一条数据的不同版本（time stamp）或者不</p><p>同的类型（Put/Delete）。</p><p>5） 将从文件中查询到的数据块（Block，HFile 数据存储单元，默认大小为 64KB）缓存到</p><p>Block Cache(读缓存)。 </p><p>6）将合并后的最终结果返回给客户端。</p><p><font color="red">注意：HBase框架是一个读比写慢的框架。</font></p><h3 id="MemStore-Flush"><a href="#MemStore-Flush" class="headerlink" title="MemStore Flush"></a>MemStore Flush</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211012212143889.png" alt="image-20211012212143889"></p><p><strong>MemStore</strong> <strong>刷写时机：</strong></p><p>1.当某个 memstroe 的大小达到了 <strong>hbase.hregion.memstore.flush.size</strong>（默认值 <strong>128M</strong>）， 其所在 region 的所有 memstore 都会刷写。 当 memstore 的大小达到了<strong>hbase.hregion.memstore.flush.size</strong>（默认值 <strong>128M</strong>）<strong>hbase.hregion.memstore.block.multiplier</strong>（默认值 <strong>4</strong>）时，会阻止继续往该 memstore 写数据。</p><p>2.当 region server 中 memstore 的总大小达到</p><p><strong>java_heapsize</strong></p><p><strong>hbase.regionserver.global.memstore.size</strong>（默认值<strong>0.4</strong>）</p><p><strong>hbase.regionserver.global.memstore.size.lower.limit</strong>（默认值 <strong>0.95</strong>），</p><p>region 会按照其所有 memstore 的大小顺序（由大到小）依次进行刷写。直到 region server中所有 memstore 的总大小减小到上述值以下。 当 region server 中 memstore 的总大小达到</p><p><strong>java_heapsizehbase.regionserver.global.memstore.size</strong>（默认值 <strong>0.4</strong>）时，会阻止继续往所有的 memstore 写数据。</p><p>3.到达自动刷写的时间，也会触发 memstore flush。自动刷新的时间间隔由该属性进行</p><p>配置 <strong>hbase.regionserver.optionalcacheflushinterval</strong>（默认 <strong>1</strong> <strong>小时）</strong>。</p><p>4.当 WAL 文件的数量超过 <strong>hbase.regionserver.max.logs</strong>，region 会按照时间顺序依次进行刷写，直到 WAL 文件数量减小到 <strong>hbase.regionserver.max.log</strong> 以下（该属性名已经废弃，现无需手动设置，最大值为 32）。</p><h3 id="StoreFile-Compaction"><a href="#StoreFile-Compaction" class="headerlink" title="StoreFile Compaction"></a>StoreFile Compaction</h3><p>由于memstore每次刷写都会生成一个新的HFile，且同一个字段的不同版本（timestamp)和不同类型（Put/Delete）有可能会分布在不同的 HFile 中，因此查询时需要遍历所有的 HFile。为了减少 HFile 的个数，以及清理掉过期和删除的数据，会进行 StoreFile Compaction。</p><p>Compaction 分为两种，分别是 <font color="red">Minor Compaction</font> 和<font color="red">Major Compaction</font>。Minor Compaction会将临近的若干个较小的 HFile 合并成一个较大的 HFile，但<font color="red">不会清理过期和删除的数据</font>。Major Compaction 会将一个 Store 下的所有的 HFile 合并成一个大 HFile，并且<font color="red">会清理掉过期和删除的数据。</font></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211013154246967.png" alt="image-20211013154246967"></p><h3 id="Region-Split"><a href="#Region-Split" class="headerlink" title="Region Split"></a>Region Split</h3><p>​        默认情况下，每个 Table 起初只有一个 Region，随着数据的不断写入，Region 会自动进行拆分。刚拆分时，两个子 Region 都位于当前的 Region Server，但处于负载均衡的考虑，HMaster 有可能会将某个 Region 转移给其他的 Region Server。</p><p>Region Split 时机：</p><p>​    1.当1个region中的某个Store下所有StoreFile的总大小超过<font color="red">hbase.hregion.max.filesize</font>， </p><p>该 Region 就会进行拆分（0.94 版本之前）。</p><ol start="2"><li>当 1 个 region 中 的 某 个 Store 下所有 StoreFile 的 总 大 小 超 过 Min(R^2 * </li></ol><p>“hbase.hregion.memstore.flush.size”,hbase.hregion.max.filesize”)，该 Region 就会进行拆分，其</p><p>中 R 为当前 Region Server 中属于该 Table 的个数（0.94 版本之后）。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211013154349937.png" alt="image-20211013154349937"></p><h2 id="HBase-JavaAPI操作"><a href="#HBase-JavaAPI操作" class="headerlink" title="HBase JavaAPI操作"></a>HBase JavaAPI操作</h2><p><strong>Hbase API类和数据模型之间的对应关系</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211013200957608.png" alt="image-20211013200957608"></p><h3 id="例一：创建test-api表"><a href="#例一：创建test-api表" class="headerlink" title="例一：创建test_api表"></a>例一：创建test_api表</h3><p><strong>代码如下所示</strong></p><h4 id="创建配置，指定zookeeper集群地址"><a href="#创建配置，指定zookeeper集群地址" class="headerlink" title="创建配置，指定zookeeper集群地址"></a>创建配置，指定zookeeper集群地址</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Configuration conf = HBaseConfiguration.create();</span><br><span class="line">conf.set(<span class="string">&quot;hbase.zookeeper.quorum&quot;</span>,<span class="string">&quot;master,node1,node2&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="创建连接"><a href="#创建连接" class="headerlink" title="创建连接"></a>创建连接</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection connection = ConnectionFactory.createConnection(conf);</span><br></pre></td></tr></table></figure><h4 id="创建Admin对象"><a href="#创建Admin对象" class="headerlink" title="创建Admin对象"></a>创建Admin对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Admin admin = connection.getAdmin();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HTableDescriptor hTableDescriptor = <span class="keyword">new</span> HTableDescriptor(TableName.valueOf(<span class="string">&quot;test_api&quot;</span>));</span><br></pre></td></tr></table></figure><h4 id="创建列簇-我这里取名叫做cf1"><a href="#创建列簇-我这里取名叫做cf1" class="headerlink" title="创建列簇,我这里取名叫做cf1"></a>创建列簇,我这里取名叫做cf1</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HColumnDescriptor cf1 = <span class="keyword">new</span> HColumnDescriptor(<span class="string">&quot;cf1&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="对列簇进行配置-可选操作"><a href="#对列簇进行配置-可选操作" class="headerlink" title="对列簇进行配置(可选操作)"></a>对列簇进行配置(可选操作)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cf1.setTimeToLive(<span class="number">100</span>); <span class="comment">//设置过期时间</span></span><br><span class="line">cf1.setMaxVersions(<span class="number">3</span>); <span class="comment">//设置版本</span></span><br></pre></td></tr></table></figure><h4 id="增加列簇"><a href="#增加列簇" class="headerlink" title="增加列簇"></a>增加列簇</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hTableDescriptor.addFamily(cf1);</span><br><span class="line">admin.createTable(hTableDescriptor);</span><br></pre></td></tr></table></figure><h4 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">connection.close();</span><br></pre></td></tr></table></figure><h4 id="总代码如下所示"><a href="#总代码如下所示" class="headerlink" title="总代码如下所示"></a>总代码如下所示</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.HBaseConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.HColumnDescriptor;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.HTableDescriptor;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.TableName;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Admin;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Connection;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建配置，指定zookeeper集群地址</span></span><br><span class="line">        Configuration conf = HBaseConfiguration.create();</span><br><span class="line">        conf.set(<span class="string">&quot;hbase.zookeeper.quorum&quot;</span>,<span class="string">&quot;master,node1,node2&quot;</span>);</span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = ConnectionFactory.createConnection(conf);</span><br><span class="line">        <span class="comment">//创建Admin对象</span></span><br><span class="line">        Admin admin = connection.getAdmin();</span><br><span class="line">        <span class="comment">//例如:创建一个test_api的表</span></span><br><span class="line">        HTableDescriptor hTableDescriptor = <span class="keyword">new</span> HTableDescriptor(TableName.valueOf(<span class="string">&quot;test_api&quot;</span>));</span><br><span class="line">        <span class="comment">//创建一个列簇，我这里取名叫做cf1</span></span><br><span class="line">        HColumnDescriptor cf1 = <span class="keyword">new</span> HColumnDescriptor(<span class="string">&quot;cf1&quot;</span>);</span><br><span class="line">        <span class="comment">//对列簇进行配置</span></span><br><span class="line"><span class="comment">//        cf1.setTimeToLive(100); //设置过期时间</span></span><br><span class="line"><span class="comment">//        cf1.setMaxVersions(3); //设置版本</span></span><br><span class="line">        <span class="comment">//增加列簇</span></span><br><span class="line">        hTableDescriptor.addFamily(cf1);</span><br><span class="line">        admin.createTable(hTableDescriptor);</span><br><span class="line">        <span class="comment">//关闭连接</span></span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211013211207512.png" alt="image-20211013211207512"></p><p>可以很清楚的看到已经创建成功了。</p><h3 id="例二，相关API操作"><a href="#例二，相关API操作" class="headerlink" title="例二，相关API操作"></a>例二，相关API操作</h3><h4 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//put</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//put操作</span></span><br><span class="line">    Table test_api = connection.getTable(TableName.valueOf(<span class="string">&quot;test_api&quot;</span>));</span><br><span class="line">    Put put = <span class="keyword">new</span> Put(<span class="string">&quot;001&quot;</span>.getBytes());</span><br><span class="line">    put.addColumn(<span class="string">&quot;cf1&quot;</span>.getBytes(),<span class="string">&quot;name&quot;</span>.getBytes(),<span class="string">&quot;方世涛&quot;</span>.getBytes());</span><br><span class="line">    test_api.put(put);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211013222419119.png" alt="image-20211013222419119"></p><h4 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//get</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Table test_api = connection.getTable(table);</span><br><span class="line">    Get get = <span class="keyword">new</span> Get(<span class="string">&quot;001&quot;</span>.getBytes());</span><br><span class="line">    Result result = test_api.get(get);</span><br><span class="line">    <span class="keyword">byte</span>[] value = result.getValue(<span class="string">&quot;cf1&quot;</span>.getBytes(), <span class="string">&quot;name&quot;</span>.getBytes());</span><br><span class="line">    System.out.println(Bytes.toString(value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211013233134270.png" alt="image-20211013233134270"></p><p>可以很清楚的看到已经查找成功。</p><h4 id="alter操作"><a href="#alter操作" class="headerlink" title="alter操作"></a>alter操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//alter table</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alter</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Admin admin = connection.getAdmin();</span><br><span class="line">    <span class="comment">//获取表原有的结构</span></span><br><span class="line">    HTableDescriptor tableDescriptor = admin.getTableDescriptor(table);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取所有列簇构成的HColumnDescriptor数组</span></span><br><span class="line">    HColumnDescriptor[] columnFamilies = tableDescriptor.getColumnFamilies();</span><br><span class="line">    <span class="comment">//遍历所有的列簇</span></span><br><span class="line">    <span class="keyword">for</span> (HColumnDescriptor columnFamily : columnFamilies) &#123;</span><br><span class="line">        <span class="comment">//获取列簇的名称</span></span><br><span class="line">        String cfName = columnFamily.getNameAsString();</span><br><span class="line">        <span class="comment">//对名字名为cf1的列簇进行修改</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;cf1&quot;</span>.equals(cfName))&#123;</span><br><span class="line">            <span class="comment">//修改TTL,重新设为10000</span></span><br><span class="line">            columnFamily.setTimeToLive(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修改表的结构</span></span><br><span class="line">    admin.modifyTable(table,tableDescriptor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="putAll操作"><a href="#putAll操作" class="headerlink" title="putAll操作"></a>putAll操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//putAll 读取students.txt 并且将数据写入HBase</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建students表 info</span></span><br><span class="line">        Admin admin = connection.getAdmin();</span><br><span class="line">        TableName studentsT = TableName.valueOf(<span class="string">&quot;students&quot;</span>);</span><br><span class="line">        <span class="comment">//判断表是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(!admin.tableExists(studentsT))&#123;</span><br><span class="line">            HTableDescriptor hTableDescriptor = <span class="keyword">new</span> HTableDescriptor(studentsT);</span><br><span class="line">            HColumnDescriptor info = <span class="keyword">new</span> HColumnDescriptor(<span class="string">&quot;info&quot;</span>);</span><br><span class="line">            HTableDescriptor hTableDescriptor1 = hTableDescriptor.addFamily(info);</span><br><span class="line">            admin.createTable(hTableDescriptor);</span><br><span class="line">        &#125;</span><br><span class="line">        Table stu = connection.getTable(studentsT);</span><br><span class="line"></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;D:\\Maven\\HBase\\data\\students.txt&quot;</span>));</span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        ArrayList&lt;Put&gt; puts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> batchSize = <span class="number">11</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取每一行数据</span></span><br><span class="line">            String[] split = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            String id = split[<span class="number">0</span>];</span><br><span class="line">            String name = split[<span class="number">1</span>];</span><br><span class="line">            String age = split[<span class="number">2</span>];</span><br><span class="line">            String gender = split[<span class="number">3</span>];</span><br><span class="line">            String clazz = split[<span class="number">4</span>];</span><br><span class="line">            Put put = <span class="keyword">new</span> Put(id.getBytes());</span><br><span class="line">            put.addColumn(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;name&quot;</span>.getBytes(), name.getBytes());</span><br><span class="line">            put.addColumn(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;age&quot;</span>.getBytes(), age.getBytes());</span><br><span class="line">            put.addColumn(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;gender&quot;</span>.getBytes(), gender.getBytes());</span><br><span class="line">            put.addColumn(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;clazz&quot;</span>.getBytes(), clazz.getBytes());</span><br><span class="line">            puts.add(put); <span class="comment">// 将每条数据构建好的put对象加入puts列表</span></span><br><span class="line">            <span class="keyword">if</span> (puts.size() == batchSize) &#123;</span><br><span class="line">                stu.put(puts); <span class="comment">// 批量写入</span></span><br><span class="line">                puts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            stu.put(put); // 逐条put</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (puts.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            stu.put(puts); <span class="comment">// 批量写入</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211014201133510.png" alt="image-20211014201133510"></p><h4 id="scan操作"><a href="#scan操作" class="headerlink" title="scan操作"></a>scan操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//scan</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Table students = connection.getTable(TableName.valueOf(<span class="string">&quot;students&quot;</span>));</span><br><span class="line">    Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line">    scan.withStartRow(<span class="string">&quot;1500100970&quot;</span>.getBytes());<span class="comment">//开始设置的Row</span></span><br><span class="line">    scan.withStopRow(<span class="string">&quot;1500100980&quot;</span>.getBytes());<span class="comment">//结束设置的Row</span></span><br><span class="line">    ResultScanner scanner = students.getScanner(scan);</span><br><span class="line">    <span class="keyword">for</span> (Result result : scanner) &#123;</span><br><span class="line">        String id = Bytes.toString(result.getRow());</span><br><span class="line">        String name = Bytes.toString(result.getValue(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;name&quot;</span>.getBytes()));</span><br><span class="line">        String age = Bytes.toString(result.getValue(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;age&quot;</span>.getBytes()));</span><br><span class="line">        String gender = Bytes.toString(result.getValue(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;gender&quot;</span>.getBytes()));</span><br><span class="line">        String clazz = Bytes.toString(result.getValue(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;clazz&quot;</span>.getBytes()));</span><br><span class="line">        System.out.println(id+<span class="string">&quot;,&quot;</span>+name+<span class="string">&quot;,&quot;</span>+age+<span class="string">&quot;,&quot;</span>+gender+<span class="string">&quot;,&quot;</span>+clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211014211423554.png" alt="image-20211014211423554"></p><h4 id="获取数据的另外一种方式"><a href="#获取数据的另外一种方式" class="headerlink" title="获取数据的另外一种方式"></a>获取数据的另外一种方式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取数据的另外一种方式</span></span><br><span class="line"><span class="comment">// 适用于每条数据结构不唯一的情况下 直接遍历每条数据包含的所有的cell</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scanWithUtil</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"> Table students = connection.getTable(TableName.valueOf(<span class="string">&quot;students&quot;</span>));</span><br><span class="line"> Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line"> scan.setLimit(<span class="number">5</span>);</span><br><span class="line"> scan.withStartRow(<span class="string">&quot;00&quot;</span>.getBytes());</span><br><span class="line"> scan.withStopRow(<span class="string">&quot;1500100010&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"> ResultScanner scanner = students.getScanner(scan);</span><br><span class="line">  <span class="keyword">for</span> (Result result : scanner) &#123;</span><br><span class="line"></span><br><span class="line">   String rk = Bytes.toString(result.getRow());</span><br><span class="line">   System.out.print(rk + <span class="string">&quot; &quot;</span>);</span><br><span class="line">   <span class="keyword">for</span> (Cell cell : result.listCells()) &#123;</span><br><span class="line">       String value = Bytes.toString(CellUtil.cloneValue(cell));</span><br><span class="line">       <span class="comment">// 列名</span></span><br><span class="line">       String qua = Bytes.toString(CellUtil.cloneQualifier(cell));</span><br><span class="line">       String cf = Bytes.toString(CellUtil.cloneFamily(cell)); <span class="comment">// 列簇名</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="string">&quot;age&quot;</span>.equals(qua)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Integer.parseInt(value) &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">               value = <span class="string">&quot;成年&quot;</span>;</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        value = <span class="string">&quot;未成年&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(value + <span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="comment">//  System.out.println(id + &quot;,&quot; + name + &quot;,&quot; + age + &quot;,&quot; + gender + &quot;,&quot; + clazz);</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="delete操作"><a href="#delete操作" class="headerlink" title="delete操作"></a>delete操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// delete table</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteTable</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Admin admin = connection.getAdmin();</span><br><span class="line">    <span class="keyword">if</span> (admin.tableExists(TableName.valueOf(<span class="string">&quot;test_cre&quot;</span>))) &#123;</span><br><span class="line">        admin.disableTable(TableName.valueOf(<span class="string">&quot;test_cre&quot;</span>));</span><br><span class="line">        admin.deleteTable(TableName.valueOf(<span class="string">&quot;test_cre&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;表不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="create操作"><a href="#create操作" class="headerlink" title="create操作"></a>create操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// create table</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Admin admin = connection.getAdmin();</span><br><span class="line">    <span class="keyword">if</span> (!admin.tableExists(TableName.valueOf(<span class="string">&quot;test_cre&quot;</span>))) &#123;</span><br><span class="line">        HTableDescriptor test_cre = <span class="keyword">new</span> HTableDescriptor(TableName.valueOf(<span class="string">&quot;test_cre&quot;</span>));</span><br><span class="line">        HColumnDescriptor cf1 = <span class="keyword">new</span> HColumnDescriptor(<span class="string">&quot;cf1&quot;</span>);</span><br><span class="line">        cf1.setMaxVersions(<span class="number">3</span>);</span><br><span class="line">        test_cre.addFamily(cf1);</span><br><span class="line">        admin.createTable(test_cre);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;表已存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211014213109678.png" alt="image-20211014213109678"></p><p>可以看到表已经创建成功。</p><h4 id="总代码如下"><a href="#总代码如下" class="headerlink" title="总代码如下"></a>总代码如下</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.util.Bytes;</span><br><span class="line"><span class="keyword">import</span> org.junit.After;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2API</span> </span>&#123;</span><br><span class="line">    Connection connection;</span><br><span class="line">    TableName table = TableName.valueOf(<span class="string">&quot;test_api&quot;</span>);</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建配置，指定zookeeper集群地址</span></span><br><span class="line">        Configuration conf = HBaseConfiguration.create();</span><br><span class="line">        conf.set(<span class="string">&quot;hbase.zookeeper.quorum&quot;</span>,<span class="string">&quot;master,node1,node2&quot;</span>);</span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        connection = ConnectionFactory.createConnection(conf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//put</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//put操作</span></span><br><span class="line">        Table test_api = connection.getTable(table);</span><br><span class="line">        Put put = <span class="keyword">new</span> Put(<span class="string">&quot;001&quot;</span>.getBytes());</span><br><span class="line">        put.addColumn(<span class="string">&quot;cf1&quot;</span>.getBytes(),<span class="string">&quot;name&quot;</span>.getBytes(),<span class="string">&quot;fangshitao&quot;</span>.getBytes());</span><br><span class="line">        test_api.put(put);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//alter table</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alter</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Admin admin = connection.getAdmin();</span><br><span class="line">        <span class="comment">//获取表原有的结构</span></span><br><span class="line">        HTableDescriptor tableDescriptor = admin.getTableDescriptor(table);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有列簇构成的HColumnDescriptor数组</span></span><br><span class="line">        HColumnDescriptor[] columnFamilies = tableDescriptor.getColumnFamilies();</span><br><span class="line">        <span class="comment">//遍历所有的列簇</span></span><br><span class="line">        <span class="keyword">for</span> (HColumnDescriptor columnFamily : columnFamilies) &#123;</span><br><span class="line">            <span class="comment">//获取列簇的名称</span></span><br><span class="line">            String cfName = columnFamily.getNameAsString();</span><br><span class="line">            <span class="comment">//对名字名为cf1的列簇进行修改</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;cf1&quot;</span>.equals(cfName))&#123;</span><br><span class="line">                <span class="comment">//修改TTL,重新设为10000</span></span><br><span class="line">                columnFamily.setTimeToLive(<span class="number">10000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//修改表的结构</span></span><br><span class="line">        admin.modifyTable(table,tableDescriptor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//get</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Table test_api = connection.getTable(table);</span><br><span class="line">        Get get = <span class="keyword">new</span> Get(<span class="string">&quot;001&quot;</span>.getBytes());</span><br><span class="line">        Result result = test_api.get(get);</span><br><span class="line">        <span class="keyword">byte</span>[] value = result.getValue(<span class="string">&quot;cf1&quot;</span>.getBytes(), <span class="string">&quot;name&quot;</span>.getBytes());</span><br><span class="line">        System.out.println(Bytes.toString(value));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//putAll 读取students.txt 并且将数据写入HBase</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建students表 info</span></span><br><span class="line">        Admin admin = connection.getAdmin();</span><br><span class="line">        TableName studentsT = TableName.valueOf(<span class="string">&quot;students&quot;</span>);</span><br><span class="line">        <span class="comment">//判断表是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(!admin.tableExists(studentsT))&#123;</span><br><span class="line">            HTableDescriptor hTableDescriptor = <span class="keyword">new</span> HTableDescriptor(studentsT);</span><br><span class="line">            HColumnDescriptor info = <span class="keyword">new</span> HColumnDescriptor(<span class="string">&quot;info&quot;</span>);</span><br><span class="line">            HTableDescriptor hTableDescriptor1 = hTableDescriptor.addFamily(info);</span><br><span class="line">            admin.createTable(hTableDescriptor);</span><br><span class="line">        &#125;</span><br><span class="line">        Table stu = connection.getTable(studentsT);</span><br><span class="line"></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;D:\\Maven\\HBase\\data\\students.txt&quot;</span>));</span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        ArrayList&lt;Put&gt; puts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> batchSize = <span class="number">11</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取每一行数据</span></span><br><span class="line">            String[] split = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            String id = split[<span class="number">0</span>];</span><br><span class="line">            String name = split[<span class="number">1</span>];</span><br><span class="line">            String age = split[<span class="number">2</span>];</span><br><span class="line">            String gender = split[<span class="number">3</span>];</span><br><span class="line">            String clazz = split[<span class="number">4</span>];</span><br><span class="line">            Put put = <span class="keyword">new</span> Put(id.getBytes());</span><br><span class="line">            put.addColumn(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;name&quot;</span>.getBytes(), name.getBytes());</span><br><span class="line">            put.addColumn(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;age&quot;</span>.getBytes(), age.getBytes());</span><br><span class="line">            put.addColumn(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;gender&quot;</span>.getBytes(), gender.getBytes());</span><br><span class="line">            put.addColumn(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;clazz&quot;</span>.getBytes(), clazz.getBytes());</span><br><span class="line">            puts.add(put); <span class="comment">// 将每条数据构建好的put对象加入puts列表</span></span><br><span class="line">            <span class="keyword">if</span> (puts.size() == batchSize) &#123;</span><br><span class="line">                stu.put(puts); <span class="comment">// 批量写入</span></span><br><span class="line">                puts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            stu.put(put); // 逐条put</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (puts.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            stu.put(puts); <span class="comment">// 批量写入</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//scan</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Table students = connection.getTable(TableName.valueOf(<span class="string">&quot;students&quot;</span>));</span><br><span class="line">        Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line">        scan.withStartRow(<span class="string">&quot;1500100970&quot;</span>.getBytes());<span class="comment">//开始设置的Row</span></span><br><span class="line">        scan.withStopRow(<span class="string">&quot;1500100980&quot;</span>.getBytes());<span class="comment">//结束设置的Row</span></span><br><span class="line">        ResultScanner scanner = students.getScanner(scan);</span><br><span class="line">        <span class="keyword">for</span> (Result result : scanner) &#123;</span><br><span class="line">            String id = Bytes.toString(result.getRow());</span><br><span class="line">            String name = Bytes.toString(result.getValue(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;name&quot;</span>.getBytes()));</span><br><span class="line">            String age = Bytes.toString(result.getValue(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;age&quot;</span>.getBytes()));</span><br><span class="line">            String gender = Bytes.toString(result.getValue(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;gender&quot;</span>.getBytes()));</span><br><span class="line">            String clazz = Bytes.toString(result.getValue(<span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;clazz&quot;</span>.getBytes()));</span><br><span class="line">            System.out.println(id+<span class="string">&quot;,&quot;</span>+name+<span class="string">&quot;,&quot;</span>+age+<span class="string">&quot;,&quot;</span>+gender+<span class="string">&quot;,&quot;</span>+clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取数据的另外一种方式</span></span><br><span class="line">    <span class="comment">// 适用于每条数据结构不唯一的情况下 直接遍历每条数据包含的所有的cell</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scanWithUtil</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Table students = connection.getTable(TableName.valueOf(<span class="string">&quot;students&quot;</span>));</span><br><span class="line">        Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line">        scan.setLimit(<span class="number">5</span>);</span><br><span class="line">        scan.withStartRow(<span class="string">&quot;00&quot;</span>.getBytes());</span><br><span class="line">        scan.withStopRow(<span class="string">&quot;1500100010&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        ResultScanner scanner = students.getScanner(scan);</span><br><span class="line">        <span class="keyword">for</span> (Result result : scanner) &#123;</span><br><span class="line"></span><br><span class="line">            String rk = Bytes.toString(result.getRow());</span><br><span class="line">            System.out.print(rk + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Cell cell : result.listCells()) &#123;</span><br><span class="line">                String value = Bytes.toString(CellUtil.cloneValue(cell));</span><br><span class="line">                <span class="comment">// 列名</span></span><br><span class="line">                String qua = Bytes.toString(CellUtil.cloneQualifier(cell));</span><br><span class="line">                String cf = Bytes.toString(CellUtil.cloneFamily(cell)); <span class="comment">// 列簇名</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;age&quot;</span>.equals(qua)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (Integer.parseInt(value) &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">                        value = <span class="string">&quot;成年&quot;</span>;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        value = <span class="string">&quot;未成年&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(value + <span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="comment">//            System.out.println(id + &quot;,&quot; + name + &quot;,&quot; + age + &quot;,&quot; + gender + &quot;,&quot; + clazz);</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// delete table</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteTable</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Admin admin = connection.getAdmin();</span><br><span class="line">        <span class="keyword">if</span> (admin.tableExists(TableName.valueOf(<span class="string">&quot;test_cre&quot;</span>))) &#123;</span><br><span class="line">            admin.disableTable(TableName.valueOf(<span class="string">&quot;test_cre&quot;</span>));</span><br><span class="line">            admin.deleteTable(TableName.valueOf(<span class="string">&quot;test_cre&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;表不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// create table</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Admin admin = connection.getAdmin();</span><br><span class="line">        <span class="keyword">if</span> (!admin.tableExists(TableName.valueOf(<span class="string">&quot;test_cre&quot;</span>))) &#123;</span><br><span class="line">            HTableDescriptor test_cre = <span class="keyword">new</span> HTableDescriptor(TableName.valueOf(<span class="string">&quot;test_cre&quot;</span>));</span><br><span class="line">            HColumnDescriptor cf1 = <span class="keyword">new</span> HColumnDescriptor(<span class="string">&quot;cf1&quot;</span>);</span><br><span class="line">            cf1.setMaxVersions(<span class="number">3</span>);</span><br><span class="line">            test_cre.addFamily(cf1);</span><br><span class="line">            admin.createTable(test_cre);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;表已存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>详细代码可以访问我的GitHub仓库地址:<a href="https://github.com/Fang-gg/HBaseJavaAPI.git">https://github.com/Fang-gg/HBaseJavaAPI.git</a></strong></p><h2 id="MR读写HBase"><a href="#MR读写HBase" class="headerlink" title="MR读写HBase"></a>MR读写HBase</h2><h2 id="HBase高可用"><a href="#HBase高可用" class="headerlink" title="HBase高可用"></a>HBase高可用</h2><p>高可用模式可以防止当HMaster挂掉之后，zk会分配一个新的HMaster，让程序继续运行。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211014223532869.png" alt="image-20211014223532869"></p><h2 id="HBase调优"><a href="#HBase调优" class="headerlink" title="HBase调优"></a>HBase调优</h2><h3 id="预分区"><a href="#预分区" class="headerlink" title="预分区"></a>预分区</h3><ul><li>默认情况下，在创建HBase表的时候会自动创建一个region分区，当导入数据的时候， 所有的HBase客户端都向这一个region写数据，直到这个region足够大了才进行切分。 一种可以加快批量写入速度的方法是通过预先创建一些空的regions，这样当数据写入 HBase时，会按照region分区情况，在集群内做数据的负载均衡。 </li><li>如果知道hbase数据表的key的分布情况，就可以在建表的时候对hbase进行region的预分区。这样做的好处是防止大数据量插入的热点问题，提高数据插入的效率。</li></ul><h4 id="预分区实现步骤"><a href="#预分区实现步骤" class="headerlink" title="预分区实现步骤"></a>预分区实现步骤</h4><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211018201306660.png" alt="image-20211018201306660"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211018201322782.png" alt="image-20211018201322782"></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="string">&#x27;分割的表名&#x27;</span>,<span class="string">&#x27;列簇名&#x27;</span>,&#123;SPLITS_FILE<span class="operator">=</span><span class="operator">&gt;</span><span class="string">&#x27;以什么作为分割的文件的路径&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211018205710464.png" alt="image-20211018205710464"></p><p>去web界面可以很清楚的看到已经分区了。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211018205745688.png" alt="image-20211018205745688"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211018205808423.png" alt="image-20211018205808423"></p><h4 id="删除分区-truncate"><a href="#删除分区-truncate" class="headerlink" title="删除分区 truncate"></a>删除分区 truncate</h4><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211018210121001.png" alt="image-20211018210121001"></p><p>可以看到此时之前创建的预分区都失效了。</p><h3 id="RowKey设计-重中之重！！！"><a href="#RowKey设计-重中之重！！！" class="headerlink" title="RowKey设计(重中之重！！！)"></a>RowKey设计(重中之重！！！)</h3><ul><li>HBase中row key用来检索表中的记录，支持以下三种方式: <ul><li>通过单个row key访问:即按照某个row key键值进行get操作; </li><li>通过row key的range进行scan:即通过设置startRowKey和endRowKey，在这个范围内进行扫描;</li><li>全表扫描:即直接扫描整张表中所有行记录。</li></ul></li></ul><p>在HBase中，row key可以是任意字符串，最大长度64KB，实际应用中一般为 10~100bytes，存为byte[]字节数组，一般设计成定长的。  </p><p><font color="red">rowkey是按照字典升序存储</font>，因此，设计row key时，要充分利用这个排序特点，将经常一起读取的数据存储到一块，将最近可能会被访问的数据放在一块。 </p><p>请参考 <strong>HBase的RowKey设计</strong></p><h2 id="HBase-BulkLoading"><a href="#HBase-BulkLoading" class="headerlink" title="HBase BulkLoading"></a>HBase BulkLoading</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol><li><p>如果我们一次性入库hbase巨量数据，处理速度慢不说，还特别占用Region资源， 一个比较高效便捷的方法就是使用 “Bulk Loading”方法，即HBase提供的HFileOutputFormat类。</p></li><li><p>它是利用hbase的数据信息按照特定格式存储在hdfs内这一原理，直接生成这种hdfs内存储的数据格式文件，然后上传至合适位置，即完成巨量数据快速入库的办法。配合mapreduce完成，高效便捷，而且不占用region资源，增添负载。</p></li></ol><h3 id="限制："><a href="#限制：" class="headerlink" title="限制："></a>限制：</h3><ol><li><p>仅适合初次数据导入，即表内数据为空，或者每次入库表内都无数据的情况。</p></li><li><p>HBase集群与Hadoop集群为同一集群，即HBase所基于的HDFS为生成HFile的MR的集群</p></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ol><li>生成HFile部分</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shujia;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.HBaseConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.KeyValue;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.TableName;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Connection;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.RegionLocator;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Table;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.io.ImmutableBytesWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.mapreduce.HFileOutputFormat2;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.mapreduce.KeyValueSortReducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.mapreduce.LoadIncrementalHFiles;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.mapreduce.SimpleTotalOrderPartitioner;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoBulkLoading</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BulkLoadingMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">ImmutableBytesWritable</span>, <span class="title">KeyValue</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            String[] splits = value.toString().split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            String mdn = splits[<span class="number">0</span>];</span><br><span class="line">            String start_time = splits[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 经度</span></span><br><span class="line">            String longitude = splits[<span class="number">4</span>];</span><br><span class="line">            <span class="comment">// 维度</span></span><br><span class="line">            String latitude = splits[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">            String rowkey = mdn + <span class="string">&quot;_&quot;</span> + start_time;</span><br><span class="line"></span><br><span class="line">            KeyValue lg = <span class="keyword">new</span> KeyValue(rowkey.getBytes(), <span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;lg&quot;</span>.getBytes(), longitude.getBytes());</span><br><span class="line">            KeyValue lt = <span class="keyword">new</span> KeyValue(rowkey.getBytes(), <span class="string">&quot;info&quot;</span>.getBytes(), <span class="string">&quot;lt&quot;</span>.getBytes(), latitude.getBytes());</span><br><span class="line"></span><br><span class="line">            context.write(<span class="keyword">new</span> ImmutableBytesWritable(rowkey.getBytes()), lg);</span><br><span class="line">            context.write(<span class="keyword">new</span> ImmutableBytesWritable(rowkey.getBytes()), lt);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Configuration conf = HBaseConfiguration.create();</span><br><span class="line">        conf.set(<span class="string">&quot;hbase.zookeeper.quorum&quot;</span>, <span class="string">&quot;master:2181,node1:2181,node2:2181&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Job实例</span></span><br><span class="line">        Job job = Job.getInstance(conf);</span><br><span class="line">        job.setJarByClass(DemoBulkLoading.class);</span><br><span class="line">        job.setJobName(<span class="string">&quot;DemoBulkLoading&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保证全局有序</span></span><br><span class="line">        job.setPartitionerClass(SimpleTotalOrderPartitioner.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置reduce个数</span></span><br><span class="line">        job.setNumReduceTasks(<span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 配置map任务</span></span><br><span class="line">        job.setMapperClass(BulkLoadingMapper.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置reduce任务</span></span><br><span class="line">        <span class="comment">// KeyValueSortReducer 保证在每个Reduce有序</span></span><br><span class="line">        job.setReducerClass(KeyValueSortReducer.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输入输出路径</span></span><br><span class="line">        FileInputFormat.addInputPath(job, <span class="keyword">new</span> Path(<span class="string">&quot;/data/DIANXIN/&quot;</span>));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(<span class="string">&quot;/data/hfile&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建HBase连接</span></span><br><span class="line">        Connection conn = ConnectionFactory.createConnection(conf);</span><br><span class="line">        <span class="comment">// create &#x27;dianxin_bulk&#x27;,&#x27;info&#x27;</span></span><br><span class="line">        <span class="comment">// 获取dianxin_bulk 表</span></span><br><span class="line">        Table dianxin_bulk = conn.getTable(TableName.valueOf(<span class="string">&quot;dianxin_bulk&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取dianxin_bulk 表 region定位器</span></span><br><span class="line">        RegionLocator regionLocator = conn.getRegionLocator(TableName.valueOf(<span class="string">&quot;dianxin_bulk&quot;</span>));</span><br><span class="line">        <span class="comment">// 使用HFileOutputFormat2将输出的数据按照HFile的形式格式化</span></span><br><span class="line">        HFileOutputFormat2.configureIncrementalLoad(job, dianxin_bulk, regionLocator);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等到MapReduce任务执行完成</span></span><br><span class="line">        job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载HFile到 dianxin_bulk 中</span></span><br><span class="line">        LoadIncrementalHFiles load = <span class="keyword">new</span> LoadIncrementalHFiles(conf);</span><br><span class="line">        load.doBulkLoad(<span class="keyword">new</span> Path(<span class="string">&quot;/data/hfile&quot;</span>), conn.getAdmin(), dianxin_bulk, regionLocator);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  create &#x27;dianxin_bulk&#x27;,&#x27;info&#x27;</span></span><br><span class="line"><span class="comment">         *  hadoop jar HBaseJavaAPI10-1.0-jar-with-dependencies.jar com.shujia.Demo1BulkLoading</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ol><li><p>最终输出结果，无论是map还是reduce，输出部分key和value的类型必须是： &lt; ImmutableBytesWritable, KeyValue&gt;或者&lt; ImmutableBytesWritable, Put&gt;。</p></li><li><p>最终输出部分，Value类型是KeyValue 或Put，对应的Sorter分别是KeyValueSortReducer或PutSortReducer。</p></li><li><p>MR例子中HFileOutputFormat2.configureIncrementalLoad(job, dianxin_bulk, regionLocator);自动对job进行配置。SimpleTotalOrderPartitioner是需要先对key进行整体排序，然后划分到每个reduce中，保证每一个reducer中的的key最小最大值区间范围，是不会有交集的。因为入库到HBase的时候，作为一个整体的Region，key是绝对有序的。</p></li><li><p>MR例子中最后生成HFile存储在HDFS上，输出路径下的子目录是各个列族。如果对HFile进行入库HBase，相当于move HFile到HBase的Region中，HFile子目录的列族内容没有了，但不能直接使用mv命令移动，因为直接移动不能更新HBase的元数据。</p></li><li><p>HFile入库到HBase通过HBase中 LoadIncrementalHFiles的doBulkLoad方法，对生成的HFile文件入库</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大数据学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HBase安装教程</title>
      <link href="/2021/10/09/HBase%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
      <url>/2021/10/09/HBase%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="HBase安装教程"><a href="#HBase安装教程" class="headerlink" title="HBase安装教程"></a>HBase安装教程</h1><p><font color="red">注意：必须建立在Hadoop和Zookeeper之上！</font></p><h2 id="启动Hadoop"><a href="#启动Hadoop" class="headerlink" title="启动Hadoop"></a>启动Hadoop</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">start-all.sh</span><br></pre></td></tr></table></figure><h2 id="启动zookeeper"><a href="#启动zookeeper" class="headerlink" title="启动zookeeper"></a>启动zookeeper</h2><p>需要在在三台中分别启动<br>zkServer.sh start<br>zkServer.sh status</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211009151600283.png" alt="image-20211009151600283"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211009151615468.png" alt="image-20211009151615468"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211009151627186.png" alt="image-20211009151627186"></p><p>可以很直观的看到全部启动成功了。</p><h2 id="搭建Hbase"><a href="#搭建Hbase" class="headerlink" title="搭建Hbase"></a>搭建Hbase</h2><h3 id="上传并且解压"><a href="#上传并且解压" class="headerlink" title="上传并且解压"></a>上传并且解压</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211009152035029.png" alt="image-20211009152035029"></p><p><strong>解压</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf hbase-1.4.6-bin.tar.gz -C /usr/<span class="built_in">local</span>/soft/</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211009161609157.png" alt="image-20211009161609157"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211009161827640.png" alt="image-20211009161827640"></p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> HBASE_HOME=/usr/<span class="built_in">local</span>/soft/hbase-1.4.6</span><br><span class="line"><span class="variable">$HBASE_HOME</span>/bin</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211009162455919.png" alt="image-20211009162455919"></p><h3 id="修改hbase-env-sh文件"><a href="#修改hbase-env-sh文件" class="headerlink" title="修改hbase-env.sh文件"></a>修改hbase-env.sh文件</h3><p><strong>增加java配置</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/soft/jdk1.8.0_171  <span class="comment">#这里的jdk版本是你自己安装过的</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211009181528582.png" alt="image-20211009181528582"></p><p><strong>关闭默认zk配置</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> HBASE_MANAGES_ZK=<span class="literal">false</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211009181607557.png" alt="image-20211009181607557"></p><h3 id="修改hbase-site-xml文件"><a href="#修改hbase-site-xml文件" class="headerlink" title="修改hbase-site.xml文件"></a>修改hbase-site.xml文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;property&gt; </span><br><span class="line">   &lt;name&gt;hbase.rootdir&lt;/name&gt; </span><br><span class="line">   &lt;value&gt;hdfs://master:9000/hbase&lt;/value&gt; </span><br><span class="line">&lt;/property&gt; </span><br><span class="line">&lt;property&gt; </span><br><span class="line">   &lt;name&gt;hbase.cluster.distributed&lt;/name&gt; </span><br><span class="line">   &lt;value&gt;<span class="literal">true</span>&lt;/value&gt; </span><br><span class="line">&lt;/property&gt; </span><br><span class="line">&lt;property&gt; </span><br><span class="line">   &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt; </span><br><span class="line">   &lt;value&gt;node1,node2,master&lt;/value&gt; </span><br><span class="line">&lt;/property&gt; </span><br></pre></td></tr></table></figure><h3 id="修改regionservers文件"><a href="#修改regionservers文件" class="headerlink" title="修改regionservers文件"></a>修改regionservers文件</h3><p><strong>增加</strong><br>node1<br>node2</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211009181807643.png" alt="image-20211009181807643"></p><p>注意：如果是伪分布式版本，增加master即可</p><h3 id="同步到所有节点"><a href="#同步到所有节点" class="headerlink" title="同步到所有节点"></a>同步到所有节点</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -r hbase-1.4.6/ node1:/usr/<span class="built_in">local</span>/soft/</span><br><span class="line">scp -r hbase-1.4.6/ node2:/usr/<span class="built_in">local</span>/soft/</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211009181941020.png" alt="image-20211009181941020"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211009182113375.png" alt="image-20211009182113375"></p><h3 id="启动hbase集群，需要在master上执行"><a href="#启动hbase集群，需要在master上执行" class="headerlink" title="启动hbase集群，需要在master上执行"></a>启动hbase集群，需要在master上执行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">start-hbase.sh</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211009182516960.png" alt="image-20211009182516960"></p><h2 id="至此HBase已经部署完成，进入web端查看下"><a href="#至此HBase已经部署完成，进入web端查看下" class="headerlink" title="至此HBase已经部署完成，进入web端查看下"></a>至此HBase已经部署完成，进入web端查看下</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://master:16010</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211009182647001.png" alt="image-20211009182647001"></p><p>可以很直观的看到已经搭建完毕。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HiveSQL练习题</title>
      <link href="/2021/10/08/HiveSQL%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
      <url>/2021/10/08/HiveSQL%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="HiveSQL练习题"><a href="#HiveSQL练习题" class="headerlink" title="HiveSQL练习题"></a>HiveSQL练习题</h1><p>建表语句：<br><strong>员工信息表emp：</strong><br>字段：员工id,员工名字,工作岗位,部门经理,受雇日期,薪水,奖金,部门编号<br>英文名：EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,BONUS,DEPTNO</p><p>create table emp(<br>EMPNO int<br>,ENAME string<br>,JOB string<br>,MGR int<br>,HIREDATE string<br>,SAL int<br>,BONUS int<br>,DEPTNO int<br>)<br>row format delimited<br>fields terminated by ‘,’;</p><p>7369,SMITH,CLERK,7902,1980-12-17,800,null,20<br>7499,ALLEN,SALESMAN,7698,1981-02-20,1600,300,30<br>7521,WARD,SALESMAN,7698,1981-02-22,1250,500,30<br>7566,JONES,MANAGER,7839,1981-04-02,2975,null,20,<br>7654,MARTIN,SALESMAN,7698,1981-09-28,1250,1400,30<br>7698,BLAKE,MANAGER,7839,1981-05-01,2850,null,30<br>7782,CLARK,MANAGER,7839,1981-06-09,2450,null,10<br>7788,SCOTT,ANALYST,7566,1987-04-19,3000,null,20<br>7839,KING,PRESIDENT,null,1981-11-17,5000,null,10<br>7844,TURNER,SALESMAN,7698,1981-09-08,1500,0,30<br>7876,ADAMS,CLERK,7788,1987-05-23,1100,null,20<br>7900,JAMES,CLERK,7698,1981-12-03,950,null,30<br>7902,FORD,ANALYST,7566,1981-12-03,3000,null,20<br>7934,MILLER,CLERK,7782,1982-01-23,1300,null,10</p><p><strong>部门信息表dept：</strong><br>字段：部门编号,部门名称,部门地点<br>英文名：DEPTNO,DEPTNAME,DEPTADDR</p><p>create table dept(<br>DEPTNO int<br>,DEPTNAME string<br>,DEPTADDR string<br>)<br>row format delimited<br>fields terminated by ‘,’;</p><p>10,ACCOUNTING,NEW YORK<br>10,ACCOUNTING,shanghai<br>20,RESEARCH,DALLAS<br>30,SALES,CHICAGO<br>40,OPERATIONS,BOSTON</p><h2 id="题目与答案"><a href="#题目与答案" class="headerlink" title="题目与答案"></a>题目与答案</h2><p>1． 列出至少有一个员工的所有部门。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(*) as c,deptno from emp group by deptno having c &gt;= 1;</span><br></pre></td></tr></table></figure><p>2． 列出薪金比“SMITH”多的所有员工。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MySQL:</span><br><span class="line">select * from emp where sal &gt; (select sal from emp where ename = &#x27;SMITH&#x27;);</span><br><span class="line"></span><br><span class="line">Hive:</span><br><span class="line">select a.ename,a.sal from</span><br><span class="line">(select ename,sal,1 as cid from emp) as a</span><br><span class="line">left join</span><br><span class="line">(select sal ,1 as cid from emp where ename=‘SMITH’) as b</span><br><span class="line">on a.cid=b.cid where a.sal&gt;b.sal;</span><br></pre></td></tr></table></figure><p>3． 列出所有员工的姓名及其直接上级的姓名。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MySQL:</span><br><span class="line">select worker.ename,boss.ename from emp as worker left join emp as boss on worker.mgr = boss.empno;</span><br><span class="line"></span><br><span class="line">Hive:</span><br><span class="line">select a.ename,b.ename from</span><br><span class="line">(select ename,mgr from emp) as a</span><br><span class="line">left join</span><br><span class="line">(select ename,empno from emp) as b</span><br><span class="line">on a.mgr=b.empno</span><br></pre></td></tr></table></figure><p>4． 列出受雇日期早于其直接上级的所有员工。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select worker.ename,boss.ename</span><br><span class="line">from</span><br><span class="line">(select empno,ename,hiredate from emp) as boss</span><br><span class="line">right join</span><br><span class="line">(select mgr,ename,hiredate from emp) as worker</span><br><span class="line">on boss.empno=worker.mgr</span><br><span class="line">where boss.hiredate&gt;worker.hiredate</span><br></pre></td></tr></table></figure><p>5． 列出部门名称和这些部门的员工信息，同时列出那些没有员工的部门。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp as t1</span><br><span class="line">left join dept as t2</span><br><span class="line">on t1.deptno=t2.deptno</span><br></pre></td></tr></table></figure><p>6． 列出所有“CLERK”（办事员）的姓名及其部门名称。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select t1.ename,t2.deptname</span><br><span class="line">from</span><br><span class="line">(select ename,deptno from emp where job=‘CLERK’) as t1</span><br><span class="line">left join</span><br><span class="line">dept as t2</span><br><span class="line">on t1.deptno=t2.deptno</span><br></pre></td></tr></table></figure><p>7． 列出最低薪金大于1500的各种工作。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select job</span><br><span class="line">from</span><br><span class="line">(select job,min(sal) as min_sal from emp group by job) as t</span><br><span class="line">where min_sal &gt; 1500</span><br></pre></td></tr></table></figure><p>8． 列出在部门“SALES”（销售部）工作的员工的姓名，假定不知道销售部的部门编号</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select t1.ename</span><br><span class="line">from emp t1</span><br><span class="line">join</span><br><span class="line">dept t2</span><br><span class="line">on t1.deptno=t2.deptno</span><br><span class="line">where t2.deptname=‘SALES’</span><br><span class="line"></span><br><span class="line">select t1.name</span><br><span class="line">from emp t1</span><br><span class="line">join</span><br><span class="line">(select deptno from dept where deptname=‘SALES’) t2</span><br><span class="line">on t1.deptno=t2.deptno</span><br></pre></td></tr></table></figure><p>9． 列出薪金高于公司平均薪金的所有员工。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select t1.ename,t1.sal ,t2.avg_sal</span><br><span class="line">from</span><br><span class="line">(select ename,sal,1 as cid from emp) as t1</span><br><span class="line">join</span><br><span class="line">(select avg(sal) as avg_sal,1 as cid from emp) as t2</span><br><span class="line">on t1.cid=t2.cid</span><br><span class="line">where t1.sal&gt;t2.avg_sal</span><br></pre></td></tr></table></figure><p>10．列出与“SCOTT”从事相同工作的所有员工。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select t1.ename</span><br><span class="line">from</span><br><span class="line">(select ename,job,1 as cid from emp) as t1</span><br><span class="line">join</span><br><span class="line">(select job,1 as cid from emp where ename=‘SCOTT’) as t2</span><br><span class="line">on t1.cid=t2.cid</span><br><span class="line">where t1.job=t2.job and t1.ename!=‘SCOTT’</span><br></pre></td></tr></table></figure><p>11．列出薪金 等于部门30中 员工的薪金 的所有员工的姓名和薪金。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select t1.ename,t1.sal</span><br><span class="line">from emp as t1</span><br><span class="line">join</span><br><span class="line">(select distinct SAL from emp where DEPTNO = 30) t2</span><br><span class="line">on t1.sal=t2.sal</span><br><span class="line">where t1.deptno!=30</span><br></pre></td></tr></table></figure><p>12．列出薪金高于在部门30工作的所有员工的薪金的员工姓名和薪金。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select t1.ename,t1.sal</span><br><span class="line">from (select ename,sal,1 as cid from emp where deptno!=30) as t1</span><br><span class="line">left join</span><br><span class="line">(select max(sal) as max_sal,1 as cid from emp where deptno=30) as t2</span><br><span class="line">on t1.cid=t2.cid</span><br><span class="line">where t1.sal&gt;t2.max_sal</span><br></pre></td></tr></table></figure><p>13．列出在每个部门工作的员工数量、平均工资和平均服务期限。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select t1.deptno,t1.people,t2.avg_sal,t3.avg_time</span><br><span class="line">from</span><br><span class="line">(select count(*) as people,deptno from emp group by deptno) as t1</span><br><span class="line">left join</span><br><span class="line">(select round(avg(sal),2) as avg_sal,deptno from emp group by deptno) as t2</span><br><span class="line">on t1.deptno=t2.deptno</span><br><span class="line">left join</span><br><span class="line">(select round(avg(datediff(current_date,hiredate)),2) as avg_time,deptno from emp group by deptno) as t3</span><br><span class="line">on t2.deptno=t3.deptno</span><br></pre></td></tr></table></figure><p>14．列出所有员工的姓名、部门名称和工资。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select t1.ename,t2.deptname,t1.sal</span><br><span class="line">from emp as t1</span><br><span class="line">left join</span><br><span class="line">dept as t2</span><br><span class="line">on t1.deptno=t2.deptno</span><br></pre></td></tr></table></figure><p>15．列出所有部门的详细信息和部门人数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select *</span><br><span class="line">from</span><br><span class="line">(select * from dept) as t1</span><br><span class="line">left join</span><br><span class="line">(select deptno,count(*) from emp group by deptno) as t2</span><br><span class="line">on t1.deptno=t2.deptno</span><br></pre></td></tr></table></figure><p>16．列出各种工作的最低工资。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select job,min(sal) from emp group by job</span><br></pre></td></tr></table></figure><p>17．列出各个部门的MANAGER（经理）的最低薪金。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select deptno,ename,min(sal) from emp where job=‘MANAGER’ group by deptno,ename</span><br></pre></td></tr></table></figure><p>18．列出所有员工的年工资,按年薪从低到高排序。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ename,(sal+if(bonus is null,0,bonus))*12 as year_sal from emp</span><br><span class="line">order by year_sal</span><br></pre></td></tr></table></figure><ol start="19"><li>列出每个部门薪水最高的前两名人员名称以及薪水。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ename,sal</span><br><span class="line">from</span><br><span class="line">(select ename,sal,deptno,row_number() over(partition by deptno order by sal desc) as rk</span><br><span class="line">from emp) as t</span><br><span class="line">where rk&lt;=2</span><br></pre></td></tr></table></figure><ol start="20"><li>列出每个员工从受雇开始到2018-12-12 为止共受雇了多少天。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ename,datediff(‘2018-12-12’,hiredate) from emp</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大数据学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive学习小结</title>
      <link href="/2021/09/26/Hive%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
      <url>/2021/09/26/Hive%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Hive学习小结"><a href="#Hive学习小结" class="headerlink" title="Hive学习小结"></a>Hive学习小结</h1><h2 id="Hive概述"><a href="#Hive概述" class="headerlink" title="Hive概述"></a>Hive概述</h2><p>Hive：由Facebook开源用于解决<font color="red">海量结构化日志</font>的数据统计。</p><p>Hive时基于Hadoop的一个<font color="red">数据仓库工具</font>,可以将<font color="red">结构化的数据文件映射为一张表</font>，并且提供<font color="red">类SQL</font>查询功能。</p><p><font color="red">本质是：将HQL转化成MapReduce程序。</font></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210926161107566.png" alt="image-20210926161107566"></p><ul><li>Hive处理的数据存储在HDFS上</li><li>Hive分析数据底层的默认实现时MapReduce</li><li>执行程序运行在Yarn上</li></ul><h2 id="Hive优缺点"><a href="#Hive优缺点" class="headerlink" title="Hive优缺点"></a>Hive优缺点</h2><p><strong>优点：</strong></p><ul><li>操作接口采用类SQL语法，提供快速开发的能力(简单、容易上手)</li><li>避免了去写MapReduce，减少开发人员的学习成本</li><li>Hive的执行延迟比较高，因此Hive常用于数据分析，对实时性要求不高的场合</li><li>Hive优势在于处理大数据，对于处理小数据没有优势，因为Hive的执行延迟比较高</li><li>Hive支持用户自定义函数，用户可以根据自己的需求来实现自己的函数</li></ul><p><strong>缺点：</strong></p><ul><li>Hive的HQL表达能力有限<ul><li>迭代式算法无法表达</li><li>数据挖掘方面不擅长</li></ul></li><li>Hive的效率比较低<ul><li>Hive自动生成的MapReduce作业，通常情况下不够智能化</li><li>Hive调优比较困难，粒度较粗</li></ul></li></ul><h2 id="Hive架构原理"><a href="#Hive架构原理" class="headerlink" title="Hive架构原理"></a>Hive架构原理</h2><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210926162659494.png" alt="image-20210926162659494"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210926163152731.png" alt="image-20210926163152731"></p><h2 id="数据上传"><a href="#数据上传" class="headerlink" title="数据上传"></a>数据上传</h2><p>将本地数据上传可以用两种方法</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法一：</span></span><br><span class="line">hadoop dfs -put xxx---本地数据的绝对路径 /user/hive/warehouse/xx--这个xx是你自己闯的数据库</span><br><span class="line"></span><br><span class="line"><span class="comment">#方法二：</span></span><br><span class="line">直接在hive里面输入</span><br><span class="line">load data <span class="built_in">local</span> inpath <span class="string">&#x27;xxx--本地数据的绝对路径&#x27;</span> into table xxx--你自己c</span><br></pre></td></tr></table></figure><h2 id="数据导出"><a href="#数据导出" class="headerlink" title="数据导出"></a>数据导出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert overwrite local directory &#x27;xxx--本地路径&#x27; select查询语句；</span><br></pre></td></tr></table></figure><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><h3 id="创表相关"><a href="#创表相关" class="headerlink" title="创表相关"></a>创表相关</h3><p>Hive表的默认分割符是：\001</p><p>以后创建表肯定要做分割的，所以需要在创表语句之后加上。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">row format delimited fields terminated by <span class="string">&#x27;xxx--你需要按照什么去分割&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="查看数据库更多详细信息：desc"><a href="#查看数据库更多详细信息：desc" class="headerlink" title="查看数据库更多详细信息：desc"></a>查看数据库更多详细信息：desc</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">desc database extended xxx--你需要删除的数据库名字</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210927210449453.png" alt="image-20210927210449453"></p><h3 id="删除数据库：drop"><a href="#删除数据库：drop" class="headerlink" title="删除数据库：drop"></a>删除数据库：drop</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">drop database xxx--你需要删除的数据库名字</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210927210838970.png" alt="image-20210927210838970"></p><h3 id="数据库表的操作"><a href="#数据库表的操作" class="headerlink" title="数据库表的操作"></a>数据库表的操作</h3><h4 id="内部表操作"><a href="#内部表操作" class="headerlink" title="内部表操作"></a>内部表操作</h4><h5 id="创建表的语法"><a href="#创建表的语法" class="headerlink" title="创建表的语法"></a>创建表的语法</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create [external] table [<span class="keyword">if</span> not exists] table_name(</span><br><span class="line">col_name data_type [comment <span class="string">&#x27;字段描述信息&#x27;</span>]</span><br><span class="line">col_name data_type [comment <span class="string">&#x27;字段描述信息&#x27;</span>]</span><br><span class="line">[comment <span class="string">&#x27;表的描述信息&#x27;</span>]</span><br><span class="line">[partitioned by (col_name data_type),...]</span><br><span class="line">[clustered by (col_name,col_name,...]</span><br><span class="line">[sorted by (col_name [asc|desc],...) into num_buckets buckets]</span><br><span class="line">[row format row_format]</span><br><span class="line">[storted as ...]</span><br><span class="line">[location <span class="string">&#x27;指定表的路径&#x27;</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>create table<ul><li>创建一个指定名字的表。如果相同名字的表已经存在，则抛出异常；用户可以用IF NOT EXISTS 选项来忽略这个一场</li></ul></li><li>external<ul><li>可以让用户创建一个外部表，在建表的同时指定一个指向实际数据的路径(LOCATION)，<font color="red">Hive创建内部表时，会将数据移动到数据仓库指向的路径；若创建外部表，仅记录数据所在的路径，不对数据的位置做任何改变。在删除表的时候，内部表的元数据和数据会被一起删除，而外部表只删除元数据，不删除数据。</font></li></ul></li><li>comment<ul><li>表示注释，默认不能使用中文</li></ul></li><li>partitioned by<ul><li>表示使用表分区，一个表可以拥有一个或者多个分区，每一个分区单独存在一个目录下</li></ul></li><li>clustered by<ul><li>对于每一个表分文件，Hive可以进行组织成桶，也就是说桶是更为细粒度的数据范围划分。Hive也是针对某一列进行桶的组织</li></ul></li><li>sorted by<ul><li>指定排序字段和排序规则</li></ul></li><li>row format<ul><li>指定表文件字段分隔符</li></ul></li><li>storted as<ul><li>指定表文件的存储格式。常用格式：SEQUENCEFILE,TEXTFILE,RCFILE,如果数据是纯文本，可以使用STORED AS TEXTFILE。如果数据需要压缩，使用storted as SEQUENCEFILE。</li></ul></li><li>location<ul><li>指定表文件的存储路径</li></ul></li></ul><h5 id="创建表并且指定文件的存放路径"><a href="#创建表并且指定文件的存放路径" class="headerlink" title="创建表并且指定文件的存放路径"></a>创建表并且指定文件的存放路径</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create table <span class="keyword">if</span> not exists table_name(id int,name string,...) row format delimited fields terminated by <span class="string">&#x27;,&#x27;</span> location <span class="string">&#x27;xxx--你需要存放的路径&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="根据查询结果创建表"><a href="#根据查询结果创建表" class="headerlink" title="根据查询结果创建表"></a>根据查询结果创建表</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create table table_name as select * from table_name1; <span class="comment"># 通过复制表结构和表内容创建新表</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210927220531314.png" alt="image-20210927220531314"></p><h5 id="根据已经存在的表结构创建表"><a href="#根据已经存在的表结构创建表" class="headerlink" title="根据已经存在的表结构创建表"></a>根据已经存在的表结构创建表</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create table table_name like table_name1; <span class="comment"># 只会创建出表的结构，并不会同时创建表中的数据</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210927220740030.png" alt="image-20210927220740030"></p><h5 id="查看表的详细信息"><a href="#查看表的详细信息" class="headerlink" title="查看表的详细信息"></a>查看表的详细信息</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">desc formatted xxx--你表的名字</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210928194521758.png" alt="image-20210928194521758"></p><h5 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">drop table xxx--你表的名字</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210928194636315.png" alt="image-20210928194636315"></p><p>其实是将数据移动到了回收站。</p><h4 id="外部表操作"><a href="#外部表操作" class="headerlink" title="外部表操作"></a>外部表操作</h4><h5 id="外部表说明"><a href="#外部表说明" class="headerlink" title="外部表说明"></a>外部表说明</h5><p>外部表因为是指定其他的hdfs路径的数据加载到表当中来，所以hive表会认为自己不完全独占这份数据，所以删除hive表的时候，数据仍然存放在hdfs当中，不会删掉。</p><h5 id="内部表和外部表的使用场景"><a href="#内部表和外部表的使用场景" class="headerlink" title="内部表和外部表的使用场景"></a>内部表和外部表的使用场景</h5><p>例如：每天需要将收集到的网站日志定期流入HDFS文本文件中。然后在这个基础上对数据做大量分析，而这个数据可能要对很多部门进行共享，那么这个时候我们就需要用到外部表。而每个部门经过分析之后得到了属于自己的一些结果，那么我们就可以将生成的一些中间表，结果表使用内部表存储。数据通过SELECT+INSERT进入内部表。</p><p><strong>创建外部表的时候只需要加上external关键字即可。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210928195839473.png" alt="image-20210928195839473"></p><p>此时创建的这张表就是外部表。</p><h5 id="查询表的类型"><a href="#查询表的类型" class="headerlink" title="查询表的类型"></a>查询表的类型</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">desc formatted xx--你的表的名字</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211005104849992.png" alt="image-20211005104849992"></p><h5 id="修改表为外部表"><a href="#修改表为外部表" class="headerlink" title="修改表为外部表"></a>修改表为外部表</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alter table xx--你需要修改表的名字 <span class="built_in">set</span> tblproperties(<span class="string">&#x27;EXTERNAL&#x27;</span>=<span class="string">&#x27;TRUE&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211005105148917.png" alt="image-20211005105148917"></p><p>此时就能很直观的看到已经修改为外部表了。</p><p><font color="red">注意：’EXTERNAL’=’TRUE’必须是大写！！！</font></p><h4 id="分区表的操作"><a href="#分区表的操作" class="headerlink" title="分区表的操作"></a>分区表的操作</h4><p>在大数据中，最常用的一种思想就是分治，我们可以把大的文件切割划分成一个个的小的文件，这样每次操作一个小的文件就会很容易了，同样的道理，在hive当中也是支持这种思想的，就是我们可以把大的数据，按照每月，或者天进行切分成一个个的小的文件，存放在不同的文件夹中。</p><p><strong>关键字：partitioned by</strong></p><p>例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create table fst(id int,name string) partitioned by (xxx--你要以什么作为分区) row format delimited fields terminated by <span class="string">&#x27;\t&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210928220614714.png" alt="image-20210928220614714"></p><h5 id="加载数据到分区"><a href="#加载数据到分区" class="headerlink" title="加载数据到分区"></a>加载数据到分区</h5><p>因为之前已经分过区了，所以加载数据进去的时候需要指明以什么作为分区。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210928220907209.png" alt="image-20210928220907209"></p><h5 id="增加分区"><a href="#增加分区" class="headerlink" title="增加分区"></a>增加分区</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alter table xx--你的表 add partition (xxx--你的分区)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211005111122502.png" alt="image-20211005111122502"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211005111139585.png" alt="image-20211005111139585"></p><h5 id="查看分区"><a href="#查看分区" class="headerlink" title="查看分区"></a>查看分区</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">show partitions xxx--你自己的数据表</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210928221225302.png" alt="image-20210928221225302"></p><h5 id="删除分区"><a href="#删除分区" class="headerlink" title="删除分区"></a>删除分区</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alter table xxx--你自己的表 drop partition(xxx--你刚刚创的分区);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210928221456978.png" alt="image-20210928221456978"></p><p>可以清楚的看到我刚创的分区已经被我给删除了。</p><h5 id="修复表"><a href="#修复表" class="headerlink" title="修复表"></a>修复表</h5><p>当表与数据文件之间的映射关系没有建立起来时，可以对表进行修复，重新建立映射关系。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msck repair table xxx--你自己表的名称;</span><br></pre></td></tr></table></figure><h4 id="动态分区"><a href="#动态分区" class="headerlink" title="动态分区"></a>动态分区</h4><p>动态分区：根据数据中某几列的不同的取值划分不同的分区。但是在Hive中是默认不开启动态分区的。我们要想进行动态分区，就需要开启它。</p><h5 id="开启Hive的动态分区功能"><a href="#开启Hive的动态分区功能" class="headerlink" title="开启Hive的动态分区功能"></a>开启Hive的动态分区功能</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> hive.exec.dynamic.partition=<span class="literal">true</span>;<span class="comment"># 表示开启动态分区set hive.exec.dynamic.partition.mode=nostrict;# 表示动态分区模式：strict（需要配合静态分区一起使用）、nostrictset hive.exec.max.dynamic.partitions.pernode=1000;# 表示支持的最大的分区数量为1000，可以根据业务自己调整</span></span><br></pre></td></tr></table></figure><h4 id="分桶表操作"><a href="#分桶表操作" class="headerlink" title="分桶表操作"></a>分桶表操作</h4><p><font color="red">分区针对的是数据的存储路径，分桶针对的是数据文件</font></p><p>分桶，就是将数据按照指定的字段进行划分到多个文件当中去，分桶就是MapReduce中的分区。</p><p>Hive默认的是关闭了分桶功能，此时我们要想进行分桶操作，就要开启它。</p><h5 id="开启Hive的分桶功能"><a href="#开启Hive的分桶功能" class="headerlink" title="开启Hive的分桶功能"></a>开启Hive的分桶功能</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> hive.enforce.bucketing=<span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h5 id="设置Reduce个数"><a href="#设置Reduce个数" class="headerlink" title="设置Reduce个数"></a>设置Reduce个数</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> mapreduce.job.reduce=3;</span><br></pre></td></tr></table></figure><h5 id="创建分桶表"><a href="#创建分桶表" class="headerlink" title="创建分桶表"></a>创建分桶表</h5><p><strong>关键字：clustered by</strong></p><p>例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create table course(c_id string,c_name string,t_id string) clustered by (c_id) into 3 buckets row format delimited fields terminated by <span class="string">&#x27;\t&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>桶表中的数据加载，由于桶表的数据加载通过hdfs dfs -put文件或者通过load data均不好使，只能通过insert overwrite。</p><p>创建普通表，并通过insert overwrite的方式将普通表通过查询的方式加载到桶表当中去。</p><h5 id="创建普通表"><a href="#创建普通表" class="headerlink" title="创建普通表"></a>创建普通表</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create table course_common(c_id string,c_name string,t_id string) row format delimited fields terminated by <span class="string">&#x27;\t&#x27;</span>;</span><br></pre></td></tr></table></figure><h5 id="普通表中加载数据"><a href="#普通表中加载数据" class="headerlink" title="普通表中加载数据"></a>普通表中加载数据</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">load data <span class="built_in">local</span> inpath <span class="string">&#x27;xxx--你自己数据的路径&#x27;</span> into table course_common;</span><br></pre></td></tr></table></figure><h5 id="通过insert-overwrite给桶表中加载数据"><a href="#通过insert-overwrite给桶表中加载数据" class="headerlink" title="通过insert overwrite给桶表中加载数据"></a>通过insert overwrite给桶表中加载数据</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">insert overwrite table course select * from course_common cluster by (c_id);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210929194140298.png" alt="image-20210929194140298"></p><p>可以很直观的看到确实将数据分成了3份。</p><h3 id="修改表的结构"><a href="#修改表的结构" class="headerlink" title="修改表的结构"></a>修改表的结构</h3><h4 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alter table old_table_name rename to new_table_name;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210929194651269.png" alt="image-20210929194651269"></p><p>可以很明确的看到已经修改成功了。</p><h4 id="添加列"><a href="#添加列" class="headerlink" title="添加列"></a>添加列</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alter table xxx--你需要添加的列的表 add columns (xxx--这是你需要添加的字段)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210929195327460.png" alt="image-20210929195327460"></p><p>可以很清楚的看到添加成功了。</p><h4 id="更新列"><a href="#更新列" class="headerlink" title="更新列"></a>更新列</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alter table xxx---你需要修改的列的表 change column x--原来列的名字 xx--新的列名字 xxx--新的列属性</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210929195801325.png" alt="image-20210929195801325"></p><h2 id="Hive语法"><a href="#Hive语法" class="headerlink" title="Hive语法"></a>Hive语法</h2><p>和MySQL中的基本类似。</p><ul><li>order by会对输入做全局排序，因此只有一个reducer，会导致当输入规模较大时，需要较长的计算时间。</li><li>sort by不是全局排序，其在数据进入reducer前完成排序。因此，如果使用sort by进行排序，并且设置mapred.reduce.task&gt;1,则sort by只保证每个reducer的输出有序，不保证全局有序。</li><li>distribute by(字段)根据指定的字段将数据分到不同的reducer，且分发算法是hash散列。</li><li>cluster by(字段)除了具有distribute by的功能外，还会对该字段进行排序。</li></ul><p>因此，如果distribute和sort字段是同一个时，此时，<font color="red">cluster by = distribute by + sort by。</font></p><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><ul><li>count()：求总行数</li><li>max：求最大值</li><li>min：求最小值</li><li>sum：求和</li><li>avg：求平均值</li></ul><h3 id="LIMIT语句"><a href="#LIMIT语句" class="headerlink" title="LIMIT语句"></a>LIMIT语句</h3><p>典型的查询会返回多行数据。LIMIT子句用于限制返回的行数。和MySQL中的一样。</p><h3 id="WHERE语句"><a href="#WHERE语句" class="headerlink" title="WHERE语句"></a>WHERE语句</h3><p>和MySQL中用法一样。</p><h3 id="GROUP-BY语句"><a href="#GROUP-BY语句" class="headerlink" title="GROUP BY语句"></a>GROUP BY语句</h3><p>和MySQL中一样，值得注意的是：在hive中，select后面的字段必须和分组的字段一样，也可以省略不写，这点和MySQL中的有点区别。</p><h3 id="HIVING语句"><a href="#HIVING语句" class="headerlink" title="HIVING语句"></a>HIVING语句</h3><ul><li>having与where不同点<ul><li>where针对表中的列发挥作用，查询数据；having针对查询结果中的列发挥作用，筛选数据。</li><li>where后面不能写分组函数，而having后面可以使用分组函数。</li><li>having只用于group by分组统计语句</li></ul></li></ul><h3 id="表的别名"><a href="#表的别名" class="headerlink" title="表的别名"></a>表的别名</h3><ul><li>好处<ul><li>使用别名可以简化查询</li><li>使用别名前缀可以提高执行效率</li></ul></li></ul><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="全局排序"><a href="#全局排序" class="headerlink" title="全局排序"></a>全局排序</h4><p>Order By：全局排序，只能有一个reduce；</p><ul><li>使用order by子句排序默认升序：ASC;降序：DESC</li><li>order by子句在select语句的结尾。</li></ul><h4 id="每个MapReduce内部排序-sort-by-局部排序"><a href="#每个MapReduce内部排序-sort-by-局部排序" class="headerlink" title="每个MapReduce内部排序(sort by)局部排序"></a>每个MapReduce内部排序(sort by)局部排序</h4><p>sort by：每个MapReduce内部进行排序，对全局结果集来说不是排序。</p><p>设置reduce个数</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> mapreduce.job.reduce=3;</span><br></pre></td></tr></table></figure><p>查看设置reduce个数</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> mapreduce.job.reduces;</span><br></pre></td></tr></table></figure><p>将查询结果文件导入到本地</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert overwrite local directory &#x27;xxx--本地路径&#x27; select查询语句；</span><br></pre></td></tr></table></figure><h4 id="分区排序-DISTRIBUTE-BY"><a href="#分区排序-DISTRIBUTE-BY" class="headerlink" title="分区排序(DISTRIBUTE BY)"></a>分区排序(DISTRIBUTE BY)</h4><p>Distribute By：类似MR中的partition，进行分区，结合sort by使用。</p><p>注意：Hive要求distribute by语句要写在sort by语句之前</p><p>对于distribute by进行测试，一定要分配多个reduce进行处理，否则无法看到distribute by的效果。</p><p>设置reduce的个数，将我们对应的文件划分到对应的reduce中去。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> mapreduce.job.reduces=xx--你想设置的个数；</span><br></pre></td></tr></table></figure><h4 id="Cluster-By"><a href="#Cluster-By" class="headerlink" title="Cluster By"></a>Cluster By</h4><p>当distribute by和sort by字段相同时，可以使用cluster by方式。</p><p>cluster by除了具有distribute by的功能外还兼具sort by的功能。但是排序<font color="red">只能是升序排序，</font>不能指定排序规则为ASC或者DESC。</p><h2 id="Hive函数"><a href="#Hive函数" class="headerlink" title="Hive函数"></a>Hive函数</h2><h3 id="空字段赋值"><a href="#空字段赋值" class="headerlink" title="空字段赋值"></a>空字段赋值</h3><p>NVL：给值为NULL的数据赋值，它的格式是NVL(string1，replace_with)。它的功能是如果string1为NULL，则NVL函数返回replace_with，否则返回string1的值，如果两个参数都为NULL，则返回NULL。</p><h3 id="时间类"><a href="#时间类" class="headerlink" title="时间类"></a>时间类</h3><ul><li>date_format:格式化时间</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211005143243726.png" alt="image-20211005143243726"></p><ul><li>date_add:时间跟天数相加</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211005143310544.png" alt="image-20211005143310544"></p><ul><li>date_sub:时间跟天数相减</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211005143349752.png" alt="image-20211005143349752"></p><ul><li>datediff:两个时间相减</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211005143430189.png" alt="image-20211005143430189"></p><h3 id="行转列"><a href="#行转列" class="headerlink" title="行转列"></a>行转列</h3><p>CONCAT(string A/col, string B/col…)：返回输入字符串连接后的结果，支持任意个输入字符串;</p><p>CONCAT_WS(separator, str1, str2,…)：它是一个特殊形式的 CONCAT()。第一个参数剩余参数间的分隔符。分隔符可以是与剩余参数一样的字符串。如果分隔符是 NULL，返回值也将为 NULL。这个函数会跳过分隔符参数后的任何 NULL 和空字符串。分隔符将被加到被连接的字符串之间;</p><p>COLLECT_SET(col)：函数只接受基本数据类型，它的主要作用是将某字段的值进行去重汇总，产生 array 类型字段。</p><h4 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h4><p>拼接任意字符串</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211005154504775.png" alt="image-20211005154504775"></p><h4 id="concat-ws"><a href="#concat-ws" class="headerlink" title="concat_ws"></a>concat_ws</h4><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211005155520173.png" alt="image-20211005155520173"></p><h3 id="列转行"><a href="#列转行" class="headerlink" title="列转行"></a>列转行</h3><p>EXPLODE(col)：将 hive 一列中复杂的 array 或者 map 结构拆分成多行。</p><p>LATERAL VIEW</p><p>用法：LATERAL VIEW udtf(expression) tableAlias AS columnAlias</p><p>解释：用于和 split, explode 等 UDTF 一起使用，它能够将一列数据拆成多行数据，在此基础上可以对拆分后的数据进行聚合。</p><p>例如：</p><p>这里的数据是我自己准备好的。需要将电影分类中的数组数据展开成如下结果</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211005182142031.png" alt="image-20211005182142031"></p><p><strong>原数据：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211005182206876.png" alt="image-20211005182206876"></p><p>导入数据如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211005182650003.png" alt="image-20211005182650003"></p><p>结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select movie,category_name from movie_info lateral view explode(category) table_tmp as category_name;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211005183846684.png" alt="image-20211005183846684"></p><h3 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h3><p>OVER()：指定分析函数工作的数据窗口大小，这个数据窗口大小可能会随着行的变化</p><p>而变化；</p><p>CURRENT ROW：当前行； </p><p>n PRECEDING：往前 n 行数据； </p><p>n FOLLOWING：往后 n 行数据；</p><p>UNBOUNDED：起点，UNBOUNDED PRECEDING 表示从前面的起点，UNBOUNDED FOLLOWING 表示到后面的终点； </p><p>LAG(col,n)：往前第 n 行数据；</p><p>LEAD(col,n)：往后第 n 行数据；</p><p>NTILE(n)：把有序分区中的行分发到指定数据的组中，各个组有编号，编号从 1 开始，</p><p>对于每一行，NTILE 返回此行所属的组的编号。注意：n 必须为 int 类型</p><h3 id="RANK"><a href="#RANK" class="headerlink" title="RANK"></a>RANK</h3><p>RANK() 排序相同时会重复，总数不会变</p><p>DENSE_RANK() 排序相同时会重复，总数会减少</p><p>ROW_NUMBER() 会根据顺序计算</p><p>举例说明，以下数据是为了计算排名：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">RANK()DENSE_RANK()ROW_NUMBER()</span><br><span class="line">90 111</span><br><span class="line">90     112</span><br><span class="line">80 323</span><br><span class="line">70 434</span><br></pre></td></tr></table></figure><h3 id="窗口帧格式-即滑动窗口"><a href="#窗口帧格式-即滑动窗口" class="headerlink" title="窗口帧格式(即滑动窗口)"></a>窗口帧格式(即滑动窗口)</h3><p>窗口帧格式<br>    格式1:按照行的记录取值<br>        ROWS  BETWEEN (UNBOUNDED | [num]) PRECEDING AND ([num] PRECEDING | CURRENT ROW | (UNBOUNDED | [num]) FOLLOWING)<br>    格式2:当前所指定值的范围取值<br>        RANGE BETWEEN (UNBOUNDED | [num]) PRECEDING AND ([num] PRECEDING | CURRENT ROW | (UNBOUNDED | [num]) FOLLOWING)<br>    注意:<br>        UNBOUNDED:无界限<br>        CURRENT ROW:当前行</p><p>rows格式1:前2行+当前行+后两行<br>    sum(score) over (partition by clazz order by score desc rows between 2 PRECEDING and 2 FOLLOWING)<br>rows格式2:前记录到最末尾的总和<br>    sum(score) over (partition by clazz order by score desc rows between CURRENT ROW and UNBOUNDED FOLLOWING)</p><p>range格式1: 如果当前值在80,取值就会落在范围在80-2=78和80+2=82组件之内的行<br>    max(score) over (partition by clazz order by score desc range between 2 PRECEDING and 2 FOLLOWING)</p><h2 id="自定义函数UDF"><a href="#自定义函数UDF" class="headerlink" title="自定义函数UDF"></a>自定义函数UDF</h2><p>Hive 提供的内置函数无法满足你的业务处理需要时,此时就可以考虑使用用户自定义函数。</p><h3 id="UDF一进一出"><a href="#UDF一进一出" class="headerlink" title="UDF一进一出"></a>UDF一进一出</h3><h4 id="一个参数"><a href="#一个参数" class="headerlink" title="一个参数"></a>一个参数</h4><p>1.首先创建maven项目并添加依赖</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.hive&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;hive-exec&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.2.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>2.编写代码，继承org.apache.hadoop.hive.ql.exec.UDF <strong>实现evaluate方法</strong>，在evaluate方法中实现自己的逻辑</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import org.apache.hadoop.hive.ql.exec.UDF;</span><br><span class="line"></span><br><span class="line">public class HiveUDF extends UDF &#123;</span><br><span class="line">    public String evaluate(String str)&#123;</span><br><span class="line">        String s = <span class="string">&quot;---&quot;</span>+str+<span class="string">&quot;---&quot;</span>;</span><br><span class="line">        <span class="built_in">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.打成jar包上传至虚拟机</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211008211855026.png" alt="image-20211008211855026"></p><p>上传至存放包的路径下</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211008211934906.png" alt="image-20211008211934906"></p><p>4.进入hive客户端添加jar包</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/c02a3abffa7e4d768f952d272011eff1.png" alt="在这里插入图片描述"></p><p>5.创建临时函数：hive&gt;CREATE TEMPORARY FUNCTION f_up as ‘name’;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/21b4a5344b6f4f918f6447c761b653d5.png" alt="img"></p><p>6.使用HiveUDF函数</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/345a07fd7f734a4697c3bfe1d7ae223b.png" alt="img"></p><h4 id="多个参数"><a href="#多个参数" class="headerlink" title="多个参数"></a>多个参数</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import org.apache.hadoop.hive.ql.exec.UDF;</span><br><span class="line"></span><br><span class="line">public class HiveUDF01 extends UDF &#123;</span><br><span class="line">    public String evaluate(String str1,String str2)&#123;</span><br><span class="line">        String s = str1+<span class="string">&quot;---&quot;</span>+str2;</span><br><span class="line">        <span class="built_in">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现有多个参数的时候，也是可以只输出一个结果，所以UDAF（多进一出就不常用）</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/611d43e45ca5421cabb045bea9163c5d.png" alt="img"></p><h3 id="UDTF一进多出"><a href="#UDTF一进多出" class="headerlink" title="UDTF一进多出"></a>UDTF一进多出</h3><p>大致的步骤差不多，这里只给出关键代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.exec.UDFArgumentException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.metadata.HiveException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.udf.generic.GenericUDTF;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HiveUDTF</span> <span class="keyword">extends</span> <span class="title">GenericUDTF</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.3.1之后不需要写</span></span><br><span class="line">    <span class="comment">//初始化：指定输出的数量和输出的格式</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StructObjectInspector <span class="title">initialize</span><span class="params">(StructObjectInspector argOIs)</span> <span class="keyword">throws</span> UDFArgumentException </span>&#123;</span><br><span class="line">        <span class="comment">//指定输出多少列（操作列的数量和名称）</span></span><br><span class="line">        ArrayList&lt;String&gt; fieldName = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">//操作列的类型</span></span><br><span class="line">        ArrayList&lt;ObjectInspector&gt; fieldObj = <span class="keyword">new</span> ArrayList&lt;ObjectInspector&gt;();<span class="comment">//检测当前给的是什么类型</span></span><br><span class="line">        <span class="comment">//输出两列</span></span><br><span class="line">        <span class="comment">//第一列</span></span><br><span class="line">        fieldName.add(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">        fieldObj.add(PrimitiveObjectInspectorFactory.javaStringObjectInspector);<span class="comment">//检查给的是不是String类型</span></span><br><span class="line">        <span class="comment">//第二列</span></span><br><span class="line">        fieldName.add(<span class="string">&quot;y&quot;</span>);</span><br><span class="line">        fieldObj.add(PrimitiveObjectInspectorFactory.javaStringObjectInspector);</span><br><span class="line">        <span class="keyword">return</span> ObjectInspectorFactory.getStandardStructObjectInspector(fieldName,fieldObj);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//假设进来的格式为：(&quot;k1:v1,k2:v2,k3:v3&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Object[] objects)</span> <span class="keyword">throws</span> HiveException </span>&#123;</span><br><span class="line">        String s = objects[<span class="number">0</span>].toString();<span class="comment">//这里的参数0，指的就是上面进来的格式</span></span><br><span class="line">        <span class="comment">//切分出来每行数据</span></span><br><span class="line">        String[] rows = s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String row : rows) &#123;</span><br><span class="line">            String[] split = row.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">            <span class="comment">//通过forward()输出</span></span><br><span class="line">            forward(split);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打包上传并且注册函数并执行</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/f2a0c5d6b2564b0bb54e3d06c212b6b6.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/3fa04a84a9e84e989187a19668f94f8c.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 大数据学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive环境搭建</title>
      <link href="/2021/09/25/Hive%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2021/09/25/Hive%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Hive搭建"><a href="#Hive搭建" class="headerlink" title="Hive搭建"></a>Hive搭建</h1><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>安装的前提首先需要先将相应的环境都搭建完毕。Hadoop，mysql啥的，详情请见之前的服务搭建步骤。</p><p>其次就是<font color="red">Hadoop和mysql必须要先启动</font>。</p><h2 id="将压缩包上传并且解压"><a href="#将压缩包上传并且解压" class="headerlink" title="将压缩包上传并且解压"></a>将压缩包上传并且解压</h2><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210925133220212.png" alt="image-20210925133220212"></p><p><strong>解压</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf /usr/<span class="built_in">local</span>/module/apache-hive-1.2.1-bin.tar.gz -C /usr/<span class="built_in">local</span>/soft/</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210925133746320.png" alt="image-20210925133746320"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210925133906664.png" alt="image-20210925133906664"></p><p>可以看到解压已经完成。我这里名字太长了，所以重起了一个名字。</p><p>修改目录名称</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv apache-hive-1.2.1-bin/ hive-1.2.1</span><br></pre></td></tr></table></figure><h2 id="修改Hive配置文件"><a href="#修改Hive配置文件" class="headerlink" title="修改Hive配置文件"></a>修改Hive配置文件</h2><h3 id="备份配置文件"><a href="#备份配置文件" class="headerlink" title="备份配置文件"></a>备份配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp hive-env.sh.template hive-env.sh</span><br><span class="line">cp hive-default.xml.template hive-site.xml</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210925134245026.png" alt="image-20210925134245026"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210925135746445.png" alt="image-20210925135746445"></p><h3 id="修改hive-env-sh配置文件"><a href="#修改hive-env-sh配置文件" class="headerlink" title="修改hive-env.sh配置文件"></a>修改hive-env.sh配置文件</h3><p>在里面加入三行内容(视个人配置情况而定)</p><p>HADOOP_HOME=/usr/local/soft/hadoop-2.7.6<br>JAVA_HOME=/usr/local/soft/jdk1.8.0_171<br>HIVE_HOME=/usr/local/soft/hive-1.2.1</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210925135019048.png" alt="image-20210925135019048"></p><h3 id="修改hive-site-xml配置文件"><a href="#修改hive-site-xml配置文件" class="headerlink" title="修改hive-site.xml配置文件"></a>修改hive-site.xml配置文件</h3><h4 id="分别修改如下的配置即可"><a href="#分别修改如下的配置即可" class="headerlink" title="分别修改如下的配置即可"></a>分别修改如下的配置即可</h4><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210925150535899.png" alt="image-20210925150535899"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210925140535136.png" alt="image-20210925140535136"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210925140600103.png" alt="image-20210925140600103"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210925140638638.png" alt="image-20210925140638638"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210925140757786.png" alt="image-20210925140757786"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210925140918229.png" alt="image-20210925140918229"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210925140958829.png" alt="image-20210925140958829"></p><h4 id="配置文件总代码如下"><a href="#配置文件总代码如下" class="headerlink" title="配置文件总代码如下"></a>配置文件总代码如下</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;</span><br><span class="line">&lt;value&gt;jdbc:mysql://master:3306/hive?characterEncoding=UTF-8&amp;amp;createDatabaseIfNotExist=<span class="literal">true</span>&amp;amp;useSSL=<span class="literal">false</span>&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;</span><br><span class="line">&lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;</span><br><span class="line">&lt;value&gt;root&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;</span><br><span class="line">&lt;value&gt;123456&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;hive.querylog.location&lt;/name&gt;</span><br><span class="line">&lt;value&gt;/usr/<span class="built_in">local</span>/soft/hive-1.2.1/tmp&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;hive.exec.local.scratchdir&lt;/name&gt;</span><br><span class="line">&lt;value&gt;/usr/<span class="built_in">local</span>/soft/hive-1.2.1/tmp&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;hive.downloaded.resources.dir&lt;/name&gt;</span><br><span class="line">&lt;value&gt;/usr/<span class="built_in">local</span>/soft/hive-1.2.1/tmp&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><h3 id="拷贝mysql驱动到-HIVE-HOME-lib目录下"><a href="#拷贝mysql驱动到-HIVE-HOME-lib目录下" class="headerlink" title="拷贝mysql驱动到$HIVE_HOME/lib目录下"></a>拷贝mysql驱动到$HIVE_HOME/lib目录下</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210925141405552.png" alt="image-20210925141405552"></p><p>在这个路径下面去执行拷贝</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp /usr/<span class="built_in">local</span>/module/mysql-connector-java-5.1.49.jar /usr/<span class="built_in">local</span>/soft/hive-1.2.1/lib/</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210925141529946.png" alt="image-20210925141529946"></p><h3 id="将hadoop的jline-2-12-jar的jar替换成hive的版本"><a href="#将hadoop的jline-2-12-jar的jar替换成hive的版本" class="headerlink" title="将hadoop的jline-2.12.jar的jar替换成hive的版本"></a>将hadoop的jline-2.12.jar的jar替换成hive的版本</h3><p>先将hadoop中的jline-2.12.jar给删除，因为怕冲突。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -rf /usr/<span class="built_in">local</span>/soft/hadoop-2.7.6/share/hadoop/yarn/lib/jline-2.12.jar</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210925143753792.png" alt="image-20210925143753792"></p><p>接着执行拷贝命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp /usr/<span class="built_in">local</span>/soft/hive-1.2.1/lib/jline-2.12.jar /usr/<span class="built_in">local</span>/soft/hadoop-2.7.6/share/hadoop/yarn/lib/</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210925142213278.png" alt="image-20210925142213278"></p><h2 id="至此Hive已经搭建完成"><a href="#至此Hive已经搭建完成" class="headerlink" title="至此Hive已经搭建完成"></a>至此Hive已经搭建完成</h2><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210925145907191.png" alt="image-20210925145907191"></p>]]></content>
      
      
      <categories>
          
          <category> 大数据学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadooop-HA安装步骤</title>
      <link href="/2021/09/24/Hadooop-HA%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/"/>
      <url>/2021/09/24/Hadooop-HA%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Hadoop——HA"><a href="#Hadoop——HA" class="headerlink" title="Hadoop——HA"></a>Hadoop——HA</h1><p>之前的博客写了搭建hadoop集群环境，今天写一写搭建高可用（HA）环境。Hadoop-HA模式大致分为两个(个人在学习中的理解)：</p><ul><li>namenode 高可用</li><li>yarn 高可用</li><li>主备切换</li></ul><p>在之前的博客中，Hadoop分布式环境搭建有教程，zookeeper集群搭建也有教程，这里是在这两个要求的前提下进行的。</p><p>Namenode在HDFS中是一个非常重要的组件，相当于HDFS文件系统的心脏，在显示分布式集群环境中，还是会有可能出现Namenode的崩溃或各种意外。所以，高可用模式就体现出作用了。<br>namenode HA配置大概流程(个人理解)：</p><ul><li>在启动namenode之前，需要启动hadoop2.x中新引入的（QJM）Quorum Journal Manager，QJM主要用来管理namenode之间的数据同步，当active namenode数据更新时会传递给QJM，QJM在所有的namenode之间同步，最后QJM将active namenode 更新的数据同步到了standby namenode中。</li><li>启动多个namenode时，并配置namenode的主机地址，还要配置隔离机制，因为容易出现SB（split-brain）状况，所谓的sb状况意思就是当多个namenode正常状态时，一台active，多台standby。如果某段时间因为网络等非namenode自身关系导致namenode间交流阻断了，这样容易出现多台active的设备，容易抢占资源等。</li><li>引入zookeeper来对namenode进行监听，因为在一般情况下，active 的namenode崩溃了的话，需要人工切换standby Namenode为active。非常不人性化。通过zookeeper可以监听多个namenode，当active namenode崩溃的话，zookeeper监听到后马上通知zookeeper的leader进行主备选举，在standby namenode中选举出一台，并将它置为active模式替换崩溃的namenode。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924202821954.png" alt="image-20210924202821954"></p><h2 id="HDFS搭建步骤如下所示"><a href="#HDFS搭建步骤如下所示" class="headerlink" title="HDFS搭建步骤如下所示"></a>HDFS搭建步骤如下所示</h2><h3 id="设置免密"><a href="#设置免密" class="headerlink" title="设置免密"></a>设置免密</h3><p>先设置免密，在node1下面设置。因为之前master已经设置过了，现在需要的是高可用版本，需要进行主备切换。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line"><span class="comment"># 分别发送</span></span><br><span class="line">ssh-copy-id -i master</span><br><span class="line">ssh-copy-id -i node1</span><br><span class="line">ssh-copy-id -i node1</span><br></pre></td></tr></table></figure><h3 id="修改hadoop配置文件"><a href="#修改hadoop配置文件" class="headerlink" title="修改hadoop配置文件"></a>修改hadoop配置文件</h3><p>修改两个文件：core-site.xml和hdfs-site.xml。并且修改之后同步到其他两个节点</p><p>scp * master:/usr/local/soft/hadoop-2.7.6/etc/hadoop/</p><p>scp * node2:/usr/local/soft/hadoop-2.7.6/etc/hadoop/</p><p><strong>core-site.xml修改配置如下</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;?xml-stylesheet <span class="built_in">type</span>=<span class="string">&quot;text/xsl&quot;</span> href=<span class="string">&quot;configuration.xsl&quot;</span>?&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">  Licensed under the Apache License, Version 2.0 (the <span class="string">&quot;License&quot;</span>);</span><br><span class="line">  you may not use this file except <span class="keyword">in</span> compliance with the License.</span><br><span class="line">  You may obtain a copy of the License at</span><br><span class="line"></span><br><span class="line">    http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"></span><br><span class="line">  Unless required by applicable law or agreed to <span class="keyword">in</span> writing, software</span><br><span class="line">  distributed under the License is distributed on an <span class="string">&quot;AS IS&quot;</span> BASIS,</span><br><span class="line">  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">  See the License <span class="keyword">for</span> the specific language governing permissions and</span><br><span class="line">  limitations under the License. See accompanying LICENSE file.</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Put site-specific property overrides <span class="keyword">in</span> this file. --&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">&lt;value&gt;hdfs://cluster&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">&lt;value&gt;/usr/<span class="built_in">local</span>/soft/hadoop-2.7.6/tmp&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;fs.trash.interval&lt;/name&gt;</span><br><span class="line">&lt;value&gt;1440&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">      &lt;name&gt;ha.zookeeper.quorum&lt;/name&gt;</span><br><span class="line">      &lt;value&gt;master:2181,node1:2181,node2:2181&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>hdfs-site.xml修改配置如下</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;?xml-stylesheet <span class="built_in">type</span>=<span class="string">&quot;text/xsl&quot;</span> href=<span class="string">&quot;configuration.xsl&quot;</span>?&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">  Licensed under the Apache License, Version 2.0 (the <span class="string">&quot;License&quot;</span>);</span><br><span class="line">  you may not use this file except <span class="keyword">in</span> compliance with the License.</span><br><span class="line">  You may obtain a copy of the License at</span><br><span class="line"></span><br><span class="line">    http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"></span><br><span class="line">  Unless required by applicable law or agreed to <span class="keyword">in</span> writing, software</span><br><span class="line">  distributed under the License is distributed on an <span class="string">&quot;AS IS&quot;</span> BASIS,</span><br><span class="line">  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">  See the License <span class="keyword">for</span> the specific language governing permissions and</span><br><span class="line">  limitations under the License. See accompanying LICENSE file.</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Put site-specific property overrides <span class="keyword">in</span> this file. --&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;!-- 指定hdfs元数据存储的路径 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;</span><br><span class="line">&lt;value&gt;/usr/<span class="built_in">local</span>/soft/hadoop-2.7.6/data/namenode&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 指定hdfs数据存储的路径 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;</span><br><span class="line">&lt;value&gt;/usr/<span class="built_in">local</span>/soft/hadoop-2.7.6/data/datanode&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 数据备份的个数 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">&lt;value&gt;1&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 关闭权限验证 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.permissions.enabled&lt;/name&gt;</span><br><span class="line">&lt;value&gt;<span class="literal">false</span>&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 开启WebHDFS功能（基于REST的接口服务） --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.webhdfs.enabled&lt;/name&gt;</span><br><span class="line">&lt;value&gt;<span class="literal">true</span>&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- //////////////以下为HDFS HA的配置////////////// --&gt;</span><br><span class="line">&lt;!-- 指定hdfs的nameservices名称为mycluster --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.nameservices&lt;/name&gt;</span><br><span class="line">&lt;value&gt;cluster&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 指定cluster的两个namenode的名称分别为nn1,nn2 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.ha.namenodes.cluster&lt;/name&gt;</span><br><span class="line">&lt;value&gt;nn1,nn2&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置nn1,nn2的rpc通信端口 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.namenode.rpc-address.cluster.nn1&lt;/name&gt;</span><br><span class="line">&lt;value&gt;master:8020&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.namenode.rpc-address.cluster.nn2&lt;/name&gt;</span><br><span class="line">&lt;value&gt;node1:8020&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置nn1,nn2的http通信端口 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.namenode.http-address.cluster.nn1&lt;/name&gt;</span><br><span class="line">&lt;value&gt;master:50070&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.namenode.http-address.cluster.nn2&lt;/name&gt;</span><br><span class="line">&lt;value&gt;node1:50070&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 指定namenode元数据存储在journalnode中的路径 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.namenode.shared.edits.dir&lt;/name&gt;</span><br><span class="line">&lt;value&gt;qjournal://master:8485;node1:8485;node2:8485/cluster&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 指定journalnode日志文件存储的路径 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.journalnode.edits.dir&lt;/name&gt;</span><br><span class="line">&lt;value&gt;/usr/<span class="built_in">local</span>/soft/hadoop-2.7.6/data/journal&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 指定HDFS客户端连接active namenode的java类 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.client.failover.proxy.provider.cluster&lt;/name&gt;</span><br><span class="line">&lt;value&gt;org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置隔离机制为ssh --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.ha.fencing.methods&lt;/name&gt;</span><br><span class="line">&lt;value&gt;sshfence&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 指定秘钥的位置 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.ha.fencing.ssh.private-key-files&lt;/name&gt;</span><br><span class="line">&lt;value&gt;/root/.ssh/id_rsa&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 开启自动故障转移 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.ha.automatic-failover.enabled&lt;/name&gt;</span><br><span class="line">&lt;value&gt;<span class="literal">true</span>&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><h3 id="删除hadoop数据存储目录下的文件，每个节点都要删除"><a href="#删除hadoop数据存储目录下的文件，每个节点都要删除" class="headerlink" title="删除hadoop数据存储目录下的文件，每个节点都要删除"></a>删除hadoop数据存储目录下的文件，每个节点都要删除</h3><p>rm -rf /usr/local/soft/hadoop-2.7.6/tmp</p><h3 id="启动zookeeper-三台都需要启动"><a href="#启动zookeeper-三台都需要启动" class="headerlink" title="启动zookeeper  三台都需要启动"></a>启动zookeeper  三台都需要启动</h3><p>zkServer.sh start<br>zkServer.sh status</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924210642900.png" alt="image-20210924210642900"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924210659308.png" alt="image-20210924210659308"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924210722205.png" alt="image-20210924210722205"></p><h3 id="启动JN，存储HDFS元数据"><a href="#启动JN，存储HDFS元数据" class="headerlink" title="启动JN，存储HDFS元数据"></a>启动JN，存储HDFS元数据</h3><p>注意：这步骤的前提是Hadoop没有启动</p><p>三台JN上执行 启动命令：<br> hadoop-daemon.sh start journalnode</p><h3 id="注意：此时执行到这个步骤时，节点应该一共有6个"><a href="#注意：此时执行到这个步骤时，节点应该一共有6个" class="headerlink" title="注意：此时执行到这个步骤时，节点应该一共有6个"></a>注意：此时执行到这个步骤时，节点应该一共有6个</h3><p>如图所示：分别是 master，node1，node2</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924211430002.png" alt="image-20210924211430002"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924211605477.png" alt="image-20210924211605477"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924211651077.png" alt="image-20210924211651077"></p><h3 id="格式化-在一台NN上执行"><a href="#格式化-在一台NN上执行" class="headerlink" title="格式化 在一台NN上执行"></a>格式化 在一台NN上执行</h3><p>​      hdfs namenode -format<br>​      启动当前的NN<br>​      hadoop-daemon.sh start namenode</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924212022062.png" alt="image-20210924212022062"></p><p>可以很直观的查看到高可用版本已经启动，并且主节点master上面已经有了NameNode</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924212146389.png" alt="image-20210924212146389"></p><h3 id="执行同步"><a href="#执行同步" class="headerlink" title="执行同步"></a>执行同步</h3><p>在没有格式化的NN上执行，在另外一个namenode上面执行。这里我是在node1上执行的。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924212302053.png" alt="image-20210924212302053"></p><p>可以看出已经绑定了</p><h3 id="格式化ZK"><a href="#格式化ZK" class="headerlink" title="格式化ZK"></a>格式化ZK</h3><p>在已经启动的namenode上执行！！！一定要先把ZK集群正常启动起来</p><p>hdfs zkfc -formatZK</p><h3 id="启动hdfs集群"><a href="#启动hdfs集群" class="headerlink" title="启动hdfs集群"></a>启动hdfs集群</h3><p>在启动了namenode的节点上执行</p><p>start-dfs.sh</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924213103725.png" alt="image-20210924213103725"></p><h3 id="注意：此时执行到这个步骤时，节点个数应该是一共有12个"><a href="#注意：此时执行到这个步骤时，节点个数应该是一共有12个" class="headerlink" title="注意：此时执行到这个步骤时，节点个数应该是一共有12个"></a>注意：此时执行到这个步骤时，节点个数应该是一共有12个</h3><p>如图所示：分别是 master，node1，node2</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924213338789.png" alt="image-20210924213338789"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924213418582.png" alt="image-20210924213418582"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924213439389.png" alt="image-20210924213439389"></p><p>接下来执行YARN的搭建步骤。</p><h2 id="YARN高可用搭建步骤如下所示"><a href="#YARN高可用搭建步骤如下所示" class="headerlink" title="YARN高可用搭建步骤如下所示"></a>YARN高可用搭建步骤如下所示</h2><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>修改yarn-site.xml和mapred-site.xml两个配置文件。并且修改之后同步到其他两个节点</p><p>scp * node1:/usr/local/soft/hadoop-2.7.6/etc/hadoop/</p><p>scp * node2:/usr/local/soft/hadoop-2.7.6/etc/hadoop/</p><p><strong>yarn-site.xml修改配置如下：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">  Licensed under the Apache License, Version 2.0 (the <span class="string">&quot;License&quot;</span>);</span><br><span class="line">  you may not use this file except <span class="keyword">in</span> compliance with the License.</span><br><span class="line">  You may obtain a copy of the License at</span><br><span class="line"></span><br><span class="line">    http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"></span><br><span class="line">  Unless required by applicable law or agreed to <span class="keyword">in</span> writing, software</span><br><span class="line">  distributed under the License is distributed on an <span class="string">&quot;AS IS&quot;</span> BASIS,</span><br><span class="line">  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">  See the License <span class="keyword">for</span> the specific language governing permissions and</span><br><span class="line">  limitations under the License. See accompanying LICENSE file.</span><br><span class="line">--&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;!-- NodeManager上运行的附属服务，需配置成mapreduce_shuffle才可运行MapReduce程序 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">&lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置Web Application Proxy安全代理（防止yarn被攻击） --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.web-proxy.address&lt;/name&gt;</span><br><span class="line">&lt;value&gt;master:8888&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 开启日志 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.log-aggregation-enable&lt;/name&gt;</span><br><span class="line">&lt;value&gt;<span class="literal">true</span>&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置日志删除时间为7天，-1为禁用，单位为秒 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.log-aggregation.retain-seconds&lt;/name&gt;</span><br><span class="line">&lt;value&gt;604800&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 修改日志目录 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.nodemanager.remote-app-log-dir&lt;/name&gt;</span><br><span class="line">&lt;value&gt;/logs&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置nodemanager可用的资源内存 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.nodemanager.resource.memory-mb&lt;/name&gt;</span><br><span class="line">&lt;value&gt;2048&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置nodemanager可用的资源CPU --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.nodemanager.resource.cpu-vcores&lt;/name&gt;</span><br><span class="line">&lt;value&gt;2&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- //////////////以下为YARN HA的配置////////////// --&gt;</span><br><span class="line">&lt;!-- 开启YARN HA --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.resourcemanager.ha.enabled&lt;/name&gt;</span><br><span class="line">&lt;value&gt;<span class="literal">true</span>&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 启用自动故障转移 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.resourcemanager.ha.automatic-failover.enabled&lt;/name&gt;</span><br><span class="line">&lt;value&gt;<span class="literal">true</span>&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 指定YARN HA的名称 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.resourcemanager.cluster-id&lt;/name&gt;</span><br><span class="line">&lt;value&gt;yarncluster&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 指定两个resourcemanager的名称 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.resourcemanager.ha.rm-ids&lt;/name&gt;</span><br><span class="line">&lt;value&gt;rm1,rm2&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置rm1，rm2的主机 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.resourcemanager.hostname.rm1&lt;/name&gt;</span><br><span class="line">&lt;value&gt;master&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.resourcemanager.hostname.rm2&lt;/name&gt;</span><br><span class="line">&lt;value&gt;node1&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置YARN的http端口 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.resourcemanager.webapp.address.rm1&lt;/name&gt;</span><br><span class="line">&lt;value&gt;master:8088&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.resourcemanager.webapp.address.rm2&lt;/name&gt;</span><br><span class="line">&lt;value&gt;node1:8088&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置zookeeper的地址 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.resourcemanager.zk-address&lt;/name&gt;</span><br><span class="line">&lt;value&gt;master:2181,node1:2181,node2:2181&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置zookeeper的存储位置 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.resourcemanager.zk-state-store.parent-path&lt;/name&gt;</span><br><span class="line">&lt;value&gt;/rmstore&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 开启yarn resourcemanager restart --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.resourcemanager.recovery.enabled&lt;/name&gt;</span><br><span class="line">&lt;value&gt;<span class="literal">true</span>&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置resourcemanager的状态存储到zookeeper中 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.resourcemanager.store.class&lt;/name&gt;</span><br><span class="line">&lt;value&gt;org.apache.hadoop.yarn.server.resourcemanager.recovery.ZKRMStateStore&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 开启yarn nodemanager restart --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.nodemanager.recovery.enabled&lt;/name&gt;</span><br><span class="line">&lt;value&gt;<span class="literal">true</span>&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置nodemanager IPC的通信端口 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.nodemanager.address&lt;/name&gt;</span><br><span class="line">&lt;value&gt;0.0.0.0:45454&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p><strong>mapred-site.xml修改配置如下：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span><br><span class="line">&lt;?xml-stylesheet <span class="built_in">type</span>=<span class="string">&quot;text/xsl&quot;</span> href=<span class="string">&quot;configuration.xsl&quot;</span>?&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">  Licensed under the Apache License, Version 2.0 (the <span class="string">&quot;License&quot;</span>);</span><br><span class="line">  you may not use this file except <span class="keyword">in</span> compliance with the License.</span><br><span class="line">  You may obtain a copy of the License at</span><br><span class="line"></span><br><span class="line">    http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"></span><br><span class="line">  Unless required by applicable law or agreed to <span class="keyword">in</span> writing, software</span><br><span class="line">  distributed under the License is distributed on an <span class="string">&quot;AS IS&quot;</span> BASIS,</span><br><span class="line">  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">  See the License <span class="keyword">for</span> the specific language governing permissions and</span><br><span class="line">  limitations under the License. See accompanying LICENSE file.</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Put site-specific property overrides <span class="keyword">in</span> this file. --&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;!-- 指定MapReduce计算框架使用YARN --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">&lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 指定jobhistory server的rpc地址 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt;</span><br><span class="line">&lt;value&gt;node1:10020&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 指定jobhistory server的http地址 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt;</span><br><span class="line">&lt;value&gt;node1:19888&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 开启uber模式（针对小作业的优化） --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;mapreduce.job.ubertask.enable&lt;/name&gt;</span><br><span class="line">&lt;value&gt;<span class="literal">true</span>&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置启动uber模式的最大map数 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;mapreduce.job.ubertask.maxmaps&lt;/name&gt;</span><br><span class="line">&lt;value&gt;9&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置启动uber模式的最大reduce数 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;mapreduce.job.ubertask.maxreduces&lt;/name&gt;</span><br><span class="line">&lt;value&gt;1&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>连接ZK，可以看到多了一个 hadoop-ha。起到一个监控作用。如果节点挂了，那么会启动回调函数，然后自动启动备用的节点。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924220849376.png" alt="image-20210924220849376"></p><h3 id="启动yarn"><a href="#启动yarn" class="headerlink" title="启动yarn"></a>启动yarn</h3><p>在master启动</p><p>start-yarn.sh</p><h3 id="在另外一台主节点上启动RM"><a href="#在另外一台主节点上启动RM" class="headerlink" title="在另外一台主节点上启动RM"></a>在另外一台主节点上启动RM</h3><p>yarn-daemon.sh start resourcemanager</p><h2 id="至此Hadoop——HA高可用已经全部弄好了，此时节点一共会有16个节点"><a href="#至此Hadoop——HA高可用已经全部弄好了，此时节点一共会有16个节点" class="headerlink" title="至此Hadoop——HA高可用已经全部弄好了，此时节点一共会有16个节点"></a>至此Hadoop——HA高可用已经全部弄好了，此时节点一共会有16个节点</h2><p>如图所示：分别是 master，node1，node2</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924221436253.png" alt="image-20210924221436253"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924221514774.png" alt="image-20210924221514774"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924221541718.png" alt="image-20210924221541718"></p>]]></content>
      
      
      <categories>
          
          <category> 大数据学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop——HA安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper</title>
      <link href="/2021/09/23/Zookeeper/"/>
      <url>/2021/09/23/Zookeeper/</url>
      
        <content type="html"><![CDATA[<h1 id="Zookeeper组件"><a href="#Zookeeper组件" class="headerlink" title="Zookeeper组件"></a>Zookeeper组件</h1><h2 id="Zookeeper安装"><a href="#Zookeeper安装" class="headerlink" title="Zookeeper安装"></a>Zookeeper安装</h2><p>上传zookeeper压缩包并且解压之后就要进行相应的环境变量的修改了。</p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>​    vim /etc/profile</p><h3 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210923184946776.png" alt="image-20210923184946776"></p><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp  zoo_sample.cfg zoo.cfg<span class="comment"># 拷贝一份进行修改</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210923185117479.png" alt="image-20210923185117479"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210923185212440.png" alt="image-20210923185212440"></p><h3 id="随后同步到其他节点上面。接着source一下。"><a href="#随后同步到其他节点上面。接着source一下。" class="headerlink" title="随后同步到其他节点上面。接着source一下。"></a>随后同步到其他节点上面。接着source一下。</h3><p>scp -r zookeeper-3.4.6路径 node1:新路径<br>scp -r zookeeper-3.4.6路径 node2:新路径</p><p>scp /etc/profile node1:/etc/<br>scp /etc/profile node2:/etc/</p><p>并且source。</p><h3 id="创建-usr-local-soft-zookeeper-3-4-6-data目录-所有节点都要创建"><a href="#创建-usr-local-soft-zookeeper-3-4-6-data目录-所有节点都要创建" class="headerlink" title="创建/usr/local/soft/zookeeper-3.4.6/data目录,所有节点都要创建"></a>创建/usr/local/soft/zookeeper-3.4.6/data目录,所有节点都要创建</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /usr/<span class="built_in">local</span>/soft/zookeeper-3.4.6/data</span><br></pre></td></tr></table></figure><p>在data目录下创建myid文件<br>    vim myid<br>    master,node1,node2分别加上0，1，2</p><h3 id="启动Zookeeper"><a href="#启动Zookeeper" class="headerlink" title="启动Zookeeper"></a>启动Zookeeper</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zkServer.sh start  三台都需要执行</span><br><span class="line">zkServer.sh status 查看状态</span><br><span class="line"></span><br><span class="line">当有一个leader的时候启动成功</span><br></pre></td></tr></table></figure><h3 id="连接Zookeeper"><a href="#连接Zookeeper" class="headerlink" title="连接Zookeeper"></a>连接Zookeeper</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zkCli.sh</span><br><span class="line">zk  是一个目录结构 ，每个节点可以存数据，同时可以有子节点</span><br></pre></td></tr></table></figure><h2 id="Zookeeper的概述"><a href="#Zookeeper的概述" class="headerlink" title="Zookeeper的概述"></a>Zookeeper的概述</h2><p>Zookeeper是一个开源的分布式协调服务框架，主要用来解决分布式集群中应用系统的一致性问题和数据管理问题。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210912153120466.png" alt="image-20210912153120466"></p><h2 id="Zookeeper的特点"><a href="#Zookeeper的特点" class="headerlink" title="Zookeeper的特点"></a>Zookeeper的特点</h2><p>Zookeeper本质上是一个分布式文件系统，适合存放小文件，也可以理解为一个数据库</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210912161631045.png" alt="image-20210912161631045"></p><ul><li>在上图左侧，Zookeeper中存储的其实是一个又一个Znode，Znode是Zookeeper中的节点。<ul><li>Znode也是有路径的，例如/data/host1，/data/host2，这个路径也可以理解为是Znode的Name</li><li>Znode也可以携带数据，例如某个Znode的路径是/data/host1，其值是一个字符串”192.168.0.1”</li></ul></li><li>正因为Znode的特性，所以Zookeeper可以对外提供出一个类似于文件系统的试图，可以通过操作文件系统的方式操作Zookeeper<ul><li>使用路径获取Znode</li><li>获取Znode携带的数据</li><li>修改Znode携带的数据</li><li>删除Znode</li><li>添加Znode</li></ul></li></ul><h2 id="Zookeeper的架构"><a href="#Zookeeper的架构" class="headerlink" title="Zookeeper的架构"></a>Zookeeper的架构</h2><p>其实Zookeeper本身也是一个集群，Zookeeper集群是一个基于主从架构的高可用集群。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210912163628667.png" alt="image-20210912163628667"></p><p>每个服务器承担如下三种角色中的一种</p><ul><li><strong>Leader</strong>一个Zookeeper集群同一时间只会有一个实际工作的Leader，它会发起并维护与各Follwer及Observer间的心跳。所有的写操作必须要通过Leader完成再由Leader将写操作广播给其他服务器。</li><li><strong>Follower</strong>一个Zookeeper集群可能同时存在多个Follower，它会响应Leader的心跳。Follower可直接处理并返回客户端的读请求，同时会将写请求转发给Leader处理，并且负责在Leader处理写请求时对请求进行投票。</li><li><strong>Observer</strong>角色与Follower类似，但是无投票权。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210912164448359.png" alt="image-20210912164448359"></p><h2 id="Zookeeper的选举机制"><a href="#Zookeeper的选举机制" class="headerlink" title="Zookeeper的选举机制"></a>Zookeeper的选举机制</h2><p>Zookeeper的选举又叫做Leader选举。Leader选举是保证分布式数据一致性的关键所在。当Zookeeper集群中的一台服务器出现以下两种情况之一时，需要进入Leader选举。</p><h3 id="服务器启动时期的Leader选举"><a href="#服务器启动时期的Leader选举" class="headerlink" title="服务器启动时期的Leader选举"></a>服务器启动时期的Leader选举</h3><p>若进行Leader选举，则至少需要两台机器，这里选取3台机器组成的服务器集群为例。在集群初始化阶段，当有一台服务器Server1启动时，其单独无法进行和完成Leader选举，当第二台服务器Server2启动时，此时两台机器可以相互通信，每台机器都试图找到Leader，于是进入Leader选举过程，选举过程如下</p><p>(1)<strong>每个Server发出一个投票</strong>。由于是初始情况，Server1和Server2都会将自己作为Leader服务器来进行投票，每次投票会包含所推举的服务器的myid和ZXID，使用(myid,ZXID)来表示，此时Server1的投票为(1，0)，Server2的投票为(2，0).然后各自将这个投票发给集群中的其他机器。</p><blockquote><p>myid:每台服务器的编号，值越大就表示机器越强，在选举中越占优势</p><p>ZXID:事务ID，值越大表示数据越新，越强大，在选举中越占优势</p></blockquote><p>(2)<strong>接受来自各个服务器的投票</strong>。集群中的每个服务器收到投票后，首先判断该投票的有效性，如检查是否是本轮投票，是否来自LOOKING状态的服务器</p><p>(3)<strong>处理投票。</strong>针对每一个投票，服务器都需要将别人的投票和自己的投票进行OK，PK规则如下所示:</p><ul><li><strong>优先检查ZXID</strong>。ZXID比较大的服务器优先作为Leader(注意:前提是投票的票数必须过半)</li><li><strong>如果ZXID相同，那么就比较myid</strong>。myid较大的服务器作为Leader服务器(注意:前提是投票的票数必须过半)</li></ul><p>对于Server1而言，它的投票是(1，0)，接收Server2的投票为(2，0)，首先会比较两者的ZXID，均为0。对于Server2而言，其无须更新自己的投票，只是再次向集群中所有机器发出上一次投票信息即可。</p><p>(4)<strong>统计投票</strong>。每次投票后，服务器都会统计投票信息，判断是否已经有过半机器接收到相同的投票信息，对于Server1，Server2而言，都统计出集群中已经有两台机器接受了(2,0)的投票信息，此时便认为已经选出了Leader。</p><p>(5)<strong>改变服务器状态</strong>。一旦确定了Leader，每个服务器就会更新自己的状态，如果是Follower，那么就变更为FOLLOWING，如果是Leader，就变更为LEADING。</p><h3 id="服务器运行时期的Leader选举"><a href="#服务器运行时期的Leader选举" class="headerlink" title="服务器运行时期的Leader选举"></a>服务器运行时期的Leader选举</h3><p>在Zookeeper运行期间，Leader与非Leader服务器各司其职，即便当有非Leader服务器宕机或新加入，此时也不会影响Leader，但是一旦Leader服务器挂了，那么整个集群将暂停对外服务，进入新一轮Leader选举，其过程和启动时期的Leader选举过程基本一致，过程相同。</p><h2 id="Zookeeper的数据模型"><a href="#Zookeeper的数据模型" class="headerlink" title="Zookeeper的数据模型"></a>Zookeeper的数据模型</h2><p>Zookeeper的数据模型，在结构上和标准文件系统的非常相似，拥有一个层次的命名空间，都是采用树形结构。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210913194642506.png" alt="image-20210913194642506"></p><p>Zookeeper树中的每个节点被称为一个Znode。和文件系统的目录树一样，Zookeeper树中的每个节点可以拥有子节点。</p><p>但也有不同之处:</p><p><strong>Znode兼具文件和目录两种特点</strong>。既像文件一样维护着数据，元信息，ACL，时间戳等数据结构，又像目录一样可以作为路径标识的一部分，并可以具有子Znode。用户对Znode具有增删改查等操作(权限允许的情况下)</p><p><strong>Znode存储数据大小有限制</strong>。Zookeeper虽然可以关联一些数据，但并没有被设计为常规的数据库或者大数据存储，相反的是，它用来管理调度数据，比如分布式应用中的配置文件信息，状态信息，汇聚位置等等。这些数据的共同特性就是它们都是很小的数据，通常以KB为大小单位。Zookeeper的服务器和客户端都被设计为严格检查并限制，每个Znode的数据大小至多为1M，常规使用中应该远远小于此值。</p><p><strong>Znode通过路径引用</strong>，如上图所示，路径并且必须要是绝对的。因此他们必须由斜杠字符来开头。除此之外，他们必须是唯一的，也就是说每一个路径只有一个表示，因此这些路径不能改变。在Zookeeper中，路径由Unicode字符串组成，并且有一些限制。字符串”/Zookeeper”用以保存管理信息，比如关键配额信息。</p><p><strong>每个Znode由3部分组成</strong></p><p>stat:此为状态信息，描述该Znode的版本，权限等信息</p><p>data:与该Znode关联的数据</p><p>children:该Znode下的子节点</p><h2 id="Znode节点类型"><a href="#Znode节点类型" class="headerlink" title="Znode节点类型"></a>Znode节点类型</h2><p>Znode有两种，分别为临时节点和永久节点。节点的类型在创建时即被确定，并且不能改变。</p><p><strong>临时节点</strong>:该节点的生命周期依赖于创建他们的会话。一旦会话结束，临时节点将被自动删除。当然也可以手动删除。临时节点不允许拥有子节点。</p><p><strong>永久节点</strong>:该节点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作的时候，他们才能被删除。</p><p><strong>Znode还有一个序列化的特性</strong>，如果创建的时候指定的话，该Znode的名字后面会自动追加一个不断增加的序列号。序列号对于此节点的父节点来说是唯一的，这样便会记录每一个子节点创建的先后顺序。</p><p>Znode四种类型的节点:</p><p>PERSISTENT:永久节点</p><p>EPHEMERAL:临时节点</p><p>FERSISTENT_SEQUENTIAL:永久节点，序列化</p><p>EPHEMERAL_SEQUENTIAL:临时节点，序列化</p><h1 id="Zookeeper-JAVA-API操作"><a href="#Zookeeper-JAVA-API操作" class="headerlink" title="Zookeeper JAVA API操作"></a>Zookeeper JAVA API操作</h1><h2 id="创建Zookeeper连接"><a href="#创建Zookeeper连接" class="headerlink" title="创建Zookeeper连接"></a>创建Zookeeper连接</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String connectionString = <span class="string">&quot;127.0.0.1:2181&quot;</span>; <span class="keyword">int</span> sessionTimeout = <span class="number">30000</span>; ZooKeeper zk = <span class="keyword">new</span> ZooKeeper(connectionString,sessionTimeout,<span class="keyword">null</span> &#125;);</span><br></pre></td></tr></table></figure><p> connectionString是连接信息，当为集群的时候，使用”,”分隔，如 </p><p>“192.168.1.1:2181,192.168.1.2:2181”</p><p> sessionTimeout指会话过期时间，其值minSessionTimeout最小为tickTime的2倍，最大值 maxSessionTimeout为tickTime的20倍；即使传入的值不在此范围实际起作用的也是minSessionTimeout至maxSessionTimeout</p><p><strong>例如在我自己电脑上面创建Zookeeper连接就是如下所示</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ZooKeeper zooKeeper = <span class="keyword">new</span> ZooKeeper(<span class="string">&quot;master:2181,node1:2181,node2:2181&quot;</span>,<span class="number">3000</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h2 id="创建节点-create"><a href="#创建节点-create" class="headerlink" title="创建节点(create)"></a>创建节点(create)</h2><p>zk.create(“/testRoot”,”testRoot”.getBytes(),       ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);</p><p><strong>例如在我自己电脑上我创建了一个show节点</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">zooKeeper.create(<span class="string">&quot;/show&quot;</span>,<span class="string">&quot;show&quot;</span>.getBytes(StandardCharsets.UTF_8),</span><br><span class="line">                ZooDefs.Ids.OPEN_ACL_UNSAFE,</span><br><span class="line">                CreateMode.PERSISTENT);</span><br></pre></td></tr></table></figure><p>可以很清楚的看到是创建成功了的</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924193943269.png" alt="image-20210924193943269"></p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>CreateMode.PERSISTENT</td><td>永久性节点</td></tr><tr><td>CreateMode.PERSISTENT_SEQUENTIAL</td><td>永久性序列节点</td></tr><tr><td>CreateMode.EPHEMERAL</td><td>临时节点，会话断开或过期时会删除此节点</td></tr><tr><td>CreateMode.PERSISTENT_SEQUENTIAL</td><td>临时序列节点，会话断开或过期时会删除此节点</td></tr></tbody></table><h2 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h2><p>Stat stat = new Stat(); zk.getData(“/testRoot”,true,stat);</p><p><strong>例如在我自己电脑上就是这样操作</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stat stat = new Stat();</span><br><span class="line">      byte[] data = zooKeeper.getData(&quot;/show&quot;, true, stat);</span><br><span class="line">      System.out.println(Arrays.toString(data));</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924195519706.png" alt="image-20210924195519706"></p><h2 id="修改节点数据"><a href="#修改节点数据" class="headerlink" title="修改节点数据"></a>修改节点数据</h2><p>// -1表示忽略版本 zk.setData(“/testRoot”, “testRoot_modified”.getBytes(), -1);</p><h2 id="创建子节点"><a href="#创建子节点" class="headerlink" title="创建子节点"></a>创建子节点</h2><p>zk.create(“/testRoot/child1”,”child1_data”.getBytes(),        ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);</p><h2 id="获取子节点"><a href="#获取子节点" class="headerlink" title="获取子节点"></a>获取子节点</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; children = zk.getChildren(<span class="string">&quot;/testRoot&quot;</span>,<span class="keyword">new</span> Watcher()</span><br><span class="line"> &#123;    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span></span><br><span class="line"><span class="function"></span>&#123;       </span><br><span class="line">System.out.println(<span class="string">&quot;this is children node event&quot;</span>); </span><br><span class="line"></span><br><span class="line">      System.out.println(event);     &#125;  </span><br><span class="line"></span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p><em>注：getChildren方法会在子点有变化时触发Watcher()这个监听器</em></p><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><p>zk.delete(“/testRoot”, -1); zk.delete(“/testRoot/child1”, -1);</p><h2 id="关闭连连接"><a href="#关闭连连接" class="headerlink" title="关闭连连接"></a>关闭连连接</h2><p>zk.close();</p><h2 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Zookeeper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooDefs;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.data.Stat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperTest01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException, KeeperException </span>&#123;</span><br><span class="line">        <span class="comment">//创建zk连接</span></span><br><span class="line">        ZooKeeper zooKeeper = <span class="keyword">new</span> ZooKeeper(<span class="string">&quot;master:2181,node1:2181,node2:2181&quot;</span>,<span class="number">3000</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//调用create</span></span><br><span class="line"><span class="comment">//        zooKeeper.create(&quot;/show&quot;,&quot;show&quot;.getBytes(StandardCharsets.UTF_8),</span></span><br><span class="line"><span class="comment">//                ZooDefs.Ids.OPEN_ACL_UNSAFE,</span></span><br><span class="line"><span class="comment">//                CreateMode.PERSISTENT);</span></span><br><span class="line">        <span class="comment">//获取节点</span></span><br><span class="line">        Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line">        <span class="keyword">byte</span>[] data = zooKeeper.getData(<span class="string">&quot;/show&quot;</span>, <span class="keyword">true</span>, stat);</span><br><span class="line">        System.out.println(Arrays.toString(data));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大数据学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MapReduce学习小结</title>
      <link href="/2021/09/22/MapReduce%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
      <url>/2021/09/22/MapReduce%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h1><h2 id="MapReduce概述"><a href="#MapReduce概述" class="headerlink" title="MapReduce概述"></a>MapReduce概述</h2><ul><li>MapReduce是一种分布式计算模型，由Google提出，主要用于搜索领域，解决海量数据的计算问题。</li><li>MapReduce是分布式运行的，由两个阶段组成：Map和Reduce。Map阶段是一个独立的程序，有很多个节点同时运行，每个节点处理一部分数据。Reduce阶段是一个独立的程序，有很多个节点同时运行，每个节点处理一部分数据(在这先把reduce理解为一个单独的聚合程序即可)</li><li>MapReduce框架都有默认实现，用户只需要覆盖map()和reduce()两个函数，即可实现分布式计算，非常简单。</li><li>这两个函数的形参和返回值都是&lt;key、value&gt;，使用的时候一定要注意构造&lt;k,v&gt;</li></ul><h2 id="MapReduce优缺点"><a href="#MapReduce优缺点" class="headerlink" title="MapReduce优缺点"></a>MapReduce优缺点</h2><p><strong>优点：</strong></p><ul><li>1.MapReduce易于编程<ul><li><font color="red">它简单的实现一些接口，就可以完成一个分布式程序，</font>这个分布式程序可以分布到大量廉价的PC机器上运行。也就是说你写一个分布式程序，跟写一个简单的串行程序是一模一样的。就是因为这个特点使得MapReduce编程变得非常流行。</li></ul></li><li>2.良好的拓展性<ul><li>当你的计算资源不能得到满足的时候，你可以通过简单的增加机器来扩展它的计算能力。</li></ul></li><li>3.高容错性<ul><li>MapReduce设计的初衷就是使程序能够部署在廉价的PC机器上，这就要求它具有很高的容错性。比如<font color="red">其中一台机器挂了，它就可以把上面的计算任务转移到另外一个节点上运行，不至于这个任务运行失败，</font>而且这个过程不需要人工参与，而完全是由Hadoop内部完成的。</li></ul></li><li>4.适合PB级别以上的海量数据的离线处理<ul><li>可以实现上千台服务器集群并发工作，提供数据处理能力。</li></ul></li></ul><p><strong>缺点：</strong></p><ul><li>1.不擅长实时计算<ul><li>MapReduce无法像MySQL一样，在毫秒或者秒级内返回结果</li></ul></li><li>2.不擅长流式计算<ul><li>流式计算的输入数据是动态的，而<font color="red">MapReduce的输入数据集是静态的，</font>不能动态变化。这是因为MapReduce自身的设计特点决定了数据源必须是静态的。</li></ul></li><li>3.不擅长DAG(有向图)计算<ul><li>多个应用程序存在依赖关系，后一个应用程序的输入为前一个的输出。在这种情况下，MapReduce并不是不能这么做，而是使用后，<font color="red">每个MapReduce作业的输出结果都会写入到磁盘，会造成大量的磁盘IO，导致性能非常的低下。</font></li></ul></li></ul><h2 id="MapReduce原理"><a href="#MapReduce原理" class="headerlink" title="MapReduce原理"></a>MapReduce原理</h2><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922195326324.png" alt="image-20210922195326324"></p><p>默认可以溢出1.1，即128M基础上溢出1.1就是140M</p><h2 id="MapReduce每个阶段的解释"><a href="#MapReduce每个阶段的解释" class="headerlink" title="MapReduce每个阶段的解释"></a>MapReduce每个阶段的解释</h2><h3 id="Map阶段"><a href="#Map阶段" class="headerlink" title="Map阶段"></a>Map阶段</h3><p>1.1 框架使用InputFormat类的子类把输入文件(夹)划分为很多InputSplit，默认，每个HDFS的block对应一个InputSplit。通过RecordReader类，把每个InputSplit解析成一个个&lt;k1,v1&gt;。默认，框架对每个InputSplit中的每一行，解析成一个&lt;k1,v1&gt;。<br>1.2 框架调用Mapper类中的map(…)函数，map函数的形参是&lt;k1,v1&gt;对，输出是&lt;k2,v2&gt;对。一个InputSplit对应一个map task。程序员可以覆盖map函数，实现自己的逻辑。<br>1.3<br>(假设reduce存在)框架对map输出的&lt;k2,v2&gt;进行分区。不同的分区中的&lt;k2,v2&gt;由不同的reduce task处理。默认只有1个分区。<br> (假设reduce不存在)框架对map结果直接输出到HDFS中。<br>1.4 (假设reduce存在)框架对每个分区中的数据，按照k2进行排序、分组。分组指的是相同k2的v2分成一个组。注意：分组不会减少&lt;k2,v2&gt;数量。<br>1.5 (假设reduce存在，可选)在map节点，框架可以执行reduce归约。<br>1.6 (假设reduce存在)框架会对map task输出的&lt;k2,v2&gt;写入到linux 的磁盘文件中。<br>至此，整个map阶段结束</p><h3 id="Reduce阶段"><a href="#Reduce阶段" class="headerlink" title="Reduce阶段"></a>Reduce阶段</h3><p>1.1 框架对多个map任务的输出，按照不同的分区，通过网络copy到不同的reduce节点。这个过程称作shuffle。<br>1.2 框架对reduce端接收的[map任务输出的]相同分区的&lt;k2,v2&gt;数据进行合并、排序、分组。<br>1.3 框架调用Reducer类中的reduce方法，reduce方法的形参是&lt;k2,{v2…}&gt;，输出是&lt;k3,v3&gt;。一个&lt;k2,{v2…}&gt;调用一次reduce函数。程序员可以覆盖reduce函数，实现自己的逻辑。<br>1.4 框架把reduce的输出保存到HDFS中。<br>至此，整个reduce阶段结束。</p><h3 id="Shuffle阶段"><a href="#Shuffle阶段" class="headerlink" title="Shuffle阶段"></a>Shuffle阶段</h3><p>1.每个map有一个环形内存缓冲区，用于存储map的输出。默认大小100MB（io.sort.mb属性），一旦达到阀值0.8（io.sort.spill.percent）,一个后台线程把内容溢写到(spilt)磁盘的指定目录（mapred.local.dir）下的一个新建文件中。<br>2.写磁盘前，要partition,sort。如果有combiner，combine排序后数据。<br>3.等最后记录写完，合并全部文件为一个分区且排序的文件。</p><p>1.Reducer通过Http方式得到输出文件的特定分区的数据。<br>2.排序阶段合并map输出。然后走Reduce阶段。<br>3.reduce执行完之后，写入到HDFS中。</p><p>mapreduce中，map阶段处理的数据如何传递给reduce阶段，是mapreduce框架中最关键的一个流程，这个流程就叫shuffle；</p><p>具体来说：就是将maptask输出的处理结果数据，分发给reducetask，并在分发的过程中，对数据按key进行了分区和排序；</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210923205558436.png" alt="image-20210923205558436"></p><p>Shuffle中的缓冲区大小会影响到mapreduce程序的执行效率，原则上说，缓冲区越大，磁盘io的次数越少，执行速度就越快。</p><p>随后将mr的程序开发好，并运行即可，这就涉及到一个问题。如何运行。</p><h2 id="MapReduce默认输入处理类"><a href="#MapReduce默认输入处理类" class="headerlink" title="MapReduce默认输入处理类"></a>MapReduce默认输入处理类</h2><ul><li>InputFormat<ul><li>抽象类，只是定义了两个方法。</li></ul></li><li>FileInputFormat<ul><li>FileInputFormat是所有以文件作为数据源的InputFormat实现的基类，FileInputFormat保存作为job输入的所有文件，并实现了对输入文件计算splits的方法。至于获得记录的方法是有不同的子类——TextInputFormat进行实现的。</li></ul></li><li>TextInputFormat<ul><li>是默认的处理类，处理普通文本文件</li><li>文件中每一行作为一个记录，他将每一行在文件中的起始偏移量作为key，每一行的内容作为value</li><li>默认以\n或回车键作为一行记录</li></ul></li></ul><h2 id="InputSplit"><a href="#InputSplit" class="headerlink" title="InputSplit"></a>InputSplit</h2><ul><li>在执行mapreduce之前，原始数据被分割成若干split，每个split作为一个map任务的输入。</li><li>当Hadoop处理很多小文件（文件大小小于hdfs block大小）的时候，由于FileInputFormat不会对小文件进行划分，所以每一个小文件都会被当做一个split并分配一个map任务，会有大量的map task运行，导致效率低下</li><li>例如：一个1G的文件，会被划分成8个128MB的split，并分配8个map任务处理，而10000个100kb的文件会被10000个map任务处理</li><li>Map任务的数量<ul><li>一个InputSplit对应一个Map task</li><li>InputSplit的大小是由Math.max(minSize, Math.min(maxSize,blockSize))决定</li><li>单节点建议运行10—100个map task</li><li>map task执行时长不建议低于1分钟，否则效率低</li></ul></li><li>通过对源码进行查看，可以知道一个split默认128M，可以有1.1的范围溢出，即140M</li></ul><h2 id="MapReduce实战"><a href="#MapReduce实战" class="headerlink" title="MapReduce实战"></a>MapReduce实战</h2><h3 id="WordCount单词统计-使用自带的mapreduce"><a href="#WordCount单词统计-使用自带的mapreduce" class="headerlink" title="WordCount单词统计(使用自带的mapreduce)"></a>WordCount单词统计(使用自带的mapreduce)</h3><p>先自定义一些数据用作测试</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922201933220.png" alt="image-20210922201933220"></p><p>进入hadoop中原装的mapreduce中，并且查看一下。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922202352930.png" alt="image-20210922202352930"></p><p>可以很明显的发现自带了一个jar，我们用刚刚的测试数据来测试下。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922203333957.png" alt="image-20210922203333957"></p><p>可以从生成的日志中很清楚的看到是成功了的，并且可以通过访问这个圈出来的网站去查看。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922203549181.png" alt="image-20210922203549181"></p><p>此时查看一下是否输出了单词统计</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922203829007.png" alt="image-20210922203829007"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922204032074.png" alt="image-20210922204032074"></p><p>可以很清楚的看到确实进行了一个单词统计。</p><h2 id="我们自己来定义MapReduce"><a href="#我们自己来定义MapReduce" class="headerlink" title="我们自己来定义MapReduce"></a>我们自己来定义MapReduce</h2><p>因为在实际开发过程中往往会面临很多种情况，因此需要我们来重写MapReduce。根据不同情况，写出来的代码也不一样</p><h3 id="先实现下刚刚上面的那个情况"><a href="#先实现下刚刚上面的那个情况" class="headerlink" title="先实现下刚刚上面的那个情况"></a>先实现下刚刚上面的那个情况</h3><h4 id="自定义Map"><a href="#自定义Map" class="headerlink" title="自定义Map"></a>自定义Map</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//map类</span></span><br><span class="line">   <span class="comment">//第一队k，v，是决定数据的输入格式</span></span><br><span class="line">   <span class="comment">//第二队k，v，是决定数据的输出格式</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * KEYIN</span></span><br><span class="line"><span class="comment">   *    ----&gt;k1 表示每一行的起始位置(偏移量offset)</span></span><br><span class="line"><span class="comment">   * VALUEIN</span></span><br><span class="line"><span class="comment">   *    ----&gt;V1 表示每一行的文本内容</span></span><br><span class="line"><span class="comment">   * KEYOUT</span></span><br><span class="line"><span class="comment">   *    ----&gt;k2 表示每一行中的每个单词</span></span><br><span class="line"><span class="comment">   * VALUEOUT</span></span><br><span class="line"><span class="comment">   *    ----&gt;V2 表示每一行中的每个单词的出现次数，固定值为1</span></span><br><span class="line"><span class="comment">   * */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>,<span class="title">Text</span>,<span class="title">LongWritable</span>&gt;</span>&#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * map阶段数据是一行一行过来的</span></span><br><span class="line"><span class="comment">       * 每一行数据都需要执行代码</span></span><br><span class="line"><span class="comment">       * */</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException,   InterruptedException </span>&#123;</span><br><span class="line">           <span class="comment">//通过Context输出 Text(一整行数据)，1</span></span><br><span class="line">           String line = value.toString();</span><br><span class="line">           context.write(<span class="keyword">new</span> Text(line),<span class="keyword">new</span> LongWritable(<span class="number">1</span>));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="自定义Reduce"><a href="#自定义Reduce" class="headerlink" title="自定义Reduce"></a>自定义Reduce</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//reduce类</span></span><br><span class="line">  <span class="comment">//用来接收map端输出的数据</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountReduce</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>,<span class="title">LongWritable</span>,<span class="title">Text</span>,<span class="title">LongWritable</span>&gt;</span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;LongWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">           * reduce 聚合程序 每一个k都会调用一次</span></span><br><span class="line"><span class="comment">           * 默认是一个节点</span></span><br><span class="line"><span class="comment">           * key:每一个单词</span></span><br><span class="line"><span class="comment">           * values:map端 当前k所对应的所有的v</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="keyword">long</span> sum = <span class="number">0l</span>;</span><br><span class="line">          <span class="keyword">for</span> (LongWritable value : values) &#123;</span><br><span class="line">                 sum += value.get();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 把计算结果输出到hdfs</span></span><br><span class="line">          context.write(key,<span class="keyword">new</span> LongWritable(sum));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="Main方法"><a href="#Main方法" class="headerlink" title="Main方法"></a>Main方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是当前mapreduce程序入口</span></span><br><span class="line"><span class="comment"> * 用来构建mapreduce程序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个job任务</span></span><br><span class="line">    Job job = Job.getInstance();</span><br><span class="line">    <span class="comment">//指定job名称</span></span><br><span class="line">    job.setJobName(<span class="string">&quot;第一个mapreduce程序，单词统计&quot;</span>);</span><br><span class="line">    <span class="comment">//构建mapreduce</span></span><br><span class="line">    <span class="comment">//指定当前main所在类名(识别具体的类)</span></span><br><span class="line">    job.setJarByClass(DemoWordCount1.class);</span><br><span class="line">    <span class="comment">//指定Map端的类</span></span><br><span class="line">    job.setMapperClass(WordCountMapper.class);</span><br><span class="line">    <span class="comment">//指定Map端输出的kv类型</span></span><br><span class="line">    job.setMapOutputKeyClass(Text.class);</span><br><span class="line">    job.setMapOutputValueClass(LongWritable.class);</span><br><span class="line">    <span class="comment">//指定Reduce端的类</span></span><br><span class="line">    job.setReducerClass(WordCountReduce.class);</span><br><span class="line">    <span class="comment">//指定Reduce端输出的kv类型</span></span><br><span class="line">    job.setOutputKeyClass(Text.class);</span><br><span class="line">    job.setOutputValueClass(LongWritable.class);</span><br><span class="line">    <span class="comment">//指定输入路径</span></span><br><span class="line">    Path in = <span class="keyword">new</span> Path(<span class="string">&quot;/word&quot;</span>);</span><br><span class="line">    FileInputFormat.addInputPath(job,in);</span><br><span class="line">    <span class="comment">//指定输出路径</span></span><br><span class="line">    Path out = <span class="keyword">new</span> Path(<span class="string">&quot;/out&quot;</span>);       <span class="comment">//是因为输出的路径是不能提前存在的</span></span><br><span class="line">    <span class="comment">//如果路径存在，就删除</span></span><br><span class="line">    FileSystem fs = FileSystem.get(<span class="keyword">new</span> Configuration());</span><br><span class="line">    <span class="keyword">if</span>(fs.exists(out))&#123;</span><br><span class="line">        fs.delete(out,<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    FileOutputFormat.setOutputPath(job,out);</span><br><span class="line">    <span class="comment">//启动任务</span></span><br><span class="line">    job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;mapreduce正在执行&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mapreduce;</span><br><span class="line"><span class="comment">//用来统计文件中单词个数</span></span><br><span class="line"><span class="comment">// 重写 覆盖mapreduce框架中的map()方法和reduce()方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoWordCount1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//map类</span></span><br><span class="line">    <span class="comment">//第一队k，v，是决定数据的输入格式</span></span><br><span class="line">    <span class="comment">//第二队k，v，是决定数据的输出格式</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * KEYIN</span></span><br><span class="line"><span class="comment">    *    ----&gt;k1 表示每一行的起始位置(偏移量offset)</span></span><br><span class="line"><span class="comment">    * VALUEIN</span></span><br><span class="line"><span class="comment">    *    ----&gt;V1 表示每一行的文本内容</span></span><br><span class="line"><span class="comment">    * KEYOUT</span></span><br><span class="line"><span class="comment">    *    ----&gt;k2 表示每一行中的每个单词</span></span><br><span class="line"><span class="comment">    * VALUEOUT</span></span><br><span class="line"><span class="comment">    *    ----&gt;V2 表示每一行中的每个单词的出现次数，固定值为1</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>,<span class="title">Text</span>,<span class="title">LongWritable</span>&gt;</span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * map阶段数据是一行一行过来的</span></span><br><span class="line"><span class="comment">        * 每一行数据都需要执行代码</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException,   InterruptedException </span>&#123;</span><br><span class="line">            <span class="comment">//通过Context输出 Text(一整行数据)，1</span></span><br><span class="line">            String line = value.toString();</span><br><span class="line">            context.write(<span class="keyword">new</span> Text(line),<span class="keyword">new</span> LongWritable(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//reduce类</span></span><br><span class="line">    <span class="comment">//用来接收map端输出的数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountReduce</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>,<span class="title">LongWritable</span>,<span class="title">Text</span>,<span class="title">LongWritable</span>&gt;</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;LongWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * reduce 聚合程序 每一个k都会调用一次</span></span><br><span class="line"><span class="comment">             * 默认是一个节点</span></span><br><span class="line"><span class="comment">             * key:每一个单词</span></span><br><span class="line"><span class="comment">             * values:map端 当前k所对应的所有的v</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">long</span> sum = <span class="number">0l</span>;</span><br><span class="line">            <span class="keyword">for</span> (LongWritable value : values) &#123;</span><br><span class="line">                   sum += value.get();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把计算结果输出到hdfs</span></span><br><span class="line">            context.write(key,<span class="keyword">new</span> LongWritable(sum));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是当前mapreduce程序入口</span></span><br><span class="line"><span class="comment">     * 用来构建mapreduce程序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个job任务</span></span><br><span class="line">        Job job = Job.getInstance();</span><br><span class="line">        <span class="comment">//指定job名称</span></span><br><span class="line">        job.setJobName(<span class="string">&quot;第一个mapreduce程序，单词统计&quot;</span>);</span><br><span class="line">        <span class="comment">//构建mapreduce</span></span><br><span class="line">        <span class="comment">//指定当前main所在类名(识别具体的类)</span></span><br><span class="line">        job.setJarByClass(DemoWordCount1.class);</span><br><span class="line">        <span class="comment">//指定Map端的类</span></span><br><span class="line">        job.setMapperClass(WordCountMapper.class);</span><br><span class="line">        <span class="comment">//指定Map端输出的kv类型</span></span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(LongWritable.class);</span><br><span class="line">        <span class="comment">//指定Reduce端的类</span></span><br><span class="line">        job.setReducerClass(WordCountReduce.class);</span><br><span class="line">        <span class="comment">//指定Reduce端输出的kv类型</span></span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(LongWritable.class);</span><br><span class="line">        <span class="comment">//指定输入路径</span></span><br><span class="line">        Path in = <span class="keyword">new</span> Path(<span class="string">&quot;/word&quot;</span>);</span><br><span class="line">        FileInputFormat.addInputPath(job,in);</span><br><span class="line">        <span class="comment">//指定输出路径</span></span><br><span class="line">        Path out = <span class="keyword">new</span> Path(<span class="string">&quot;/out&quot;</span>);       <span class="comment">//是因为输出的路径是不能提前存在的</span></span><br><span class="line">        <span class="comment">//如果路径存在，就删除</span></span><br><span class="line">        FileSystem fs = FileSystem.get(<span class="keyword">new</span> Configuration());</span><br><span class="line">        <span class="keyword">if</span>(fs.exists(out))&#123;</span><br><span class="line">            fs.delete(out,<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        FileOutputFormat.setOutputPath(job,out);</span><br><span class="line">        <span class="comment">//启动任务</span></span><br><span class="line">        job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;mapreduce正在执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922215132274.png" alt="image-20210922215132274"></p><p>此时用Maven里面的package打包上传到服务器，然后执行就可以了。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922220015535.png" alt="image-20210922220015535"></p><ul><li>提交任务<ul><li>通过maven中的package将项目打包上传服务器然后执行</li><li>执行任务 hadoop jar 刚刚自己上传的包 自己的项目路径 hdfs中的输入路径 输出路径(输入和输出路径我都已经在代码里面定义过了)</li></ul></li><li>例如我的就是:</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hadoop jar Hadoop-1.0-SNAPSHOT.jar mapreduce.DemoWordCount1 /word</span><br><span class="line"><span class="comment"># (输入和输出路径我都已经在代码里面定义过了，可以省略，我这输入的路径忘记省略了)</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922220745263.png" alt="image-20210922220745263"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922221141989.png" alt="image-20210922221141989"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922221208495.png" alt="image-20210922221208495"></p><p>可以很直观的看到是成功了的。我这里是因为程序中没去除空格，所以统计的时候也统计了空格的数量。</p><h3 id="切片分析"><a href="#切片分析" class="headerlink" title="切片分析"></a>切片分析</h3><p>刚刚上面的情况是一行只有一个数据，那么当一行中有多个数据该怎么办勒？此时就可以用切片方法。</p><p>先创建一些原始数据，可以看到一行有很多个单词。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922224631032.png" alt="image-20210922224631032"></p><h4 id="自定义Map-1"><a href="#自定义Map-1" class="headerlink" title="自定义Map"></a>自定义Map</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>,<span class="title">Text</span>,<span class="title">LongWritable</span>&gt; </span>&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">           String line = value.toString();</span><br><span class="line">           String[] split = line.split(<span class="string">&quot;,&quot;</span>); <span class="comment">//以逗号进行切分</span></span><br><span class="line">           <span class="keyword">for</span> (String s : split) &#123;</span><br><span class="line">               context.write(<span class="keyword">new</span> Text(s),<span class="keyword">new</span> LongWritable(<span class="number">1</span>));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="自定义Reduce-1"><a href="#自定义Reduce-1" class="headerlink" title="自定义Reduce"></a>自定义Reduce</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountReduce</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>,<span class="title">LongWritable</span>,<span class="title">Text</span>,<span class="title">LongWritable</span>&gt;</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;LongWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> sum = <span class="number">0l</span>;</span><br><span class="line">            <span class="keyword">for</span> (LongWritable value : values) &#123;</span><br><span class="line">                sum += value.get();</span><br><span class="line">            &#125;</span><br><span class="line">            context.write(key,<span class="keyword">new</span> LongWritable(sum));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Main方法-1"><a href="#Main方法-1" class="headerlink" title="Main方法"></a>Main方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个job任务</span></span><br><span class="line">    Job job = Job.getInstance();</span><br><span class="line">    <span class="comment">//指定job名称</span></span><br><span class="line">    job.setJobName(<span class="string">&quot;第二个mapreduce程序，单词统计&quot;</span>);</span><br><span class="line">    <span class="comment">//构建mapreduce</span></span><br><span class="line">    <span class="comment">//指定当前main所在类名(识别具体的类)</span></span><br><span class="line">    job.setJarByClass(DemoWordCount2.class);</span><br><span class="line">    <span class="comment">//指定Map端的类</span></span><br><span class="line">    job.setMapperClass(WordCountMapper.class);</span><br><span class="line">    <span class="comment">//指定Map端输出的kv类型</span></span><br><span class="line">    job.setMapOutputKeyClass(Text.class);</span><br><span class="line">    job.setMapOutputValueClass(LongWritable.class);</span><br><span class="line">    <span class="comment">//指定Reduce端的类</span></span><br><span class="line">    job.setReducerClass(WordCountReduce.class);</span><br><span class="line">    <span class="comment">//指定Reduce端输出的kv类型</span></span><br><span class="line">    job.setOutputKeyClass(Text.class);</span><br><span class="line">    job.setOutputValueClass(LongWritable.class);</span><br><span class="line">    <span class="comment">//指定输入路径</span></span><br><span class="line">    Path in = <span class="keyword">new</span> Path(<span class="string">&quot;/word&quot;</span>);</span><br><span class="line">    FileInputFormat.addInputPath(job,in);</span><br><span class="line">    <span class="comment">//指定输出路径</span></span><br><span class="line">    Path out = <span class="keyword">new</span> Path(<span class="string">&quot;/out&quot;</span>);       <span class="comment">//是因为输出的路径是不能提前存在的</span></span><br><span class="line">    <span class="comment">//如果路径存在，就删除</span></span><br><span class="line">    FileSystem fs = FileSystem.get(<span class="keyword">new</span> Configuration());</span><br><span class="line">    <span class="keyword">if</span>(fs.exists(out))&#123;</span><br><span class="line">        fs.delete(out,<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    FileOutputFormat.setOutputPath(job,out);</span><br><span class="line">    <span class="comment">//启动任务</span></span><br><span class="line">    job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;mapreduce正在执行&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总代码-1"><a href="#总代码-1" class="headerlink" title="总代码"></a>总代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mapreduce;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">//切片</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoWordCount2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>,<span class="title">Text</span>,<span class="title">LongWritable</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            String line = value.toString();</span><br><span class="line">            String[] split = line.split(<span class="string">&quot;,&quot;</span>); <span class="comment">//以逗号进行切分</span></span><br><span class="line">            <span class="keyword">for</span> (String s : split) &#123;</span><br><span class="line">                context.write(<span class="keyword">new</span> Text(s),<span class="keyword">new</span> LongWritable(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountReduce</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>,<span class="title">LongWritable</span>,<span class="title">Text</span>,<span class="title">LongWritable</span>&gt;</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;LongWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> sum = <span class="number">0l</span>;</span><br><span class="line">            <span class="keyword">for</span> (LongWritable value : values) &#123;</span><br><span class="line">                sum += value.get();</span><br><span class="line">            &#125;</span><br><span class="line">            context.write(key,<span class="keyword">new</span> LongWritable(sum));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个job任务</span></span><br><span class="line">        Job job = Job.getInstance();</span><br><span class="line">        <span class="comment">//指定job名称</span></span><br><span class="line">        job.setJobName(<span class="string">&quot;第二个mapreduce程序，单词统计&quot;</span>);</span><br><span class="line">        <span class="comment">//构建mapreduce</span></span><br><span class="line">        <span class="comment">//指定当前main所在类名(识别具体的类)</span></span><br><span class="line">        job.setJarByClass(DemoWordCount2.class);</span><br><span class="line">        <span class="comment">//指定Map端的类</span></span><br><span class="line">        job.setMapperClass(WordCountMapper.class);</span><br><span class="line">        <span class="comment">//指定Map端输出的kv类型</span></span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(LongWritable.class);</span><br><span class="line">        <span class="comment">//指定Reduce端的类</span></span><br><span class="line">        job.setReducerClass(WordCountReduce.class);</span><br><span class="line">        <span class="comment">//指定Reduce端输出的kv类型</span></span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(LongWritable.class);</span><br><span class="line">        <span class="comment">//指定输入路径</span></span><br><span class="line">        Path in = <span class="keyword">new</span> Path(<span class="string">&quot;/word&quot;</span>);</span><br><span class="line">        FileInputFormat.addInputPath(job,in);</span><br><span class="line">        <span class="comment">//指定输出路径</span></span><br><span class="line">        Path out = <span class="keyword">new</span> Path(<span class="string">&quot;/out&quot;</span>);       <span class="comment">//是因为输出的路径是不能提前存在的</span></span><br><span class="line">        <span class="comment">//如果路径存在，就删除</span></span><br><span class="line">        FileSystem fs = FileSystem.get(<span class="keyword">new</span> Configuration());</span><br><span class="line">        <span class="keyword">if</span>(fs.exists(out))&#123;</span><br><span class="line">            fs.delete(out,<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        FileOutputFormat.setOutputPath(job,out);</span><br><span class="line">        <span class="comment">//启动任务</span></span><br><span class="line">        job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;mapreduce正在执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922231243523.png" alt="image-20210922231243523"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922231526450.png" alt="image-20210922231526450"></p><p>可以很直观的查看到已经成功了，并且也已经做出了统计。</p><h2 id="GitHub地址"><a href="#GitHub地址" class="headerlink" title="GitHub地址"></a>GitHub地址</h2><p>更多代码请查看我的GitHub地址仓库地址</p><p><a href="https://github.com/Fang-gg/Hadoop.git">https://github.com/Fang-gg/Hadoop.git</a></p>]]></content>
      
      
      <categories>
          
          <category> 大数据学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDFS学习小结</title>
      <link href="/2021/09/22/HDFS%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
      <url>/2021/09/22/HDFS%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h1><h2 id="HDFS产生背景和定义"><a href="#HDFS产生背景和定义" class="headerlink" title="HDFS产生背景和定义"></a>HDFS产生背景和定义</h2><p>随着数据量越来越大，在一个操作系统存不下所有的数据，那么就分配到更多的操作系统管理的磁盘中，但是不方便管理和维护。<font color="red">迫切需要一种系统来管理多台机器上的文件，</font>这就是分布式文件管理系统。<font color="red">HDFS只是分布式文件管理系统中的一种。</font></p><p>定义：<font color="blue">HDFS，它是一个文件系统</font>，用于存储文件，通过目录树来定位文件；<font color="blue">其次，它是分布式的</font>,由很多服务器联合起来实现其功能，集群中的服务器有各自的角色。</p><p><font color="red">HDFS的使用场景：适合一次写入，多次读出的场景，且不支持文件的修改。</font>适合用来做数据分析，并不适合用来做网盘应用。</p><h2 id="HDFS优缺点"><a href="#HDFS优缺点" class="headerlink" title="HDFS优缺点"></a>HDFS优缺点</h2><p>优点：</p><ul><li>高容错性<ul><li>数据自动保存多个副本。它通过增加副本的形式，提高容错性</li><li>某一个副本丢失以后，它可以自动恢复</li></ul></li><li>适合处理大数据<ul><li>数据规模：能够处理数据规模达到GB、TB、甚至PB级别的数据</li><li>文件规模：能够处理百万规模以上的文件数量，数量相当之大</li></ul></li><li>可以构建在廉价机器上，通过多副本机制，提高可靠性。</li></ul><p>缺点：</p><ul><li><font color="red">不适合低延时数据访问</font>，比如毫秒级的存储数据，是做不到的</li><li><font color="red">无法高效的对大量小文件进行存储</font><ul><li>存储大量小文件的话，它会占用NameNode大量的内存来存储文件目录和块信息。这样是不可取的，因为NameNode的内存总是有限的</li><li>小文件存储的寻址时间会超过读取时间，它违反了HDFS的设计目标</li></ul></li><li>不支持并发写入，文件随即修改<ul><li>一个文件只能有一个写，不允许多个线程同时写</li><li><font color="red">仅支持数据append(追加)，</font>不支持文件的随即修改</li></ul></li></ul><h2 id="HDFS组成架构"><a href="#HDFS组成架构" class="headerlink" title="HDFS组成架构"></a>HDFS组成架构</h2><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210921105505867.png" alt="image-20210921105505867"></p><p><font color="blue">NameNode：就是Master，它是一个主管，管理者</font></p><ul><li>管理HDFS的名称空间</li><li>配置副本策略</li><li>管理数据块(Block)映射信息</li><li>处理客户端读写请求</li></ul><p><font color="blue">DataNode：就是Slave。NameNode下达命令，DataNode执行实际的操作</font></p><ul><li>存储实际的数据块</li><li>执行数据块的读/写操作</li></ul><p><font color="blue">Client：就是客户端</font></p><ul><li>文件切分。文件上传HDFS的时候，Client将文件切分成一个一个的Block，然后进行上传</li><li>与NameNode交互，获取文件的位置信息</li><li>与DataNode交互，读取或者写入数据</li><li>Client提供一些命令来管理HDFS，比如NameNode格式化</li><li>Client可以通过一些命令来访问HDFS，比如对HDFS增删改查操作</li></ul><p><font color="blue">Secondary NameNode：并非NameNode的热备。当NameNode挂掉的时候，它并不能马上替换NameNode并提供服务</font></p><ul><li>辅助NameNode，分担其工作量，比如定期合并Fsimage和Edits，并推送给NameNode</li><li>在紧急情况下，可辅助恢复NameNode</li></ul><h2 id="HDFS文件块大小-面试重点"><a href="#HDFS文件块大小-面试重点" class="headerlink" title="HDFS文件块大小(面试重点)"></a>HDFS文件块大小(面试重点)</h2><p>HDFS中的文件在物理上是分块存储(Block)，块的大小可以通过配置参数(dfs.blocksize)来规定，<font color="red">默认大小在Hadoop2.x版本中是128M，老版本是64M。</font></p><h3 id="思考：为什么块的大小不能设置太小，也不能设置太大？"><a href="#思考：为什么块的大小不能设置太小，也不能设置太大？" class="headerlink" title="思考：为什么块的大小不能设置太小，也不能设置太大？"></a>思考：为什么块的大小不能设置太小，也不能设置太大？</h3><ul><li>HDFS的块<font color="red">设置太小，会增加寻址时间，</font>程序一直在找块的开始位置</li><li>如果块<font color="red">设置的太大，从磁盘传输数据的时间会明显大于定位这个块开始位置所需的时间。</font>导致程序在处理这块数据的时候，或非常慢。</li></ul><p><font color="red">总结：HDFS块的大小设置主要取决于磁盘传输速率。</font></p><h2 id="HDFS的Shell操作-开发重点"><a href="#HDFS的Shell操作-开发重点" class="headerlink" title="HDFS的Shell操作(开发重点)"></a>HDFS的Shell操作(开发重点)</h2><ul><li><font color="red">hadoop dfs -ls /</font>，显示目录信息</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210921143153565.png" alt="image-20210921143153565"></p><p>然后我们去可视化界面查看以下是否正确</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210921143246306.png" alt="image-20210921143246306"></p><p>可以直观地看到和Linux界面显示的是一致的！</p><ul><li><font color="red">hadoop dfs -mkdir /</font>，在HDFS上创造目录</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210921144528651.png" alt="image-20210921144528651"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210921144626661.png" alt="image-20210921144626661"></p><p>可以很直观的看到创建成功</p><ul><li><font color="red">hadoop dfs -touchz</font>，创建一个文件</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210921145355674.png" alt="image-20210921145355674"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210921145457238.png" alt="image-20210921145457238"></p><p>可以很直观的看到在fst这个目录下面我创建成功了fangshitao.txt文件</p><ul><li><font color="red">hadoop dfs -appendToFile</font>，追加一个本地文件到已经存在的文件的末尾</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210921152517808.png" alt="image-20210921152517808"></p><p>此时我这个文件大小是0，这时候我追加一个进去。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210921152810988.png" alt="image-20210921152810988"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210921152831174.png" alt="image-20210921152831174"></p><p>此时就能很直观的查看到fangshitao.txt这个文件大小已经发生了变化。</p><ul><li><font color="red">hadoop dfs -cat </font>，查看文件内容</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210921153023790.png" alt="image-20210921153023790"></p><ul><li><font color="red">hadoop dfs -rm -r </font>，删除文件。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210921153327918.png" alt="image-20210921153327918"></p><p><strong>注意：</strong>此时这个删除会将文件放入回收站内，想要彻底删除还得将回收站清空</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210921153521433.png" alt="image-20210921153521433"></p><p>可以很直观的查看到此时删除的文件在Trash这个回收站中。</p><ul><li><font color="red">hadoop dfs -rm -r -skipTrash</font>，删除文件的时候会自动跳过回收站。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210921153717390.png" alt="image-20210921153717390"></p><p>此时的删除就不会再出现上面的那种问题了。因为直接跳过了垃圾回收。</p><p>其实总的来说，HDFS中的命令和Linux类似，唯一的不同点就是：<font color="blue">HDFS的命令需要在前面加上hadoop dfs -</font></p><ul><li><font color="red">hadoop dfs -setrep</font>，设置HDFS中文件的副本数</li></ul><h2 id="Java操作HDFS"><a href="#Java操作HDFS" class="headerlink" title="Java操作HDFS"></a>Java操作HDFS</h2><h3 id="创建连接"><a href="#创建连接" class="headerlink" title="创建连接"></a>创建连接</h3><p>使用Java操作HDFS，其实是使用hdfs的文件管理系统file system(在hdfs-site.xml中)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileSystem fs;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> URISyntaxException </span>&#123;</span><br><span class="line">        <span class="comment">//获得配置文件</span></span><br><span class="line">        Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">        <span class="comment">//设置副本数</span></span><br><span class="line">        conf.set(<span class="string">&quot;dfs.replication&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="comment">//获取指定的连接地址</span></span><br><span class="line">        <span class="comment">//端口号9000在core-site.xml中，50070只是一个前端的界面端口号</span></span><br><span class="line">        URI uri = <span class="keyword">new</span> URI(<span class="string">&quot;hdfs://master:9000&quot;</span>);</span><br><span class="line">        <span class="comment">//创建获取文件管理系统的对象，通过对象操作HDFS</span></span><br><span class="line">        fs = FileSystem.get(uri, conf);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="创建目录或者文件"><a href="#创建目录或者文件" class="headerlink" title="创建目录或者文件"></a>创建目录或者文件</h3><p>值得注意的是mkdirs方法里面需要的是Path，而不是一个直接的路径</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> mkdirs = fs.mkdirs(<span class="keyword">new</span> Path(<span class="string">&quot;/fst/fst&quot;</span>));</span><br><span class="line">        System.out.println(mkdirs);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="删除目录或者文件"><a href="#删除目录或者文件" class="headerlink" title="删除目录或者文件"></a>删除目录或者文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//boolean表示是否可以迭代删除</span></span><br><span class="line">       <span class="comment">//true表示可以迭代删除，false表示不行。</span></span><br><span class="line">       <span class="keyword">boolean</span> delete = fs.delete(<span class="keyword">new</span> Path(<span class="string">&quot;/fst/fst&quot;</span>),<span class="keyword">true</span>);</span><br><span class="line">       System.out.println(delete);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="查看HDFS上的文件"><a href="#查看HDFS上的文件" class="headerlink" title="查看HDFS上的文件"></a>查看HDFS上的文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FSDataInputStream open = fs.open(<span class="keyword">new</span> Path(<span class="string">&quot;/datas/score.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//封装成缓冲流</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(open));</span><br><span class="line">        String line=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line=br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="上传文件到HDFS"><a href="#上传文件到HDFS" class="headerlink" title="上传文件到HDFS"></a>上传文件到HDFS</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//hdfs上的文件默认不能被修改</span></span><br><span class="line">    <span class="comment">//上传文件</span></span><br><span class="line">    <span class="comment">//覆盖掉，没有追加的功能</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FSDataOutputStream fsDataOutputStream = fs.create(<span class="keyword">new</span> Path(<span class="string">&quot;/datas/score.txt&quot;</span>));</span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(fsDataOutputStream));</span><br><span class="line">        bw.write(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        bw.write(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        bw.flush();</span><br><span class="line">        bw.close();</span><br><span class="line">        fsDataOutputStream.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922191908697.png" alt="image-20210922191908697"></p><h2 id="HDFS读写数据"><a href="#HDFS读写数据" class="headerlink" title="HDFS读写数据"></a>HDFS读写数据</h2><h3 id="HDFS读数据流程"><a href="#HDFS读数据流程" class="headerlink" title="HDFS读数据流程"></a>HDFS读数据流程</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922184350441.png" alt="image-20210922184350441"></p><p><strong>简化描述</strong><br>1、open，打开HDFS的文件存储系统<br>2、向下找某一个具体的数据；这就需要去找namenode了，namenode里面存储了它的元数据信息（包括位置在哪，大小是多少等等）<br>3、开始读数据了（多个block就按顺序读）<br>挂了就找副本<br>4、读完就关闭</p><p><strong>原描述</strong><br>1.首先调用FileSystem对象的open方法，其实是一个DistributedFileSystem的实例<br>2.DistributedFileSystem通过rpc获得文件的第一个block的locations（namenode查出来的），同一block按照副本数（一个block的文件有三个备份）会返回多个locations（返回给open方法），这些locations按照hadoop拓扑结构（远近）排序，距离客户端近的排在前面.<br>3.前两步会返回一个（io流对象，封装成）FSDataInputStream对象，该对象会被封装成DFSInputStream对象，DFSInputStream可以方便的管理datanode和namenode数据流。客户端调用read方法，DFSInputStream最会找出离客户端最近的datanode并连接。<br>4.数据从datanode源源不断的流向客户端。<br>5.如果第一块的数据读完了，就会关闭指向第一块的datanode连接，接着读取下一块。（有多个block就还继续按照上面的顺序接着读取）这些操作对客户端来说是透明的（也就是用户不需要知道下面都做了什么），客户端的角度看来只是读一个持续不断的流。<br>6.如果第一批block都读完了，DFSInputStream就会去namenode拿下一批blocks的location，然后继续读，如果所有的块都读完，这时就会关闭掉所有的流。<br>如果在读数据的时候，DFSInputStream和datanode的通讯发生异常，就会尝试正在读的block的排第二近的datanode,并且会记录哪个datanode发生错误，剩余的blocks读的时候就会直接跳过该datanode。DFSInputStream也会检查block数据校验和，如果发现一个坏的block,就会先报告到namenode节点，然后DFSInputStream在其他的datanode上读该block的镜像<br>该设计的方向就是客户端直接连接datanode来检索数据并且namenode来负责为每一个block提供最优的datanode，namenode仅仅处理block location的请求，这些信息都加载在namenode的内存中，hdfs通过datanode集群可以承受大量客户端的并发访问。</p><h3 id="HDFS写数据流程"><a href="#HDFS写数据流程" class="headerlink" title="HDFS写数据流程"></a>HDFS写数据流程</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922184921488.png" alt="image-20210922184921488"></p><p>写数据的时候要注意副本问题，要么同时成功，要么同时失败，具有<strong>原子性</strong>；不存在一个副本写入成功，一个副本写入失败的问题。</p><p><strong>简化描述</strong><br>1、create，打开了FileSystem<br>2、打开namenode；namenode要了解这个新的文件的信息（文件写在了哪，大小多少等等）<br>3、写数据<br>4、包的形式做数据传输，namenode告诉流，哪个地方存储比较合适<br>5、返回做验证，验证是否写成功，要是一个失败，那就全部失败（原子性），打开ack，监听是否成功<br>6、关闭流<br>7、将数据传给namenode做分配</p><p><strong>原描述</strong><br>1.客户端通过调用DistributedFileSystem的create方法创建新文件<br>2.DistributedFileSystem通过RPC调用namenode去创建一个没有blocks关联的新文件（这时候还没有决定存在哪个位置），创建前，namenode会做各种校验，比如文件是否存在，客户端有无权限去创建等。如果校验通过，namenode就会记录下新文件，否则就会抛出IO异常.<br>3.前两步结束后会返回FSDataOutputStream的对象，像读文件的时候相似，FSDataOutputStream被封装成DFSOutputStream.DFSOutputStream可以协调namenode和datanode。客户端开始写数据到DFSOutputStream,DFSOutputStream会把数据切成一个个小packet，然后排成队列data quene（理解为缓存，将数据进行排列，有序的，方便切分，比如数据到了128MB，可以进行切分）。<br>4.DataStreamer会去处理接受data queue，他先问询namenode这个新的block最适合存储的在哪几个datanode里，比如副本数是3，那么就找到3个最适合的datanode（namenode告诉了数据流，存储到哪个地方比较合适），把他们排成一个pipeline（类似于队列中的出栈，出去就没了）.DataStreamer把packet按队列输出到管道的第一个datanode中，第一个datanode又把packet输出到第二个datanode中，以此类推。<br>5.DFSOutputStream还有一个对列叫ack queue（一个队列是传输数据，一个队列是验证），也是由packet组成，等待datanode的收到响应，当pipeline中的所有datanode都表示已经收到的时候，这时ack queue才会把对应的packet包移除掉。（ack就是把数据搞成了两个队列，防止数据发生错误；一个队列是出栈的，存储到datanode，一个队列是验证的，当验证没有问题之后，ack才会把自己的数据丢掉，留着就是为了防止出现问题，找不到数据了）<br>如果在写的过程中某个datanode发生错误，会采取以下几步：1) pipeline被关闭掉；2)为了防止丢包ack queue里的packet会同步到data queue里；3)把产生错误的datanode上当前在写但未完成的block删掉；4）block剩下的部分被写到剩下的两个正常的datanode中；5）namenode找到另外的datanode去创建这个块的复制（也是三个的）。当然，这些操作对客户端来说是无感知的。<br>6.客户端完成写数据后调用close方法关闭写入流<br>7.DataStreamer把剩余得包都刷到pipeline里然后等待ack信息，收到最后一个ack后，通知namenode把文件标示为已完成</p><h2 id="NameNode和SecondaryNameNode-面试开发重点"><a href="#NameNode和SecondaryNameNode-面试开发重点" class="headerlink" title="NameNode和SecondaryNameNode(面试开发重点)"></a>NameNode和SecondaryNameNode(面试开发重点)</h2><p>思考：NameNode中的元数据是存储在哪里的？</p><p>​        首先，我们做个假设，如果存储在NameNode节点的磁盘中，因为经常需要进行随机访问，还有响应客户请求，必然是效率过低。因此，元数据需要存放在内存中。但如果只存在内存中，一旦断电，源数据丢失，整个集群就无法工作了。<font color="red">因此产生在磁盘中备份元数据的FsImage。</font></p><p>​        这样又会带来新的问题，当在内存中的元数据更新时，如果同时更新FsImage，就会导致效率过低，但如果不更新，就会发生一致性问题，一旦NameNode节点断电，就会产生数据丢失。<font color="red">因此，引入Edits文件(只进行追加操作，效率很高)。每当元数据有更新或者添加元数据时，修改内存中的元数据并追加到Edits中。</font>这样，一旦NameNode节点断电，可以通过FsImage和Edits的合并，合成元数据。</p><p>​        但是，如果长时间添加数据到Edits中，会导致该文件数据过大，效率降低，而且一旦断电，恢复原数据需要的时间过长。因此，需要定期进行FsImage和Edits的合并，如果这个操作由NameNode节点完成，优惠效率过低。<font color="red">因此，引入一个新的节点SecondaryNameNode，专门用于FsImage和Edits的合并。</font></p><ul><li>fsimage:元数据镜像文件（<strong>备份</strong>）。存储某一时段NameNode内存元数据信息。</li><li>edits:操作日志文件，namenode启动后一些新增元信息日志。（存的是hdfs的操作记录）</li><li>fstime:保存最近一次checkpoint的时间</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922183416186.png" alt="image-20210922183416186"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922183845809.png" alt="image-20210922183845809"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922183857676.png" alt="image-20210922183857676"></p><h2 id="DataNode工作机制"><a href="#DataNode工作机制" class="headerlink" title="DataNode工作机制"></a>DataNode工作机制</h2><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922184219645.png" alt="image-20210922184219645"></p><h2 id="集群安全模式"><a href="#集群安全模式" class="headerlink" title="集群安全模式"></a>集群安全模式</h2><ul><li><strong>NameNode启动</strong><ul><li>NameNode启动时，首先将镜像文件(Fsimage)载入到内存，并执行编辑日志(Edits)中的各项操作。一旦在内存中成功建立文件系统元数据的映像，则创建一个新的Fsimage文件和一个空的编辑日志。此时，NameNode开始监听DataNode请求。<font color="red">这个过程期间，NameNode一直运行在安全模式，即NameNode的文件系统对于客户端来说是只读的。</font></li></ul></li><li>DataNode启动<ul><li><font color="red">系统中的数据块的位置并不是由NameNode维护的，而是以块列表的形式存储在DataNode中。</font>在系统的正常操作期间，NameNode会在内存中保留所有块位置的映射信息。在安全模式下，各个DataNode会向NameNode发送最新的块列表信息，NameNode了解到足够多的块信息之后，即可高效运行文件系统。</li></ul></li><li>安全模式推出判断<ul><li>如果满足<font color="red">“最小副本条件”，NameNode会在30秒钟之后就退出安全模式。</font>所谓的最小副本条件指的是在整个文件系统中99.9%的块满足最小副本级别(默认值：dfs.replication.min=1)。<font color="red">在启动一个刚刚格式化的HDFS集群时，因为系统中还没有任何块，所以NameNode不会进入安全模式。</font></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 大数据学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop学习</title>
      <link href="/2021/09/20/Hadoop%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/09/20/Hadoop%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h1><p>学习Hadoop之前请先将对应的环境搭建好，可以参考我之前的Hadoop2.x版本安装</p><h2 id="Hadoop的优势"><a href="#Hadoop的优势" class="headerlink" title="Hadoop的优势"></a>Hadoop的优势</h2><p>1.高可靠性：Hadoop底层维护了多个数据副本，所以即使Hadoop某个计算元素或存储出现故障，也不会导致数据的丢失。</p><p>2.高扩展性：在集群间分配任务数据，可方便的扩展数以千计的节点。</p><p>3.高效性：在MapReduce的思想下，Hadoop是并行工作的，以加快任务处理速度</p><p>4.高容错性：能够自动将失败的任务重新分配。</p><h2 id="Hadoop1-x和Hadoop2-x区别"><a href="#Hadoop1-x和Hadoop2-x区别" class="headerlink" title="Hadoop1.x和Hadoop2.x区别"></a>Hadoop1.x和Hadoop2.x区别</h2><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210920104137821.png" alt="image-20210920104137821"></p><h2 id="HDFS架构概述"><a href="#HDFS架构概述" class="headerlink" title="HDFS架构概述"></a>HDFS架构概述</h2><p>1.NameNode：存储文件的元数据，如文件名，文件目录结构，文件属性(生成时间，副本数，文件权限)，以及每个文件的块列表和块所在的DataNode等。</p><p>2.DataNode：在本地文件系统存储文件块数据，以及块数据的校验和。</p><p>3.Secondary NameNode：用来监控HDFS状态的辅助后台程序，每隔一段时间获取HDFS元数据的快照。</p><h2 id="YARN架构"><a href="#YARN架构" class="headerlink" title="YARN架构"></a>YARN架构</h2><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210920105251286.png" alt="image-20210920105251286"></p><h2 id="MapReduce架构概述"><a href="#MapReduce架构概述" class="headerlink" title="MapReduce架构概述"></a>MapReduce架构概述</h2><p>MapReduce将计算过程分为两个阶段：Map和Reduce</p><p>1.Map阶段并行处理数据</p><p>2.Reduce阶段对Map结果进行汇总</p><h2 id="Hadoop运行模式"><a href="#Hadoop运行模式" class="headerlink" title="Hadoop运行模式"></a>Hadoop运行模式</h2><p>Hadoop运行模式包括：本地模式，伪分布式模式以及完全分布式模式</p>]]></content>
      
      
      <categories>
          
          <category> 大数据学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop2.x安装教程</title>
      <link href="/2021/09/17/Hadoop2-x%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
      <url>/2021/09/17/Hadoop2-x%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Hadoop2-x安装-完全分布式安装"><a href="#Hadoop2-x安装-完全分布式安装" class="headerlink" title="Hadoop2.x安装(完全分布式安装)"></a>Hadoop2.x安装(完全分布式安装)</h1><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 必须有3台虚拟机，然后密钥也需要弄!!!</span></span><br><span class="line"><span class="comment"># 如果没设置密钥，可以在master中生成密钥文件。</span></span><br><span class="line"><span class="comment"># 如果你的主机名字不是叫做master，在弄配置文件的时候，只需要将你的主机名替换掉我的master就可以了。</span></span><br><span class="line"></span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line">一直回车</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将密钥文件同步到所有节点</span></span><br><span class="line">ssh-copy-id master</span><br><span class="line">ssh-copy-id node1</span><br><span class="line">ssh-copy-id node2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我的电脑因为之前弄过了，所以密钥已经有了。</span></span><br></pre></td></tr></table></figure><h2 id="NO1-本地通过XFTP上传到Linux上"><a href="#NO1-本地通过XFTP上传到Linux上" class="headerlink" title="NO1.本地通过XFTP上传到Linux上"></a>NO1.本地通过XFTP上传到Linux上</h2><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917185804921.png" alt="image-20210917185804921"></p><p>我这里安装的是Hadoop-2.7.6版本的。</p><h2 id="NO2-解压到soft目录下面"><a href="#NO2-解压到soft目录下面" class="headerlink" title="NO2.解压到soft目录下面"></a>NO2.解压到soft目录下面</h2><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917185936742.png" alt="image-20210917185936742"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917190303756.png" alt="image-20210917190303756"></p><h2 id="NO3-配置环境变量"><a href="#NO3-配置环境变量" class="headerlink" title="NO3.配置环境变量"></a>NO3.配置环境变量</h2><p>在master下。使用命令  vim /etc/profile</p><p>增加hadoop环境变量，将bin和sbin都配置到PATH中</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917191204559.png" alt="image-20210917191204559"></p><p>然后记得刷新一下。使用命令   source /etc/profile</p><p>接着分发到将profile分发到两台从机上面去,同时也要刷新以下。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917191439519.png" alt="image-20210917191439519"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -r /etc/profile node1:/etc/profile</span><br><span class="line"></span><br><span class="line">scp -r /etc/profile node2:/etc/profile</span><br></pre></td></tr></table></figure><h2 id="NO4-修改配置文件-操作均在master上执行"><a href="#NO4-修改配置文件-操作均在master上执行" class="headerlink" title="NO4.修改配置文件(操作均在master上执行)"></a>NO4.修改配置文件(操作均在master上执行)</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hadoop 配置文件在/usr/<span class="built_in">local</span>/soft/hadoop-2.7.6/etc/hadoop/</span><br><span class="line"></span><br><span class="line">使用命令  <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/soft/hadoop-2.7.6/etc/hadoop</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-1-修改slaves"><a href="#4-1-修改slaves" class="headerlink" title="4.1 修改slaves"></a>4.1 修改slaves</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim slaves</span><br><span class="line">增加node1,node2</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917191935303.png" alt="image-20210917191935303"></p><h3 id="4-2-修改Hadoop环境配置文件"><a href="#4-2-修改Hadoop环境配置文件" class="headerlink" title="4.2 修改Hadoop环境配置文件"></a>4.2 修改Hadoop环境配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim hadoop-env.sh</span><br><span class="line"><span class="comment"># 修改JAVA_HOME</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/soft/jdk1.8.0_171</span><br><span class="line"><span class="comment"># 路径就是自己jdk安装的路径，然后jdk版本填写自己的。</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917192449991.png" alt="image-20210917192449991"></p><h3 id="4-3-修改core-site-xml这是Hadoop的核心配置文件"><a href="#4-3-修改core-site-xml这是Hadoop的核心配置文件" class="headerlink" title="4.3 修改core-site.xml这是Hadoop的核心配置文件"></a>4.3 修改core-site.xml这是Hadoop的核心配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim core-site.xml</span><br><span class="line"><span class="comment"># 在configuration中间增加以下内容</span></span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">&lt;value&gt;hdfs://master:9000&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">&lt;value&gt;/usr/<span class="built_in">local</span>/soft/hadoop-2.7.6/tmp&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;fs.trash.interval&lt;/name&gt;</span><br><span class="line">&lt;value&gt;1440&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917192835262.png" alt="image-20210917192835262"></p><h3 id="4-4-修改hdfs-site-xml-这是hdfs配置文件"><a href="#4-4-修改hdfs-site-xml-这是hdfs配置文件" class="headerlink" title="4.4 修改hdfs-site.xml 这是hdfs配置文件"></a>4.4 修改hdfs-site.xml 这是hdfs配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim hdfs-site.xml</span><br><span class="line"><span class="comment"># 在configuration中间增加以下内容</span></span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">&lt;value&gt;1&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.permissions&lt;/name&gt;</span><br><span class="line">&lt;value&gt;<span class="literal">false</span>&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917193335322.png" alt="image-20210917193335322"></p><h3 id="4-5-修改yarn-site-xml-这是yarn的配置文件"><a href="#4-5-修改yarn-site-xml-这是yarn的配置文件" class="headerlink" title="4.5 修改yarn-site.xml 这是yarn的配置文件"></a>4.5 修改yarn-site.xml 这是yarn的配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim yarn-site.xml</span><br><span class="line"><span class="comment"># 在configuration中间增加以下内容</span></span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;</span><br><span class="line">&lt;value&gt;master&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">&lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.log-aggregation-enable&lt;/name&gt;</span><br><span class="line">&lt;value&gt;<span class="literal">true</span>&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.log-aggregation.retain-seconds&lt;/name&gt;</span><br><span class="line">&lt;value&gt;604800&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;  </span><br><span class="line">&lt;name&gt;yarn.nodemanager.resource.memory-mb&lt;/name&gt;  </span><br><span class="line">&lt;value&gt;20480&lt;/value&gt;  </span><br><span class="line">&lt;/property&gt;  </span><br><span class="line"></span><br><span class="line">&lt;property&gt;  </span><br><span class="line">&lt;name&gt;yarn.scheduler.minimum-allocation-mb&lt;/name&gt;  </span><br><span class="line">&lt;value&gt;2048&lt;/value&gt;  </span><br><span class="line">&lt;/property&gt;  </span><br><span class="line"></span><br><span class="line">&lt;property&gt;  </span><br><span class="line">&lt;name&gt;yarn.nodemanager.vmem-pmem-ratio&lt;/name&gt;  </span><br><span class="line">&lt;value&gt;2.1&lt;/value&gt;  </span><br><span class="line">&lt;/property&gt; </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917194010581.png" alt="image-20210917194010581"></p><h3 id="4-6-修改mapred-site-xml-这是mapreduce的配置文件"><a href="#4-6-修改mapred-site-xml-这是mapreduce的配置文件" class="headerlink" title="4.6 修改mapred-site.xml 这是mapreduce的配置文件"></a>4.6 修改mapred-site.xml 这是mapreduce的配置文件</h3><p>在2.x版本中，会有一个mapred-site.xml.template这个文件，我们要给它重命名</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重命名</span></span><br><span class="line">mv mapred-site.xml.template mapred-site.xml</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917194118845.png" alt="image-20210917194118845"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim mapred-site.xml</span><br><span class="line"><span class="comment"># 在configuration中间增加以下内容</span></span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">&lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;  </span><br><span class="line">&lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt;  </span><br><span class="line">&lt;value&gt;master:10020&lt;/value&gt;  </span><br><span class="line">&lt;/property&gt;  </span><br><span class="line"></span><br><span class="line">&lt;property&gt;  </span><br><span class="line">&lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt;  </span><br><span class="line">&lt;value&gt;master:19888&lt;/value&gt;  </span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917194339898.png" alt="image-20210917194339898"></p><h2 id="NO5-将hadoop安装文件同步到子节点上"><a href="#NO5-将hadoop安装文件同步到子节点上" class="headerlink" title="NO5.将hadoop安装文件同步到子节点上"></a>NO5.将hadoop安装文件同步到子节点上</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -r /usr/<span class="built_in">local</span>/soft/hadoop-2.7.6/ node1:/usr/<span class="built_in">local</span>/soft/</span><br><span class="line">scp -r /usr/<span class="built_in">local</span>/soft/hadoop-2.7.6/ node2:/usr/<span class="built_in">local</span>/soft/</span><br></pre></td></tr></table></figure><p>同步之后就能在子节点中找到相应文件了</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917195046675.png" alt="image-20210917195046675"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917195124002.png" alt="image-20210917195124002"></p><h2 id="NO6-格式化namenode"><a href="#NO6-格式化namenode" class="headerlink" title="NO6.格式化namenode"></a>NO6.格式化namenode</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hdfs namenode -format </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917195354737.png" alt="image-20210917195354737"></p><h2 id="NO7-启动hadoop并且通过jps查看"><a href="#NO7-启动hadoop并且通过jps查看" class="headerlink" title="NO7.启动hadoop并且通过jps查看"></a>NO7.启动hadoop并且通过jps查看</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动hadoop，在hadoop的sbin目录下启动</span></span><br><span class="line">start-all.sh</span><br><span class="line"><span class="comment"># jps主机和从机都查看</span></span><br><span class="line">jps</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917200000230.png" alt="image-20210917200000230"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917200218711.png" alt="image-20210917200218711"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917200247802.png" alt="image-20210917200247802"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917200313588.png" alt="image-20210917200313588"></p><h2 id="NO7-访问hdfs页面验证是否安装成功"><a href="#NO7-访问hdfs页面验证是否安装成功" class="headerlink" title="NO7.访问hdfs页面验证是否安装成功"></a>NO7.访问hdfs页面验证是否安装成功</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在本地浏览器中输入</span></span><br><span class="line">http://192.168.30.66:50070</span><br><span class="line"><span class="comment"># 192.168.30.66是我自己的虚拟机的IP地址，要是修改只需要改成你们自己的就可以！！！</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917200713906.png" alt="image-20210917200713906"></p><p>要是能出现这样的页面就是说明成功了。</p><p>至此安装全部结束！！！</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 关闭集群</span></span><br><span class="line">stop-all.sh</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917201546951.png" alt="image-20210917201546951"></p>]]></content>
      
      
      <categories>
          
          <category> 大数据学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习---day03</title>
      <link href="/2021/09/05/MySQL%E5%AD%A6%E4%B9%A0-day03/"/>
      <url>/2021/09/05/MySQL%E5%AD%A6%E4%B9%A0-day03/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="1-创建表"><a href="#1-创建表" class="headerlink" title="1.创建表"></a>1.<strong>创建表</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">建表语句格式    </span><br><span class="line">    create table 表名(    其实后面还有个约束，但是这里我们先不讲</span><br><span class="line">        字段名1 数据类型</span><br><span class="line">        字段名2 数据类型</span><br><span class="line">        字段名3 数据类型</span><br><span class="line">        ......</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">建议起名字要做到见名知意。</span><br></pre></td></tr></table></figure><p>关于MySQL当中字段的数据类型，以下只说几种最为常用的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int            整数型(对应java中的int)</span><br><span class="line">bigint         长整型(相当于是java中的long)</span><br><span class="line">float          浮点型(对应java中的float)</span><br><span class="line">double         浮点型(对应java中的double)</span><br><span class="line">char           定长字符串(对应java中的String)</span><br><span class="line">varchar        可变长字符串(最多存储255个字符，对应java中的StringBuffer/StringBuilder)</span><br><span class="line">date           日期类型(对应java中的java.sql.Date类型)</span><br><span class="line">BLOB           二进制大对象(存储图片,视频等流媒体信息)    Binary Large OBject</span><br><span class="line">CLOB           字符大对象(存储较大文本,比如，可以存储4G的字符串)    Character Large OBject</span><br><span class="line">.......</span><br></pre></td></tr></table></figure><h3 id="char和varchar怎么选择？"><a href="#char和varchar怎么选择？" class="headerlink" title="char和varchar怎么选择？"></a><strong>char和varchar怎么选择？</strong></h3><p>  <strong>在实际开发过程中，当某个字段中的数据长度不发生改变的时候，是定长的，用char。例如:性别，生日等都是采用char。<br>  当一个字段的数据长度不确定的时候，就用varchar。例如:简介，姓名等都是采用varchar。</strong></p><blockquote><p> 建议:表名在数据库中一般以:t_或者tbl_开始。见名知意。</p></blockquote><p>例如，现在新建一个表student</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table t_student(</span><br><span class="line"></span><br><span class="line">no bigint,</span><br><span class="line"></span><br><span class="line">name varchar(255),</span><br><span class="line"></span><br><span class="line">sex char(1),</span><br><span class="line"></span><br><span class="line">classno varchar(255),</span><br><span class="line"></span><br><span class="line">birth char(10)</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210905094625.png"></p><h2 id="2-insert语句插入数据"><a href="#2-insert语句插入数据" class="headerlink" title="2.insert语句插入数据"></a>2.<strong>insert语句插入数据</strong></h2><p>语法格式</p><p>insert into 表名(字段名1，字段名2…..) values(值1，值2……)</p><p>要求:字段的数量和值的数量相同，并且数据类型要对应相同。</p><p>例如开始往上表中插入数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into t_student(no,name,sex,classno,birth) values(1,&#x27;zhangsan&#x27;,&#x27;1&#x27;,&#x27;gaosan1&#x27;,&#x27;1999-1-1&#x27;);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210905095030.png"></p><p><strong>注意:当一条insert语句执行成功之后，表格当中必然会多一行记录。即是多的这一行记录当中某些字段是NULL，后期也没有办法在执行insert语句插入数据了，只能用update进行更新</strong></p><h2 id="3-表的复制"><a href="#3-表的复制" class="headerlink" title="3.表的复制"></a>3.<strong>表的复制</strong></h2><blockquote><p>语法:</p><p>create table 表名 as select语句;</p><p>将查询结果当作表创建出来</p></blockquote><p>例如:</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210905095917.png"></p><h2 id="4-将查询结果插入到一张表中"><a href="#4-将查询结果插入到一张表中" class="headerlink" title="4.将查询结果插入到一张表中"></a>4.<strong>将查询结果插入到一张表中</strong></h2><p>例如将查询dept中的结果插入到dept1中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into dept1 select * from dept;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210905100234.png"></p><p><strong>注意:两张表的字段都得相同</strong></p><h2 id="5-修改数据-update"><a href="#5-修改数据-update" class="headerlink" title="5.修改数据:update"></a>5.<strong>修改数据:update</strong></h2><p>语法格式:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update 表名 set 字段名1=值1，字段名2=值2，.....where 条件；</span><br></pre></td></tr></table></figure><p>例如，将dept1中的部门10的LOC修改为shanghai，将部门名称修改为人事部</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update dept1 set loc=&#x27;shanghai&#x27;,dname=&#x27;renshibu&#x27; where deptno = 10;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210905100839.png"></p><blockquote><p><strong>注意:当没有说明条件的时候，那将会更新表中所有记录！！！</strong></p></blockquote><h2 id="6-删除数据"><a href="#6-删除数据" class="headerlink" title="6.删除数据"></a>6.<strong>删除数据</strong></h2><p>语法格式:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from 表名 where 条件；</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意:当没有说明条件的时候，那么表中数据都会被删除！！！</strong></p></blockquote><p>例如:删除10部门的数据</p><p>delete from dept1 where deptno = 10;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210905101236.png"></p><p>删除所有记录</p><p>delete from dept1;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210905101334.png"></p><p><strong>怎么删除大表？(重点)</strong></p><p>关键字:truncate  <strong>表明表被截断，不可回滚，永久丢失</strong></p><p><strong>注意:使用truncate删除表的时候一定要注意！！！因为删除之后就恢复不了了。</strong></p><h2 id="7-增删改查有一个术语-CRUD操作"><a href="#7-增删改查有一个术语-CRUD操作" class="headerlink" title="7.增删改查有一个术语: CRUD操作"></a>7.<strong>增删改查有一个术语: CRUD操作</strong></h2><p>C: Create(增)    R: Retrieve(检索)    U: Update(修改)    D: Delete(删除)</p><h2 id="8-约束-Constraint"><a href="#8-约束-Constraint" class="headerlink" title="8.约束(Constraint)"></a>8.约束(Constraint)</h2><h3 id="8-1-什么是约束？常见的约束有哪些？"><a href="#8-1-什么是约束？常见的约束有哪些？" class="headerlink" title="8.1 什么是约束？常见的约束有哪些？"></a>8.1 什么是约束？常见的约束有哪些？</h3><p><strong>在创建表的时候，可以给表的字段添加相应的约束，添加约束的目的是为了保证表中数据的合法性，有效性，完整性。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">常见的约束:</span><br><span class="line"></span><br><span class="line">非空约束(not null):约束的字段不能为NULL</span><br><span class="line"></span><br><span class="line">唯一约束(unique):约束的字段不能重复</span><br><span class="line"></span><br><span class="line">主键约束(primary key):约束的字段既不能为NULL，也不能重复</span><br><span class="line"></span><br><span class="line">外键约束(foreign key)</span><br><span class="line"></span><br><span class="line">检查约束(check):注意: Oracle数据库中由check约束，但是mysql没有，目前mysql不支持该约束。</span><br></pre></td></tr></table></figure><h3 id="8-2-非空约束-not-null"><a href="#8-2-非空约束-not-null" class="headerlink" title="8.2 非空约束 not null"></a>8.2 非空约束 not null</h3><p>例如:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table if exists t_user;</span><br><span class="line"></span><br><span class="line">create table t_user(</span><br><span class="line"></span><br><span class="line">id int,</span><br><span class="line"></span><br><span class="line">username varchar(255) not null,</span><br><span class="line"></span><br><span class="line">password varchar(255),</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这里的not null 就是一个非空约束。</p><h3 id="8-3-唯一性约束-unique"><a href="#8-3-唯一性约束-unique" class="headerlink" title="8.3 唯一性约束(unique)"></a>8.3 唯一性约束(unique)</h3><p><strong>唯一约束修饰的字段具有唯一性，不能重复，但是可以为NULL</strong></p><p>例如:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table if exists t_user;</span><br><span class="line"></span><br><span class="line">create table t_user(</span><br><span class="line"></span><br><span class="line">id int,</span><br><span class="line"></span><br><span class="line">usename varchar(255) unique,</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>注意:如果是在每列后面添加unique，那么就叫做列级约束</strong></p><p>​        <strong>如果是等所有字段声明完之后再添加unique，那么就叫做表级约束。</strong></p><p><strong>not null约束只有列级约束，没有表级约束。</strong></p><h3 id="8-4-主键约束"><a href="#8-4-主键约束" class="headerlink" title="8.4 主键约束"></a>8.4 主键约束</h3><p>例如:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table if exists t_user;</span><br><span class="line"></span><br><span class="line">create table t_user(</span><br><span class="line"></span><br><span class="line">id int primary key,   //列级约束</span><br><span class="line"></span><br><span class="line">username varchar(255),</span><br><span class="line"></span><br><span class="line">email varchar(255),</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>当给一个字段添加主键约束之后，那么主键字段中的数据不能为NULL，也不能重复</p><p><strong>主键的特点:不能为NULL，也不能重复</strong></p><h4 id="主键相关的术语"><a href="#主键相关的术语" class="headerlink" title="主键相关的术语"></a>主键相关的术语</h4><p>主键约束: primary key</p><p>主键字段: id字段添加primary key之后，id叫做主键字段</p><p>主键值: id字段中的每一个值都是主键值</p><h4 id="主键有什么作用"><a href="#主键有什么作用" class="headerlink" title="主键有什么作用"></a>主键有什么作用</h4><p>表的设计三范式中有要求，第一范式就要求任何一张表都应该有主键</p><p><strong>主键的作用:</strong></p><p><strong>主键值是这行记录在这张表当中的唯一标识。(就像一个人的身份证号码一样)</strong></p><h4 id="主键的分类"><a href="#主键的分类" class="headerlink" title="主键的分类"></a>主键的分类</h4><p>根据主键字段和字段数量来划分:</p><p>​    <strong>单一主键</strong>(推荐的，常用的)</p><p>​    <strong>复合主键</strong>(多个字段联合起来添加一个主键约束)(复合主键不建议使用，因为复合主键违背了三范式)</p><p>根据主键性质来划分:</p><p>​    <strong>自然主键</strong>主键值最好就是一个和业务没有任何关系的自然数。</p><p><strong>业务主键</strong>主键值和系统的业务挂钩(不推荐用)</p><h4 id="注意！！！"><a href="#注意！！！" class="headerlink" title="注意！！！"></a>注意！！！</h4><p><strong>一张表的主键约束只能有1个！！！(必须记住)</strong></p><h4 id="mysql提供了主键值自增"><a href="#mysql提供了主键值自增" class="headerlink" title="mysql提供了主键值自增"></a>mysql提供了主键值自增</h4><p>关键字: auto_increment</p><h3 id="8-5-外键约束"><a href="#8-5-外键约束" class="headerlink" title="8.5 外键约束"></a>8.5 外键约束</h3><p>外键约束的相关术语；</p><p>​    外键约束: foreign key</p><p>​    外键字段: 添加有外键约束的字段</p><p>​    外键值: 外键字段中的每一个值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法格式: foreign key()  references tablename()</span><br></pre></td></tr></table></figure><h2 id="存储引擎-了解即可"><a href="#存储引擎-了解即可" class="headerlink" title="存储引擎(了解即可)"></a>存储引擎(了解即可)</h2><p>1.mysql默认使用的存储引擎是InnoDB方式，默认采用的字符集是UTF8。</p><p>2.什么是存储引擎？</p><p>存储引擎这个名字只有在mysql中存在。(Oracle中有对应的机制，但是不叫做存储引擎。Oracle中没有特殊的名字，就是”表的存储方式”)</p><p>mysql支持很多存储引擎，每一个存储引擎都对应了一种不同的存储方式。每一个存储引擎都有自己的优缺点，需要在合适的时机选择合适的存储引擎。</p><p>3.常见的存储引擎</p><blockquote><p>MYISAM存储引擎，不支持事务，是mysql常用的引擎，但是不是默认的。</p><p>优点:可被压缩，节省存储空间。并且可以转换为只读表，提高检索效率。</p><p>缺点: 不支持事务</p></blockquote><blockquote><p>InnoDB存储引擎</p><p>优点: 支持事务，行级锁，外键等。这种存储引擎数据的安全得到保障。</p><p>表的存储结构再xxx.frm文件中。数据存储在tablespace这样的表空间中(逻辑概念)，无法被压缩，无法转换成只读。</p><p>这种存储引擎可以在MySQL数据库崩溃之后提供自动恢复机制。同时它支持级联删除和级联更新。</p></blockquote><blockquote><p>MEMORY存储引擎</p><p>缺点: 不支持事务。数据容易丢失，因为所有数据和索引都是存储在内存当中的。</p><p>优点: 查询速度最快</p></blockquote><h2 id="事务-Transaction"><a href="#事务-Transaction" class="headerlink" title="事务(Transaction)"></a>事务(Transaction)</h2><p>1.什么是事务？</p><p>一个事务是一个完整的业务逻辑单元，不可再分。</p><p>2.<strong>只有DML语句(insert,delete,update)才和事务相关。</strong></p><p>因为只有这三个语句都是和数据库表当中的”数据”相关的。</p><p>事务的存在是为了保证数据的完整性，安全性。</p><p>3.事务的特性</p><p>事务的四大特性: ACID</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A: 原子性(事务是最小的工作单元，不可再分。)</span><br><span class="line">C: 一致性(事务必须保证多条DML语句同时成功或者同时失败)</span><br><span class="line">I: 隔离性(事务A与事务B之间具有隔离)</span><br><span class="line">D: 持久性(持久性说的是最终数据必须持久化到硬盘文件中，事务才算成功的)</span><br></pre></td></tr></table></figure><p>4.关于事务之间的隔离性</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">事务隔离性存在隔离级别。理论上隔离级别包括4个</span><br><span class="line"></span><br><span class="line">第一级别: 读未提交(read uncommitted)</span><br><span class="line"></span><br><span class="line">对方事务还没有提交，我们当前事务可以读取到对方未提交的数据。</span><br><span class="line"></span><br><span class="line">读未提交存在脏读(Dirty Read)现象: 表示读到了脏的数据</span><br><span class="line"></span><br><span class="line">第二级别: 读已提交(read committed)</span><br><span class="line"></span><br><span class="line">对方事务提交之后的数据我方可以读取到</span><br><span class="line"></span><br><span class="line">读已提交存在的问题是: 不可重复读。</span><br><span class="line"></span><br><span class="line">这种隔离级别解决了脏读现象</span><br><span class="line"></span><br><span class="line">第三级别: 可重复读(repeatable read)</span><br><span class="line"></span><br><span class="line">这种隔离级别解决了不可重复读问题。</span><br><span class="line"></span><br><span class="line">这种隔离级别存在的问题是: 读取到的数据是幻想</span><br><span class="line"></span><br><span class="line">第四级别: 序列化读/串行化读</span><br><span class="line"></span><br><span class="line">解决了所有问题，但是效率低，需要事务排队。</span><br><span class="line"></span><br><span class="line">oracle数据库默认的隔离级别是: 读已提交</span><br><span class="line"></span><br><span class="line">mysql数据库默认的隔离级别是: 可重复读</span><br></pre></td></tr></table></figure><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="1-什么是索引？有什么用？"><a href="#1-什么是索引？有什么用？" class="headerlink" title="1.什么是索引？有什么用？"></a>1.什么是索引？有什么用？</h3><p>​        索引就相当于一本书的目录，通过目录可以快速的找到对应的资源。<br>​        在数据库方面，查询一张表的时候有两种检索方式：<br>​            第一种方式：全表扫描<br>​            第二种方式：根据索引检索（效率很高）</p><p>​    索引为什么可以提高检索效率呢？<br>​        其实最根本的原理是缩小了扫描的范围。<br>​<br>​    索引虽然可以提高检索效率，但是不能随意的添加索引，因为索引也是数据库当中<br>​    的对象，也需要数据库不断的维护。是有维护成本的。比如，表中的数据经常被修改<br>​    这样就不适合添加索引，因为数据一旦修改，索引需要重新排序，进行维护。</p><p>​    添加索引是给某一个字段，或者说某些字段添加索引。</p><p>​    select ename,sal from emp where ename = ‘SMITH’;<br>​    当ename字段上没有添加索引的时候，以上sql语句会进行全表扫描，扫描ename字段中所有的值。<br>​    当ename字段上添加索引的时候，以上sql语句会根据索引扫描，快速定位。</p><h3 id="2、怎么创建索引对象？怎么删除索引对象？"><a href="#2、怎么创建索引对象？怎么删除索引对象？" class="headerlink" title="2、怎么创建索引对象？怎么删除索引对象？"></a>2、怎么创建索引对象？怎么删除索引对象？</h3><p>​    创建索引对象：<br>​        create index 索引名称 on 表名(字段名);<br>​    删除索引对象：<br>​        drop index 索引名称 on 表名;</p><h3 id="3、什么时候考虑给字段添加索引？（满足什么条件）"><a href="#3、什么时候考虑给字段添加索引？（满足什么条件）" class="headerlink" title="3、什么时候考虑给字段添加索引？（满足什么条件）"></a>3、什么时候考虑给字段添加索引？（满足什么条件）</h3><pre><code>* 数据量庞大。（根据客户的需求，根据线上的环境）* 该字段很少的DML操作。（因为字段进行修改操作，索引也需要维护）* 该字段经常出现在where子句中。（经常根据哪个字段查询）</code></pre><h3 id="4-注意：主键和具有unique约束的字段自动会添加索引。"><a href="#4-注意：主键和具有unique约束的字段自动会添加索引。" class="headerlink" title="4.注意：主键和具有unique约束的字段自动会添加索引。"></a>4.注意：主键和具有unique约束的字段自动会添加索引。</h3><p>​    根据主键查询效率较高。尽量根据主键检索。</p><h3 id="5-索引底层采用的数据结构是：B-Tree"><a href="#5-索引底层采用的数据结构是：B-Tree" class="headerlink" title="5.索引底层采用的数据结构是：B + Tree"></a>5.<strong>索引底层采用的数据结构是：B + Tree</strong></h3><h3 id="6-索引的实现原理？"><a href="#6-索引的实现原理？" class="headerlink" title="6.索引的实现原理？"></a>6.索引的实现原理？</h3><p>​    通过B Tree缩小扫描范围，底层索引进行了排序，分区，索引会携带数据在表中的“物理地址”，<br>​    最终通过索引检索到数据之后，获取到关联的物理地址，通过物理地址定位表中的数据，效率<br>​    是最高的。<br>​        select ename from emp where ename = ‘SMITH’;<br>​        通过索引转换为：<br>​        select ename from emp where 物理地址 = 0x3;</p><h3 id="7-索引的分类？"><a href="#7-索引的分类？" class="headerlink" title="7.索引的分类？"></a>7.索引的分类？</h3><p>​    单一索引：给单个字段添加索引<br>​    复合索引: 给多个字段联合起来添加1个索引<br>​    主键索引：主键上会自动添加索引<br>​    唯一索引：有unique约束的字段上会自动添加索引<br>​    ….</p><h3 id="8-索引什么时候失效？"><a href="#8-索引什么时候失效？" class="headerlink" title="8.索引什么时候失效？"></a>8.索引什么时候失效？</h3><p>​    select ename from emp where ename like ‘%A%’;<br>​    模糊查询的时候，第一个通配符使用的是%，这个时候索引是失效的。</p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>1.什么是视图？<br>        站在不同的角度去看到数据。（同一张表的数据，通过不同的角度去看待）。</p><p>2.怎么创建视图？怎么删除视图？<br>    create view myview as select empno,ename from emp;<br>    drop view myview;</p><p>​    注意：只有DQL语句才能以视图对象的方式创建出来。</p><p>3.对视图进行增删改查，会影响到原表数据。（通过视图影响原表数据的，不是直接操作的原表）<br>可以对视图进行CRUD操作。</p><p>4.视图的作用？<br>        视图可以隐藏表的实现细节。保密级别较高的系统，数据库只对外提供相关的视图，java程序员<br>        只对视图对象进行CRUD。</p><h2 id="数据库设计三范式（重点内容，面试经常问）"><a href="#数据库设计三范式（重点内容，面试经常问）" class="headerlink" title="数据库设计三范式（重点内容，面试经常问）"></a>数据库设计三范式（重点内容，面试经常问）</h2><h3 id="1、什么是设计范式？"><a href="#1、什么是设计范式？" class="headerlink" title="1、什么是设计范式？"></a>1、什么是设计范式？</h3><p>​    设计表的依据。按照这个三范式设计的表不会出现数据冗余。</p><h3 id="2、三范式都是哪些？"><a href="#2、三范式都是哪些？" class="headerlink" title="2、三范式都是哪些？"></a>2、三范式都是哪些？</h3><p>​    第一范式：任何一张表都应该有主键，并且每一个字段原子性不可再分。</p><p>​    第二范式：建立在第一范式的基础之上，所有非主键字段完全依赖主键，不能产生部分依赖。<br>​    第三范式：建立在第二范式的基础之上，所有非主键字段直接依赖主键，不能产生传递依赖。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL学习心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习---day02</title>
      <link href="/2021/09/02/MySQL%E5%AD%A6%E4%B9%A0-day02/"/>
      <url>/2021/09/02/MySQL%E5%AD%A6%E4%B9%A0-day02/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="关于查询结果集的去重，使用关键字distinct"><a href="#关于查询结果集的去重，使用关键字distinct" class="headerlink" title="关于查询结果集的去重，使用关键字distinct"></a>关于查询结果集的去重，使用关键字distinct</h2><p>例如:eg1去除emp中的重复记录</p><p>select distinct deptno,job from emp;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904212212.png"></p><blockquote><p><strong>注意:distinct只能出现在所有字段的最前面！！！</strong> </p></blockquote><p> eg2统计岗位的数量</p><p>select count(distinct job) from emp;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904212348.png"></p><h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><p><strong>2.1</strong>在实际开发过程中,大部分的情况都不是从单表之中查询，都是许多表关联起来查询。</p><p><strong>2.2</strong>连接查询的分类</p><p>内连接，包括等值连接，非等值连接，自连接</p><p>外连接，包括左外连接(左连接)，右外连接(右连接)</p><p>全连接</p><p><strong>2.3</strong>在表的连接查询中有一种现象叫做笛卡尔积现象</p><p>例如:找出每一个员工的部门名称，要求显示员工名和部门名。</p><p>select ename,dname from emp,dept;    //这里能看到一共有56条记录</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904212448.png"></p><blockquote><p><strong>笛卡尔乘积现象:当两张表进行连接查询的时候，没有任何条件进行限制，最终的查询结果条数是两张表记录条数的乘积。</strong></p></blockquote><p>但一般都是用表的别名这种语句进行查询</p><p>select e.ename,d.dname from emp e,dept d;</p><p>表的别名有什么好处？</p><p>No1.执行效率高 No2.可读性好</p><blockquote><p><strong>2.4</strong> <strong>避免笛卡尔积现象可以采用加条件过滤，但是避免笛卡尔积现象不会减少匹配次数，加条件只不过是显示出了有效记录。</strong></p></blockquote><p><strong>2.5 内连接中的等值连接</strong></p><p>最大的特点是:条件是等量关系 </p><p>常用语法 select e.ename,d.dname from emp e inner join dept d on e.deptno = d.deptno;//SQL99语法，这里的inner可以省略。效果如下所示</p><p>SQL99语法比较清晰，表的连接条件和之后的where条件分离了</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904212632.png"></p><p> <strong>2.6内连接中的非等值连接</strong></p><p>最大的特点是:连接条件中的关系是非等量关系</p><p>例如:找出每个员工的工资等级，要求显示员工名，工资，工资等级</p><p>select e.ename,e.sal,s.grade from emp e join salgrade s on e.sal between s.losal and s.hisal;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904212811.png"></p><p> <strong>2.7内连接中的自连接</strong></p><p>最大特点是:一张表可以看作两张表，自己连自己。</p><p>例如:找出每个员工的上级领导，要求显示员工名和对应的领导名。</p><p>select a.ename as ‘员工名’,b.ename as ‘领导名’ from emp a join emp b on a.mgr = b.empno;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904212837.png"></p><p> <strong>2.8外连接</strong></p><p>外连接和内连接的区别</p><p>​    内连接:假设A和B进行连接，使用内连接的话，凡是A表和B表能够匹配上的记录都查询出来，这就是内连接。AB两张表没有主副之分，两张表是平等的。</p><p>​    外连接:<br>​     假设A和B表进行连接，使用外连接的话，AB两张表中有一张表是主表，一张表是副表，主要查询主表中的数据，捎带着查询副表，当副表中的数据没有和主表中的数据匹配上，副表自动模拟出NULL与之匹配。</p><p>外连接的分类？<br>     左外连接（左连接）：表示左边的这张表是主表。<br>     右外连接（右连接）：表示右边的这张表是主表。</p><p>​     左连接有右连接的写法，右连接也会有对应的左连接的写法。</p><p>例如:找出每个员工的上级领导</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904212928.png"></p><p>select a.ename as ‘员工名’,b.ename as ‘领导名’ from emp a left join emp b on a.mgr = b.empno;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904212959.png"></p><p> 这里之所以比上面的查询数据多了一个KING，是因为KING也算是员工，但是他是大BOSS，没有上级领导。</p><blockquote><p><strong>外连接最重要的特点是:主表的数据无条件的全部都查出来</strong></p></blockquote><p>例如:找出哪个部门没有员工</p><p>select d.* from dept d left join emp e on d.deptno = e.deptno where e.empno is null;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904213100.png"></p><p> <strong>2.9三张表的连接查询</strong></p><p>例如:找出每一个员工的部门名称以及工资等级</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EMP e</span><br><span class="line">+-------+--------+---------+--------+</span><br><span class="line">| empno | ename  | sal     | deptno |</span><br><span class="line">+-------+--------+---------+--------+</span><br><span class="line">|  7369 | SMITH  |  800.00 |     20 |</span><br><span class="line">|  7499 | ALLEN  | 1600.00 |     30 |</span><br><span class="line">|  7521 | WARD   | 1250.00 |     30 |</span><br><span class="line">|  7566 | JONES  | 2975.00 |     20 |</span><br><span class="line">|  7654 | MARTIN | 1250.00 |     30 |</span><br><span class="line">|  7698 | BLAKE  | 2850.00 |     30 |</span><br><span class="line">|  7782 | CLARK  | 2450.00 |     10 |</span><br><span class="line">|  7788 | SCOTT  | 3000.00 |     20 |</span><br><span class="line">|  7839 | KING   | 5000.00 |     10 |</span><br><span class="line">|  7844 | TURNER | 1500.00 |     30 |</span><br><span class="line">|  7876 | ADAMS  | 1100.00 |     20 |</span><br><span class="line">|  7900 | JAMES  |  950.00 |     30 |</span><br><span class="line">|  7902 | FORD   | 3000.00 |     20 |</span><br><span class="line">|  7934 | MILLER | 1300.00 |     10 |</span><br><span class="line">+-------+--------+---------+--------+</span><br><span class="line">DEPT d</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">| DEPTNO | DNAME      | LOC      |</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">|     10 | ACCOUNTING | NEW YORK |</span><br><span class="line">|     20 | RESEARCH   | DALLAS   |</span><br><span class="line">|     30 | SALES      | CHICAGO  |</span><br><span class="line">|     40 | OPERATIONS | BOSTON   |</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">SALGRADE s</span><br><span class="line">+-------+-------+-------+</span><br><span class="line">| GRADE | LOSAL | HISAL |</span><br><span class="line">+-------+-------+-------+</span><br><span class="line">|     1 |   700 |  1200 |</span><br><span class="line">|     2 |  1201 |  1400 |</span><br><span class="line">|     3 |  1401 |  2000 |</span><br><span class="line">|     4 |  2001 |  3000 |</span><br><span class="line">|     5 |  3001 |  9999 |</span><br><span class="line">+-------+-------+-------+</span><br></pre></td></tr></table></figure><p> select e.ename,d.dname,s.grade from emp e left join dept d on e.deptno = d.deptno left join salgrade s on e.sal between s.losal and s.hisal;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904213435.png"></p><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p><strong>3.1什么是子查询？子查询都可以出现在哪里？</strong></p><p>select语句当中嵌套select语句，被嵌套的select语句是子查询。<br>   子查询可以出现在哪里？<br>     select<br>       ..(select).<br>     from<br>       ..(select).<br>     where<br>       ..(select).</p><p><strong>3.2where子句中使用子查询</strong></p><p>例如:找出高于平均薪资的员工信息</p><p>select * from emp where sal &gt; (select avg(sal) from emp);</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904213511.png"></p><p> <strong>3.3from后面嵌套子查询</strong></p><p>例如:找出每个部门平均薪水的薪资等级。</p><p>第一步:找出每个部门平均薪水(按照部门编号分组，求sal的平均值)</p><p>select deptno,avg(sal) as avgsal from emp group by deptno;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904213540.png"></p><p> 第二步:将以上的查询结果当作临时表t，让t表和salgrade s表连接，条件是:t.avgsal between s.losal and s.hisal;</p><p>select t.*,s.grade from (select deptno,avg(sal) as avgsal from emp group by deptno) t left join salgrade s on t.avgsal between s.losal and s.hisal;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904213613.png"></p><p> <strong>3.4在select后面嵌套子查询</strong></p><h2 id="union-可以将查询结果相加"><a href="#union-可以将查询结果相加" class="headerlink" title="union(可以将查询结果相加)"></a>union(可以将查询结果相加)</h2><p>例如:找出工作岗位是salesman和manager的员工</p><p>按照之前讲的也能写出来</p><p>第一种:select ename,job from emp where job = ‘salesman’ or job = ‘manager’;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904213711.png"></p><p>第二种:用in。select ename,job from emp where job in (‘manager’,’salesman’); </p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904213746.png"></p><p>第三种:用union。select ename,job from emp where job = ‘manager’ </p><p>​              union</p><p>​              select ename,job from emp where job = ‘salesman’;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904213902.png"></p><blockquote><p><strong>采用union就是将表与表之间的查询结果做拼接。 注意:用union查询时，必须保证前面的查询结果的列的数量和后一个查询结果的列的数量保持一致。</strong></p></blockquote><h2 id="limit-重点中的重点！！！以后分页查询就靠它"><a href="#limit-重点中的重点！！！以后分页查询就靠它" class="headerlink" title="limit(重点中的重点！！！以后分页查询就靠它)"></a>limit(重点中的重点！！！以后分页查询就靠它)</h2><p>5.1 limit是MySQL中所特有的，其他的数据库都没有，不通用。</p><p>5.2 limit取结果集中的部分数据，这是它的作用</p><p>5.3 语法机制</p><blockquote><p><strong>limit startIndex,length   startIndex表示起始位置，length表示取几个</strong></p></blockquote><p> 例如:取出工资前五名的员工</p><p>select ename,sal from emp order by sal limit 5;//我这里是按照升序排</p><p>也可以这样写:select ename,sal from emp order by sal limit 0,5;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904214034.png"></p><p><strong>5.4 limit是sql语句最后执行的一个环节！！！</strong> </p><p><strong>执行顺序如下:</strong></p><pre><code>select            5    ...from            1    ...        where            2    ...    group by        3    ...having            4    ...order by        6    ...limit            7    ...;</code></pre><p>例如:找出工资排名在第4到第9名的员工</p><p>select ename,sal from emp order by sal limit 3,6;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904214112.png"></p><p>5.6 通用的标准分页sql</p><p>例如:每页显示3条信息</p><p>第一页:0，3；</p><p>第二页:3, 3;</p><p>第三页:6，3；</p><p>此时就能发现规律</p><blockquote><p><strong>每页显示n条消息,那么规律如下</strong></p><p><strong>第pageNo页:(pageNo - 1) * n，n   //这里的pageNo就是显示第几页，n表示每页显示多少条记录</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MySQL学习心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习---day01</title>
      <link href="/2021/09/02/MySQL%E5%AD%A6%E4%B9%A0-day01/"/>
      <url>/2021/09/02/MySQL%E5%AD%A6%E4%B9%A0-day01/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>所有MySQL使用的sql文本内容都出自B站老杜，有需要的小伙伴可以加我QQ<strong>1845356586</strong>。</p><h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><p>SQL语句分为</p><p>​            DQL（数据查询语言）: 查询语句，凡是select语句都是DQL。<br>​            DML（数据操作语言）：insert delete update，对表当中的数据进行增删改。<br>​            DDL（数据定义语言）：create drop alter，对表结构的增删改。<br>​            TCL（事务控制语言）：commit提交事务，rollback回滚事务。(TCL中的T是Transaction)<br>​            DCL（数据控制语言）: grant授权、revoke撤销权限等。</p><h2 id="基本的MySQL指令"><a href="#基本的MySQL指令" class="headerlink" title="基本的MySQL指令"></a>基本的MySQL指令</h2><p>1.在dos窗口下登录MySQL:<strong>mysql -u root -p</strong>(这里是你的登陆密码)</p><p>2.查看数据库指令:<strong>show databases;</strong>(这个不是SQL语句，属于MySQL的命令。)</p><p>3.创建数据库指令:<strong>create database xxxx;</strong>(这个不是SQL语句，属于MySQL的命令。)</p><p>4.使用数据库指令:<strong>use xxxx;</strong>(这个不是SQL语句，属于MySQL的命令。)</p><p>5.查看当前的数据库有哪些表:<strong>show tables;</strong>(这个不是SQL语句，属于MySQL的命令。)</p><p>6.删除数据库指令:<strong>drop database xxxx;</strong></p><p>7.查看表中数据:<strong>select * from xxxx;</strong></p><blockquote><p><strong>由于我电脑本身已经有了相关数据，所以接下来的操作我会直接用数据进行操作。</strong></p></blockquote><p>8.查看当前使用的是哪个数据库:<strong>select database();</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/1.png"></p><p>9.查看当前数据库版本号:<strong>select version();</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/2.png"></p><p>10.查看创建表的语句:<strong>show create table emp;</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/3.png"></p><p> 11.给查询的列重命名:<strong>select ename,sal * 12 as ‘年薪’ from emp;</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904204409.png"></p><blockquote><p><strong>注意:标准sql语句中要求字符串使用单引号括起来，虽然mysql支持双引号，但是尽量别使用。</strong> </p></blockquote><p> 12.条件查询语法格式:<strong>select 字段，字段…. from 表名 where 条件;</strong></p><p>执行顺序**:先from，然后where，最后select**</p><p> 例如:eg1查询工资等于5000的员工姓名</p><p>select ename,sal from emp where sal = 5000;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904204729.png"></p><p> eg2查询工资不等于3000的员工姓名</p><p>select ename,sal from emp where sal &lt;&gt; 3000;或select ename,sal from emp where sal != 3000;</p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904204845.png"><p>eg3找出工资在1100和3000之间的员工</p><p>select ename,sal from emp where sal between 1100 and 3000;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904204938.png"></p><p><strong>注意:between …. and ….是闭区间，</strong>即上述例子是查 [1100,3000],包含1100和3000</p><p> 13.NULL，在数据库中NULL不是一个值，代表什么也没有，为空。空不是一个值，不能用等号衡量。必须使用is null 或 is not null。</p><p>例如:eg1找出哪些人的津贴不为NULL</p><p>select ename,sal,comm from emp where comm is not null;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904205125.png"></p><p> eg2找出哪些人没有津贴</p><p>select ename,sal,comm from emp where comm is null or comm = 0;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904205245.png"></p><p>eg3找出工作岗位是manager和salesman的员工</p><p> select ename,sal,job from emp where job = ‘manager’ or job = ‘salesman’;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904205321.png"></p><p>and和or联合起来用：找出薪资大于1000的并且部门编号是20或30部门的员工。</p><p>select ename,sal,deptno from emp where sal &gt; 1000 and (deptno = 20 or deptno = 30);</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904205359.png"></p><p>14.<strong>模糊查找like,(在模糊查询当中，必须掌握两个特殊的符号，一个是%，一个是）%代表任意多个字符，代表任意1个字符。</strong></p><p> eg1找出名字里面有o的</p><p>select ename from emp where ename like ‘%o%’;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904205636.png"></p><p>eg2找出第二个字母是A的</p><p>select ename from emp where ename like ‘_A%’;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904205731.png"></p><p>15.排序，升序</p><p>格式: <strong>select 字段名，字段名….  from 表名 order by 条件;</strong> </p><p> 例如:eg1 按照工资升序，找出员工名和薪资</p><p>select ename,sal from emp order by sal;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904210905.png"></p><blockquote><p><strong>注意:默认是升序，那怎么指定升序和降序勒？ asc升序，desc降序</strong> </p></blockquote><p> eg2 还是拿上面的例子</p><p>select ename,sal from emp order by sal;//升序</p><p>select ename,sal from emp order by sal asc;//升序</p><p>select ename,sal from emp order by sal desc;//降序</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904210957.png"></p><p> eg3按照工资的降序排，如果工资一样，那就按照名字的升序排。</p><p>select ename,sal from emp order by sal desc,ename asc;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904211114.png"></p><blockquote><p><strong>注意：多字段排序时，越靠前的字段越能起到主导作用。只有当前面的字段无法完成排序的时候，才会启用后面的字段。</strong> </p></blockquote><p> <strong>where和order by同时使用，格式</strong></p><p><strong>select 字段名，字段名…. from 表名 where 条件 order by ….</strong></p><p><strong>先执行 from 接着where 接着select 最后 order by排序。</strong></p><p>eg1查询工作是salesman的并且按照工资的升序排</p><p>select ename,sal,job from emp where job = ‘salesman’ order by sal;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904211234.png"></p><p>16.分组函数</p><p>count计数，sum求和会自动忽略NULL，max最大值，min最小值，avg平均值</p><p><strong>注:count(*)和count(具体的某个字段)，他们有什么区别？<br>     count(*):不是统计某个字段中数据的个数，而是统计总记录条数。（和某个字段无关）<br>     count(comm): 表示统计comm字段中不为NULL的数据总数量。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904211339.png"></p><p>注意:所有的分组函数都是对’某一组’数据进行操作的。</p><p>分组函数一共有5个，同时分组函数还有另外一个名字:多行处理函数。其特点是:输入多行，最终输出的结果是1行。并且分组函数会自动忽略NULL。</p><p>17.单行处理函数:输入一行，输出一行。</p><blockquote><p><strong>重点：所有数据库都是这样规定的，只要有NULL参与的运算结果一定是NULL。</strong> </p></blockquote><p>eg1计算所有工人的年薪</p><p>select ename,(sal+comm) * 12 as ‘年薪’ from emp;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904211524.png"></p><p>要想不出现NULL，就得使用ifnull() 空处理函数<br>ifnull(可能为NULL的数据,被当做什么处理) ： 属于单行处理函数。</p><p>eg2:如果津贴是NULL，那就当作0来处理</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904211618.png"></p><p>18.group by 和 having</p><p>group by:按照某个字段或者某些字段进行分组</p><p>having:having是对分组之后的数据进行再次过滤</p><p>eg1找出每个工作岗位的最高薪资</p><p>select max(sal) from emp group by job;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904211706.png"></p><blockquote><p> <strong>注意:分组函数一般和group by联合使用，这也是为什么它被称为分组函数的原因。</strong></p><p><strong>并且任何一个分组函数(sum,avg,max,min,count)都是在group by语句执行结束后才会执行。当一条sql语句没有group by的话，整张表的数据会自成一组。</strong></p><p><strong>另外:分组函数之所以不能用在where子句中，是因为group by是在where之后执行的</strong></p></blockquote><p> <strong>结论:当一条语句中有group by的话，select后面只能跟分组函数和参与分组的字段。</strong></p><p>eg2找出每个工作岗位的平均薪资</p><p>select avg(sal),job from emp group by job;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904211737.png"></p><p>eg3找出每个部门的最高薪资，要求显示薪资大于2900的数据</p><p>select deptno,max(sal) from emp group by deptno having max(sal) &gt; 2900;//这种方式效率低</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904211911.png"></p><p> 可以直接使用where过滤</p><p>select deptno,max(sal) from emp where sal &gt; 2900 group by deptno;//效率较高，建议能使用where过滤尽量使用</p><p>19.总结一个完整的DQL语句怎么写</p><p>执行顺序如下:<br>         select         5<br>           ..<br>         from          1<br>           ..<br>         where        2<br>           ..<br>         group by     3<br>           ..<br>         having       4<br>           ..<br>         order by     6<br>           ..</p>]]></content>
      
      
      <categories>
          
          <category> MySQL学习心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2020/10/02/%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/10/02/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="链表——1"><a href="#链表——1" class="headerlink" title="链表——1"></a>链表——1</h1><p>与数组一样，链表也支持数据的查找、插入和删除操作。我们知道，在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是 O(n)。而在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为<strong>链表的存储空间本身就不是连续的</strong>。所以，在链表中插入和删除一个数据是非常快速的。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904182947.png"></p><p>从图中我们可以看出，针对链表的插入和删除操作，我们只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 O(1)。</p><p>但是有利就有弊，<strong>数组的特点是:查询快，增删慢;<strong>与之相对应的</strong>链表则是:查询慢，增删快</strong>。这是<strong>因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。</strong></p><p><strong>2.循环链表</strong></p><p><strong>循环链表是一种特殊的单链表。</strong>它跟单链表唯一的区别就在尾结点。我们知道，单链表的尾结点指针指向空地址，表示这就是最后的结点了。而<strong>循环链表的尾结点指针是指向链表的头结点</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904183045.png"></p><p>和单链表相比，<strong>循环链表的优点是从链尾到链头比较方便</strong>。<strong>当要处理的数据具有环型结构特点时，就特别适合采用循环链表。</strong>比如著名的<strong>约瑟夫问题</strong>。尽管用单链表也可以实现，但是用循环链表实现的话，代码就会简洁很多。</p><p><strong>3.双向链表(在实际软件开发中较为常用，主要用”空间换时间”的设计思想)</strong></p><p><strong>“空间换时间”思想:当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构。相反，如果内存比较紧缺，比如代码跑在手机或者单片机上，这个时候，就要反过来用时间换空间的设计思路。</strong></p><p>单向链表只有一个方向，结点只有一个后继指针 next 指向后面的结点。而双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904183126.png"></p><h2 id="单向链表和双向链表的区别"><a href="#单向链表和双向链表的区别" class="headerlink" title="单向链表和双向链表的区别?"></a><strong>单向链表和双向链表的区别?</strong></h2><p><strong>单向链表的结点只有两个域，一个是数据域，另外一个是存储后继结点地址的指针域。 而双向链表的结点有三个域，一个是数据域，一个是存储后继结点地址的指针域（后继指针next），还有一个是存储前驱结点地址的指针域（前驱指针prev）</strong></p><p><strong>从结构上来看，双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。</strong></p><p>当把双向链表和循环链表结合在一起，就会形成双向循环链表。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904183337.png"></p><p><strong>链表 VS 数组性能大比拼</strong></p><p>正是因为内存存储的区别，它们插入、删除、随机访问操作的时间复杂度正好相反。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904183423.png"></p><p> 不过，数组和链表的对比，并不能局限于时间复杂度。而且，在实际的软件开发中，不能仅仅利用复杂度分析就决定使用哪个数据结构来存储数据。</p><p>数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。</p><h2 id="CPU缓存机制"><a href="#CPU缓存机制" class="headerlink" title="CPU缓存机制:"></a><strong>CPU缓存机制</strong>:</h2><p><strong>CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中。而CPU每次从内存读取数据并不是只读取那个特定要访问的地址，而是读取一个数据块(一般64位cpu每次会读取64字节数据到缓存)并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取。这样就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义:为了弥补内存访问速度过慢与CPU执行速度快之间的差异而引入。 对于数组来说，存储空间是连续的，所以在加载某个下标的时候可以把以后的几个下标元素也加载到CPU缓存这样执行速度会快于存储空间不连续的链表存储。</strong></p><p><strong>数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。</strong></p><p>你可能会说，我们 Java 中的 ArrayList 容器，也可以支持动态扩容啊？但是当我们往支持动态扩容的数组中插入一个数据时，如果数组中没有空闲空间了，就会申请一个更大的空间，将数据拷贝过去，而数据拷贝的操作是非常耗时的。</p><p>我举一个稍微极端的例子。如果我们用 ArrayList 存储了了 1GB 大小的数据，这个时候已经没有空闲空间了，当我们再插入数据的时候，ArrayList 会申请一个 1.5GB 大小的存储空间，并且把原来那 1GB 的数据拷贝到新申请的空间上。听起来是不是就很耗时？</p><p>除此之外，如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）。</p><p>所以，在我们实际的开发中，针对不同类型的项目，要根据具体情况，权衡究竟是选择数组还是链表。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2020/10/02/%E6%95%B0%E7%BB%84/"/>
      <url>/2020/10/02/%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p><strong>1.什么是数组？</strong></p><p>数组(Array)是一种<strong>线性表数据结构</strong>。它是一组<strong>连续的</strong>内存空间，来存储<strong>具有相同类型</strong>的数据。</p><p>首先，剖析关键字。No.1 <strong>线性表</strong>。顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904181835.png"></p><p>与之相对立的概念就是非线性表，比如二叉树、堆、图等。之所以叫做非线性，是因为在非线性表中，数据之间并不是简单的前后关系。如下图</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904182053.png"></p><p>剖析第二个关键字，No.2 <strong>连续的内存空间和相同类型的数据。</strong> 正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“随机访问”。但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。</p><p>这里我要特别纠正一个“错误”。在面试的时候，常常HR会问数组和链表的区别，很多人都回答说，“链表适合插入、删除，时间复杂度 O(1)；数组适合查找，查找时间复杂度为 O(1)”。<strong>实际上，这种表述是不准确的。数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)。所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。</strong></p><p>低效的“插入”和“删除”前面概念部分我们提到，数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效。现在我们就来详细说一下，究竟为什么会导致低效？又有哪些改进方法呢？我们先来看插入操作。假设数组的长度为 n，现在，如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k～n 这部分的元素都顺序地往后挪一位。那插入操作的时间复杂度是多少呢？你可以自己先试着分析一下。如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 O(n)。 因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 (1+2+…n)/n=O(n)。如果数组中的数据是有序的，我们在某个位置插入一个新的元素时，就必须按照刚才的方法搬移 k 之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数据插入到第 k 个位置，为了避免大规模的数据搬移，我们还有一个简单的办法就是，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。为了更好地理解，我们举一个例子。假设数组 a[10]中存储了如下 5 个元素：a，b，c，d，e。我们现在需要将元素 x 插入到第 3 个位置。我们只需要将 c 放入到 a[5]，将 a[2]赋值为 x 即可。最后，数组中的元素如下： a，b，x，d，e，c。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904182238.png"></p><p>利用这种处理技巧，在特定场景下，在第 k 个位置插入一个元素的时间复杂度就会降为 O(1)。这个处理思想在快排中也会用到，我会在排序那一节具体来讲，这里就说到这儿。我们再来看删除操作。跟插入数据类似，如果我们要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)。实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率是不是会提高很多呢？我们继续来看例子。数组 a[10]中存储了 8 个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除 a，b，c 三个元素。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904182327.png"></p><p>为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。如果你了解 JVM，你会发现，这不就是 JVM 标记清除垃圾回收算法的核心思想吗？没错，数据结构和算法的魅力就在于此，很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的。如果你细心留意，不管是在软件开发还是架构设计中，总能找到某些算法和数据结构的影子。</p><p><strong>JVM标记清楚算法思想:1.复制算法. 2.标记清除算法. 3.标记整理算法. 简单思想: 数组中删除数据时,并不真正的删除,而是标记一下,先不进行数据的搬移工作,等数组空间不够用时,我们再执行删除操作.进行数据的搬移工作. –&gt; 这样可以减少因为删除操作导致的数据搬移. 这种思想在JVM垃圾回收算法的 标记清除算法中 也有体现. 第一遍扫描先标记垃圾对象,第二遍扫描再清除垃圾对象. –&gt; 这种垃圾回收算法 容易产生内存碎片,导致出现虽然内存空间充足,但是无法放置大对象的诡异现象.</strong></p><p><strong>容器能否完全替代数组？</strong></p><p>针对数组类型，很多语言都提供了容器类，比如 Java 中的 ArrayList、C++ STL 中的 vector。在项目开发中，什么时候适合用数组，什么时候适合用容器呢？这里我拿 Java 语言来举例。如果你是 Java 工程师，几乎天天都在用 ArrayList，对它应该非常熟悉。那它与数组相比，到底有哪些优势呢？我个人觉得，ArrayList 最大的优势就是<strong>可以将很多数组操作的细节封装起来</strong>。比如前面提到的数组插入、删除数据时需要搬移其他数据等。另外，它还有一个优势，就是<strong>支持动态扩容</strong>。数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间。如果我们申请了大小为 10 的数组，当第 11 个数据需要存储到数组中时，我们就需要重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。如果使用 ArrayList，我们就完全不需要关心底层的扩容逻辑，ArrayList 已经帮我们实现好了。每次存储空间不够的时候，它都会将空间自动扩容为 1.5 倍大小。不过，这里需要注意一点，因为扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好<strong>在创建 ArrayList 的时候事先指定数据大小</strong>。</p><p>作为高级语言编程者，是不是数组就无用武之地了呢？当然不是，有些时候，用数组会更合适些，我总结了几点自己的经验。</p><p>1.Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。</p><p>\2. 如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。</p><p>\3. 还有一个是我个人的喜好，当要表示多维数组时，用数组往往会更加直观。比如 Object[][] array；而用容器的话则需要这样定义：ArrayList &gt; array。</p><p>我总结一下，对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。</p><p><strong>总结:数组用一块连续的内存空间，来存储相同类型的一组数据，最大的特点就是支持随机访问，但插入、删除操作也因此变得比较低效，平均情况时间复杂度为 O(n)。在平时的业务开发中，我们可以直接使用编程语言提供的容器类，但是，如果是特别底层的开发，直接使用数组可能会更合适。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC操作数据库</title>
      <link href="/2020/09/11/JDBC%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2020/09/11/JDBC%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="JDBC操作数据库"><a href="#JDBC操作数据库" class="headerlink" title="JDBC操作数据库"></a>JDBC操作数据库</h1><h2 id="在idea中导包"><a href="#在idea中导包" class="headerlink" title="在idea中导包"></a>在idea中导包</h2><p>操作之前必须先把相关的mysql包导入。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210911154746193.png" alt="image-20210911154746193"></p><h2 id="JDBC操作"><a href="#JDBC操作" class="headerlink" title="JDBC操作"></a>JDBC操作</h2><h3 id="该操作执行器是createStatement-该执行器会有一个SQL注入问题，下面会细说"><a href="#该操作执行器是createStatement-该执行器会有一个SQL注入问题，下面会细说" class="headerlink" title="该操作执行器是createStatement(该执行器会有一个SQL注入问题，下面会细说)"></a>该操作执行器是createStatement(<strong>该执行器会有一个SQL注入问题，下面会细说</strong>)</h3><h4 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mysqlTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.加载驱动</span></span><br><span class="line">        Class.format(com.mysql.jdbc.Driver)</span><br><span class="line">        <span class="comment">//2.建立连接</span></span><br><span class="line">        Connection con = DriverManager.getConnection(</span><br><span class="line">            <span class="string">&quot;jdbc:mysql://master:3306/test&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;123456&quot;</span>)<span class="comment">//指定端口和需要操作的库</span></span><br><span class="line">    <span class="comment">//3.创建执行器来执行sql语句</span></span><br><span class="line">    <span class="comment">//3.1执行器createStatement</span></span><br><span class="line">    String sql = <span class="string">&quot;select * from dept&quot;</span>;</span><br><span class="line">    Statement statement = con.createStatement();</span><br><span class="line">    ResultSet resuletset = statement.executeQuery(sql);</span><br><span class="line">        <span class="keyword">while</span> (resultSet.next())&#123;</span><br><span class="line">            <span class="comment">//这里给的是String类型，表示的是字段名称</span></span><br><span class="line">            System.out.println(resultSet.getInt(<span class="string">&quot;deptno&quot;</span>));</span><br><span class="line">            System.out.println(resultSet.getString(<span class="string">&quot;dname&quot;</span>));</span><br><span class="line">            System.out.println(resultSet.getString(<span class="string">&quot;loc&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.获取结果</span></span><br><span class="line">        System.out.println(resultSet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.关闭</span></span><br><span class="line">        resultSet.close();</span><br><span class="line">        statement.close();</span><br><span class="line">        conn.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加操作"><a href="#添加操作" class="headerlink" title="添加操作"></a>添加操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mysqlInsert</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//直接插入信息</span></span><br><span class="line"><span class="comment">//        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span></span><br><span class="line"><span class="comment">//        Connection conn = DriverManager.getConnection(</span></span><br><span class="line"><span class="comment">//                &quot;jdbc:mysql://master:3306/test1&quot;,</span></span><br><span class="line"><span class="comment">//                &quot;root&quot;,</span></span><br><span class="line"><span class="comment">//                &quot;123456&quot;</span></span><br><span class="line"><span class="comment">//        );</span></span><br><span class="line"><span class="comment">//        Statement statement = conn.createStatement();</span></span><br><span class="line"><span class="comment">//        String sql = &quot;insert into dept values(50,&#x27;doctor&#x27;,&#x27;HuaiBei&#x27;)&quot;;</span></span><br><span class="line"><span class="comment">//        int i = statement.executeUpdate(sql);</span></span><br><span class="line"><span class="comment">//        if(i!=0)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;添加成功&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;else &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;添加失败&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        statement.close();</span></span><br><span class="line"><span class="comment">//        conn.close();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//键盘录入信息</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入部门编号&quot;</span>);</span><br><span class="line">        Integer deptno = sc.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入部门职责&quot;</span>);</span><br><span class="line">        String dname = sc.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入工作地点&quot;</span>);</span><br><span class="line">        String loc = sc.next();</span><br><span class="line"></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        Connection conn = DriverManager.getConnection(</span><br><span class="line">                <span class="string">&quot;jdbc:mysql://master:3306/test1&quot;</span>,</span><br><span class="line">                <span class="string">&quot;root&quot;</span>,</span><br><span class="line">                <span class="string">&quot;123456&quot;</span></span><br><span class="line">        );</span><br><span class="line">        Statement statement = conn.createStatement();</span><br><span class="line">        String sql = <span class="string">&quot;insert into dept values(&quot;</span></span><br><span class="line">                    +deptno+<span class="string">&quot;,&quot;</span>+</span><br><span class="line">                    <span class="string">&quot;\&quot;&quot;</span>+dname+<span class="string">&quot;\&quot;&quot;</span> + <span class="string">&quot;,&quot;</span>+</span><br><span class="line">                    <span class="string">&quot;\&quot;&quot;</span>+loc+<span class="string">&quot;\&quot;)&quot;</span>;</span><br><span class="line">        System.out.println(sql);</span><br><span class="line">        <span class="keyword">int</span> i = statement.executeUpdate(sql);</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;录入成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;录入失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        statement.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mysqlDelete</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        Connection conn = DriverManager.getConnection(</span><br><span class="line">                <span class="string">&quot;jdbc:mysql://master:3306/test1&quot;</span>,</span><br><span class="line">                <span class="string">&quot;root&quot;</span>,</span><br><span class="line">                <span class="string">&quot;123456&quot;</span></span><br><span class="line">        );</span><br><span class="line">        Statement statement = conn.createStatement();</span><br><span class="line">        String sql = <span class="string">&quot;delete from dept where deptno=10&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> i = statement.executeUpdate(sql);</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        statement.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mysqlUpdate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        Connection conn = DriverManager.getConnection(</span><br><span class="line">                <span class="string">&quot;jdbc:mysql://master:3306/test1&quot;</span>,</span><br><span class="line">                <span class="string">&quot;root&quot;</span>,</span><br><span class="line">                <span class="string">&quot;123456&quot;</span></span><br><span class="line">        );</span><br><span class="line">        Statement statement = conn.createStatement();</span><br><span class="line">        String sql = <span class="string">&quot;update dept set loc=&#x27;shanghai&#x27; where deptno=60&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> i = statement.executeUpdate(sql);</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;更新成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;更新失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        statement.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="执行器preparedStatement-能有效解决SQL注入问题"><a href="#执行器preparedStatement-能有效解决SQL注入问题" class="headerlink" title="执行器preparedStatement(能有效解决SQL注入问题)"></a>执行器preparedStatement(能有效解决SQL注入问题)</h3><h4 id="什么是SQL注入？"><a href="#什么是SQL注入？" class="headerlink" title="什么是SQL注入？"></a>什么是SQL注入？</h4><p>简单来说就是利用createStatement的一个漏洞，通过拼接字符串的形式来登录SQL</p><p>下面用代码来演示下SQL注入</p><p>(以下代码都是通过加载配置文件来操作的)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *   在JDBC中 以后使用PreparedStatement</span></span><br><span class="line"><span class="comment"> *   因为使用Statement时会存在SQL注入问题</span></span><br><span class="line"><span class="comment"> *   以下是SQL注入演示</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IOException, SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">//让用户输入管理员和密码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入管理员的名字:&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String admin_user = scanner.nextLine();<span class="comment">//如果需要看到SQL注入演示效果，就需要用nextLine()方法，因为next()方法会自动屏蔽掉空格</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入管理员的密码&quot;</span>);</span><br><span class="line">        String admin_pwd = scanner.nextLine();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//加载配置文件</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">        String user = properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        String password = properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        String url = properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        String driver = properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册驱动</span></span><br><span class="line">        Class.forName(driver);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//建立连接</span></span><br><span class="line">        Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">        <span class="comment">//获取Statement</span></span><br><span class="line">        Statement statement = connection.createStatement();</span><br><span class="line">        <span class="comment">//写sql</span></span><br><span class="line">        String sql = <span class="string">&quot;select ename,deptno from emp where ename = &#x27;&quot;</span> + admin_user + <span class="string">&quot;&#x27; and deptno = &#x27;&quot;</span>+ admin_pwd + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">        ResultSet resultSet = statement.executeQuery(sql);</span><br><span class="line">        <span class="keyword">if</span>(resultSet.next())&#123;<span class="comment">//如果查询到记录，就说明存在</span></span><br><span class="line">            System.out.println(<span class="string">&quot;登陆成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;登陆失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        resultSet.close();</span><br><span class="line">        statement.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我输入万能用户名和密码，就会出现如下情况</p><p>输入用户名 为 1’ or </p><p>输入万能密码 为 or ‘1’= ‘1 </p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210911193518196.png" alt="image-20210911193518196"></p><p>这就是SQL注入，通过万能账号和密码就能登录。</p><p>但是preparedStatement就能显著的解决这个问题</p><p>还是上面的代码，用prapareStatement加以修改，如下所示</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   使用 PreparedStatement处理</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, SQLException, ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">//让用户输入管理员和密码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入管理员的名字:&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String admin_user = scanner.nextLine();<span class="comment">//如果需要看到SQL注入演示效果，就需要用nextLine()方法，因为next()方法会自动屏蔽掉空格</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入管理员的密码&quot;</span>);</span><br><span class="line">        String admin_pwd = scanner.nextLine();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//加载配置文件</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">        String user = properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        String password = properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        String url = properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        String driver = properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册驱动</span></span><br><span class="line">        Class.forName(driver);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//建立连接</span></span><br><span class="line">        Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取PreparedStatement</span></span><br><span class="line">        <span class="comment">//1.1写sql</span></span><br><span class="line">        String sql = <span class="string">&quot;select ename,deptno from test where ename = ? and deptno = ?&quot;</span>;</span><br><span class="line">        <span class="comment">//1.2获取连接</span></span><br><span class="line">        PreparedStatement preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">        <span class="comment">//1.3 给?赋值</span></span><br><span class="line">        preparedStatement.setString(<span class="number">1</span>,admin_user);</span><br><span class="line">        preparedStatement.setString(<span class="number">2</span>,admin_pwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行select语句</span></span><br><span class="line">        ResultSet resultSet = preparedStatement.executeQuery();</span><br><span class="line">        <span class="keyword">if</span>(resultSet.next())&#123;<span class="comment">//如果查询到记录，就说明存在</span></span><br><span class="line">            System.out.println(<span class="string">&quot;登陆成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;登陆失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        resultSet.close();</span><br><span class="line">        preparedStatement.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210911193749029.png" alt="image-20210911193749029"></p><h4 id="如何解决SQL注入"><a href="#如何解决SQL注入" class="headerlink" title="如何解决SQL注入"></a>如何解决SQL注入</h4><p>此时还是用刚刚的账号和密码就会显示登陆错误。这是因为preparedStatement执行的SQL语句中的参数用问号(?)来表示，调用其对象的setXxx()方法来设置这些参数。setXxx()方法有两个参数，第一个参数是要设置的SQL语句中的参数的索引(从1开始)，第二个是设置的SQL语句中的参数的值</p><p>用预处理的好处就是:</p><p>1.不再使用+拼接sql语句，减少了语法错误</p><p>2.有效的解决了sql注入问题</p><p>3.大大减少了编译次数，效率较高</p>]]></content>
      
      
      
        <tags>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式以及网络编程</title>
      <link href="/2020/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2020/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式以及网络编程"><a href="#设计模式以及网络编程" class="headerlink" title="设计模式以及网络编程"></a>设计模式以及网络编程</h1><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>设计模式:是经过大量的经验积累得出的一个开发模板</p><p>设计模式：</p><ul><li>创建型 创建对象</li><li>结构型 对象的组成</li><li>行为型 对象的功能</li></ul><p>创建型模式：</p><ul><li>简单工厂模式</li><li>工厂方法模式</li><li>单例模式：<ul><li>饿汉式</li><li>懒汉式</li></ul></li></ul><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat1</span> <span class="keyword">extends</span> <span class="title">Animal1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog1</span> <span class="keyword">extends</span> <span class="title">Animal1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃肉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalFactory1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Animal <span class="title">createAnimal</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;dog&quot;</span>.equals(type))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Dog();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;cat&quot;</span>.equals(type))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal a1 = AnimalFactory1.createAnimal(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">        Animal a2 = AnimalFactory1.createAnimal(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">        a1.eat();</span><br><span class="line">        a2.eat();</span><br><span class="line">        Animal a3 = AnimalFactory1.createAnimal(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(a3!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            a3.eat();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;无法创建该动物&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">工厂方式模式</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Animal1 <span class="title">createAnimal</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat1Factory</span> <span class="keyword">implements</span> <span class="title">Factory1</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Animal1 <span class="title">createAnimal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cat1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog1Factory</span> <span class="keyword">implements</span> <span class="title">Factory1</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Animal1 <span class="title">createAnimal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Dog1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat1</span> <span class="keyword">extends</span> <span class="title">Animal1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog1</span> <span class="keyword">extends</span> <span class="title">Animal1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃肉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//我现在需要一只狗</span></span><br><span class="line">        Animal1 dog = <span class="keyword">new</span> Dog1Factory().createAnimal();</span><br><span class="line">        dog.eat();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//我现在需要一只猫</span></span><br><span class="line">        Animal1 cat = <span class="keyword">new</span> Cat1Factory().createAnimal();</span><br><span class="line">        cat.eat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式：保证类在内存中只有一个对象<br>单例模式：</p><h4 id="饿汉式：类一加载就创建对象"><a href="#饿汉式：类一加载就创建对象" class="headerlink" title="饿汉式：类一加载就创建对象"></a>饿汉式：类一加载就创建对象</h4><h4 id="懒汉式：用的时候，再去创建对象"><a href="#懒汉式：用的时候，再去创建对象" class="headerlink" title="懒汉式：用的时候，再去创建对象"></a>懒汉式：用的时候，再去创建对象</h4><p>懒加载（延迟加载）<br>线程安全问题<br>是否有多线程环境<br>是否有共享数据<br>是否有多条语句操作共享数据<br>饿汉式<br>如何保证内存中只有一个对象呢：</p><p>构造方法私有<br>在成员位置上自己创建一个对象<br>提供一个公共的方法给外界去访问<br>也就是说，随着类的加载，对象就已经创建好了<br>这样的特点，在单例模式中我们称之为：饿汉式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student1</span></span>&#123;</span><br><span class="line">    Student1()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Student1 s = <span class="keyword">new</span> Student1();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student1 <span class="title">getStudent1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这样创造出来的对象不是单例的</span></span><br><span class="line">        Student1 s1 = <span class="keyword">new</span> Student1();</span><br><span class="line">        Student1 s2 = <span class="keyword">new</span> Student1();</span><br><span class="line">        System.out.println(s1==s2);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//这样创造出来的对象是单例的</span></span><br><span class="line">        Student1 s3 = Student1.getStudent1();</span><br><span class="line">        Student1 s4 = Student1.getStudent1();</span><br><span class="line">        System.out.println(s3==s4);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">懒汉式</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Teacher1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Teacher1 teacher1 = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">synchronized</span> Teacher1 <span class="title">getTeacher1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (teacher1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            teacher1 = <span class="keyword">new</span> Teacher1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> teacher1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Teacher1 t1 = Teacher1.getTeacher1();</span><br><span class="line">        Teacher1 t2 = Teacher1.getTeacher1();</span><br><span class="line">        System.out.println(t1==t2);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="网络OSI参考模型"><a href="#网络OSI参考模型" class="headerlink" title="网络OSI参考模型"></a>网络OSI参考模型</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904201129.png"></p><h3 id="网络编程三要素"><a href="#网络编程三要素" class="headerlink" title="网络编程三要素"></a>网络编程三要素</h3><p><strong>网络编程三要素</strong>：<br>1、IP地址<br>2、端口<br>3、协议</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904201242.png"></p><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>Socket：网络套接字</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904201339.png"></p><h4 id="UDP通信过程"><a href="#UDP通信过程" class="headerlink" title="UDP通信过程"></a>UDP通信过程</h4><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904201448.png"></p><h5 id="UDP协议发送数据"><a href="#UDP协议发送数据" class="headerlink" title="UDP协议发送数据"></a>UDP协议发送数据</h5><p>1、创建发送端Socket对象<br>2、创建数据，并且把数据打包<br>3、调用Socket对象的发送方法发送数据包<br>4、释放资源，关闭Socket</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建发送端的Socket对象</span></span><br><span class="line">        DatagramSocket ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建数据，并且把数据打包</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="string">&quot;helloworld&quot;</span>.getBytes();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//获取数组的长度</span></span><br><span class="line">        <span class="keyword">int</span> length = bytes.length;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//IP地址对象</span></span><br><span class="line">        InetAddress address = InetAddress.getByName(<span class="string">&quot;192.168.3.24&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//设置端口号</span></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">10086</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//DatagramPacket(byte[] buf,int length,InetAddress address,int port)</span></span><br><span class="line">        DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bytes, length, address, port);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//调用Socket对象的发送方法发送数据包</span></span><br><span class="line">        <span class="comment">//void send(DatagramPacket p)</span></span><br><span class="line">        ds.send(dp);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="UDP协议接收数据"><a href="#UDP协议接收数据" class="headerlink" title="UDP协议接收数据"></a>UDP协议接收数据</h5><p>1、创建接收端的Socket对象<br>2、创建一个数据包（接收容器）<br>3、调用Socket对象接收方法接收数据<br>4、解析数据包，并显示在控制台<br>5、释放资源，关闭Socket</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个接收端Socket对象</span></span><br><span class="line">        <span class="comment">//DatagramSocket(int port)</span></span><br><span class="line">        <span class="comment">//构造数据报套接字并将其绑定到本地主机上的指定端口</span></span><br><span class="line">        DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">10086</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个数据包（接收容器）</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//数组长度</span></span><br><span class="line">        <span class="keyword">int</span> length = bytes.length;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//构造一个DatagramPacket用于接收长度的数据包length</span></span><br><span class="line">        DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bytes, length);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//调用Socket对象接收方法接收数据</span></span><br><span class="line">        <span class="comment">//void receive(DatagramPacket p)    从此套接字中接收数据包</span></span><br><span class="line">        ds.receive(dp);<span class="comment">//该方法阻塞，直到接收到数据包</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">//InetAddress getAddress()</span></span><br><span class="line">        <span class="comment">//返回该数据包发送或接收数据包的计算机IP地址</span></span><br><span class="line">        InetAddress address = dp.getAddress();</span><br><span class="line">        String ip = address.getHostAddress();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//解析数据包，并显示在控制台</span></span><br><span class="line">        <span class="comment">//byte[] getDate()</span></span><br><span class="line">        <span class="comment">//返回数据缓冲区</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = dp.getData();</span><br><span class="line">        <span class="comment">//int getLength()</span></span><br><span class="line">        <span class="comment">//返回要发送的数据的长度或接收到的数据长度</span></span><br><span class="line">        <span class="keyword">int</span> length1 = dp.getLength();</span><br><span class="line">        String s = <span class="keyword">new</span> String(data, <span class="number">0</span>, length1);</span><br><span class="line">        System.out.println(ip+<span class="string">&quot;发送数据为：&quot;</span>+s);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TCP通信过程"><a href="#TCP通信过程" class="headerlink" title="TCP通信过程"></a>TCP通信过程</h4><h5 id="客户端-接收"><a href="#客户端-接收" class="headerlink" title="客户端    接收"></a><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904201635.png">客户端    接收</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">client</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.创建socket对象，指明服务器端的ip和端口号</span></span><br><span class="line">            InetAddress inet = InetAddress.getByName(<span class="string">&quot;192.168.3.27&quot;</span>);</span><br><span class="line">            socket = <span class="keyword">new</span> Socket(inet, <span class="number">888</span>);</span><br><span class="line">            <span class="comment">//2.获取一个输出流，用于输出数据</span></span><br><span class="line">            outputStream = socket.getOutputStream();</span><br><span class="line">            <span class="comment">//3.写出数据的操作</span></span><br><span class="line">            outputStream.write(<span class="string">&quot;你好，我是客户端&quot;</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(outputStream != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    outputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(socket != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="服务端-发送"><a href="#服务端-发送" class="headerlink" title="服务端   发送"></a>服务端   发送</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">    InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建服务器端的ServerSocket，指明自己的端口号</span></span><br><span class="line">        serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">888</span>);</span><br><span class="line">        <span class="comment">//2.调用accept()表示接受来自于客户端的socket</span></span><br><span class="line">        Socket accept = serverSocket.accept();</span><br><span class="line">        <span class="comment">//3.获取输入流中的数据，并且读取</span></span><br><span class="line">        inputStream = accept.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = inputStream.read(bytes) )!= -<span class="number">1</span>)&#123;</span><br><span class="line">            String s = <span class="keyword">new</span> String(bytes, <span class="number">0</span>, len);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(inputStream != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(serverSocket != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                serverSocket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TCP以及UDP区别"><a href="#TCP以及UDP区别" class="headerlink" title="TCP以及UDP区别"></a>TCP以及UDP区别</h4><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904201948.png"></p><h3 id="引入三次握手"><a href="#引入三次握手" class="headerlink" title="引入三次握手"></a>引入三次握手</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。</p><p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。<br>进行三次握手：</p><p>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN。此时客户端处于 SYN_SENT 状态。</p><p>首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。</p><p>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_RCVD 的状态。</p><p>在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。</p><p>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。</p><p>确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。</p><p>发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。</p><p>在socket编程中，客户端执行connect()时，将触发三次握手。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904202433.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904203355.png"></p><h5 id="为什么非得采用三次握手，两次不行吗"><a href="#为什么非得采用三次握手，两次不行吗" class="headerlink" title="为什么非得采用三次握手，两次不行吗?"></a>为什么非得采用三次握手，两次不行吗?</h5><p>弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。</p><p>第一次握手：客户端发送网络包，服务端收到了。<br>这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。<br>第二次握手：服务端发包，客户端收到了。<br>这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。<br>第三次握手：客户端发包，服务端收到了。<br>这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。<br>因此，需要三次握手才能确认双方的接收与发送能力是否正常。</p><h5 id="试想如果是用两次握手，则会出现下面这种情况："><a href="#试想如果是用两次握手，则会出现下面这种情况：" class="headerlink" title="试想如果是用两次握手，则会出现下面这种情况："></a>试想如果是用两次握手，则会出现下面这种情况：</h5><blockquote><p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p></blockquote><h3 id="引入四次挥手"><a href="#引入四次挥手" class="headerlink" title="引入四次挥手"></a>引入四次挥手</h3><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p><p>TCP 连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务端均可主动发起挥手动作。</p><p>刚开始双方都处于ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p><ul><li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。<br>即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</li><li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。<br>即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</li><li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。<br>即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</li><li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。<br>即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</li></ul><p>收到一个FIN只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。</p><p>在socket编程中，任何一方执行close()操作即可产生挥手操作。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904203216.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904203451.png"></p><h5 id="挥手为什么需要四次？"><a href="#挥手为什么需要四次？" class="headerlink" title="挥手为什么需要四次？"></a>挥手为什么需要四次？</h5><p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lock锁以及线程</title>
      <link href="/2020/09/02/Lock%E9%94%81%E4%BB%A5%E5%8F%8A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/09/02/Lock%E9%94%81%E4%BB%A5%E5%8F%8A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Lock锁以及线程"><a href="#Lock锁以及线程" class="headerlink" title="Lock锁以及线程"></a>Lock锁以及线程</h1><h2 id="Lock-接口"><a href="#Lock-接口" class="headerlink" title="Lock(接口)"></a>Lock(接口)</h2><p>void lock() 获得锁，加锁<br>void unlock() 释放锁</p><p>子类：<br>ReentrantLock<br>这是解决线程同步安全的第二种方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SellTick1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义票的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义锁对象</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span> (tickets&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在出售第&quot;</span>+</span><br><span class="line">                            (tickets--)+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//释放锁</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicketDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SellTick1 s = <span class="keyword">new</span> SellTick1();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建三个线程窗口</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(s, <span class="string">&quot;窗口一&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(s, <span class="string">&quot;窗口二&quot;</span>);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(s, <span class="string">&quot;窗口三&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>同步的弊端：<br>- 效率低<br>- 如果出现了同步嵌套，就容易产生死锁问题<br><strong>死锁：是指两个或者两个以上的线程在执行的过程中，因争夺资源产生的一种互相等待现象</strong></p><h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><h3 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h3><p>Java可以使用 ThreadGroup来表示线程组，它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制</p><p><strong>简单来说：线程组就是把多个线程组合到一起</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student4</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag;<span class="comment">//默认是false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置数据，相当于生产者，没有数据（false）就生产，有数据（true）就等待</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.flag)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.notify();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取数据，相当于消费者，没有数据（false）就等待（wait），有数据（true）就消费</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.flag)&#123;<span class="comment">//加感叹号是为了顺利进入循环</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name+<span class="string">&quot;---&quot;</span>+<span class="keyword">this</span>.age);</span><br><span class="line">        <span class="keyword">this</span>.flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SetThread4</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Student4 s;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SetThread4</span><span class="params">(Student4 s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                s.set(<span class="string">&quot;A&quot;</span>,<span class="number">21</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                s.set(<span class="string">&quot;B&quot;</span>,<span class="number">12</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetThread4</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Student4 s;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GetThread4</span><span class="params">(Student4 s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            s.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student4 s = <span class="keyword">new</span> Student4();</span><br><span class="line"></span><br><span class="line">        SetThread4 st = <span class="keyword">new</span> SetThread4(s);</span><br><span class="line">        GetThread4 gt = <span class="keyword">new</span> GetThread4(s);</span><br><span class="line">    </span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(st);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(gt);</span><br><span class="line">    </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="线程池的好处："><a href="#线程池的好处：" class="headerlink" title="线程池的好处："></a>线程池的好处：</h4><p>线程池的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用</p><h4 id="如何实现线程池："><a href="#如何实现线程池：" class="headerlink" title="如何实现线程池："></a>如何实现线程池：</h4><p>1、创建一个线程池对象，控制要创建几个线程对象<br>public static ExecutorServe newFixedThreadPool(int nThreads)<br>创建一个线程池，指定线程池大小<br>2、哪些线程可以放到线程池执行<br>可以执行Runnable对象或者Callable对象代表的线程<br>3、如何执行<br>Future&lt;?&gt; submit(Runnable task)<br>提交一个可运行的任务执行，并返回一个表示该任务的未来。<br>Future submit(Callable task)<br>提交值返回任务以执行，并返回代表任务待处理结果的Future。<br>4、想结束任务怎么办<br>void shutdown()<br>启动有序关闭，其中先前提交的任务将被执行，但是不会接受任何新任务</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个线程池对象，控制要创建几个线程对象</span></span><br><span class="line">        ExecutorService fixpool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用匿名内部类的形式将Runnable对象或者Callable对象放进去并执行</span></span><br><span class="line">        fixpool.submit(<span class="keyword">new</span> MyRunnable2());</span><br><span class="line">        fixpool.submit(<span class="keyword">new</span> MyRunnable2());</span><br><span class="line">    </span><br><span class="line">        fixpool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p><strong>定时器是一个应用十分广泛的线程工具，可用于调度多个定时任务以后台线程的方式执行，在Java中，可以通过Timer和TimerTask类来实现定义调度的功能</strong></p><p>Timer：定时<br>Timer() 创建一个新的计时器<br>void schedule(TimerTask task,long delay)在指定的延迟之后安排指定的任务执行<br>void schedule(TimerTask task,long delay,long period)在指定的延迟之后开始，重写执行<br>void cancel()终止此计数器，丢弃任何当前计划的任务<br>TimerTask：任务</p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程</title>
      <link href="/2020/09/02/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/09/02/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h1><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a><strong>什么是线程</strong></h3><p>如果程序只有一条执行路径，那么该程序就是单线程程序<br>如果程序有多条执行路径，那么该程序就是多线程程序。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904194721.png"></p><p><strong>进程与线程的描述</strong><br>线程是依赖于进程存在的</p><h3 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a><strong>什么是进程</strong></h3><p>通过任务管理器看到了进程的存在<br>但是，我们只发现了正在运行的进程，没有运行的程序，进程中就没有<br>进程：就是正在运行的程序<br>正在运行的程序，是系统进行资源分配和调用的独立单位<br>每一个进程都有它自己的内存空间和系统资源</p><h4 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h4><p>单进程，是计算机只能做一件事情，但是呢，现在，我们的计算机都可以做多件事情，<br>比如：一边玩游戏（游戏进程），一边听音乐（音乐进程）<br>也就是说，现在的计算机都是支持多进程的，可以在一个时间段内执行多个任务</p><p>那么：单CPU的时候，一边玩游戏一边听音乐是同时在进行的吗？<br>不是，因为单CPU在某个时间点上只能做一件事情<br>但是为什么我们感觉是同时进行的呢？<br>是因为CPU在做着程序之间高效切换让我们觉得是在同时进行</p><h4 id="什么是线程-1"><a href="#什么是线程-1" class="headerlink" title="什么是线程"></a>什么是线程</h4><p>在同一个进程中又可以执行多个任务，而这每一个任务，我们看作线程<br>线程：是进程中的单个顺序控制流，是一条执行路径，是程序的执行单元，执行路径是程序使用CPU的最基本单位<br>单线程：一个进程只有一条执行路径<br>多线程：一个进程有多条执行路径</p><h4 id="多线程有什么意义呢？"><a href="#多线程有什么意义呢？" class="headerlink" title="多线程有什么意义呢？"></a>多线程有什么意义呢？</h4><p>多线程的存在，不是提高程序的执行速度，是为了提高应用程序的使用率存在的<br>在学习过程中，我们常见两种使用CPU的方式，一种是分片调度，一种是抢占式调度，而我们的Java是抢占式调度<br>多线程就是某个进程在抢占资源的时候，执行路径比较多，有着更高的几率抢到，但是我们不能保证哪一个线程能够在哪一个时刻可以抢到CPU资源<br>所以线程的执行具有随机性</p><h4 id="并发与并行的描述"><a href="#并发与并行的描述" class="headerlink" title="并发与并行的描述"></a>并发与并行的描述</h4><p>并行：指的是逻辑上同时发生，指在某一个时间段内同时运行多个程序<br>并发：指的是物理上同时发生，指在某一个时间点内同时运行多个程序<br>Java程序的运行原理<br>由Java命令去启动一个JVM，JVM启动就相当于启动了一个进程<br>接着由该进程去创建一个主线程去调用main方法</p><h5 id="思考：JVM虚拟机启动的时候是单线程还是多线程呢"><a href="#思考：JVM虚拟机启动的时候是单线程还是多线程呢" class="headerlink" title="思考：JVM虚拟机启动的时候是单线程还是多线程呢"></a>思考：JVM虚拟机启动的时候是单线程还是多线程呢</h5><p>多线程<br>因为：垃圾回收线程也是需要启动的，否则就会出现内存溢出<br>所以JVM虚拟机启动的时候，最低启动两个线程，所以JVM虚拟机启动的时候是多线程</p><h5 id="实现多线程"><a href="#实现多线程" class="headerlink" title="实现多线程"></a>实现多线程</h5><p><strong>如何实现多线程呢</strong><br>由于线程是依赖于进程存在的，所以我们应该先创建一个进程出来，而进程最终是由系统创建的，所以我们就要想应该去调用系统的功能去创建进程<br>但是，Java并不能直接调用系统功能，所以我们就没办法实现多线程程序<br>但是，Java可以去调用C/C++写好的程序来实现多线程程序<br>由C/C++去调用系统功能创建进程，然后由Java去调用这样的东西就可以了<br>然后提供一些类给我们使用，我们就可以创建多线程程序了</p><p><strong>Java提供的类是什么呢</strong></p><h4 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h4><p>通过查看API文档，我们知道了有两种实现多线程程序的方式</p><h5 id="方式一：继承Thread类实现多线程"><a href="#方式一：继承Thread类实现多线程" class="headerlink" title="方式一：继承Thread类实现多线程"></a>方式一：继承Thread类实现多线程</h5><p>步骤：</p><p>自定义一个MyThread类继承Thread类<br>自定义重写Thread类中的run方法（类中的代码不是所有代码都需要被线程执行，只有当需要被线程执行的时候，再把代码加入到run方法中）<br>创建对象<br>启动线程</p><p>在多线程中获取和设置线程名称</p><ul><li>获取线程对象的名称：<br>public final String getName() 返回此线程的名称</li><li>设置线程对象的名称：<br>public final void setName(String name)将此线程的名称改为name</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        <span class="comment">//无参构造创建对象，开发中推荐这一招</span></span><br><span class="line"><span class="comment">//        MyThread2 m1 = new MyThread2();</span></span><br><span class="line"><span class="comment">//        MyThread2 m2 = new MyThread2();</span></span><br><span class="line"><span class="comment">//        m1.setName(&quot;zhangsan&quot;);</span></span><br><span class="line"><span class="comment">//        m2.setName(&quot;lisi&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//有参构造方法给线程对象起名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        MyThread2 m3 = new MyThread2(&quot;wangwu&quot;);</span></span><br><span class="line"><span class="comment">//        MyThread2 m4 = new MyThread2(&quot;zhaoliu&quot;);</span></span><br><span class="line"><span class="comment">//        m3.start();</span></span><br><span class="line"><span class="comment">//        m4.start();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(m1.getName());</span></span><br><span class="line"><span class="comment">//        m1.start();</span></span><br><span class="line"><span class="comment">//        m2.start();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取main方法所在的线程的名称</span></span><br><span class="line">        <span class="comment">//Thread提供了一个方法给我们，可以获取main方法的线程，也就是主线程</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h4><p><strong>如何获取线程对象的优先级</strong><br>public final int getPriority()返回此线程的优先级<br>如何设置线程对象的优先级<br>public final void setPriority(int newPriority)更改此线程的优先级<br>MIN_PRIORITY到MAX_PRIORITY之间（1-10）<br>IllegalArgumentException:抛出表示一种方法已经通过了非法或不正确的参数。非法参数异常<br><strong>注意：</strong><br>线程的默认优先级是5<br>线程的优先级范围是1-10<br>线程的优先级仅仅代表获取CPU时间片的几率，但是不是绝对会先获取<br>public final void join()：其他线程等待这个线程死亡</p><p>public final void setDaemon() 守护线程</p><p>线程的中断<br>public final void stop()：让线程停止（该方法已经过时了，但是还能用）<br>public void interrupt()：中断这个线程，并且抛出异常<br>InterruptedException: sleep interrupted<br>注意：stop是直接让方法结束了，interrupt是结束之后抛出异常</p><p>线程的生命周期</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904195253.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904195349.png"></p><h5 id="方式二：实现Runnable接口"><a href="#方式二：实现Runnable接口" class="headerlink" title="方式二：实现Runnable接口"></a>方式二：实现Runnable接口</h5><p>步骤：</p><ul><li>自定义MyRunnable类实现Runnable接口</li><li>重写run方法</li><li>创建MyRunnable对象</li><li>创建Thread对象，并把第三步的对象当作参数传入构造方法中</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//由于实现的Runnable接口没有getName()方法，就不能直接使用Thread类的方法了</span></span><br><span class="line">            <span class="comment">//但是可以间接使用</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyRunnable my = <span class="keyword">new</span> MyRunnable();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(my);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(my);</span><br><span class="line">    </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Thread-0:0</span></span><br><span class="line"><span class="comment">//Thread-1:0</span></span><br><span class="line"><span class="comment">//Thread-1:1</span></span><br><span class="line"><span class="comment">//Thread-0:1</span></span><br><span class="line"><span class="comment">//Thread-1:2</span></span><br><span class="line"><span class="comment">//Thread-1:3</span></span><br><span class="line"><span class="comment">//Thread-0:2</span></span><br><span class="line"><span class="comment">//Thread-0:3</span></span><br></pre></td></tr></table></figure><h4 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h4><ul><li>是否有多线程环境</li><li>是否有共享数据</li><li>是否有多条语句操作共享数据</li></ul><h4 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h4><p>同步代码块：<br>格式：<br>synchronized(对象){ //把需要同步的数据都放在这里面<br>需要同步的代码块;<br>}<br>1、对象是什么呢<br>我们可以随便创建一个对象试试<br>2、需要同步的代码块是什么呢<br>多条语句操作共享数据的代码部分包起来</p><h5 id="同步的好处："><a href="#同步的好处：" class="headerlink" title="同步的好处："></a>同步的好处：</h5><p>同步的出现解决了多线程的安全问题<br>同步的弊端：<br>当线程相当多的时候，因为每个线程都会取判断同步上的锁，这样会非常耗费资源，无形中降低了程序运行的效率</p><h5 id="同步代码块的锁对象是谁呢"><a href="#同步代码块的锁对象是谁呢" class="headerlink" title="同步代码块的锁对象是谁呢"></a>同步代码块的锁对象是谁呢</h5><p>任意对象</p><h5 id="同步方法："><a href="#同步方法：" class="headerlink" title="同步方法："></a>同步方法：</h5><p>就是把同步关键字加到方法上<br>private synchronized 加到权限修饰符后面</p><h5 id="同步方法的锁是什么呢"><a href="#同步方法的锁是什么呢" class="headerlink" title="同步方法的锁是什么呢"></a>同步方法的锁是什么呢</h5><p>this</p><h3 id="线程安全的类"><a href="#线程安全的类" class="headerlink" title="线程安全的类"></a>线程安全的类</h3><ul><li>Vector 不过，虽然它是线程安全的，但是我们也不用</li><li>StringBuffer</li><li>Hashtable</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符流和序列化</title>
      <link href="/2020/09/02/%E5%AD%97%E7%AC%A6%E6%B5%81%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2020/09/02/%E5%AD%97%E7%AC%A6%E6%B5%81%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="字符流和序列化"><a href="#字符流和序列化" class="headerlink" title="字符流和序列化"></a>字符流和序列化</h1><p><strong>编码表</strong></p><p>由字符及其对应的数值组成的一张表</p><p><strong>通过字符集解码字符数组</strong><br>public String(byte[] bytes,Charset charset)<br>public byte[] getBytes(Charset charset)<br><strong>总结：</strong><br>编码：把看的懂的变成看不懂的，类似于加密<br>String – byte[]<br>解码：把看不懂的变成看的懂的，根据编码表<br>byte[] – String</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;晚上&quot;</span>;</span><br><span class="line">        <span class="comment">//String -- byte[]</span></span><br><span class="line">        <span class="keyword">byte</span>[] gbk = s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">byte</span> b:gbk)&#123;</span><br><span class="line">            System.out.println(b);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] utf = s.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">byte</span> b1:utf)&#123;</span><br><span class="line">            System.out.println(b1);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] unicodes = s.getBytes(<span class="string">&quot;Unicode&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b2:unicodes) &#123;</span><br><span class="line">            System.out.println(b2);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line">        <span class="comment">//byte[] -- String</span></span><br><span class="line">        String s1 = <span class="keyword">new</span> String(unicodes,<span class="string">&quot;Unicode&quot;</span>);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//-51</span></span><br><span class="line"><span class="comment">//-19</span></span><br><span class="line"><span class="comment">//-55</span></span><br><span class="line"><span class="comment">//-49</span></span><br><span class="line"><span class="comment">//************************</span></span><br><span class="line"><span class="comment">//-26</span></span><br><span class="line"><span class="comment">//-103</span></span><br><span class="line"><span class="comment">//-102</span></span><br><span class="line"><span class="comment">//-28</span></span><br><span class="line"><span class="comment">//-72</span></span><br><span class="line"><span class="comment">//-118</span></span><br><span class="line"><span class="comment">//************************</span></span><br><span class="line"><span class="comment">//-2</span></span><br><span class="line"><span class="comment">//-1</span></span><br><span class="line"><span class="comment">//102</span></span><br><span class="line"><span class="comment">//90</span></span><br><span class="line"><span class="comment">//78</span></span><br><span class="line"><span class="comment">//10</span></span><br><span class="line"><span class="comment">//************************</span></span><br><span class="line"><span class="comment">//晚上</span></span><br></pre></td></tr></table></figure><h2 id="字符流（也叫做转换流）"><a href="#字符流（也叫做转换流）" class="headerlink" title="字符流（也叫做转换流）"></a>字符流（也叫做转换流）</h2><p><strong>字符流 = 字节流 + 编码表</strong></p><h3 id="字符输出流"><a href="#字符输出流" class="headerlink" title="字符输出流"></a>字符输出流</h3><p>public OutputStreamWriter(OutputStream out)<br>根据默认的编码用字符作为桥梁将字节流的数据转换成字符流<br>public OutputStreamWriter(OutputStream out,String charsetName)<br>根据指定的编码用字符作为桥梁将字节流的数据转换成字符流</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//设置写出的编码格式</span></span><br><span class="line"><span class="comment">//        OutputStreamWriter outputStreamWriter = new OutputStreamWriter(new FileOutputStream(&quot;b.txt&quot;),</span></span><br><span class="line"><span class="comment">//                &quot;GBK&quot;);</span></span><br><span class="line"><span class="comment">//        OutputStreamWriter outputStreamWriter = new OutputStreamWriter(new FileOutputStream(&quot;b.txt&quot;),</span></span><br><span class="line"><span class="comment">//                &quot;UTF-8&quot;);</span></span><br><span class="line">        OutputStreamWriter outputStreamWriter = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;b.txt&quot;</span>),</span><br><span class="line">                <span class="string">&quot;Unicode&quot;</span>);</span><br><span class="line"></span><br><span class="line">        outputStreamWriter.write(<span class="string">&quot;酷酷的涛&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        outputStreamWriter.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="OutputStreamWriter写数据"><a href="#OutputStreamWriter写数据" class="headerlink" title="OutputStreamWriter写数据"></a>OutputStreamWriter写数据</h4><p>public void write(int c)<br>public void write(char[] cbuf)<br>public void write(char[] cbuf,int off,int len)<br>public void write(String str)<br>public void write(String str,int off,int len)<br><strong>注意：close()与flush()的区别：</strong></p><p>close()关闭流对象，但是会先刷新一次缓冲区。关闭之后，就不能调用<br>flush()仅仅只是刷新，刷新之后还能继续调用<br><strong>字符输入流</strong><br>public InputStreamReader(InputStream in)<br>读取数据，根据默认的编码用字符作为桥梁将字节流数据转换成字符流<br>public InputStreamReader(InputStream in,String charsetName)<br>读取数据，根据指定的编码用字符作为桥梁将字节流数据转换成字符流</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//        InputStreamReader inputStreamReader = new InputStreamReader(new FileInputStream(&quot;b.txt&quot;));</span></span><br><span class="line"><span class="comment">//        InputStreamReader inputStreamReader = new InputStreamReader(new FileInputStream(&quot;b.txt&quot;),</span></span><br><span class="line"><span class="comment">//                &quot;GBK&quot;);</span></span><br><span class="line"><span class="comment">//        InputStreamReader inputStreamReader = new InputStreamReader(new FileInputStream(&quot;b.txt&quot;),</span></span><br><span class="line"><span class="comment">//                &quot;Unicode&quot;);</span></span><br><span class="line">        InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;b.txt&quot;</span>),</span><br><span class="line">                <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一次读取一个字符</span></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((b = inputStreamReader.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">        System.out.print((<span class="keyword">char</span>) b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inputStreamReader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="InputStreamReader读数据"><a href="#InputStreamReader读数据" class="headerlink" title="InputStreamReader读数据"></a>InputStreamReader读数据</h4><ul><li>public int read() 一次只读一个字符</li><li>public int read(char[] cbuf) 一次只读一个字符数组</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;b.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一次只读取一个字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        int b = 0;</span></span><br><span class="line"><span class="comment">//        while ((b = inputStreamReader.read()) != -1)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println((char)b);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//一次只读取一个字符数组</span></span><br><span class="line">    <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((len = inputStreamReader.read(chars)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(chars,<span class="number">0</span>,len));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    inputStreamReader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用字符流实现文本文件的复制</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        将当前项目目录下的a.txt内容复制到当前目录下</span></span><br><span class="line"><span class="comment">        数据源：</span></span><br><span class="line"><span class="comment">            a.txt -- 读取数据 -- 字符流 -- InputStreamReader</span></span><br><span class="line"><span class="comment">        目的地：</span></span><br><span class="line"><span class="comment">            aCopy.txt -- 写出数据 -- 字符流 -- InputStreamWriter</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">        OutputStreamWriter outputStreamWriter = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;aCopy.txt&quot;</span>));</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//读写数据</span></span><br><span class="line">        <span class="comment">//第一种方式 只读取一个字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        int b = 0;</span></span><br><span class="line"><span class="comment">//        while ((b = inputStreamReader.read()) != -1)&#123;</span></span><br><span class="line"><span class="comment">//            outputStreamWriter.write(b);</span></span><br><span class="line"><span class="comment">//            outputStreamWriter.flush();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"> <span class="comment">//第二种方式 读取一个字符数组</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> ((len = inputStreamReader.read(chars)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        outputStreamWriter.write(chars,<span class="number">0</span>,len);</span><br><span class="line">        outputStreamWriter.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    outputStreamWriter.close();</span><br><span class="line">    inputStreamReader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用字符流简化书写的方式复制文本文件<br>简化方式：FileReader、FileWriter</p><p>由于我们常见的操作都是使用本地默认的编码，我们基本上在使用的时候不去指定编码，而又因为字符流的名称有点长，所以Java就提供了子类给我们使用</p><p>字符流 = 字节流 + 编码表</p><p>OutputStreamWriter = FileOutputStream + 编码表<br>InputStreamReader = FileInputStream + 编码表</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//原先的写法</span></span><br><span class="line"><span class="comment">//        InputStreamReader inputStreamReader = new InputStreamReader(new FileInputStream(&quot;a.txt&quot;));</span></span><br><span class="line">        <span class="comment">//改进的写法</span></span><br><span class="line">        FileReader fileReader = <span class="keyword">new</span> FileReader(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//原先的写法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        OutputStreamWriter outputStreamWriter = new OutputStreamWriter(new FileOutputStream(&quot;aCopy.txt&quot;));</span></span><br><span class="line">        <span class="comment">//改进的写法</span></span><br><span class="line">        FileWriter fileWriter = <span class="keyword">new</span> FileWriter(<span class="string">&quot;aCopy.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一种方式     一次只读取一个字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        int b = 0;</span></span><br><span class="line"><span class="comment">//        while ((b = fileReader.read()) != -1)&#123;</span></span><br><span class="line"><span class="comment">//            fileWriter.write(b);</span></span><br><span class="line"><span class="comment">//            fileWriter.flush();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"> <span class="comment">//第二种方式     一次只读取一个字符数组</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> ((len = fileReader.read(chars)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        fileWriter.write(chars,<span class="number">0</span>,len);</span><br><span class="line">        fileWriter.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fileWriter.close();</span><br><span class="line">    fileReader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h3><p>BufferedWriter：字符缓冲输出流<br>将文本文件写入到字符输入流，缓冲各个字符，以提供单个字符，数组和字符串的高效写入。<br>可以指定缓冲区大小，或者接受默认大小<br>默认值足够大，可以不用再去指定了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"> <span class="comment">//原本的写法</span></span><br><span class="line"><span class="comment">//BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(&quot;a.txt&quot;)));</span></span><br><span class="line">     <span class="comment">//改进的写法</span></span><br><span class="line">    BufferedWriter bufferedWriter1 = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">    bufferedWriter1.write(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    bufferedWriter1.write(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    bufferedWriter1.flush();</span><br><span class="line"></span><br><span class="line">    bufferedWriter1.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>BufferedReader：字符缓冲输入流<ul><li>从字符输入流读取文本，缓冲字符，以提供字符，数组或行的高效读取</li><li>可以指定缓冲区的大小，或者可以使用默认大小</li><li>默认值足够大，不需要再做改变</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//原本的写法</span></span><br><span class="line"><span class="comment">//        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;a.txt&quot;)));</span></span><br><span class="line">        <span class="comment">//改进的写法</span></span><br><span class="line">        BufferedReader bufferedReader1 = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式一，一个字符的读取</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        int b = 0;</span></span><br><span class="line"><span class="comment">//        while ((b = bufferedReader1.read()) != -1)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println((char)b);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式二，一个字符数组的读取</span></span><br><span class="line">    <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((len = bufferedReader1.read(chars)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(chars,<span class="number">0</span>,len));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bufferedReader1.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>字符缓冲流复制文本文件</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">        BufferedWriter bufferedWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;aCopy.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一次读取一个字符</span></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((b = bufferedReader.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            bufferedWriter.write(b);</span><br><span class="line">            bufferedWriter.flush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        一次读取一个字符数组</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = bufferedReader.read(chars)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            bufferedWriter.write(chars,<span class="number">0</span>,len);</span><br><span class="line">            bufferedWriter.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">    bufferedReader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符缓冲流的特殊功能"><a href="#字符缓冲流的特殊功能" class="headerlink" title="字符缓冲流的特殊功能"></a>字符缓冲流的特殊功能</h4><p>BufferedWriter：void newLine()<br>写一行行分隔符，根据系统决定换行符的<br>行分隔符字符串由系统属性line.separator定义，并不一定是单个换行符(’\n’)字符<br>BufferedReader：void readLine()<br>读一行文字，一次读取一行数据<br>一行被视为由换行符(’\n’)，<br>回车符(’\r’)中的任何一个或者随后的换行符终止<br>包含行的内容的字符串，不包含任何终止字符，如果达到流的末尾，则为null</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        write();</span><br><span class="line">        read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建字符缓冲流</span></span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//public String readLine()      读一行文字，一次读取一行数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        String s = bufferedReader.readLine();</span></span><br><span class="line"><span class="comment">//        System.out.println(s);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//最终版本</span></span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        bufferedReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    </span><br><span class="line">        BufferedWriter bufferedWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            bufferedWriter.write(<span class="string">&quot;大数据&quot;</span>);</span><br><span class="line">            bufferedWriter.newLine();<span class="comment">//换行</span></span><br><span class="line">            bufferedWriter.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>字符缓冲流的特殊功能复制文本文件</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">        BufferedWriter bufferedWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;aCopy.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        String s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((s = bufferedReader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            bufferedWriter.write(s);</span><br><span class="line">            bufferedWriter.newLine();</span><br><span class="line">            bufferedWriter.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>总结</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904193951.png"></p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><ul><li>序列化流：把对象按照流一样的方式存到文本文件或者在网络中传输<br>对象 – 流数据(ObjectOutputStream)</li><li>反序列化：把文本文件中的流对象数据或者网络中的流数据还原成对象<br>流数据 – 对象（ObjectInputStream）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">301533426692145378L</span>;   <span class="comment">//加上这个之后，就可以读回来数据，怎么改变都可以了</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="comment">//    private transient int age;        //有了这个东西之后，就固定了，不被改变，比如写入年龄25，加上这个，就不改变了</span></span><br><span class="line"><span class="comment">//    int age;                  //这里第一次运行的是int age 之后 变成了 private int age 就读不回来了</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//由于我们我们要对对象进行序列化，所以定义一个类</span></span><br><span class="line">        <span class="comment">//序列化数据其实就是将对象持久化</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//            write();</span></span><br><span class="line">            read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException|ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//创建ObjectInputStream对象</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;oos.txt&quot;</span>));</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//Object readObject()</span></span><br><span class="line">        <span class="comment">//从ObjectInputStream读取一个对象。</span></span><br><span class="line">        Object o = ois.readObject();</span><br><span class="line">    </span><br><span class="line">        ois.close();</span><br><span class="line">    </span><br><span class="line">        System.out.println(o);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建ObjectOutputStream对象</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;oos.txt&quot;</span>));</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        Person zhangsan = <span class="keyword">new</span> Person(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">24</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//void writeObject(Object obj)</span></span><br><span class="line">        <span class="comment">//将指定的对象写入ObjectOutputStream。</span></span><br><span class="line">        oos.writeObject(zhangsan);</span><br><span class="line">    </span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归思想以及IO流</title>
      <link href="/2020/09/02/%E9%80%92%E5%BD%92%E6%80%9D%E6%83%B3%E4%BB%A5%E5%8F%8AIO%E6%B5%81/"/>
      <url>/2020/09/02/%E9%80%92%E5%BD%92%E6%80%9D%E6%83%B3%E4%BB%A5%E5%8F%8AIO%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="递归思想以及IO流"><a href="#递归思想以及IO流" class="headerlink" title="递归思想以及IO流"></a>递归思想以及IO流</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><strong>什么是递归</strong></p><p>方法定义中调用方法本身的现象</p><p><strong>注意</strong></p><ul><li>递归需要有出口，否则就是死递归</li><li>次数不能太多，否则就内存溢出</li><li>构造方法不能递归使用</li></ul><p>例如:求一个斐波那契数列</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1,1,2,3,5,8,13,21</span></span><br><span class="line">        <span class="comment">//第三个开始，后面的都是前面两个之和     求第二十个数</span></span><br><span class="line">    <span class="keyword">int</span> []arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        arr[i] = arr[i-<span class="number">2</span>]+arr[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(arr[arr.length-<span class="number">1</span>]);</span><br><span class="line">    System.out.println(<span class="string">&quot;***************&quot;</span>);</span><br><span class="line">    System.out.println(recursion(<span class="number">20</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span> || i==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        sum += recursion(i-<span class="number">1</span>) + recursion(i-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><p>用来解决设备之间数据传输的问题<br>简单一句话：<br><strong>如果用电脑的笔记本打开能看懂的东西，就用字符流，<br>笔记本打开看不懂，就用字节流</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904192052.png"></p><h3 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h3><p><strong>流向：</strong><br>输入流 读取数据<br>输出流 写出数据<br><strong>数据类型：</strong><br>字节流：<br>字节输入流 读取数据 InputStream<br>字节输出流 写入数据 OutputStream<br>字符流：<br>字符输入流 读取数据 Reader<br>字符输出流 写出数据 Writer<br><strong>写出</strong><br>往文件中写出一个数据<br>我们现在尝试着往文件中写入一个数据，使用记事本能看懂的，最好用字符流，但我们这里用的是字节流</p><h4 id="字节输出流的操作步骤："><a href="#字节输出流的操作步骤：" class="headerlink" title="字节输出流的操作步骤："></a>字节输出流的操作步骤：</h4><p>1、创建字节输出流对象<br>2、写入数据<br>3、释放资源</p><p>我们是通过程序写到文本文件，所以这里用的是OutputStream</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建字节输出流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>);<span class="comment">//文件如果不存在，自动创建</span></span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">        System.out.println(fileOutputStream);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        JVM创建字节输出流对象的时候，做了些什么</span></span><br><span class="line"><span class="comment">        1、调用系统功能创建文件</span></span><br><span class="line"><span class="comment">        2、创建fileOutputStream对象</span></span><br><span class="line"><span class="comment">        3、将fileOutputStream对象指向文件</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    </span><br><span class="line">        fileOutputStream.write(<span class="string">&quot;大数据&quot;</span>.getBytes());</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        为什么需要close文件</span></span><br><span class="line"><span class="comment">        1、让流对象变成垃圾，这样垃圾回收器就可以回收它了</span></span><br><span class="line"><span class="comment">        2、通知系统去释放跟该文件相关的资源</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="JVM创建字节输出流的时候，都做了些什么"><a href="#JVM创建字节输出流的时候，都做了些什么" class="headerlink" title="JVM创建字节输出流的时候，都做了些什么"></a>JVM创建字节输出流的时候，都做了些什么</h4><p>调用系统功能创建文件<br>创建fileOutputStream对象<br>将fileOutputStream对象指向该文件<br>为什么需要close文件<br>让流对象变成垃圾，这样垃圾回收器就可以回收它了<br>通知系统去释放跟该文件相关的资源<br><strong>三种使用字节输出流往文件中写入数据的方式</strong><br>public void write(int b)<br>public void write(byte[] b)<br>public void write(byte[] b,int off,int len)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        使用字节输出流写数据的方式</span></span><br><span class="line"><span class="comment">        1、创建字节输出流对象</span></span><br><span class="line"><span class="comment">        2、使用write方法写入数据</span></span><br><span class="line"><span class="comment">        3、释放资源</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//public void write(int b)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        fileOutputStream.write(97); //a.txt文件中的内容是a，可以看到这种方式，存入的是97的ASCII码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//public void write(byte[] b)</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">104</span>,<span class="number">105</span>,<span class="number">106</span>&#125;;<span class="comment">//a.txt中的内容是hij，存入的也是底层的ASCII码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        fileOutputStream.write(b);</span></span><br><span class="line"> <span class="comment">//public void write(byte[] b,int off,int len)</span></span><br><span class="line">    fileOutputStream.write(b,<span class="number">0</span>,<span class="number">2</span>);<span class="comment">//偏移量，也是ASCII码</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h4><h5 id="字节输入流的操作步骤"><a href="#字节输入流的操作步骤" class="headerlink" title="字节输入流的操作步骤"></a>字节输入流的操作步骤</h5><ul><li>创建字节输入对象</li><li>调用read方法读取数据，并把数据显示在控制台</li><li>释放资源</li></ul><h5 id="两种字节输入流读取数据的方式"><a href="#两种字节输入流读取数据的方式" class="headerlink" title="两种字节输入流读取数据的方式"></a>两种字节输入流读取数据的方式</h5><ul><li>public int read()</li><li>public int read(byte[] b)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904192438.png"></p><p><strong>缓冲区类（高效类）</strong><br>我们可以看到，在使用字节输入输出流的时候，复制照片或者视频的时候，速度非常慢，这里我们使用字节缓冲流</p><p><strong>字节缓冲输出流</strong><br>BufferedOutputStream<br><strong>字节缓冲输入流</strong><br>BufferedInputStream<br><strong>字节缓冲输出流</strong><br>BufferedOutputStream中要传入一个OutputStream的具体的子类实现对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        BufferedOutputStream bufferedOutputStream = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">    </span><br><span class="line">        bufferedOutputStream.write(<span class="string">&quot;大数据yyds&quot;</span>.getBytes());</span><br><span class="line">    </span><br><span class="line">        bufferedOutputStream.close();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字节缓冲输入流</span></span><br><span class="line"><span class="comment">//输入到控制台：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedInputStream bufferedInputStream = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = bufferedInputStream.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        bufferedInputStream.close();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">//大数据yyds</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Treeset以及Map</title>
      <link href="/2020/09/02/Treeset%E4%BB%A5%E5%8F%8AMap/"/>
      <url>/2020/09/02/Treeset%E4%BB%A5%E5%8F%8AMap/</url>
      
        <content type="html"><![CDATA[<h1 id="Treeset以及Map"><a href="#Treeset以及Map" class="headerlink" title="Treeset以及Map"></a>Treeset以及Map</h1><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p><strong>有关TreeSet</strong></p><ul><li>TreeSet：能够使元素按照某种规则进行排序</li><li>排序有两种：1、自然排序；2、选择器排序</li><li>TreeSet集合的特点：元素唯一、可以排序</li><li>通过观察TreeSet的add()方法，我们发现最终要看TreeMap的put()方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        <span class="comment">//现在这样的排序叫做 自然排序</span></span><br><span class="line">        TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;Integer&gt;();</span><br><span class="line">        set.add(<span class="number">10</span>);</span><br><span class="line">        set.add(<span class="number">20</span>);</span><br><span class="line">        set.add(<span class="number">23</span>);</span><br><span class="line">        set.add(<span class="number">90</span>);</span><br><span class="line">        set.add(<span class="number">13</span>);</span><br><span class="line">        set.add(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span>(Integer i:set)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//10</span></span><br><span class="line"><span class="comment">//13</span></span><br><span class="line"><span class="comment">//20</span></span><br><span class="line"><span class="comment">//23</span></span><br><span class="line"><span class="comment">//90</span></span><br></pre></td></tr></table></figure><p>同时Treeset底层是红黑树，主要采用的是中序遍历。</p><p>TreeSet中的add方法源码解析<br>add方法保证了元素的有序性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Interface NavigableMap&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span> <span class="keyword">implements</span> <span class="title">NavigableMap</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; t = root;</span><br><span class="line">        <span class="comment">//一开始添加元素的时候，一定是没有根的，所以第一个元素t一定是等于null的</span></span><br><span class="line">        <span class="comment">//造一个根节点</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line"></span><br><span class="line">            root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            modCount++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cmp;</span><br><span class="line">        Entry&lt;K,V&gt; parent;</span><br><span class="line">        <span class="comment">// split comparator and comparable paths</span></span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">        <span class="comment">//由于是无参构造，是自然比较，没有比较器，所以是==null的</span></span><br><span class="line">        <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                parent = t;</span><br><span class="line">                cmp = cpr.compare(key, t.key);</span><br><span class="line">                <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                    t = t.left;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                    t = t.right;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">            &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="comment">//通过观察API发现，Integer类实现了Comparable接口，所以可以向上转型</span></span><br><span class="line">            <span class="comment">//又发现了一点：无参构造虽然是自然排序，但是也需要有一个Comparable自然比较器</span></span><br><span class="line">                Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                parent = t;</span><br><span class="line">                cmp = k.compareTo(t.key);</span><br><span class="line">                <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                    t = t.left;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                    t = t.right;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">            &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            parent.left = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            parent.right = e;</span><br><span class="line">        fixAfterInsertion(e);</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeSet</span> <span class="keyword">implements</span> <span class="title">Set</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><p>通过查看API我们发现，Map集合的特点是将键映射到值的对象<br>Map中不能包含重复的键，每个键可以映射到最多一个值<br>&lt;K,V&gt;映射<br>Key Value<br>1001 zhangsan<br>1002 lisi<br>1003 wangwu<br>1004 zhaoliu<br>1001（重复了） tianqi</p><h3 id="Map集合的特点"><a href="#Map集合的特点" class="headerlink" title="Map集合的特点"></a>Map集合的特点</h3><p>将键映射到值的对象<br>一个映射不能包含重复的键<br>每个键最多只能映射到一个值</p><h3 id="Map接口和Collection接口的不同："><a href="#Map接口和Collection接口的不同：" class="headerlink" title="Map接口和Collection接口的不同："></a>Map接口和Collection接口的不同：</h3><p>Map集合的元素是成对出现的，Map集合的键是唯一的，值是可以重复的<br>Collection集合存储的元素是单独出现的，Collection的子接口Set中的元素是唯一的，List中的元素是可以重复的</p><p>Map集合的功能<br>1、添加功能：<br>V put(K key, V value) 将指定的值与该映射中的指定键相关联（可选操作）。<br>2、删除功能：<br>void clear() 从Map中删除所有的映射（可选操作）。<br>V remove(Object key) 如果存在（从可选的操作），从该地图中删除一个键的映射。<br>3、判断功能：<br>boolean containsKey(Object key) 如果此映射包含指定键的映射，则返回 true 。<br>boolean containsValue(Object value) 如果此地图将一个或多个键映射到指定的值，则返回 true 。<br>boolean isEmpty() 如果此地图不包含键值映射，则返回 true 。<br>4、获取功能：<br>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回Map中包含的映射的Set视图。<br>V get(Object key) 返回到指定键所映射的值，或 null如果此映射包含该键的映射。<br>Set keySet() 返回此地图中包含的键的Set视图。<br>Collection values() 返回Map中包含的值的Collection视图。<br>5、长度功能：<br>int size() 返回Map中键值映射的数量。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;String, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    </span><br><span class="line">        hashMap.put(<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;21&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;lisi&quot;</span>,<span class="string">&quot;22&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;wangwu&quot;</span>,<span class="string">&quot;23&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;zhaoliu&quot;</span>,<span class="string">&quot;24&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        System.out.println(hashMap);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        //void clear()</span></span><br><span class="line">        hashMap.clear();</span><br><span class="line">        System.out.println(hashMap);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //V remove(Object key)删除一个键的映射</span></span><br><span class="line">        hashMap.remove(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        System.out.println(hashMap);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        //containsKey(Object key)如果此映射包含指定键的映射，返回true</span></span><br><span class="line">        System.out.println(hashMap.containsKey(<span class="string">&quot;lisi&quot;</span>));</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //boolean isEmpty() 如果不包含键值的映射，返回true</span></span><br><span class="line">        System.out.println(hashMap.isEmpty());</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //int size() 返回Map集合中键值映射的数量</span></span><br><span class="line">        System.out.println(hashMap.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Map集合的获取功能</strong><br>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回Map中包含的映射的Set视图。<br>V get(Object key) 返回到指定键所映射的值，或 null如果此映射包含该键的映射。<br>Set keySet() 返回此地图中包含的键的Set视图。<br>Collection values() 返回Map中包含的值的Collection视图。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        HashMap&lt;String, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;String,String&gt;(); </span><br><span class="line">   <span class="comment">//创建元素并添加</span></span><br><span class="line">    hashMap.put(<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;21&quot;</span>);</span><br><span class="line">    hashMap.put(<span class="string">&quot;lisi&quot;</span>,<span class="string">&quot;22&quot;</span>);</span><br><span class="line">    hashMap.put(<span class="string">&quot;wangwu&quot;</span>,<span class="string">&quot;23&quot;</span>);</span><br><span class="line">    hashMap.put(<span class="string">&quot;zhaoliu&quot;</span>,<span class="string">&quot;24&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//V get(Object key)返回到指定键所映射的值，或null，如果此映射包含该键的映射</span></span><br><span class="line">    System.out.println(hashMap.get(<span class="string">&quot;zhangsan&quot;</span>));<span class="comment">//21</span></span><br><span class="line">    System.out.println(hashMap.get(<span class="string">&quot;lisi&quot;</span>));<span class="comment">//22</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Set&lt;K&gt; KeySet() 返回Map中包含所有键的Set集合</span></span><br><span class="line">    Set&lt;String&gt; strings = hashMap.keySet();</span><br><span class="line">    <span class="keyword">for</span>(String s : strings)&#123;</span><br><span class="line">        System.out.println(s);<span class="comment">//返回了所有的Key</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Collection&lt;V&gt; values() 返回Map中包含的值的Collection集合</span></span><br><span class="line">    Collection&lt;String&gt; values = hashMap.values();</span><br><span class="line">    <span class="keyword">for</span>(String s:values)&#123;</span><br><span class="line">        System.out.println(s);<span class="comment">//返回了所有的Value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><ul><li>基于哈希表的Map接口的实现</li><li>哈希表：用来保证键的唯一性</li><li>HashMap&lt;String,String&gt;<br>键：String<br>值：String</li></ul><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><ul><li>是哈希表和链表实现的Map接口，具有可预知的迭代顺序</li><li>由哈希表保证唯一性</li><li>由链表保证顺序，有序（存储和取出的顺序一致）</li><li>底层也是红黑树（结合红黑树、哈希表，查询速度不慢）</li></ul><h4 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h4><ul><li>HashMap中的键和值允许null，而Hashtable不允许键和值存在null</li><li>HashMap是线程不安全的，但是效率高；Hashtable是线程安全的，效率低</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型以及set集合</title>
      <link href="/2020/09/02/%E6%B3%9B%E5%9E%8B%E4%BB%A5%E5%8F%8Aset%E9%9B%86%E5%90%88/"/>
      <url>/2020/09/02/%E6%B3%9B%E5%9E%8B%E4%BB%A5%E5%8F%8Aset%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="泛型以及set集合"><a href="#泛型以及set集合" class="headerlink" title="泛型以及set集合"></a>泛型以及set集合</h1><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p><strong>泛型的介绍</strong><br>泛型：<br>一种把类型明确的工作推迟到创建对象或者调用方法的时候才去明确的类型。参数化类型，把类型当作参数一样传递</p><p><strong>格式：</strong><br>&lt;数据类型&gt;<br>注意：此处的数据类型只能是引用类型</p><p><strong>泛型的好处</strong></p><ul><li>把运行时期的问题提前到了编译时期</li><li>避免了强制类型转换</li><li>优化程序，消除黄色警告线</li><li>泛型的举例应用</li><li>泛型存储String类型数据举例</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    </span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        list.add(100);直接就报错了</span></span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            String r = iterator.next();</span><br><span class="line">            System.out.println(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//world</span></span><br></pre></td></tr></table></figure><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p><strong>泛型类：把泛型定义在类上</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTool</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getObj</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(T obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericTool genericTool = <span class="keyword">new</span> GenericTool();</span><br><span class="line">        genericTool.setObj(<span class="keyword">new</span> String(<span class="string">&quot;zhangsan&quot;</span>));</span><br><span class="line">        Object obj = genericTool.getObj();</span><br><span class="line">        String obj1 = (String) obj;</span><br><span class="line">        System.out.println(obj1);</span><br><span class="line"></span><br><span class="line">        genericTool.setObj(<span class="keyword">new</span> String(<span class="string">&quot;lisi&quot;</span>));</span><br><span class="line">        Object obj2 = genericTool.getObj();</span><br><span class="line">        String obj21 = (String) obj2;</span><br><span class="line">        System.out.println(obj21);</span><br><span class="line">    </span><br><span class="line">        GenericTool&lt;String&gt; stringGenericTool = <span class="keyword">new</span> GenericTool&lt;String&gt;();</span><br><span class="line">        stringGenericTool.setObj(<span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">        String obj3 = stringGenericTool.getObj();</span><br><span class="line">        System.out.println(obj3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//zhangsan</span></span><br><span class="line"><span class="comment">//lisi</span></span><br><span class="line"><span class="comment">//wangwu</span></span><br></pre></td></tr></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTool2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericTool2 genericTool2 = <span class="keyword">new</span> GenericTool2();</span><br><span class="line">        genericTool2.show(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        genericTool2.show(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        genericTool2.show(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//world</span></span><br><span class="line"><span class="comment">//java</span></span><br></pre></td></tr></table></figure><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericTool3</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTool3Impl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">GenericTool3</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一种情况测试</span></span><br><span class="line">        GenericTool3Impl&lt;String&gt; tool3 = <span class="keyword">new</span> GenericTool3Impl&lt;&gt;();</span><br><span class="line">        tool3.show(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种情况测试</span></span><br><span class="line">        GenericTool3Impl&lt;Integer&gt; tool31 = <span class="keyword">new</span> GenericTool3Impl&lt;&gt;();</span><br><span class="line">        tool31.show(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//100</span></span><br></pre></td></tr></table></figure><h3 id="泛型高级"><a href="#泛型高级" class="headerlink" title="泛型高级"></a>泛型高级</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 泛型高级用法（通配符）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 泛型通配符&lt;?&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 任意类型，如果没有明确，那么就是Object以及任意的Java类了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * ? extends E</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 向下限定，E及其子类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * ? super E</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 向上限定，E及其父类</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo2</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//如果用一个的时候，泛型如果明确了类型的时候，前后必须要写一致</span></span><br><span class="line">       ArrayList&lt;Object&gt; a1 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">   <span class="comment">//        ArrayList&lt;Object&gt; a2 = new ArrayList&lt;Animal&gt;();</span></span><br><span class="line">   <span class="comment">//        ArrayList&lt;Object&gt; a3 = new ArrayList&lt;Dog&gt;();</span></span><br><span class="line">   <span class="comment">//        ArrayList&lt;Object&gt; a4 = new ArrayList&lt;Cat&gt;();</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//型通配符&lt;?&gt;</span></span><br><span class="line">       <span class="comment">//  任意类型，如果没有明确，那么就是Object以及任意的Java类了</span></span><br><span class="line">       <span class="comment">//还没有明确类型</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//        ArrayList&lt;?&gt; list1 = new ArrayList&lt;Object&gt;();</span></span><br><span class="line">   <span class="comment">//        ArrayList&lt;?&gt; list2 = new ArrayList&lt;Dog&gt;();</span></span><br><span class="line">   <span class="comment">//        ArrayList&lt;?&gt; list3 = new ArrayList&lt;Cat&gt;();</span></span><br><span class="line">   <span class="comment">//        ArrayList&lt;?&gt; list4 = new ArrayList&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//? extends E</span></span><br><span class="line">        <span class="comment">//   向下限定，E及其子类</span></span><br><span class="line">        ArrayList&lt;? extends Animal&gt; o1 = <span class="keyword">new</span> ArrayList&lt;Animal&gt;();</span><br><span class="line">        ArrayList&lt;? extends Animal&gt; o2 = <span class="keyword">new</span> ArrayList&lt;Dog&gt;();</span><br><span class="line">        ArrayList&lt;? extends Animal&gt; o3 = <span class="keyword">new</span> ArrayList&lt;Cat&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        ArrayList&lt;? extends Animal&gt; o4 = new ArrayList&lt;Object&gt;();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//? super E</span></span><br><span class="line">        <span class="comment">//  向上限定，E及其父类</span></span><br><span class="line">        ArrayList&lt;? <span class="keyword">super</span> Animal&gt; alist1 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        ArrayList&lt;? super Animal&gt; alist2 = new ArrayList&lt;Dog&gt;();</span></span><br><span class="line"><span class="comment">//        ArrayList&lt;? super Animal&gt; alist3 = new ArrayList&lt;Cat&gt;();</span></span><br><span class="line">        ArrayList&lt;? <span class="keyword">super</span> Animal&gt; alist4 = <span class="keyword">new</span> ArrayList&lt;Animal&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h2><h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><p><strong>Set接口的引入</strong></p><p>Collection接口下有List和Set接口</p><p>List 元素有序（存储顺序和取出顺序一致，可以重复）<br>Set 无序（存储顺序和取出顺序不一致，元素唯一）<br>HashSet：底层是hash表，线程不安全，效率高，有时候，给的顺序正好好存储的顺序一致，但这并不代表有序，可以多试试看，元素唯一，无序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;String&gt; hashSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建字符串对象并添加到集合中</span></span><br><span class="line">        hashSet.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(String s:hashSet)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//world</span></span><br><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="comment">//hello</span></span><br></pre></td></tr></table></figure><h4 id="HashSet类"><a href="#HashSet类" class="headerlink" title="HashSet类"></a><strong>HashSet类</strong></h4><p>HashSet类概述<br>不保证set的迭代顺序<br>特别是不保证该顺序恒久不变</p><p><strong>HashSet如何保证元素的唯一性</strong><br>底层数据结构是哈希表（元素是链表的数组）<br>哈希表依赖于哈希值存储<br>添加功能底层依赖的两个方法<br>int hashCode()<br>boolean equals(Object obj)<br>public static void main(String[] args) {<br>HashSet中add方法的源码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//由哈希表（实际为HashMap实例）支持</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123; <span class="comment">//key -- e -- 要插入的元素</span></span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123; <span class="comment">//key -- e -- 要插入的元素</span></span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//HashSet中的add()方法，最终我们发现调用的是HashMap中的putVal()方法</span></span><br><span class="line">    <span class="comment">//hash的值与元素的HashCode()方法有关</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//哈希表存储的是一个个的节点数组</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//判断哈希表是否初始化，如果没有初始化就进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//根据元素对象的哈希值计算出存储位置，如果该元素的位置是null就代表，该位置没有</span></span><br><span class="line">        <span class="comment">//元素，就创建新的节点，就存储元素</span></span><br><span class="line">        <span class="comment">//通过源码我们发现，HashSet的add()方法一定和HashCode()方法有关系</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                存入的元素和以前的元素的哈希值进行比较</span></span><br><span class="line"><span class="comment">                    如果哈希值不同，继续向下执行，把元素添加到集合</span></span><br><span class="line"><span class="comment">                    如果哈希值一样，会调用对象的equals()方法进行比较</span></span><br><span class="line"><span class="comment">                        如果返回的是false，会继续向下执行，然后将元素添加到集合中</span></span><br><span class="line"><span class="comment">                        如果返回的是true,说明元素内容一样，重复了，就不存储</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p>LinkedHashSet：底层由哈希表和链表组成<br>哈希表保证元素的唯一性<br>链表保证元素的顺序，有序，（存储和取出的顺序一致）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        LinkedHashSet&lt;String&gt; strings = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;();</span><br><span class="line">    </span><br><span class="line">        strings.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        strings.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        strings.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(String s:strings)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//world</span></span><br><span class="line"><span class="comment">//java</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>List集合的练习</title>
      <link href="/2020/09/02/List%E9%9B%86%E5%90%88%E7%9A%84%E7%BB%83%E4%B9%A0/"/>
      <url>/2020/09/02/List%E9%9B%86%E5%90%88%E7%9A%84%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="List集合的练习"><a href="#List集合的练习" class="headerlink" title="List集合的练习"></a>List集合的练习</h1><h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h2><h3 id="List子集的特点"><a href="#List子集的特点" class="headerlink" title="List子集的特点"></a><strong>List子集的特点</strong></h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList:"></a><strong>ArrayList:</strong></h4><ul><li>底层结构是数组，查询快，增删慢</li><li>线程不是安全的，效率高</li></ul><p>ArrayList存储字符串并遍历代码举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList arr = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        arr.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        arr.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        arr.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        Iterator iterator = arr.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Object next = iterator.next();</span><br><span class="line">            String next1 = (String) next;</span><br><span class="line">            System.out.println(next1);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;*************&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.size();i++)&#123;</span><br><span class="line">            Object o = arr.get(i);</span><br><span class="line">            String o1 = (String) o;</span><br><span class="line">            System.out.println(o1);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//world</span></span><br><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="comment">//*************</span></span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//world</span></span><br><span class="line"><span class="comment">//java</span></span><br></pre></td></tr></table></figure><p>ArrayList存储自定义对象并遍历，代码举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    </span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        Student s3 = <span class="keyword">new</span> Student(<span class="string">&quot;王五&quot;</span>, <span class="number">23</span>);</span><br><span class="line">    </span><br><span class="line">        list.add(s1);</span><br><span class="line">        list.add(s2);</span><br><span class="line">        list.add(s3);</span><br><span class="line">    </span><br><span class="line">        Iterator iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Object next = iterator.next();</span><br><span class="line">            Student next1 = (Student) next;</span><br><span class="line">            System.out.println(next1.getName()+<span class="string">&quot;---&quot;</span>+next1.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;****************&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            Object o = list.get(i);</span><br><span class="line">            Student o1 = (Student) o;</span><br><span class="line">            System.out.println(o1.getName()+<span class="string">&quot;---&quot;</span>+o1.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//张三---21</span></span><br><span class="line"><span class="comment">//李四---22</span></span><br><span class="line"><span class="comment">//王五---23</span></span><br><span class="line"><span class="comment">//****************</span></span><br><span class="line"><span class="comment">//张三---21</span></span><br><span class="line"><span class="comment">//李四---22</span></span><br><span class="line"><span class="comment">//王五---23</span></span><br></pre></td></tr></table></figure><h5 id="使用ArrayList去除集合中字符串的重复值（字符串的内容相同）"><a href="#使用ArrayList去除集合中字符串的重复值（字符串的内容相同）" class="headerlink" title="使用ArrayList去除集合中字符串的重复值（字符串的内容相同）"></a>使用ArrayList去除集合中字符串的重复值（字符串的内容相同）</h5><h6 id="方式一：在不同的集合上操作"><a href="#方式一：在不同的集合上操作" class="headerlink" title="方式一：在不同的集合上操作"></a>方式一：在不同的集合上操作</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个集合对象，添加元素</span></span><br><span class="line">    <span class="comment">//创建一个新的集合对象</span></span><br><span class="line">    <span class="comment">//遍历旧的集合对象，获取到每个元素</span></span><br><span class="line">    <span class="comment">//拿新的集合去找，看有没有，没有就加进去，有，就跳过</span></span><br><span class="line">    <span class="comment">//遍历新的集合</span></span><br><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">ArrayList new_list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="comment">//遍历旧的集合</span></span><br><span class="line">Iterator iterator = list.iterator();</span><br><span class="line">System.out.println(<span class="string">&quot;原来的集合：&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    Object next = iterator.next();</span><br><span class="line">    String next1 = (String) next;</span><br><span class="line">    System.out.println(next1);</span><br><span class="line">    <span class="keyword">if</span>(!new_list.contains(next1))&#123;</span><br><span class="line">        new_list.add(next1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;去除集合中字符串的重复值之后的集合：&quot;</span>);</span><br><span class="line"><span class="comment">//遍历新的集合</span></span><br><span class="line">Iterator iterator1 = new_list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator1.hasNext())&#123;</span><br><span class="line">    Object next = iterator1.next();</span><br><span class="line">    String next1 = (String) next;</span><br><span class="line"></span><br><span class="line">    System.out.println(next1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="方式二：在同一个集合上操作"><a href="#方式二：在同一个集合上操作" class="headerlink" title="方式二：在同一个集合上操作"></a>方式二：在同一个集合上操作</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;spark&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;spark&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//利用选择排序的思想</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;list.size();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(list.get(i).equals(list.get(j)))&#123;</span><br><span class="line">                    list.remove(j);</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        Iterator iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Object next = iterator.next();</span><br><span class="line">            String next1 = (String) next;</span><br><span class="line">            System.out.println(next1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//world</span></span><br><span class="line"><span class="comment">//spark</span></span><br></pre></td></tr></table></figure><h5 id="使用ArrayList去除自定义类中的重复值"><a href="#使用ArrayList去除自定义类中的重复值" class="headerlink" title="使用ArrayList去除自定义类中的重复值"></a>使用ArrayList去除自定义类中的重复值</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    Student()&#123;&#125;</span><br><span class="line">    Student(String name,<span class="keyword">int</span> age)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListDemo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    </span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>,<span class="number">21</span>);</span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;李四&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        Student s3 = <span class="keyword">new</span> Student(<span class="string">&quot;王五&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        Student s4 = <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>,<span class="number">21</span>);</span><br><span class="line">    </span><br><span class="line">        list.add(s1);</span><br><span class="line">        list.add(s2);</span><br><span class="line">        list.add(s3);</span><br><span class="line">        list.add(s4);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//创建新的集合</span></span><br><span class="line">        ArrayList list1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    </span><br><span class="line">        Iterator iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Object next = iterator.next();</span><br><span class="line">            Student next1 = (Student) next;</span><br><span class="line">            <span class="keyword">if</span>(!list1.contains(next1))&#123;</span><br><span class="line">                list1.add(next1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        Iterator iterator1 = list1.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator1.hasNext())&#123;</span><br><span class="line">            Object next = iterator1.next();</span><br><span class="line">            Student next1 = (Student) next;</span><br><span class="line">            System.out.println(next1.getName()+<span class="string">&quot;---&quot;</span>+next1.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//张三---21</span></span><br><span class="line"><span class="comment">//李四---22</span></span><br><span class="line"><span class="comment">//王五---23</span></span><br><span class="line"><span class="comment">//张三---21</span></span><br></pre></td></tr></table></figure><p>但这里我们发现一个问题，我们按照规定的思维，发现并没有去除重复的元素<br>通过查看源码我们发现，contain()的方法底层依赖的是equals()方法，由于我们的Student1类中并没有重写equals()方法，所以它默认调用的是父亲Object的equals()方法，而父亲的equals()方法比较的是地址值，每个学生对象被new出来的时候，地址值是一定不同的，所以比较地址值都是true，所以结果没有生效。</p><p>解决办法：<br>   重写equals方法，不需要我们重写，自动生效即可<br>建议：<br>   每次创建类的时候，都重写一些equals方法</p><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p><strong>LinkedList集合</strong></p><ul><li>底层结构是链表，查询慢，增删快</li><li>线程是不安全的，效率高</li></ul><p><strong>LinkedList的特有功能</strong></p><ul><li>添加功能<ul><li>void addFirst(E e) 在该列表开头插入指定元素</li><li>void addLast(E e) 将指定的元素追加到此列表的末尾</li></ul></li><li>获取参数<ul><li>E getFirst() 返回此列表中的第一个元素</li><li>E getLast() 返回此列表中的最后一个元素</li></ul></li><li>删除功能<ul><li>E removeFirst() 从此列表中删除并返回第一个元素</li><li>E removeLast() 从此列表中删除并返回最后一个元素</li></ul></li></ul><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p><strong>Vector</strong></p><ul><li>底层结构是数组，查询快，增删慢</li><li>线程是安全的，效率低</li></ul><p><strong>Vector的特有功能</strong></p><ul><li><p>添加功能</p><ul><li>void addElement(Object object)将指定组件添加到此向量的末尾，将其大小增加1</li></ul></li><li><p>获取功能</p><ul><li>Object elementAt(int index) 返回指定索引处的元素 –get()</li><li>Enumeration elements() 返回此向量的组件的容器。–list.iterator()</li><li>boolean hasMoreElements() 测试此容器是否包含更多元素。 –hasNext()</li><li>E nextElement() 如果此容器对象至少有一个要提供的元素，则返回此容器的下一个元素。–next()</li></ul></li></ul><p>代码举例:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Vector vector = <span class="keyword">new</span> Vector();</span><br><span class="line">        vector.addElement(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        vector.addElement(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        vector.addElement(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        Enumeration elements = vector.elements();</span><br><span class="line">        <span class="keyword">while</span> (elements.hasMoreElements())&#123;</span><br><span class="line">            Object o = elements.nextElement();</span><br><span class="line">            String o1 = (String) o;</span><br><span class="line">            System.out.println(o1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//world</span></span><br><span class="line"><span class="comment">//java</span></span><br></pre></td></tr></table></figure><h4 id="List子类面试题（List子类的特点）"><a href="#List子类面试题（List子类的特点）" class="headerlink" title="List子类面试题（List子类的特点）"></a>List子类面试题（List子类的特点）</h4><p><strong>ArrayList：</strong><br>底层是数组，查询快，增删慢<br>线程不是安全的，效率高<br><strong>Vector：</strong><br>底层结构是数组，查询快，增删慢<br>线程是安全的，效率低<br><strong>LinkedList：</strong><br>底层结构是链表，查询慢，增删块<br>线程不是安全的，效率高<br>实际应用的时候，看实际需求：<br>需要线程安全：<br><strong>Vector</strong><br>不需要：ArrayList、Linkedlist<br>查询业务比较多：ArrayList<br>增删业务比较多：LinkedList<br>不知道选什么：ArrayList</p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合以及迭代器</title>
      <link href="/2020/09/02/%E9%9B%86%E5%90%88%E4%BB%A5%E5%8F%8A%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
      <url>/2020/09/02/%E9%9B%86%E5%90%88%E4%BB%A5%E5%8F%8A%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="集合以及迭代器"><a href="#集合以及迭代器" class="headerlink" title="集合以及迭代器"></a>集合以及迭代器</h1><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="集合的概述"><a href="#集合的概述" class="headerlink" title="集合的概述"></a>集合的概述</h3><p><strong>我们为什么要用集合</strong></p><p>我们所学的Java，是一门面向对象的语言，面向对象是基于描述现实事物而存在的，一旦我们所用的数据多了起来，我们就必须要对这些对象进行存储，我们存储之后，就不能是定义一个遍历了，我们需要一个类似于数组这样的容器来进行存储。<br>到现在为止，已经记录了数组、StringBuffer。但都有一些弊端，StringBuffer的结果是一个字符串，我们在显示业务中，大多数都是以对象的形式进行存储，这样的话，StringBuffer就不满足了，只能选择数组，而数组存储的是对象引用，这样的对象称之为对象数组。<br>对象数组也不能满足我们一些业务需求的变化，因为数组的长度唯一，这时，为了适应变化，Java提供了一个技术来解决这样的问题，也就是：集合。</p><h4 id="数组和集合的区别"><a href="#数组和集合的区别" class="headerlink" title="数组和集合的区别"></a>数组和集合的区别</h4><ul><li>长度：<br>数组的长度唯一<br>集合的长度不唯一、可变、弹性</li><li>内容不同：<br>数组存储的元素类型是一致的、统一的<br>集合可以存储不同类型的元素</li><li>元素的数据类型：<br>数组可以存储基本数据类型，也可以存储引用数据类型<br>集合只能存储引用数据类型</li></ul><p>有关集合的一个小图<br>我们可以看到Collection、List都是接口，下面的Arraylist、LinkedList才是实现类</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904135730.png"></p><h3 id="Connection集合"><a href="#Connection集合" class="headerlink" title="Connection集合"></a>Connection集合</h3><p>是所有集合的顶层接口，存在着一些可以重复元素的集合，一些不可以重复元素的集合，有些有序，有些无序</p><h4 id="添加功能"><a href="#添加功能" class="headerlink" title="添加功能"></a>添加功能</h4><ul><li>boolean add(E e) 确保此集合包含指定的元素（可选操作）。</li><li>boolean addAll(Collection&lt;? extends E&gt; c) 将指定集合中的所有元素添加到此集合（可选操作）</li></ul><p><strong>boolean add(E e) ：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接口不能被实例化</span></span><br><span class="line"><span class="comment">//        List list = new List();</span></span><br><span class="line">        Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//boolean add(E e)  确保此集合包含指定的元素（可选操作）</span></span><br><span class="line">    c.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">     c.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    System.out.println(c);<span class="comment">//[hello, world]</span></span><br></pre></td></tr></table></figure><p><strong>boolean addAll(Collection&lt;? extends E&gt; c)</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="comment">//boolean add(E e)  确保此集合包含指定的元素（可选操作）</span></span><br><span class="line">c.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">System.out.println(c);<span class="comment">//[hello, world]</span></span><br><span class="line"></span><br><span class="line">Collection c1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">c1.addAll(c);</span><br><span class="line">System.out.println(c1);<span class="comment">//[hello, world]</span></span><br></pre></td></tr></table></figure><h4 id="删除功能"><a href="#删除功能" class="headerlink" title="删除功能"></a>删除功能</h4><p>void clear() 从此集合中删除所有元素（可选操作）。</p><p>boolean remove(Object o) 从该集合中删除指定元素的单个实例（如果存在）（可选操作）。</p><p>boolean removeAll(Collection&lt;?&gt; c) 删除指定集合中包含的所有此集合的元素（可选操作）。</p><p><strong>void clear()</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        <span class="comment">//接口不能被实例化</span></span><br><span class="line"><span class="comment">//        List list = new List();</span></span><br><span class="line">        Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//boolean add(E e)  确保此集合包含指定的元素（可选操作）</span></span><br><span class="line">        c.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        System.out.println(c);<span class="comment">//[hello, world]</span></span><br><span class="line"></span><br><span class="line">        c.clear();</span><br><span class="line">        System.out.println(c);<span class="comment">//[]</span></span><br></pre></td></tr></table></figure><p><strong>boolean remove(Object o)</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">       <span class="comment">//接口不能被实例化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        List list = new List();</span></span><br><span class="line">        Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//boolean add(E e)  确保此集合包含指定的元素（可选操作）</span></span><br><span class="line">        c.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        System.out.println(c);<span class="comment">//[hello, world]</span></span><br><span class="line">    </span><br><span class="line">        c.remove(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(c);<span class="comment">//[world]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//只删除了hello</span></span><br></pre></td></tr></table></figure><p><strong>boolean removeAll(Collection&lt;?&gt; c)</strong><br>只删除包含该集合的元素：<br>c中只删除了c1中和它重复的元素</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//接口不能被实例化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        List list = new List();</span></span><br><span class="line">        Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        Collection c1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="comment">//boolean add(E e)  确保此集合包含指定的元素（可选操作）</span></span><br><span class="line">        c.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        System.out.println(c);<span class="comment">//[hello, world]</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;**********删除之后*************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        c1.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        c.removeAll(c1);</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[hello, world, java]</span></span><br><span class="line"><span class="comment">//**********删除之后*************</span></span><br><span class="line"><span class="comment">//[world, java]</span></span><br></pre></td></tr></table></figure><h4 id="判断功能"><a href="#判断功能" class="headerlink" title="判断功能"></a>判断功能</h4><p>boolean contains(Object o) 如果此集合包含指定的元素，则返回 true 。<br>boolean containsAll(Collection&lt;?&gt; c) 如果此集合包含指定 集合中的所有元素，则返回true。<br>boolean isEmpty() 如果此集合不包含元素，则返回 true 。</p><p><strong>boolean contains(Object o)</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//接口不能被实例化</span></span><br><span class="line"><span class="comment">//        List list = new List();</span></span><br><span class="line">        Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        Collection c1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="comment">//boolean add(E e)  确保此集合包含指定的元素（可选操作）</span></span><br><span class="line">        c.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        System.out.println(c);<span class="comment">//[hello, world]</span></span><br><span class="line"></span><br><span class="line">    System.out.println(c.contains(<span class="string">&quot;hello&quot;</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><strong>boolean containsAll</strong><br>c中包含了c1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">Collection c1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="comment">//boolean add(E e)  确保此集合包含指定的元素（可选操作）</span></span><br><span class="line">c.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">System.out.println(c);<span class="comment">//[hello, world]</span></span><br><span class="line"></span><br><span class="line">c1.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(c.containsAll(c1));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><strong>boolean isEmpty()</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">   Collection c1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">   <span class="comment">//boolean add(E e)  确保此集合包含指定的元素（可选操作）</span></span><br><span class="line">   c.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">   c.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">   c.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">   System.out.println(c);<span class="comment">//[hello, world]</span></span><br><span class="line">System.out.println(c.isEmpty());<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">c.clear();</span><br><span class="line"></span><br><span class="line">System.out.println(c.isEmpty());<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h4><p>按照顺序一个一个取出元素，Object[] toArray()把集合转化成数组，可以实现集合的遍历<br>注意：遍历集合中的元素，里面的元素获取到之后需要向下转型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection c = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        c.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        <span class="comment">//将集合转换成数组</span></span><br><span class="line">        Object[] objects = c.toArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;objects.length;i++)&#123;</span><br><span class="line">            <span class="comment">//输出的内容是String类型，但是上面的objects是Object类型，需要向下转型</span></span><br><span class="line">            String objects1 = (String) objects[i];</span><br><span class="line">            System.out.println(objects1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//world</span></span><br><span class="line"><span class="comment">//java</span></span><br></pre></td></tr></table></figure><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>Iterator iterator() 迭代器，集合的专用遍历方式<br>两个方法：</p><ul><li>boolean hasNext() 如果迭代具有更多的元素，就返回true</li><li>E next() 返回迭代中的下一个元素，获取元素<br>NoSuchElementException - 如果迭代没有更多的元素，报这个错</li></ul><p><strong>迭代器遍历</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        c.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        Iterator iterator = c.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Object next = iterator.next();</span><br><span class="line">            String next1 = (String) next;</span><br><span class="line">            System.out.println(next1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//world</span></span><br><span class="line"><span class="comment">//java</span></span><br></pre></td></tr></table></figure><p><strong>使用迭代器遍历集合中的元素</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        Student1 s1 = <span class="keyword">new</span> Student1(<span class="string">&quot;张三&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        Student1 s2 = <span class="keyword">new</span> Student1(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">        c.add(s1);</span><br><span class="line">        c.add(s2);</span><br><span class="line">    </span><br><span class="line">        Iterator iterator = c.iterator();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Object next = iterator.next();</span><br><span class="line">            Student1 next1 = (Student1) next;</span><br><span class="line">            System.out.println(next1.getName()+<span class="string">&quot;---&quot;</span>+next1.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//张三---21</span></span><br><span class="line"><span class="comment">//李四---22</span></span><br></pre></td></tr></table></figure><p><strong>使用迭代器遍历字符串中的元素</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        c.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Iterator iterator = c.iterator();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Object next = iterator.next();</span><br><span class="line">            String next1 = (String) next;</span><br><span class="line">            System.out.println(next1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//world</span></span><br><span class="line"><span class="comment">//java</span></span><br></pre></td></tr></table></figure><p>有关使用迭代器的一个小思考</p><p>我们可以看到，迭代器是遍历集合的一种方式，那为什么我们不把迭代器直接定义为一个类呢，这样直接用的话不是方便很多吗，为什么迭代器是一个接口呢。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904150535.png"></p><p><strong>迭代器源码</strong><br>我们看到这里面，Collection和List一个继承于Iterable，一个继承于Collection，里面都有一个Iterator()方法，该方法时实现了Iterator接口，Iterator接口中有迭代器的hasNext()和next()方法，最后时Arraylist类中的Itr实现了迭代器的两个方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function">Object <span class="title">next</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span></span>&#123;</span><br><span class="line">    <span class="function">Iterator <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span> <span class="keyword">extends</span> <span class="title">Iterable</span></span>&#123;</span><br><span class="line">    <span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span> <span class="keyword">extends</span> <span class="title">Collection</span></span>&#123;</span><br><span class="line">    <span class="function">Iterator <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> <span class="keyword">implements</span> <span class="title">List</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h3><p>特点：有序集合（存储和取出的顺序一致），可以有重复元素</p><p><strong>List集合中字符串的遍历</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        Iterator iterator = list.iterator();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Object next = iterator.next();</span><br><span class="line">            String next1 = (String) next;</span><br><span class="line">            System.out.println(next1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//world</span></span><br><span class="line"><span class="comment">//java</span></span><br></pre></td></tr></table></figure><p><strong>存储自定义对象并遍历</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        Student1 s1 = <span class="keyword">new</span> Student1(<span class="string">&quot;张三&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        Student1 s2 = <span class="keyword">new</span> Student1(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>);</span><br><span class="line">    </span><br><span class="line">        list.add(s1);</span><br><span class="line">        list.add(s2);</span><br><span class="line">    </span><br><span class="line">        Iterator iterator = list.iterator();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Object next = iterator.next();</span><br><span class="line">            Student1 next1 = (Student1) next;</span><br><span class="line">            System.out.println(next1.getName()+<span class="string">&quot;---&quot;</span>+next1.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//张三---21</span></span><br><span class="line"><span class="comment">//李四---22</span></span><br></pre></td></tr></table></figure><h4 id="List集合添加功能"><a href="#List集合添加功能" class="headerlink" title="List集合添加功能"></a>List集合添加功能</h4><p>void add(int index, E element) 将指定的元素插入此列表中的指定位置（可选操作）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        System.out.println(list);<span class="comment">//[hello, world, java]</span></span><br><span class="line">        list.add(<span class="number">1</span>,<span class="string">&quot;hadoop&quot;</span>);</span><br><span class="line">        System.out.println(list);<span class="comment">//[hello, hadoop, world, java]</span></span><br></pre></td></tr></table></figure><h4 id="List集合获取功能"><a href="#List集合获取功能" class="headerlink" title="List集合获取功能"></a>List集合获取功能</h4><p>E get(int index) 返回此列表中指定位置的元素。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        System.out.println(list);<span class="comment">//[hello, world, java]</span></span><br><span class="line">        list.add(<span class="number">1</span>,<span class="string">&quot;hadoop&quot;</span>);</span><br><span class="line">        System.out.println(list);<span class="comment">//[hello, hadoop, world, java]</span></span><br><span class="line"></span><br><span class="line">        System.out.println(list.get(<span class="number">1</span>));<span class="comment">//hadoop</span></span><br></pre></td></tr></table></figure><h4 id="删除功能-1"><a href="#删除功能-1" class="headerlink" title="删除功能"></a>删除功能</h4><p>E remove(int index) 删除该列表中指定位置的元素（可选操作）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        System.out.println(list);<span class="comment">//[hello, world, java]</span></span><br><span class="line">        list.add(<span class="number">1</span>,<span class="string">&quot;hadoop&quot;</span>);</span><br><span class="line">        System.out.println(list);<span class="comment">//[hello, hadoop, world, java]</span></span><br><span class="line"></span><br><span class="line">    System.out.println(list.get(<span class="number">1</span>));<span class="comment">//hadoop</span></span><br><span class="line">    System.out.println(list.remove(<span class="number">1</span>));<span class="comment">//hadoop</span></span><br></pre></td></tr></table></figure><h4 id="修改功能"><a href="#修改功能" class="headerlink" title="修改功能"></a>修改功能</h4><p>E set(int index, E element) 用指定的元素（可选操作）替换此列表中指定位置的元素</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        System.out.println(list);<span class="comment">//[hello, world, java]</span></span><br><span class="line">        list.add(<span class="number">1</span>,<span class="string">&quot;hadoop&quot;</span>);</span><br><span class="line">        System.out.println(list);<span class="comment">//[hello, hadoop, world, java]</span></span><br><span class="line"></span><br><span class="line">    System.out.println(list.get(<span class="number">1</span>));<span class="comment">//hadoop</span></span><br><span class="line">    System.out.println(list.remove(<span class="number">1</span>));<span class="comment">//hadoop</span></span><br><span class="line">    System.out.println(list);<span class="comment">//[hello,world,java]</span></span><br><span class="line"></span><br><span class="line">    list.set(<span class="number">1</span>,<span class="string">&quot;hadoop&quot;</span>);</span><br><span class="line">    System.out.println(list);<span class="comment">//[hello,hadoop,java]</span></span><br></pre></td></tr></table></figure><p><strong>列表迭代器</strong><br>ListIterator listIterator() 返回列表中的列表迭代器（按适当的顺序）。<br>是List特有的迭代器，该迭代器继承了Iterator，所以也有hasNext和next方法<br>List是继承自Collection，有父类的功能，也有自己的特有功能：<br>E previous() 返回列表中的上一个元素，并向后移动光标位置。<br>boolean hasPrevious() 返回 true如果遍历反向列表，列表迭代器有多个元素。<br>注意：如果想要逆序遍历，必须先正序遍历一次，才能逆序遍历，一般情况下无意义，一般不使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        ListIterator listIterator = list.listIterator();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> (listIterator.hasNext())&#123;</span><br><span class="line">            Object next = listIterator.next();</span><br><span class="line">            String next1 = (String) next;</span><br><span class="line">            System.out.println(next1);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;*********************&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(listIterator.hasPrevious())&#123;</span><br><span class="line">            Object previous = listIterator.previous();</span><br><span class="line">            String previous1 = (String) previous;</span><br><span class="line">            System.out.println(previous1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//world</span></span><br><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="comment">//*********************</span></span><br><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="comment">//world</span></span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line">特有功能：get、size</span><br><span class="line"> List list = <span class="keyword">new</span> ArrayList();</span><br></pre></td></tr></table></figure><p><strong>并发修改异常</strong><br>我们现在有一个问题，我们打算判断集合中有没有“world”这个元素，如果有的话，我们就添加一个”hadoop”<br>ConcurrentModificationException:并发修改异常。当方法里面检测到对象的并发修改的时候但是，这里不允许修改时，就会抛出这种异常<br>为什么会出现这种异常呢？<br>迭代器是依赖于集合存在的，在判断成功之后，集合中添加了新的元素，但是迭代器不知道，所以就报错了，这就是并发修改异常。<br>也就是说，迭代器遍历元素的时候，集合是不能修改元素的</p><p>怎么解决呢<br>1、迭代器遍历元素，迭代器修改元素<br>添加的元素紧跟在刚刚迭代到的元素后面<br>2、集合遍历元素，集合修改元素<br>添加的元素在最后一个</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">            list.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Iterator iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        Object next = iterator.next();</span><br><span class="line">        String next1 = (String) next;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;world&quot;</span>.equals(next1))&#123;</span><br><span class="line">            list.add(<span class="string">&quot;hadoop&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这就会出现并发修改异常ConcurrentModificationException</span></span><br><span class="line">或者这种情况也会出现并发修改异常（正确的代码里面，Iterator it = c.iterator() 应该放到c.add()后面，放到前面的话，就意味着先有了迭代器，之后再去修改数组，也会出现并发修改异常，也就是迭代器和数组不是同时被改变）</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    Student1 s1 = <span class="keyword">new</span> Student1(<span class="string">&quot;张三&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    Student1 s2 = <span class="keyword">new</span> Student1(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>);</span><br><span class="line">    Student1 s3 = <span class="keyword">new</span> Student1(<span class="string">&quot;王五&quot;</span>, <span class="number">23</span>);</span><br><span class="line">    Student1 s4 = <span class="keyword">new</span> Student1(<span class="string">&quot;赵六&quot;</span>, <span class="number">24</span>);</span><br><span class="line">    Student1 s5 = <span class="keyword">new</span> Student1(<span class="string">&quot;张三&quot;</span>, <span class="number">28</span>);</span><br><span class="line"></span><br><span class="line">    Iterator it = c.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将Student类对象添加进集合中</span></span><br><span class="line">    c.add(s2);</span><br><span class="line">    c.add(s3);</span><br><span class="line">    c.add(s4);</span><br><span class="line">    c.add(s5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        Object next = it.next();</span><br><span class="line">        Student1 s = (Student1) next;</span><br><span class="line">        System.out.println(s.getName() + <span class="string">&quot;---&quot;</span> + s.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并发修改异常的解决办法"><a href="#并发修改异常的解决办法" class="headerlink" title="并发修改异常的解决办法"></a>并发修改异常的解决办法</h3><p><strong>使用集合遍历元素，集合修改元素<br>使用迭代器遍历元素，迭代器修改元素</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//迭代器遍历元素，迭代器修改元素</span></span><br><span class="line">         List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        ListIterator listIterator = list.listIterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            Object o = list.get(i);</span><br><span class="line">            String o1 = (String) o;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;world&quot;</span>.equals(o1))&#123;</span><br><span class="line">                list.add(<span class="string">&quot;hadoop&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里在使用的时候，要注意重新创建一个新的迭代器，原来修改的数据依旧在list中，需要一个新的迭代器来输出。</span></span><br><span class="line">        ListIterator listIterator1 = list.listIterator();</span><br><span class="line">        <span class="keyword">while</span> (listIterator1.hasNext())&#123;</span><br><span class="line">            Object next = listIterator1.next();</span><br><span class="line">            String next1 = (String) next;</span><br><span class="line">            System.out.println(next1);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String类以及StringBuffer类</title>
      <link href="/2020/09/02/String%E7%B1%BB%E4%BB%A5%E5%8F%8AStringBuffer%E7%B1%BB/"/>
      <url>/2020/09/02/String%E7%B1%BB%E4%BB%A5%E5%8F%8AStringBuffer%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="String类以及StringBuffer类"><a href="#String类以及StringBuffer类" class="headerlink" title="String类以及StringBuffer类"></a>String类以及StringBuffer类</h1><h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><ul><li>String类的转换功能<ul><li>byte[] getBytes()</li><li>char[] toCharArray()</li><li>static String valueOf(char[] chs)</li><li>static String valueOf(int i)</li><li>String toLowerCase()</li><li>String toUpperCase()</li><li>String toUpperCase()</li><li>String concat(String str)</li></ul></li></ul><p>例如:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo10</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将字符串转换为字节数组</span></span><br><span class="line">        <span class="comment">//byte[] getBytes()</span></span><br><span class="line">        String s = <span class="string">&quot;BigData&quot;</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = s.getBytes();</span><br><span class="line">        System.out.println(bytes);<span class="comment">//打印的只是地址，想要打印内容，需要遍历出来</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bytes.length;i++)&#123;</span><br><span class="line">            System.out.println(bytes[i]);<span class="comment">//打印出来的是ASCII码</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;****************************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将字符串转换为字符数组</span></span><br><span class="line">        <span class="comment">//char[] toCharArray()</span></span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        System.out.println(chars);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;chars.length;i++)&#123;</span><br><span class="line">            System.out.println(chars[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;****************************************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//将字符数组转换为字符串</span></span><br><span class="line">        <span class="comment">//static String valueOf(char[] chs)</span></span><br><span class="line">        String s1 = String.valueOf(chars);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(<span class="string">&quot;****************************************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//将int类型的数据转换成字符串</span></span><br><span class="line">        <span class="comment">//static String valueOf(int i)</span></span><br><span class="line">        String s2 = String.valueOf(<span class="number">100</span>);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(<span class="string">&quot;****************************************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//将字符串中的字符都转成小写</span></span><br><span class="line">        String s3 = s.toLowerCase();</span><br><span class="line">        System.out.println(s3);</span><br><span class="line">        System.out.println(<span class="string">&quot;****************************************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//将字符串中的字符都转成大写</span></span><br><span class="line">        String s4 = s.toUpperCase();</span><br><span class="line">        System.out.println(s4);</span><br><span class="line">        System.out.println(<span class="string">&quot;****************************************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//拼接字符串</span></span><br><span class="line">        <span class="comment">//String concat(String str)</span></span><br><span class="line">        String s5 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        String s6 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        String s7 = s5 + s6;</span><br><span class="line">        String s8 = s5.concat(s6);</span><br><span class="line">        System.out.println(<span class="string">&quot;s5:&quot;</span>+s5);</span><br><span class="line">        System.out.println(<span class="string">&quot;s6:&quot;</span>+s6);</span><br><span class="line">        System.out.println(<span class="string">&quot;s7:&quot;</span>+s7);</span><br><span class="line">        System.out.println(<span class="string">&quot;s8:&quot;</span>+s8);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[B@28d93b30</span></span><br><span class="line"><span class="comment">//66</span></span><br><span class="line"><span class="comment">//105</span></span><br><span class="line"><span class="comment">//103</span></span><br><span class="line"><span class="comment">//68</span></span><br><span class="line"><span class="comment">//97</span></span><br><span class="line"><span class="comment">//116</span></span><br><span class="line"><span class="comment">//97</span></span><br><span class="line"><span class="comment">//****************************************</span></span><br><span class="line"><span class="comment">//BigData</span></span><br><span class="line"><span class="comment">//B</span></span><br><span class="line"><span class="comment">//i</span></span><br><span class="line"><span class="comment">//g</span></span><br><span class="line"><span class="comment">//D</span></span><br><span class="line"><span class="comment">//a</span></span><br><span class="line"><span class="comment">//t</span></span><br><span class="line"><span class="comment">//a</span></span><br><span class="line"><span class="comment">//****************************************</span></span><br><span class="line"><span class="comment">//BigData</span></span><br><span class="line"><span class="comment">//****************************************</span></span><br><span class="line"><span class="comment">//100</span></span><br><span class="line"><span class="comment">//****************************************</span></span><br><span class="line"><span class="comment">//bigdata</span></span><br><span class="line"><span class="comment">//****************************************</span></span><br><span class="line"><span class="comment">//BIGDATA</span></span><br><span class="line"><span class="comment">//****************************************</span></span><br><span class="line"><span class="comment">//s5:hello</span></span><br><span class="line"><span class="comment">//s6:world</span></span><br><span class="line"><span class="comment">//s7:helloworld</span></span><br><span class="line"><span class="comment">//s8:helloworld</span></span><br></pre></td></tr></table></figure><h3 id="String类的其他功能"><a href="#String类的其他功能" class="headerlink" title="String类的其他功能"></a>String类的其他功能</h3><h4 id="替换功能"><a href="#替换功能" class="headerlink" title="替换功能"></a>替换功能</h4><ul><li>String replace(char old,char new)</li><li>String replace(String old,String new)</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line">        String replace = s.replace(<span class="string">&quot;l&quot;</span>, <span class="string">&quot;m&quot;</span>);</span><br><span class="line">        System.out.println(replace);<span class="comment">//HemmoWormd</span></span><br><span class="line">        String replace1 = s.replace(<span class="string">&quot;llo&quot;</span>, <span class="string">&quot;ppl&quot;</span>);</span><br><span class="line">        System.out.println(replace1);<span class="comment">//HepplWorld</span></span><br></pre></td></tr></table></figure><h4 id="去除字符串两空格"><a href="#去除字符串两空格" class="headerlink" title="去除字符串两空格"></a>去除字符串两空格</h4><ul><li>String trim()</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;  HelloWorld   &quot;</span>;</span><br><span class="line">        String trim = s1.trim();</span><br><span class="line">        System.out.println(trim);<span class="comment">//HelloWorld</span></span><br></pre></td></tr></table></figure><h4 id="按字典顺序比较两个字符串"><a href="#按字典顺序比较两个字符串" class="headerlink" title="按字典顺序比较两个字符串"></a>按字典顺序比较两个字符串</h4><ul><li>int compareTo(String str)</li><li>int compareToIgnoreCase(String str)</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s5 = <span class="string">&quot;hello&quot;</span>;<span class="comment">//h的ASCII码104</span></span><br><span class="line">        String s6 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        String s7 = <span class="string">&quot;abc&quot;</span>;<span class="comment">//a的ASCII码97</span></span><br><span class="line">        String s8 = <span class="string">&quot;qwe&quot;</span>;<span class="comment">//q的ASCII码113</span></span><br><span class="line">        String s9 = <span class="string">&quot;hel&quot;</span>;</span><br><span class="line">        System.out.println(s5.compareTo(s6));   <span class="comment">//两个相等，相减为0</span></span><br><span class="line">        System.out.println(s5.compareTo(s7));   <span class="comment">//h的ASCII码和a的ASCII码两个相减，结果是7</span></span><br><span class="line">        System.out.println(s5.compareTo(s8));   <span class="comment">//h的ASCII码和q的ASCII码两个相减，结果是-9</span></span><br><span class="line">        System.out.println(s5.compareTo(s9));   <span class="comment">//前面的都比较完了，剩下几个字符，结果就是几</span></span><br></pre></td></tr></table></figure><h4 id="统计大串中小串出现的次数"><a href="#统计大串中小串出现的次数" class="headerlink" title="统计大串中小串出现的次数"></a>统计大串中小串出现的次数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入大串&quot;</span>);</span><br><span class="line">        String maxString = sc.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入小串&quot;</span>);</span><br><span class="line">        String minString = sc.next();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = findString(maxString,minString);</span><br><span class="line">    System.out.println(<span class="string">&quot;大串中小串出现的次数为：&quot;</span>+result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findString</span><span class="params">(String maxString,String minString)</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义出现的次数</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//大串中小串的位置</span></span><br><span class="line">    <span class="keyword">int</span> index = maxString.indexOf(minString);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(index == -<span class="number">1</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;大串中没有这个小串&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (index != -<span class="number">1</span>)&#123;</span><br><span class="line">        count ++;</span><br><span class="line">        <span class="comment">//被截取的长度</span></span><br><span class="line">        <span class="keyword">int</span> startindex = index + minString.length();</span><br><span class="line">        maxString = maxString.substring(startindex);</span><br><span class="line">        index = maxString.indexOf(minString);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h2><h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><h4 id="StringBuffer："><a href="#StringBuffer：" class="headerlink" title="StringBuffer："></a>StringBuffer：</h4><p>线程安全，可变的字符序列。字符串缓冲区就像一个String，但可以修改<br>在任何时间点，它包含一些特定的字符序列<br>但可以通过某些方法调用来更改序列的长度和内容<br>简单来说：就是一个线程安全的可变字符串</p><h4 id="StringBuffer和String的区别"><a href="#StringBuffer和String的区别" class="headerlink" title="StringBuffer和String的区别"></a>StringBuffer和String的区别</h4><p>前者长度和内容都可以改变，后者不可改变<br>前者可以提前给出缓冲区，可以进行字符串拼接不会重新开辟空间；后者会开辟新的空间，会浪费太多资源</p><h4 id="StringBuffer的构造方法"><a href="#StringBuffer的构造方法" class="headerlink" title="StringBuffer的构造方法"></a>StringBuffer的构造方法</h4><p>public StringBuffer()<br>public StringBuffer(int capacity)<br>public StringBuffer(String str)</p><h4 id="StringBuffer的方法"><a href="#StringBuffer的方法" class="headerlink" title="StringBuffer的方法"></a>StringBuffer的方法</h4><p>public int capacity()返回当前容量（容量是新插入字符可用的存储量，超过此值将进行重新分配）<br>public int length()返回长度（字符数）</p><h4 id="线程安全简单描述："><a href="#线程安全简单描述：" class="headerlink" title="线程安全简单描述："></a>线程安全简单描述：</h4><p>线程是安全的；安全，代表着有同步存在，数据是安全的，效率不高<br>不安全，不同步，效率高<br>安全问题和效率问题，一直都是一个矛盾点<br>安全：售票、取号、银行业务（都是一个一个进行的）<br>效率：论坛（可以同步进行的）</p><h3 id="StringBuffer类的成员方法"><a href="#StringBuffer类的成员方法" class="headerlink" title="StringBuffer类的成员方法"></a>StringBuffer类的成员方法</h3><h4 id="添加功能"><a href="#添加功能" class="headerlink" title="添加功能"></a>添加功能</h4><ul><li><strong>public StringBuffer append(String str)</strong><br>可以把任意类型的数据添加到字符串缓冲区中，并且返回的是字符串缓冲区本身</li><li><strong>public StringBuffer insert(int offset,String str)</strong><br>在指定位置插入数据到字符串缓冲区</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        StringBuffer sb2 = sb.append(<span class="string">&quot;hello&quot;</span>);<span class="comment">//append将任意类型数据添加到字符串缓冲区，返回的是字符串缓冲区本身</span></span><br><span class="line"></span><br><span class="line">        System.out.println(sb);</span><br><span class="line">        System.out.println(sb2);</span><br><span class="line">        System.out.println(sb == sb2);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        sb.append(<span class="keyword">true</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        sb.append(<span class="number">123</span>);</span><br><span class="line">        <span class="comment">//这两个返回的是同一个内容，因为返回的都是字符串缓冲区本身</span></span><br><span class="line">        System.out.println(sb);<span class="comment">//hellotrueworld123</span></span><br><span class="line">        System.out.println(sb2);<span class="comment">//hellotrueworld123</span></span><br><span class="line">    </span><br><span class="line">        sb.append(<span class="number">12.34f</span>).append(<span class="string">&quot;java&quot;</span>).append(<span class="number">23</span>).append(<span class="keyword">false</span>);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">        System.out.println(sb2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//hellotrueworld123</span></span><br><span class="line"><span class="comment">//hellotrueworld123</span></span><br><span class="line"><span class="comment">//hellotrueworld12312.34java23false</span></span><br><span class="line"><span class="comment">//hellotrueworld12312.34java23false</span></span><br></pre></td></tr></table></figure><h4 id="删除功能"><a href="#删除功能" class="headerlink" title="删除功能"></a>删除功能</h4><ul><li><strong>public StringBuffer deleteCharAt(int index)</strong></li><li><strong>public StringBuffer delete(int start,int end)</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        sb.append(<span class="keyword">true</span>).append(<span class="number">12</span>).append(<span class="number">12.34f</span>).append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">        System.out.println(<span class="string">&quot;**********************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除指定范围的字符（左闭右开）</span></span><br><span class="line">    sb.delete(<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line">    System.out.println(sb);</span><br><span class="line">    System.out.println(<span class="string">&quot;**********************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除指定位置字符</span></span><br><span class="line">    sb.deleteCharAt(<span class="number">2</span>);</span><br><span class="line">    System.out.println(sb);</span><br><span class="line">    System.out.println(<span class="string">&quot;**********************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除所有字符串</span></span><br><span class="line">    sb.delete(<span class="number">0</span>,sb.length());</span><br><span class="line">    System.out.println(sb);</span><br><span class="line">    System.out.println(<span class="string">&quot;**********************************&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="替换功能-1"><a href="#替换功能-1" class="headerlink" title="替换功能"></a>替换功能</h4><p><strong>public StringBuffer replace(int start,int end,String str)</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(<span class="number">12</span>).append(<span class="keyword">true</span>).append(<span class="string">&quot;hello&quot;</span>).append(<span class="number">34.56f</span>);</span><br><span class="line">    System.out.println(sb);</span><br><span class="line">    System.out.println(<span class="string">&quot;*********************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sb.replace(<span class="number">2</span>,<span class="number">5</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    System.out.println(sb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//12truehello34.56</span></span><br><span class="line"><span class="comment">//*********************************</span></span><br><span class="line"><span class="comment">//12worldehello34.56</span></span><br></pre></td></tr></table></figure><h4 id="翻转功能"><a href="#翻转功能" class="headerlink" title="翻转功能"></a>翻转功能</h4><p>**public StringBuffer reverse()**（如果序列中包含任何替代对，则将它们视为单个字符进行反向操作）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        sb.append(<span class="string">&quot;StringBuffer&quot;</span>);</span><br><span class="line">        sb.reverse();</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//reffuBgnirtS</span></span><br></pre></td></tr></table></figure><h4 id="截取功能"><a href="#截取功能" class="headerlink" title="截取功能"></a>截取功能</h4><ul><li>public String substring(int start)</li><li>public String substring(int start,int end)<br>截取功能和前面几个功能的不同：返回值是String类型，本身没有发生改变</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        sb.append(<span class="number">12</span>).append(<span class="string">&quot;hello&quot;</span>).append(<span class="number">12.34f</span>).append(<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">        System.out.println(<span class="string">&quot;********************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String sb1 = sb.substring(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">        System.out.println(sb1);</span><br><span class="line">        System.out.println(<span class="string">&quot;********************************&quot;</span>);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//12hello12.34true</span></span><br><span class="line"><span class="comment">//********************************</span></span><br><span class="line"><span class="comment">//12he</span></span><br><span class="line"><span class="comment">//********************************</span></span><br><span class="line"><span class="comment">//12hello12.34true</span></span><br></pre></td></tr></table></figure><h4 id="面试题：String、StringBuffer、StringBuilder类的区别"><a href="#面试题：String、StringBuffer、StringBuilder类的区别" class="headerlink" title="面试题：String、StringBuffer、StringBuilder类的区别"></a>面试题：String、StringBuffer、StringBuilder类的区别</h4><p>1、String、StringBuffer、StringBuilder的区别<br>String的内容是不可变的，而StringBuffer、StringBuilder的内容是可变的<br>StringBuffer是同步线程安全的，数据安全，效率低<br>StringBuilder是不同步的，数据不安全，效率高<br>2、StringBuffer和数组的区别<br>两个都可以看作是一个容器，装一些数据，但是，StringBuffer最终存储的数据是一个字符串数据，而数组可以存放多宗数据，但是同一个数组里面的元素类型一致</p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中一些常用的类以及API帮助文档</title>
      <link href="/2020/09/02/Java%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E7%B1%BB%E4%BB%A5%E5%8F%8AAPI%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/"/>
      <url>/2020/09/02/Java%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E7%B1%BB%E4%BB%A5%E5%8F%8AAPI%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Java中的一些常用类以及API帮助文档"><a href="#Java中的一些常用类以及API帮助文档" class="headerlink" title="Java中的一些常用类以及API帮助文档"></a>Java中的一些常用类以及API帮助文档</h1><h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><p>Java中有一些常用的类，主要有这些:红色和蓝色字体的多掌握一下，这里主要带着帮助文档列举几个(Object类，String类)</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210903194346.png"></p><h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><ul><li>Object类的成员方法</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210903194507.png"></p><p><strong>Object：是类Object结构的根，每个class都有Object作为超类</strong><br>所有对象（包括数组）都实现了这个类的方法<br>每个类都直接或间接的继承自Object类</p><p><strong>Object类中的方法：hashCode()</strong><br>public int hashCode()返回对象的哈希值。 支持这种方法是为了散列表，如HashMap提供的那样<br>注意： 哈希值就是根据哈希算法计算出来的一个值，这个值跟地址有关系，但是不是实际的地址值。你可以简单的理解为就一种地址。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(student.hashCode());<span class="comment">//685325104</span></span><br><span class="line">        Student student1 = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(student1.hashCode());<span class="comment">//460141958</span></span><br><span class="line"></span><br><span class="line">        Student student2 = student;</span><br><span class="line">        System.out.println(student2.hashCode());<span class="comment">//685325104</span></span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;**************************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        Student student3 = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(student3.getClass());<span class="comment">//class com.bigdata.shujia15.Student</span></span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;**************************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        Class c = student3.getClass();</span><br><span class="line">        System.out.println(c.getName());<span class="comment">//com.bigdata.shujia15.Student</span></span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;**************************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        System.out.println(student3.getClass().getName());<span class="comment">//com.bigdata.shujia15.Student</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> **Object类中的方法：toString()**，介绍在代码中为什么要重写toString方法<br>public String toString() 返回对象的字符串表达形式，一般来说，toString方法返回一个对象的字符串<br>Integer类中提供了一个静态的方法：public static String toHexString(int i)返回整数参数的字符串表示形式，作为16位中的无符号整数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student2 student2 = <span class="keyword">new</span> Student2();</span><br><span class="line">        System.out.println(student2.hashCode());<span class="comment">//685325104</span></span><br><span class="line">        System.out.println(student2.getClass().getName());<span class="comment">//com.bigdata.shujia15.Student2</span></span><br><span class="line">        System.out.println(student2.toString());<span class="comment">//com.bigdata.shujia15.Student2@28d93b30</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;****************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//toString方法的值等价于以下内容，然而这样的输出没有意义，所以JVM中为我们重写了toString方法</span></span><br><span class="line">        <span class="comment">//student2.getClass().getName()+&quot;@&quot;+Integer.toHexString(student2.hashCode())</span></span><br><span class="line">    </span><br><span class="line">        System.out.println(student2.getClass().getName()+<span class="string">&quot;@&quot;</span>+Integer.toHexString(student2.hashCode()));</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//重写之后的toString方法</span></span><br><span class="line">        student2.setName(<span class="string">&quot;酷酷的涛&quot;</span>);</span><br><span class="line">        student2.setAge(<span class="number">22</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;重写之后的方法：&quot;</span>+student2.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//685325104</span></span><br><span class="line"><span class="comment">//com.bigdata.shujia15.Student2</span></span><br><span class="line"><span class="comment">//Student2&#123;name=&#x27;null&#x27;, age=0&#125;</span></span><br><span class="line"><span class="comment">//****************</span></span><br><span class="line"><span class="comment">//com.bigdata.shujia15.Student2@28d93b30</span></span><br><span class="line"><span class="comment">//重写之后的方法：Student2&#123;name=&#x27;酷酷的涛&#x27;, age=22&#125;</span></span><br></pre></td></tr></table></figure><p><strong>Object中的方法：equals（这个方法，要重写）</strong><br>public boolean equals(Object obj) 指示一些其他的对象是否等于此，这个方法，默认情况下，比较的是地址值，但是呢，比较地址值是没有意义的，更多情况下，我们比较对象中成员变量的值是否一样，所以想到的是重写方法</p><p><strong>==：</strong><br>基本类型：比较的是值是否相同<br>引用类型：比较的是地址值是否相同<br><strong>equals：</strong><br>引用类型：默认情况下，比较的是地址值。不过，根据情况重写，可以自己重写，也可以自动生成</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student3 s1 = <span class="keyword">new</span> Student3(<span class="string">&quot;张三&quot;</span>,<span class="number">21</span>);</span><br><span class="line">        Student3 s2 = <span class="keyword">new</span> Student3(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(s1==s2);<span class="comment">//false</span></span><br><span class="line">        Student3 s3 = s1;</span><br><span class="line">        System.out.println(s1==s3);<span class="comment">//true</span></span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;********&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        System.out.println(s1.equals(s2));<span class="comment">//false</span></span><br><span class="line">        System.out.println(s1.equals(s1));<span class="comment">//true</span></span><br><span class="line">        System.out.println(s1.equals(s3));<span class="comment">//true</span></span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;********&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        Student3 s4 = <span class="keyword">new</span> Student3(<span class="string">&quot;王五&quot;</span>, <span class="number">23</span>);</span><br><span class="line">        System.out.println(s1.equals(s4));<span class="comment">//false</span></span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;********&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">        System.out.println(s1.equals(demo));<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Object中的方法：finalize()、clone()<br>protected void finalize()<br>throws Throwable当垃圾回收器确定不再有对该对象的引用时，垃圾回收器在对象上调用该对象。一个子类覆盖了处理系统资源或执行其他清理的finalize方法。简单来说，它就是用于垃圾回收的，但是呢，什么时候回收不确定<br>protected Object clone()<br>throws CloneNotSupportedException创建并返回此对象的副本。返回的是这个实例的一个克隆。</li></ul><p>public interface Cloneable一个类实现Cloneable接口，以指示Object.clone()方法，该方法对于该类的实例进行现场赋值是合法的，也就是必须要实现Cloneable接口才能使用clone方法</p><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><h4 id="String类概述"><a href="#String类概述" class="headerlink" title="String类概述"></a>String类概述</h4><ul><li><p>字符串是由多个字符组成的一串数据（字符序列）<br>字符串可以看成是字符数组</p></li><li><p>通过查看API，发现</p><ul><li>String类代表字符串<br>Java程序中所有字符串文字（例如“abc”）都可以实现为此类的实例<br>字符串字面值“abc”也可以看成一个字符串对象<br>字符串是常量，一旦被赋值，就不能被改变</li></ul></li></ul><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><ul><li>public String()</li><li>public String(byte[] bytes)</li><li>public String(byte[] bytes,int offset,int length)</li><li>public String(char[] value)</li><li>public String(char[] value,int offset,int count)</li><li>public String(String original)</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="keyword">new</span> String();</span><br><span class="line">        System.out.println(<span class="string">&quot;s:&quot;</span>+s);</span><br><span class="line">        System.out.println(<span class="string">&quot;s的长度&quot;</span>+s.length());</span><br><span class="line">        System.out.println(<span class="string">&quot;******************&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//public String(byte[] bytes) 将字节数组转化成字符串</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">66</span>,<span class="number">77</span>,<span class="number">88</span>,<span class="number">99</span>&#125;;</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(b);</span><br><span class="line">        System.out.println(<span class="string">&quot;s1:&quot;</span>+s1);</span><br><span class="line">        System.out.println(s1.length());</span><br><span class="line">        System.out.println(<span class="string">&quot;******************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//public String(byte[] bytes,int offset,int length)</span></span><br><span class="line">        <span class="comment">//将字节数组的一部分截取成字符串</span></span><br><span class="line">        String s2 = <span class="keyword">new</span> String(b,<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;s2:&quot;</span>+s2);</span><br><span class="line">        System.out.println(s2.length());</span><br><span class="line">        System.out.println(<span class="string">&quot;******************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//public String(char[] value) 将字符数组转化成字符串</span></span><br><span class="line">        <span class="keyword">char</span>[] c = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;g&#x27;</span>&#125;;</span><br><span class="line">        String s3 = <span class="keyword">new</span> String(c);</span><br><span class="line">        System.out.println(<span class="string">&quot;s3:&quot;</span>+s3);</span><br><span class="line">        System.out.println(s3.length());</span><br><span class="line">        System.out.println(<span class="string">&quot;******************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//public String(char[] value,int offset,int count)</span></span><br><span class="line">        <span class="comment">//将字符数组的一部分转化成字符串</span></span><br><span class="line">        String s4 = <span class="keyword">new</span> String(c,<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;s4:&quot;</span>+s4);</span><br><span class="line">        System.out.println(s4.length());</span><br><span class="line">        System.out.println(<span class="string">&quot;******************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//public String(String original)</span></span><br><span class="line">        <span class="comment">//将字符串常量转化成字符串对象</span></span><br><span class="line">        String abcde = <span class="keyword">new</span> String(<span class="string">&quot;abcde&quot;</span>);</span><br><span class="line">        System.out.println(abcde);</span><br><span class="line">        System.out.println(abcde.length());</span><br><span class="line">    </span><br><span class="line">        String s6 = <span class="string">&quot;asdfghj&quot;</span>;</span><br><span class="line">        String s7 = <span class="keyword">new</span> String(s6);</span><br><span class="line">        System.out.println(<span class="string">&quot;s7:&quot;</span>+s7);</span><br><span class="line">        System.out.println(s7.length());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>字符串的特点：一旦被赋值，就不能被改变</strong><br>面试题：<br>但我们发现下面这个例子，s从Hello，变为了HelloWorld</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    s += <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;s:&quot;</span>+s);<span class="comment">//HelloWorld</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但实际上，我们可以发现，当我们创建“Hello”的时候，是在方法区里面的字符串常量池创建了一个空间，“World”也开辟了一个空间，“HelloWorld”也是一个新的空间，s是从“Hello”的地址，变成了“HelloWorld”的地址，但本身的字符串是不发生改变的。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210903195535.png"></p><ul><li><strong>String s = new String(“hello”) 和 String s = “hello”的区别</strong><ul><li>== 比较的是引用类型的地址值</li><li>equals默认比较的是地址值，但是String重写了equals方法，所以比较的是内容</li><li>前者会创建两个对象，后者创建一个对象</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        String s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(s == s1);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s1.equals(s));<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图解：<br>首先是在栈里面创建了一个s1对象，然后在堆里面开辟了一个空间，赋值了hello，存进了方法区的字符串常量池，s1指向的是堆内存里面的位置；接着在栈里面开辟了s2空间，指向的是方法区中字符串常量池的位置。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210903195958.png"></p><ul><li>看程序写结果<ul><li><strong>字符串如果是变量相加，是先开辟空间，再拼接</strong></li><li><strong>字符串如果是常量相加，是先加，再去常量池中查找，如果找到就返回，否则就创建</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">        System.out.println(s3==s1+s2);  <span class="comment">//false</span></span><br><span class="line">        System.out.println(s3.equals(s1+s2));  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//经过编译，自动转化成System.out.println(s3 == &quot;helloworld&quot;);</span></span><br><span class="line">    System.out.println(s3 == <span class="string">&quot;hello&quot;</span>+<span class="string">&quot;world&quot;</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    System.out.println(s3.equals(<span class="string">&quot;hello&quot;</span>+<span class="string">&quot;world&quot;</span>)); <span class="comment">//true        </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断功能"><a href="#判断功能" class="headerlink" title="判断功能"></a>判断功能</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//注意事项：</span></span></span><br><span class="line"><span class="function">    String s </span>= <span class="string">&quot;&quot;</span>;</span><br><span class="line">    String s = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p> 以上为一些基本的判断功能，下面是相关代码展示:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//创建字符串对象</span></span><br><span class="line">        String s1 = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;Helloworld&quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//boolean equals(Object obj) 比较字符串的内容是否相同，区分大小写</span></span><br><span class="line">        System.out.println(s1.equals(s2)); <span class="comment">//false</span></span><br><span class="line">        System.out.println(s1.equals(s3)); <span class="comment">//false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;**********************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//boolean equalsIgnoreCase(String str)</span></span><br><span class="line">        <span class="comment">// 比较字符串的内容是否相同,忽略大小写</span></span><br><span class="line">        System.out.println(s1.equalsIgnoreCase(s2)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(s1.equalsIgnoreCase(s3)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;**********************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//boolean contains(String str)</span></span><br><span class="line">        <span class="comment">//判断大的字符串中是否包含小的字符串</span></span><br><span class="line">        System.out.println(s1.contains(<span class="string">&quot;Hello&quot;</span>));</span><br><span class="line">        System.out.println(s1.contains(<span class="string">&quot;lowo&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;**********************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//boolean startsWith(String str) 测试此字符串是否以指定的前缀开头。</span></span><br><span class="line">        System.out.println(s1.startsWith(<span class="string">&quot;h&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(s1.startsWith(<span class="string">&quot;he&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(s1.startsWith(<span class="string">&quot;world&quot;</span>)); <span class="comment">//false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;**********************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//boolean endsWith(String str)测试此字符串是否以指定的后缀结尾。</span></span><br><span class="line">        System.out.println(s1.endsWith(<span class="string">&quot;world&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(s1.endsWith(<span class="string">&quot;hello&quot;</span>)); <span class="comment">//false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;**********************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//boolean isEmpty() 判断字符串是不是空</span></span><br><span class="line">        System.out.println(s1.isEmpty());</span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;**********************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        String s4 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        String s5 = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(s4.isEmpty()); <span class="comment">//true</span></span><br><span class="line">        <span class="comment">//因为s5的对象都没有，所以不能够调用方法，空指针异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(s5.isEmpty()); //NullPointerException</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;asd&quot;</span>.equals(s1));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(s5.equals(&quot;asd&quot;));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较字符串的内容，推荐这种</span></span><br><span class="line">        System.out.println(<span class="string">&quot;asd&quot;</span>.equals(s5));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取功能"><a href="#获取功能" class="headerlink" title="获取功能"></a>获取功能</h4><p>int length():获取字符串的长度</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch,<span class="keyword">int</span> fromIndex)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str,<span class="keyword">int</span> fromIndex)</span></span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int length():获取字符串的长度</span></span><br><span class="line">    System.out.println(s.length());</span><br><span class="line">    System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//char charAt(int index)</span></span><br><span class="line">    <span class="comment">//返回char指定索引处的值。 指数范围为0至length() - 1</span></span><br><span class="line">    System.out.println(s.charAt(<span class="number">7</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int indexOf(int ch)</span></span><br><span class="line">    <span class="comment">//返回指定字符第一次出现的字符串内的索引。</span></span><br><span class="line">    System.out.println(s.indexOf(<span class="string">&#x27;l&#x27;</span>)); <span class="comment">//2</span></span><br><span class="line">    System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int indexOf(String str)</span></span><br><span class="line">    <span class="comment">//返回指定子字符串第一次出现的字符串内的索引。</span></span><br><span class="line">    System.out.println(s.indexOf(<span class="string">&quot;ello&quot;</span>)); <span class="comment">//1</span></span><br><span class="line">    System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int indexOf(int ch,int fromIndex)</span></span><br><span class="line">    <span class="comment">//返回指定字符第一次出现的字符串内的索引，以指定的索引开始搜索。</span></span><br><span class="line">    System.out.println(s.indexOf(<span class="string">&#x27;l&#x27;</span>,<span class="number">4</span>)); <span class="comment">//8</span></span><br><span class="line">    System.out.println(s.indexOf(<span class="string">&#x27;p&#x27;</span>,<span class="number">4</span>)); <span class="comment">//-1</span></span><br><span class="line">    System.out.println(s.indexOf(<span class="string">&#x27;l&#x27;</span>,<span class="number">40</span>)); <span class="comment">//-1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//int indexOf(String str,int fromIndex)</span></span><br><span class="line">    <span class="comment">//返回指定子串的第一次出现的字符串中的索引，从指定的索引开始</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//String substring(int start)</span></span><br><span class="line">    <span class="comment">//返回一个字符串，该字符串是此字符串的子字符串。</span></span><br><span class="line">    <span class="comment">// 子字符串以指定索引处的字符开头，并扩展到该字符串的末尾</span></span><br><span class="line">    <span class="comment">//截串</span></span><br><span class="line">    <span class="comment">//最大可以传的数值到length的值</span></span><br><span class="line">    System.out.println(s.substring(<span class="number">3</span>)); <span class="comment">//loworld</span></span><br><span class="line">    <span class="comment">//System.out.println(s.substring(11));//StringIndexOutOfBoundsException</span></span><br><span class="line">    System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//String substring(int start,int end)</span></span><br><span class="line">    <span class="comment">//返回一个字符串，该字符串是此字符串的子字符串。</span></span><br><span class="line">    <span class="comment">// 子串开始于指定beginIndex并延伸到字符索引endIndex - 1 。</span></span><br><span class="line">    <span class="comment">// 因此，子串的长度为endIndex-beginIndex 。</span></span><br><span class="line">    <span class="comment">//左闭右开</span></span><br><span class="line">    System.out.println(s.substring(<span class="number">1</span>,<span class="number">3</span>)); <span class="comment">//el</span></span><br><span class="line">    System.out.println(s.substring(<span class="number">4</span>,<span class="number">8</span>)); <span class="comment">//owor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>权限修饰符以及内部类</title>
      <link href="/2020/09/02/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%E4%BB%A5%E5%8F%8A%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2020/09/02/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%E4%BB%A5%E5%8F%8A%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="权限修饰符以及内部类"><a href="#权限修饰符以及内部类" class="headerlink" title="权限修饰符以及内部类"></a>权限修饰符以及内部类</h1><h2 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h2><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210903190340.png"></p><h3 id="同一个类下"><a href="#同一个类下" class="headerlink" title="同一个类下:"></a>同一个类下:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerDemo1</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> age = <span class="number">21</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> String id = <span class="string">&quot;001&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        PowerDemo1 powerDemo1 = <span class="keyword">new</span> PowerDemo1();</span><br><span class="line">        System.out.println(powerDemo1.name);</span><br><span class="line">        System.out.println(powerDemo1.age);</span><br><span class="line">        System.out.println(powerDemo1.flag);</span><br><span class="line">        System.out.println(powerDemo1.id);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//张三</span></span><br><span class="line"><span class="comment">//21</span></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//001</span></span><br></pre></td></tr></table></figure><h3 id="同一个包子类，其他类"><a href="#同一个包子类，其他类" class="headerlink" title="同一个包子类，其他类:"></a>同一个包子类，其他类:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Power</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> age = <span class="number">21</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> String id = <span class="string">&quot;001&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerDemo1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Power power = <span class="keyword">new</span> Power();</span><br><span class="line">        System.out.println(power.name);</span><br><span class="line">        System.out.println(power.age);</span><br><span class="line">        System.out.println(power.flag);</span><br><span class="line">        <span class="comment">//Error:(18, 33) java: id可以在com.bigdata.shujia14.Power中访问private</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(power.id);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//张三</span></span><br><span class="line"><span class="comment">//21</span></span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="不同包的子类"><a href="#不同包的子类" class="headerlink" title="不同包的子类:"></a>不同包的子类:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerTest1</span> <span class="keyword">extends</span> <span class="title">PowerDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PowerTest1 powerTest1 = <span class="keyword">new</span> PowerTest1();</span><br><span class="line">        System.out.println(powerTest1.name);    <span class="comment">//public修饰的</span></span><br><span class="line">        System.out.println(powerTest1.age);     <span class="comment">//protected修饰的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//张三</span></span><br><span class="line"><span class="comment">//21</span></span><br></pre></td></tr></table></figure><h3 id="不同包的其他类"><a href="#不同包的其他类" class="headerlink" title="不同包的其他类"></a>不同包的其他类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerTest1</span> <span class="keyword">extends</span> <span class="title">PowerDemo1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PowerDemo1 powerDemo1 = <span class="keyword">new</span> PowerDemo1();</span><br><span class="line">        System.out.println(powerDemo1.name);<span class="comment">//public修饰的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//张三</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>类及其成员修饰符</strong><br><strong>权限修饰符：private、默认的、protected、public<br>状态修饰符：static、final<br>抽象修饰符：abstract</strong></p></li><li><p>类：</p><p>权限修饰符：默认的、public</p><p>状态修饰符：final</p><p>抽象修饰符：abstract</p><p>最常用的是public</p><p><strong>成员变量：</strong><br>权限修饰符：private、默认的、protected、public<br>状态修饰符：static、final<br><strong>最常用的是public</strong></p></li><li><p><strong>构造方法：</strong><br>权限修饰符：private、默认的、protected、public<br><strong>最常用的是public</strong></p></li><li><p><strong>成员方法：</strong><br>权限修饰符：private、默认的、protected、public<br>状态修饰符：static、final<br>抽象修饰符：abstract<br><strong>最常用的是public</strong></p></li></ul><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul><li><p><strong>把类定义在其他类的内部，这个类就被称为内部类</strong><br>举例：在类A中定义了一个类B，类B就是内部类</p></li><li><p>内部类的访问特点：</p><ul><li>内部类可以访问外部类的成员，包括私有</li><li>外部类如果想要访问内部类的成员，就必须要创建对象</li></ul></li><li><p><strong>内部类的位置：</strong><br>按照内部类在类中定义的位置不同，分为如下两种格式<br>- 成员位置（成员内部类）<br>- 局部位置（局部内部类）</p></li><li><p>成员内部类：</p><ul><li>内部类可以访问外部类的成员，包括私有</li><li>如何创建对象呢<br>外部类名.内部类名 对象名 = new 外部类名.new 内部类名</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer3</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//想要访问内部类的show()方法，就必须要创建Inner对象</span></span><br><span class="line"><span class="comment">//        Inner inner = new Inner();</span></span><br><span class="line"><span class="comment">//        inner.show();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//正确创建内部类对象的格式：</span></span><br><span class="line">        Outer3.Inner i = <span class="keyword">new</span> Outer3().<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">        i.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//20</span></span><br></pre></td></tr></table></figure><p><strong>成员内部类常见修饰符：</strong><br>private：为了保证数据的安全性<br>static：为了方便访问数据<br>注意事项：静态内部类访问的外部数据必须由静态修饰</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer4</span></span>&#123;</span><br><span class="line">    <span class="comment">//局部变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成员内部类被静态修饰    访问的局部变量也只能是静态的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner4</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            System.out.println(num);</span></span><br><span class="line">            System.out.println(num2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            System.out.println(num);</span></span><br><span class="line">            System.out.println(num2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer4.Inner4 i = <span class="keyword">new</span> Outer4.Inner4();</span><br><span class="line">        i.show();<span class="comment">//20</span></span><br><span class="line">        i.show2();<span class="comment">//20</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//另一种创建内部类的方式，当成员变量被静态修饰后，访问的格式如下：</span></span><br><span class="line">        <span class="comment">//外部类名.内部类名 对象名 = new   外部类名.内部类名()</span></span><br><span class="line">        Outer4.Inner4 i1 = <span class="keyword">new</span> Outer4.Inner4();</span><br><span class="line">        i1.show();<span class="comment">//20</span></span><br><span class="line">        i1.show2();<span class="comment">//20</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">//调用show2()的另一种方式</span></span><br><span class="line">        Outer4.Inner4.show2();<span class="comment">//20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><ul><li>就是内部类的简化写法</li><li>前提：存在一个类或者接口<br>这里的类可以是具体类，也可以是抽象类</li><li>格式：new 类名或者接口名(){重写方法;}</li><li>本质是：是一个继承了这个类或者实现了这个接口的子类的匿名对象</li></ul><p>例如:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer7</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        new Inter() &#123;</span></span><br><span class="line"><span class="comment">//            public void show() &#123;</span></span><br><span class="line"><span class="comment">//                System.out.println(&quot;show()方法&quot;);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            public void show2() &#123;</span></span><br><span class="line"><span class="comment">//                System.out.println(&quot;这是show2()方法&quot;);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;.show2();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        new Inter()&#123;</span></span><br><span class="line"><span class="comment">//            public void show()&#123;</span></span><br><span class="line"><span class="comment">//                System.out.println(&quot;这是show()方法&quot;);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            public void show2()&#123;</span></span><br><span class="line"><span class="comment">//                System.out.println(&quot;这是show2()方法&quot;);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;.show();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//问题，如果我这个接口有很多方法，还需要使用匿名内部类的形式就很麻烦</span></span><br><span class="line">        <span class="comment">//怎么改进</span></span><br><span class="line">        Inter inter = <span class="keyword">new</span> Inter()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;这是show方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;这是show2方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        inter.show();</span><br><span class="line">        inter.show2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassDemo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer7 outer7 = <span class="keyword">new</span> Outer7();</span><br><span class="line">        outer7.fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是show方法</span></span><br><span class="line"><span class="comment">//这是show2方法</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象类，接口以及形式参数</title>
      <link href="/2020/09/02/%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%8C%E6%8E%A5%E5%8F%A3%E4%BB%A5%E5%8F%8A%E5%BD%A2%E5%BC%8F%E5%8F%82%E6%95%B0/"/>
      <url>/2020/09/02/%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%8C%E6%8E%A5%E5%8F%A3%E4%BB%A5%E5%8F%8A%E5%BD%A2%E5%BC%8F%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="抽象类，接口以及形式参数"><a href="#抽象类，接口以及形式参数" class="headerlink" title="抽象类，接口以及形式参数"></a>抽象类，接口以及形式参数</h1><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p><strong>概述：</strong><br>用之前的猫狗、动物举例，动物中不应该具体的东西，而且动物中的吃方法、睡觉方法这些等都不应该也是具体，我们把一个不具体的功能称之为抽象的功能，也叫做抽象方法，而类中如果有抽象方法，该类必须定义为抽象类。</p><p>例如:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"><span class="comment">//    public abstract void eat()&#123;&#125;  //这样写会报错，因为抽象方法不能有主体</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        Animal a = new Animal();  //Animal是抽象的，无法实例化</span></span><br><span class="line">        Animal a = <span class="keyword">new</span> Cat();</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//猫吃鱼</span></span><br></pre></td></tr></table></figure><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li><p>抽象类和抽象方法必须使用abstract关键字修饰<br>格式：abstract class 类名 {}</p></li><li><p>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类</p></li><li><p>抽象类不能实例化<br>那么，抽象类如何实例化呢？<br>按照多态的方式，由具体的子类实例化。其实这也是多态的一种，抽象类多态</p></li><li><p>抽象类的子类</p><ul><li>要么是抽象类，不需要重写父抽象类的抽象方法<br>要么重写抽象类中所有的抽象方法，那么这个时候子类是一个具体的类</li></ul></li><li><p>成员变量：可以是变量，也可以是常量</p></li><li><p>构造方法：有。可以有构造方法，但是抽象类又不能具体实例化，有什么用呢<br>用于子类访问父类的初始化</p></li><li><p>成员方法：可以是抽象方法，也可以不是抽象方法</p></li><li><p>如果抽象类中包含成员方法是抽象方法，那么就需要强制具体子类去重写</p></li><li><p>如果抽象类中包含成员方法是非抽象方法，那么继承的子类可以不去调用，提高了代码的复用性</p></li></ul><p>例如:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal2</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal2</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;<span class="comment">//抽象类中的抽象方法，就需要子类去强制重写</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;<span class="comment">//抽象类中的非抽象方法，继承的子类可以不去调用</span></span><br><span class="line">        System.out.println(<span class="string">&quot;这是抽象类中一个具体的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog2</span> <span class="keyword">extends</span> <span class="title">Animal2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是Dog2类继承Animal2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           Animal2 a = <span class="keyword">new</span> Dog2();</span><br><span class="line">           a.num = <span class="number">100</span>;</span><br><span class="line">           System.out.println(a.num);</span><br><span class="line"><span class="comment">//           a.num2 = 200;//无法改变final修饰的变量</span></span><br><span class="line">        System.out.println(<span class="string">&quot;*****************************&quot;</span>);</span><br><span class="line">            a.show();</span><br><span class="line">            a.show2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//100</span></span><br><span class="line"><span class="comment">//        *****************************</span></span><br><span class="line"><span class="comment">//        这是Dog2类继承Animal2</span></span><br><span class="line"><span class="comment">//        这是抽象类中一个具体的方法</span></span><br></pre></td></tr></table></figure><ul><li><strong>一个类如果没有抽象方法，可不可以定义为抽象类？如果可以，有什么意义？</strong><br>抽象类里面可以没有抽象方法<br>不能创建对象</li><li><strong>abstract不能和哪些关键字共存</strong><ul><li>private 冲突</li><li>final 冲突</li><li>static 冲突</li></ul></li></ul><p>例如:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line"><span class="comment">//    public abstract void show();</span></span><br><span class="line">    <span class="comment">//Error:(7, 27) java: 非法的修饰符组合: abstract和private</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    private abstract void show1();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Error:(10, 25) java: 非法的修饰符组合: abstract和final</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    final abstract void show3();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Error:(14, 26) java: 非法的修饰符组合: abstract和static</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    static abstract void show4();</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是继承的一个静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fu f = <span class="keyword">new</span> Zi();</span><br><span class="line">        f.show5();</span><br><span class="line">        Fu.show5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是一个静态方法</span></span><br><span class="line"><span class="comment">//这是一个静态方法</span></span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>牢记接口是来做额外的动作的，来体现事物的扩展性</p><ul><li>接口的特点<ul><li>接口用关键字interface表示<br>格式：interface 接口名 {}</li><li>类实现接口用implements表示<br>格式：class 类名 implements 接口名 {}</li><li>接口不能实例化<br>那么，接口如何实例化呢<br>按照多态的方式，由具体的子类实例化，这也是多态的一种，接口多态</li><li>接口的子类<br>要么是抽象类<br>要么重写接口中所有的抽象方法</li></ul></li><li>由此可见最常用的是<ul><li>接口多态<br>抽象类多态<br>具体的类多态</li></ul></li></ul><p>一个简单的接口举例：（可以理解为，使用接口，为cat猫类加了一个新的方法）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个动物训练接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AnimalTrain</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat1</span> <span class="keyword">implements</span> <span class="title">AnimalTrain</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫跳高&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        AnimalTrain animalTrain = new AnimalTrain();//抽象类无法实例化</span></span><br><span class="line">        AnimalTrain a = <span class="keyword">new</span> Cat1();<span class="comment">//就可以直接理解为使用接口为cat猫添加了一个新的方法</span></span><br><span class="line">        a.jump();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//猫跳高</span></span><br></pre></td></tr></table></figure><ul><li><strong>接口成员的特点</strong>：<br>成员变量：只能是常量，并且是静态的<br>它里面默认有修饰符：public static final<br>建议：全部手动给出<br>构造方法：接口里面没有构造方法<br>成员方法：只能是抽象方法，没有方法体<br>默认修饰符是：public abstract<br>建议：全部手动给出</li><li>注意：虽然接口里面没有构造方法，但是，所有的类都默认继承一个类：Object，Object是类Object结构的根，每个class都有Object作为超类，所有对象（包括数组）都实现了这个类的方法</li><li>成员接口的成员变量默认修饰符：public static final</li><li>成员接口的成员方法默认修饰符：public abstract</li><li><strong>类与类</strong><br>继承关系，只能<strong>单继承，但是可以多层继承</strong></li><li><strong>类与接口</strong><br>实现关系，<strong>可以单实现，可以多实现</strong>，还可以在继承一个类的同时实现多个接口</li><li><strong>接口与接口</strong><br>没有实现关系，只有继承关系，<strong>可以单继承，可以多继承</strong></li></ul><h2 id="形式参数和返回值"><a href="#形式参数和返回值" class="headerlink" title="形式参数和返回值"></a>形式参数和返回值</h2><h3 id="形式参数"><a href="#形式参数" class="headerlink" title="形式参数"></a>形式参数</h3><ul><li>形式参数：<br>基本数据类型<br>引用数据类型：<br>类：实际上需要的是该类的对象<br>抽象类<br>接口</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类实际上需要的是该类的对象代码举例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student3</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;好好学习&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student3Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(Student3 s)</span></span>&#123;</span><br><span class="line">        s.study();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student3 student3 = <span class="keyword">new</span> Student3();</span><br><span class="line">        Student3Demo student3Demo = <span class="keyword">new</span> Student3Demo();</span><br><span class="line">        student3Demo.fun(student3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//好好学习</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象类:当抽象类作为形式参数传入方法的时候，需要的是该抽象类的子类对象代码举例</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person3</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(Person3 p)</span></span>&#123;</span><br><span class="line">        p.study();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student4</span> <span class="keyword">extends</span> <span class="title">Person3</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生学习&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        Person3 person3 = new Person3();//抽象类不能实例化</span></span><br><span class="line"></span><br><span class="line">        Student4 student4 = <span class="keyword">new</span> Student4();</span><br><span class="line">        Person3 p =<span class="keyword">new</span> Student4();</span><br><span class="line">    </span><br><span class="line">        PersonDemo personDemo = <span class="keyword">new</span> PersonDemo();</span><br><span class="line">        personDemo.fun(student4);</span><br><span class="line">        personDemo.fun(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//学生学习</span></span><br><span class="line"><span class="comment">//学生学习</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当接口作为形式参数传入方法的时候，需要的是该接口具体的实现类对象</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person6</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person6Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(Person6 p)</span></span>&#123;</span><br><span class="line">        p.study();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher6</span> <span class="keyword">implements</span> <span class="title">Person6</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老师学习&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Teacher6 teacher6 = <span class="keyword">new</span> Teacher6();</span><br><span class="line">        Person6Demo person6Demo = <span class="keyword">new</span> Person6Demo();</span><br><span class="line">        person6Demo.fun(teacher6);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//老师学习</span></span><br></pre></td></tr></table></figure><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>返回值类型：<br>基本数据类型<br>引用数据类型<br>类：当一个类作为返回值类型的时候，需要的是该类的对象<br>抽象类<br>接口</p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>final关键字以及多态的概述</title>
      <link href="/2020/09/02/final%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%A4%9A%E6%80%81%E7%9A%84%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/09/02/final%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%A4%9A%E6%80%81%E7%9A%84%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Final关键字以及多态的概述"><a href="#Final关键字以及多态的概述" class="headerlink" title="Final关键字以及多态的概述"></a>Final关键字以及多态的概述</h1><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ul><li><p>final关键字是最终的意思，可以修饰 类、成员变量、成员方法</p><ul><li>修饰类，类不能被继承<br>修饰变量，变量就变成了常量，只能被赋值一次<br>修饰方法，方法不能被重写<br>在构造方法初始化完成之前赋值完毕（修饰的是非静态的常量）</li></ul></li><li><p>常量:</p><ul><li>字面值常量：<br>“java”、100、false<br>自定义常量：<br>修饰变量，变量就变成了常量<br>final int x = 100;//此刻的x就是一个常量</li></ul></li><li><p>final变量的引入：<br>由于继承中有一个现象，子类的方法和父类的方法声明一样，出现重写现象，所以，父类的功能就会被子类覆盖。但有时候，我们不想让子类覆盖父类的方法或者功能，只能让子类使用，这个时候，针对这种情况，Java就提供了一个关键字：final</p></li></ul><p>例如:子类无法重写父类中被final修饰的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是父类的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu1</span></span>&#123;</span><br><span class="line"><span class="comment">//    public void show()&#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;子类无法重写父类的方法&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZiDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Zi zi = <span class="keyword">new</span> Zi();</span><br><span class="line">        zi.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是父类的方法</span></span><br></pre></td></tr></table></figure><p>例如:final修饰的变量不能被修改</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu2</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是父类的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi2</span> <span class="keyword">extends</span> <span class="title">Fu2</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        num = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        num2 = 20;//这也是一个不能被重写的变量</span></span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(num2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public void fun()&#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;这是一个不能被重写的方法&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Zi2 zi2 = <span class="keyword">new</span> Zi2();</span><br><span class="line">        zi2.show();</span><br><span class="line">        zi2.fun();<span class="comment">//这里打印的是父类的方法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> x = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        x = 30;//这是一个不能被该的变量</span></span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//100</span></span><br><span class="line"><span class="comment">//20</span></span><br><span class="line"><span class="comment">//这是父类的方法</span></span><br><span class="line"><span class="comment">//20</span></span><br></pre></td></tr></table></figure><h3 id="面试题-final修饰局部变量"><a href="#面试题-final修饰局部变量" class="headerlink" title="面试题:final修饰局部变量"></a>面试题:final修饰局部变量</h3><p>1、在方法内部，该变量不能被改变<br>2、final修饰引用数据类型的时候，引用的地址值不能发生改变，但是，该对象的堆内存里面的值是可以改变的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student1</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">        x = <span class="number">100</span>;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> y = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//        y = 200;//Java无法为最终变量y分配值</span></span><br><span class="line">        System.out.println(y);</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Student1 student1 = <span class="keyword">new</span> Student1();</span><br><span class="line">        System.out.println(student1.age);</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> Student1 student2 = <span class="keyword">new</span> Student1();</span><br><span class="line">        System.out.println(student2.age);</span><br><span class="line">        student2.age = <span class="number">20</span>;</span><br><span class="line">        System.out.println(student2.age);</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        student2 = new Student1();//Java无法为最终变量s2分配值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//100</span></span><br><span class="line"><span class="comment">//------------------</span></span><br><span class="line"><span class="comment">//20</span></span><br><span class="line"><span class="comment">//------------------</span></span><br><span class="line"><span class="comment">//10</span></span><br><span class="line"><span class="comment">//------------------</span></span><br><span class="line"><span class="comment">//10</span></span><br><span class="line"><span class="comment">//20</span></span><br><span class="line"><span class="comment">//------------------</span></span><br></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul><li>多态概述：某一个事物，在不同时刻表现出来的不同状态</li><li>举例：<br>水：<br>固态、液态、气态<br>固态的水是水、液态的水是水、气态的水是水<br>水果：<br>苹果、香蕉、西瓜<br>苹果是水果、香蕉是水果、西瓜是水果<br>但不能说水果是苹果、水果是香蕉</li><li>我们通过观察这些例子发现，要想有多态，必须要有继承，继承是多态的前提</li><li>多态的条件：<ul><li>要有继承的关系</li><li>要有方法的重写<br>其实没有也可以，但是没有重写就没有意义</li><li>要有父类引用指向子类对象<br>父 f = new 子();</li></ul></li><li>多态中成员访问特点<ul><li>成员变量<br>编译看左边，运行看左边</li><li>构造方法<br>创建子类对象的时候，先访问父类的构造方法，对父类的数据先进行初始化</li><li>成员方法<br>编译看左边，运行看右边<br>因为成员方法存在重写，所以访问看右边</li><li>静态成员方法<br>编译看左边，运行看左边<br>由于被static修饰的都是与类相关的，算不上重写，所以，运行的时候，访问的还是左边的</li></ul></li></ul><p>例如:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu3</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是父类中的成员方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是父类中的静态成员方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi3</span> <span class="keyword">extends</span> <span class="title">Fu3</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">40</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是子类中的成员方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是子类中的另一个成员方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是子类中的静态成员方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Polymorphic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fu3 f = <span class="keyword">new</span> Zi3();</span><br><span class="line">        System.out.println(f.num2);<span class="comment">//成员变量，编译看左边，运行看左边</span></span><br><span class="line"></span><br><span class="line">        f.show();<span class="comment">//成员方法，编译看左边，运行看右边</span></span><br><span class="line">        f.show2();<span class="comment">//静态成员方法，编译看左边，运行还是看左边</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//20</span></span><br><span class="line"><span class="comment">//这是子类中的成员方法</span></span><br><span class="line"><span class="comment">//这是父类中的静态成员方法</span></span><br></pre></td></tr></table></figure><ul><li><strong>多态的好处</strong><br>1、提高了代码的维护性（这是继承保证的）<br>2、提高了程序的扩展性（这是多态决定的）</li><li><strong>多态的弊端</strong><br>不能访问子类的特有功能</li></ul><p> 正是因为不能访问子类中的特有功能，所以在多态中有了一个全新的概念:向下转型。</p><blockquote><p>多态中转型的使用：<br>向上转型：Fu5 f = new Zi5();<br>向下转型：Zi5 z = (Zi5) f2;<br>注意：这样的转型，必须要求f2必须是能够转换成z的，也就是说，他俩必须要是继承关系。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu5</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是父类的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi5</span> <span class="keyword">extends</span> <span class="title">Fu5</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是子类重写父类的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是子类特有的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolymorphicDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fu5 f = <span class="keyword">new</span> Zi5();</span><br><span class="line">        f.show();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//多态中的转型，我们既然可以将子类的对象赋值给父，为什么不能把父的引用赋值给子引用</span></span><br><span class="line">        <span class="comment">//将子的对象赋值给父</span></span><br><span class="line">        Fu5 f2 = <span class="keyword">new</span> Zi5();</span><br><span class="line">        <span class="comment">//将父的引用赋值给子的引用</span></span><br><span class="line">        Zi5 z = (Zi5)f2;</span><br><span class="line">        z.show();</span><br><span class="line">        z.function();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是子类重写父类的方法</span></span><br><span class="line"><span class="comment">//这是子类重写父类的方法</span></span><br><span class="line"><span class="comment">//这是子类特有的方法</span></span><br></pre></td></tr></table></figure><p>内存结构图如下所示:</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210903181523.png"></p><p> 但是要注意一点的就是，多态转型中有一种异常，如下所示</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal5</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog5</span> <span class="keyword">extends</span> <span class="title">Animal5</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lookDoor</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat5</span> <span class="keyword">extends</span> <span class="title">Animal5</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paShu</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolymorphicDemo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal5 a = <span class="keyword">new</span> Dog5();</span><br><span class="line">        a.eat();</span><br><span class="line"><span class="comment">//        a.lookDoor();</span></span><br><span class="line"></span><br><span class="line">        Dog5 d = (Dog5) a;  <span class="comment">//在我自己看来，这地方就直接相当于是：Dog5 d = new Dog5() ，就可以直接使用Dog5里面所有的东西了</span></span><br><span class="line">    </span><br><span class="line">        a = <span class="keyword">new</span> Cat5();</span><br><span class="line">        a.eat();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        ((Cat5) a).paShu();</span></span><br><span class="line"></span><br><span class="line">        Cat5 cat5 = (Cat5)a;</span><br><span class="line">        cat5.eat();</span><br><span class="line">        cat5.paShu();</span><br><span class="line">    </span><br><span class="line">        a = <span class="keyword">new</span> Animal5();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Dog5 dd = (Dog5)a;//因为这个a现在是赋给了cat，而这句话dog和cat，两个没有继承关系，所以报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存图如下所示:</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210903181733.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的代码块以及方法的重写</title>
      <link href="/2020/09/02/Java%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BB%A5%E5%8F%8A%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99/"/>
      <url>/2020/09/02/Java%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BB%A5%E5%8F%8A%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h1 id="Java中的代码块，继承以及方法的重写"><a href="#Java中的代码块，继承以及方法的重写" class="headerlink" title="Java中的代码块，继承以及方法的重写"></a>Java中的代码块，继承以及方法的重写</h1><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>Java中，使用{}括起来的称为代码块，根据其位置和声明的不同，可以分为局部代码块、构造代码块、静态代码块、同步代码块（多线程再涉及）</p><h3 id="局部代码块"><a href="#局部代码块" class="headerlink" title="局部代码块"></a>局部代码块</h3><p>在方法中出现：限定变量的生命周期，及早释放，提高内存利用<br>只有这一种在一个类出现的时候执行顺序是自上而下的</p><h3 id="构造代码块："><a href="#构造代码块：" class="headerlink" title="构造代码块："></a>构造代码块：</h3><p>在类中方法外出现，多个构造方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行</p><h3 id="静态代码块："><a href="#静态代码块：" class="headerlink" title="静态代码块："></a>静态代码块：</h3><p>在方法外出现，加上static修饰，用于给类进行初始化，在加载的时候就执行，并且只执行一次</p><h4 id="执行顺序："><a href="#执行顺序：" class="headerlink" title="执行顺序："></a>执行顺序：</h4><p>局部代码块——静态代码块（有多少执行多少，只执行一次，自上而下）——构造代码块——构造方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Code</span></span>&#123;</span><br><span class="line">    <span class="comment">//静态代码块</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">200</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    Code()&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">300</span>;</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">100</span>;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">100</span>;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> y = <span class="number">200</span>;</span><br><span class="line">            System.out.println(y);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line">        Code c = <span class="keyword">new</span> Code();</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line">        Code c1 = <span class="keyword">new</span> Code();</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line">        Code c2 = <span class="keyword">new</span> Code();</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//100</span></span><br><span class="line"><span class="comment">//200</span></span><br><span class="line"><span class="comment">//----------------------</span></span><br><span class="line"><span class="comment">//200</span></span><br><span class="line"><span class="comment">//100</span></span><br><span class="line"><span class="comment">//300</span></span><br><span class="line"><span class="comment">//----------------------</span></span><br><span class="line"><span class="comment">//100</span></span><br><span class="line"><span class="comment">//300</span></span><br><span class="line"><span class="comment">//----------------------</span></span><br><span class="line"><span class="comment">//100</span></span><br><span class="line"><span class="comment">//300</span></span><br><span class="line"><span class="comment">//----------------------</span></span><br><span class="line"></span><br><span class="line">先执行主函数中的局部代码块，输出<span class="number">100</span>、<span class="number">200</span>，之后是<span class="keyword">new</span>了一个Code对象出来，执行的是静态代码块（一次），再到构造代码块，再到构造方法。</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h3><p>多个类中存在相同的属性和行为时，将这些内容抽取到单独的一个类，那么多个类无需再定义这些属性和行为，只要继承这个类即可<br>通过extends关键字可以实现类与类的继承</p><blockquote><pre><code>  class 子类名 extends 父类名 &#123;&#125;</code></pre></blockquote><p>单独的这个类称为父类，基类或者超类；这多个类可以称为子类或者派生类<br>有了继承之后，我们定义一个类的时候，可以在已经存在的类的基础上，还可以定义自己的新成员。</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处:"></a>好处:</h3><p>提高了代码的复用性</p><p>提高了代码的维护性</p><p>让类与类之间产生关系，为后面的多态做准备</p><h3 id="坏处"><a href="#坏处" class="headerlink" title="坏处:"></a>坏处:</h3><p>类的耦合性增强了<br>开发的原则：低耦合、高内聚<br>耦合：类与类之间的关系<br>内聚：就是自己完成某件事情的能力</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person1</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学习&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student1</span> <span class="keyword">extends</span> <span class="title">Person1</span></span>&#123; <span class="comment">//Student1是继承Person1来的，或者说是继承自Person1的子类</span></span><br><span class="line">    String stuId;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打游戏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher1</span> <span class="keyword">extends</span> <span class="title">Person1</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student1 student1 = <span class="keyword">new</span> Student1();</span><br><span class="line">        student1.eat();</span><br><span class="line">        student1.sleep();</span><br><span class="line">        student1.study();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        Teacher1 teacher1 = <span class="keyword">new</span> Teacher1();</span><br><span class="line">        teacher1.eat();</span><br><span class="line">        teacher1.sleep();</span><br><span class="line">        teacher1.study();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//吃饭</span></span><br><span class="line"><span class="comment">//睡觉</span></span><br><span class="line"><span class="comment">//学习</span></span><br><span class="line"><span class="comment">//----------------------------</span></span><br><span class="line"><span class="comment">//吃饭</span></span><br><span class="line"><span class="comment">//睡觉</span></span><br><span class="line"><span class="comment">//学习</span></span><br><span class="line"></span><br><span class="line">继承很好的提高了代码的复用性</span><br></pre></td></tr></table></figure><h3 id="Java中继承的特点："><a href="#Java中继承的特点：" class="headerlink" title="Java中继承的特点："></a>Java中继承的特点：</h3><p>  Java只支持单继承，不支持多继承</p><p>  Java支持多层基础（继承体系）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//class Father&#123;&#125;</span></span><br><span class="line"><span class="comment">//class Mother&#123;&#125;</span></span><br><span class="line"><span class="comment">//class Son extends Father&#123;&#125;</span></span><br><span class="line"><span class="comment">//class Son extends Father,Mother&#123;&#125;//错误</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrandFather</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是爷爷&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">GrandFather</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是爸爸&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是儿子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son son = <span class="keyword">new</span> Son();</span><br><span class="line">        son.show2();</span><br><span class="line">        son.show1();</span><br><span class="line">        son.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是儿子</span></span><br><span class="line"><span class="comment">//这是爸爸</span></span><br><span class="line"><span class="comment">//这是爷爷</span></span><br></pre></td></tr></table></figure><h3 id="使用继承的注意事项："><a href="#使用继承的注意事项：" class="headerlink" title="使用继承的注意事项："></a>使用继承的注意事项：</h3><p>  子类只能继承父类所有的非私有的成员（非私有的成员方法和非私有的成员变量）</p><p>  子类不能继承父类的构造方法，但是可以通过super关键字来访问父类的构造方法</p><p>  不要为了部分功能而去继承</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">通过观察发现，出现了一个show2()方法，在类A和类B中都出现了，用继承实现</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这样继承，我们发现show1()并不是我们B类中方法，但是我们一并继承过来了</span></span><br><span class="line"><span class="comment">//使用继承的情况：is a</span></span><br><span class="line"><span class="comment">//满足这一条件就可以使用继承</span></span><br><span class="line"><span class="comment">//Person</span></span><br><span class="line"><span class="comment">//Student</span></span><br><span class="line"><span class="comment">//Teacher</span></span><br><span class="line"><span class="comment">//Doctor</span></span><br></pre></td></tr></table></figure><h3 id="继承与成员变量的关系："><a href="#继承与成员变量的关系：" class="headerlink" title="继承与成员变量的关系："></a>继承与成员变量的关系：</h3><h4 id="类的组成："><a href="#类的组成：" class="headerlink" title="类的组成："></a>类的组成：</h4><p>成员变量<br>成员方法<br>构造方法<br>引入继承之后，我们开始考虑继承与这些的关系<br>1、当父类的成员变量与子类的成员变量不一样的时候<br>2、当父类的成员变量与子类的成员变量一样的时候<br>查找顺序：<br>1、在子类方法的局部范围找，找到返回<br>2、在子类方法的成员范围找，找到返回<br>3、在父类方法的成员范围找，找到返回<br>4、都找不到，报错</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father2</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num3 = <span class="number">50</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span> <span class="keyword">extends</span> <span class="title">Father2</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">30</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">40</span>;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(num2);</span><br><span class="line"><span class="comment">//        System.out.println(num3);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son2 son2 = <span class="keyword">new</span> Son2();</span><br><span class="line">        son2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//40</span></span><br><span class="line"><span class="comment">//20</span></span><br></pre></td></tr></table></figure><h2 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h2><p>当我们不仅想输出局部范围的num，还想输出父类中的num，我们应该怎么做呢<br>Java中提供了一个关键字：super</p><h4 id="super和this的区别是什么呢？（面试题）"><a href="#super和this的区别是什么呢？（面试题）" class="headerlink" title="super和this的区别是什么呢？（面试题）"></a>super和this的区别是什么呢？（面试题）</h4><p>this代表当前对象的引用<br>super代表的是父类存储空间的标识（可以操作父类的成员）</p><h4 id="怎么使用？"><a href="#怎么使用？" class="headerlink" title="怎么使用？"></a>怎么使用？</h4><h5 id="调用成员变量"><a href="#调用成员变量" class="headerlink" title="调用成员变量"></a>调用成员变量</h5><p>this.成员变量 调用的是本类的成员变量<br>super.成员变量 调用的是父类的成员变量<br>访问构造方法（子父类的构造方法）<br>this(…) super(…)<br>访问成员方法<br>this.成员方法() super.成员方法()<br>super关键字的使用举例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father3</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son3</span> <span class="keyword">extends</span> <span class="title">Father3</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">30</span>;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.num);</span><br><span class="line">        System.out.println(<span class="keyword">super</span>.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son3 son3 = <span class="keyword">new</span> Son3();</span><br><span class="line">        son3.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//30</span></span><br><span class="line"><span class="comment">//20</span></span><br><span class="line"><span class="comment">//10</span></span><br></pre></td></tr></table></figure><h3 id="继承与构造方法的关系"><a href="#继承与构造方法的关系" class="headerlink" title="继承与构造方法的关系"></a>继承与构造方法的关系</h3><p>   子类中所有的构造方法默认都会访问父类中空参的构造方法</p><p>   为什么？<br>   因为子类会继承父类的数据，可能还会使用父类的数据<br>   所以在初始化子类之前，一定会先完成父类的初始化</p><p> 注意：<br>   每一个子类的构造方法的第一句话默认都是super()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father4</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是父类的无参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father4</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是父类的有参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son4</span> <span class="keyword">extends</span> <span class="title">Father4</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是子类的无参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son4</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是子类的有参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son4 son4 = <span class="keyword">new</span> Son4();</span><br><span class="line">        Son4 son5 = <span class="keyword">new</span> Son4(<span class="string">&quot;祥哥&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是父类的无参构造方法</span></span><br><span class="line"><span class="comment">//这是子类的无参构造方法</span></span><br><span class="line"><span class="comment">//这是父类的无参构造方法</span></span><br><span class="line"><span class="comment">//这是子类的有参构造方法</span></span><br></pre></td></tr></table></figure><p>但是，当父类没有无参构造方法的时候，怎么办呢</p><p>使用super带参的形式去访问父类的带参构造方法<br>子类通过this去调用本类的其他构造方法<br>本类其他构造方法也必须首先访问父类的构造方法<br>使用this就是间接的调用super去访问父类的构造方法<br>注意事项：</p><p>super(…)或者this(…)必须出现在第一条语句上<br>否则，就会有父类数据的多次初始化，每个类只能初始化一次</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father5</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的无参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father5</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的有参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son5</span> <span class="keyword">extends</span> <span class="title">Father5</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();<span class="comment">//JVM虚拟机会默认在调用子类构造方法的时候添加一个super()，而且必须放在第一句</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类的无参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son5</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        this(&quot;hb&quot;);</span></span><br><span class="line">        <span class="keyword">super</span>(<span class="string">&quot;hb&quot;</span>);<span class="comment">//这是调用父类的有参构造方法</span></span><br><span class="line">        <span class="comment">//这里的this或者super只能出现一个，我的解释是：如果出现多个，或者同时出现</span></span><br><span class="line">        <span class="comment">//会造成父类数据的多次初始化，但每个类只能初始化一次</span></span><br><span class="line">        <span class="comment">//使用super可以理解是父类的带参的调用</span></span><br><span class="line">        <span class="comment">//使用this时，也需要继承父类，，也会有super的出现，所以也会造成父类的初始化</span></span><br><span class="line">        <span class="comment">//所以只能有一个</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类的带参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son5 son5 = <span class="keyword">new</span> Son5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承中成员方法的关系："><a href="#继承中成员方法的关系：" class="headerlink" title="继承中成员方法的关系："></a>继承中成员方法的关系：</h3><p>子类的成员方法与父类的成员方法不一样</p><p>子类的成员方法与父类的成员方法一样的时候，怎么办</p><p>​    先找到子类，有没有这个方法，如果有，就调用</p><p>​    如果子类中没有这个方法，就去父类中找，如果有，就调用</p><p>​    如果都没有，就报错 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father6</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is show()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son6</span> <span class="keyword">extends</span> <span class="title">Father6</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is son6 show2()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public void show()&#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;this is son6 show()&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son6 son6 = <span class="keyword">new</span> Son6();</span><br><span class="line">        son6.show();</span><br><span class="line">        son6.show2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//this is show()</span></span><br><span class="line"><span class="comment">//this is son6 show2()</span></span><br></pre></td></tr></table></figure><h2 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h2><p>方法的重写：<br>子类中如果出现了和父类中一模一样的方法声明，也被称为方法覆盖，方法复写</p><p>方法的重载：<br>本类中出现了方法名一样，参数列表不一样的方法，与返回值无关</p><p>子类的成员方法与父类的成员方法一样的时候，怎么办<br>1、先找子类中，有没有这个方法，如果有，就调用<br>2、如果子类中没有该方法，就去父类中查找，如果有，就调用<br>3、如果都没有，就报错</p><h3 id="方法重写的注意事项"><a href="#方法重写的注意事项" class="headerlink" title="方法重写的注意事项:"></a>方法重写的注意事项:</h3><p>1、父类的私有方法不能被重写<br>2、子类重写父类方法时，访问权限不能低<br>要么子类重写的方法比父类的权限高，要么一样<br>3、父类的静态方法，子类也必须通过静态方法进行重写（其实算不上重写）</p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造方法以及静态的main方法</title>
      <link href="/2020/09/02/%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E9%9D%99%E6%80%81%E7%9A%84main%E6%96%B9%E6%B3%95/"/>
      <url>/2020/09/02/%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E9%9D%99%E6%80%81%E7%9A%84main%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="构造方法以及静态的main方法"><a href="#构造方法以及静态的main方法" class="headerlink" title="构造方法以及静态的main方法"></a>构造方法以及静态的main方法</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>概述：<br>给对象的数据进行初始化。</p><h3 id="构造方法格式："><a href="#构造方法格式：" class="headerlink" title="构造方法格式："></a>构造方法格式：</h3><p>方法名和类名相同<br>没有返回值，连void都没有<br>没有具体的返回值</p><h3 id="构造方法的注意事项："><a href="#构造方法的注意事项：" class="headerlink" title="构造方法的注意事项："></a>构造方法的注意事项：</h3><p>如果不提供构造方法，系统会默认给出构造方法<br>如果自己提供了构造方法，系统将不再提供<br>构造方法也可以重载</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contruction</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    Contruction()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这就是一个构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContructionDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Contruction contruction = <span class="keyword">new</span> Contruction();</span><br><span class="line">        System.out.println(contruction);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这就是一个构造方法</span></span><br><span class="line"><span class="comment">//com.bigdata.shujia10.Contruction@28d93b30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我们可以看到，在这里，我们只是new了一个contruction，就直接打印出来了“这是一个构造方法”，就是因为我们自己定义了一个构造方法，并给了它一个print</span></span><br></pre></td></tr></table></figure><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>1、如果我们没有给出构造方法，JVM会自动给我们提供一个无参构造方法<br>2、如果我们给出了构造方法，JVM就不再提供默认的无参构造方法。<br>这时候如果我们还想使用无参构造方法，就必须要自己给出来，JVM一旦发现我们自己给出了构造方法（不管是有参还是无参，只要我们自己定义了），就永远不会给出默认的构造方法。<br>3、构造方法可以发生重载（方法名一致，参数列表不一样）。</p><h3 id="构造方法的作用："><a href="#构造方法的作用：" class="headerlink" title="构造方法的作用："></a>构造方法的作用：</h3><p>可以给成员变量赋初始化值。<br>给成员变量赋值的两种方式：<br>1、使用setXxx()的形式给私有的成员变量赋值<br>2、使用带参数的构造方法给私有成员变量赋值，配合this指针使用<br>无参有参构造方法举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contruction2</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    Contruction2()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个无参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Contruction2(String name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是带有参数name的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Contruction2(<span class="keyword">int</span> age)&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是带有参数age的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Contruction2(String name,<span class="keyword">int</span> age)&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是带有参数name和参数age的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name+<span class="string">&quot;---&quot;</span>+<span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContructionDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里调用无参构造方法</span></span><br><span class="line">        Contruction2 contruction2 = <span class="keyword">new</span> Contruction2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里调用一个参数的构造方法</span></span><br><span class="line">        Contruction2 contruction21 = <span class="keyword">new</span> Contruction2(<span class="string">&quot;酷酷的涛&quot;</span>);</span><br><span class="line">        Contruction2 contruction22 = <span class="keyword">new</span> Contruction2(<span class="number">22</span>);</span><br><span class="line">        System.out.println(contruction22.getName()+<span class="string">&quot;---&quot;</span>+contruction22.getAge());</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//这里调用两个参数的构造方法</span></span><br><span class="line">        Contruction2 contruction23 = <span class="keyword">new</span> Contruction2(<span class="string">&quot;酷酷的涛&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        contruction23.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是一个无参构造方法</span></span><br><span class="line"><span class="comment">//这是带有参数name的构造方法</span></span><br><span class="line"><span class="comment">//这是带有参数age的构造方法</span></span><br><span class="line"><span class="comment">//null---22</span></span><br><span class="line"><span class="comment">//这是带有参数name和参数age的构造方法</span></span><br><span class="line"><span class="comment">//酷酷的涛---22</span></span><br></pre></td></tr></table></figure><h2 id="类的组成："><a href="#类的组成：" class="headerlink" title="类的组成："></a>类的组成：</h2><p>成员变量<br>构造方法<br>成员方法<br>根据返回值：<br>void，无返回值类型<br>非void的有参构造类型<br>形式参数：<br>空参的构造方法<br>有参的构造方法</p><p>当我们在new对象的时候，其实JVM给出了一系列运行，如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;亚当&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">    Person()&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">&quot;夏娃&quot;</span>;</span><br><span class="line">        <span class="keyword">this</span>.age = <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name+<span class="string">&quot;---&quot;</span>+<span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.show();</span><br><span class="line"><span class="comment">//        System.out.println();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图解如下所示:</p><p><img src="https://i.loli.net/2021/09/02/LlcPKZzSvtf6s4a.png"></p><blockquote><p>首先是<br>将Person.class文件加载到方法区<br>再在栈中给person开辟一个栈内存空间<br>再在堆中给person开辟一个堆内存空间<br>紧接着JVM给成员变量赋予初始值，一个是null，一个是0<br>再给成员变量进行初始化<br>再通过构造方法对成员变量进行初始化<br>数据初始化完毕，将内存中的地址给栈引用</p></blockquote><h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>可以修饰成员变量和成员方法<br>static关键字的特点：<br>随着类的加载而加载<br>优先于对象存在<br>被类的所有对象共享（这也是判断是否使用静态关键字的条件）<br>可以通过类名调用<br>static关键字注意事项：<br>在静态方法中是没有this关键字的<br>静态方法只能访问静态的成员变量和静态的成员方法<br>一般情况下，只要看到一个类中有静态修饰的成员变量或者是成员方法，我们一律采用 类名.静态成员 这种方法使用<br>推荐使用类名调用<br>静态修饰的内容我们一般称为：类成员、与类相关的</p><h3 id="static关键字使用的注意事项"><a href="#static关键字使用的注意事项" class="headerlink" title="static关键字使用的注意事项"></a>static关键字使用的注意事项</h3><p>在静态方法中是没有this关键字的<br>静态方法：<br>访问内容：<br>成员变量：只能访问静态的成员变量<br>成员方法：只能访问静态的成员方法<br>非静态方法：<br>访问内容：<br>成员变量：既可以访问静态的成员变量，也可以访问非静态的成员变量<br>成员方法：既可以访问静态的成员方法，也可以访问非静态的成员方法<br>也就是：静态的只能访问静态的。</p><p>举例：静态的只能访问静态的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span></span>&#123;</span><br><span class="line">    <span class="comment">//非静态的成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//静态的成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非静态的成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(num2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//静态的成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//System.out.println(this.num);//无法从静态上下文中引用非静态 变量 this</span></span><br><span class="line">        System.out.println(num2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//静态的成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//非静态的成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Teacher teacher = <span class="keyword">new</span> Teacher();</span><br><span class="line">        teacher.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//10</span></span><br><span class="line"><span class="comment">//20 </span></span><br></pre></td></tr></table></figure><p>此时的内存静态图如下所示:</p><p><img src="https://i.loli.net/2021/09/02/jJ2YFmhPZy3Cdt5.png"></p><p>static随着类的加载而加载</p><h4 id="static内存图。"><a href="#static内存图。" class="headerlink" title="static内存图。"></a>static内存图。</h4><p>用下面这些代码来解释在有static静态关键字的时候，内存是如果工作的。<br>将内存分为 栈、堆、方法区、静态区<br>首先方法里面有 class文件区、Human的方法区、静态区<br>1、首先运行主函数main，在栈中开辟main(String[] args)空间<br>2、紧接着到了函数Human h1 = new Human(“朱一龙”,41,“中国”);<br>3、在堆中new了一个空间出来，地址是0x0001，给name和age赋<br>初始值，Human中又包括了静态引用和方法引用。<br>h1指向0x0001，之后将name赋值为“朱一龙”，将<br>age赋值为41，紧接着到了静态引用，将country赋值为中国<br>再到了方法引用，然后到了方法引用，里面包括了构造方法和<br>show方法，之后展示数据</p><p>之后就在不断的重复这一过程。</p><p>main方法的格式讲解<br>main方法的格式讲解：<br><code>public static void main(String[] args) &#123;…&#125;</code></p><p>public: 公共的，访问权限是最大的。JVM默认的就是它。<br>    由于main方法是被JVM调用的，所以他的权限要是最大的。<br>static:静态的，不需要创建对象，通过类名就可以调用，方便我们JVM虚拟机调用<br>void:无返回值的意思，一般情况下，方法写返回是为了将结果返回给调用者，<br>   而main方法是被JVM虚拟机调用的，写返回内容没有意义。<br>main:是一个方法名，也是java程序的入口方法。大部分的语言入口的名字都是main<br>    小部分的程序入口方法不是main,例如C语言，底层调用的是_start</p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础小知识</title>
      <link href="/2020/09/02/Java%E5%9F%BA%E7%A1%80%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/09/02/Java%E5%9F%BA%E7%A1%80%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="主要说说成员变量与局部变量的区别、形式参数、匿名对象与Java的封装性。"><a href="#主要说说成员变量与局部变量的区别、形式参数、匿名对象与Java的封装性。" class="headerlink" title="主要说说成员变量与局部变量的区别、形式参数、匿名对象与Java的封装性。"></a>主要说说成员变量与局部变量的区别、形式参数、匿名对象与Java的封装性。</h1><h2 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h2><h3 id="在类中定义的位置不同："><a href="#在类中定义的位置不同：" class="headerlink" title="在类中定义的位置不同："></a>在类中定义的位置不同：</h3><p>成员变量：类中，但是定义在方法外。<br>局部变量：定义在方法类中。</p><h3 id="在内存中的位置不同："><a href="#在内存中的位置不同：" class="headerlink" title="在内存中的位置不同："></a>在内存中的位置不同：</h3><p>成员变量：定义在堆中。<br>局部变量：定义在栈中。</p><h3 id="生命周期不同："><a href="#生命周期不同：" class="headerlink" title="生命周期不同："></a>生命周期不同：</h3><p>成员变量：随着对象的创建而存在，随着对象的结束而结束。<br>局部变量：随着方法的调用而存在，随着方法的结束而结束。</p><h3 id="初始化值不同："><a href="#初始化值不同：" class="headerlink" title="初始化值不同："></a>初始化值不同：</h3><p>成员变量：有默认的初始化值，比如int给的是0，String类型给的是null<br>局部变量：没有系统给它初始化值，必须在定义的时候给它赋值，才能使用。<br>注意：<br>1、方法与方法之间里面的局部变量不能互相调用。<br>2、局部变量可以和成员变量一样，在方法中使用的时候，采用就近原则。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BianLiang</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        int n1;</span></span><br><span class="line">        <span class="keyword">int</span>  n1 = <span class="number">22</span>;</span><br><span class="line">        String name = <span class="string">&quot;酷酷的涛&quot;</span>;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(n1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BianLiangDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BianLiang b1 = <span class="keyword">new</span> BianLiang();</span><br><span class="line">        b1.show(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//访问成员变量</span></span><br><span class="line">        System.out.println(b1.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//酷酷的涛</span></span><br><span class="line"><span class="comment">//22</span></span><br><span class="line"><span class="comment">//null</span></span><br></pre></td></tr></table></figure><h2 id="形式参数的问题"><a href="#形式参数的问题" class="headerlink" title="形式参数的问题"></a>形式参数的问题</h2><p>在调用方法时，括号里面的参数有两种类型，一种是基本数据类型，一种是引用数据类型。<br>基本数据类型：形式参数的改变不会影响到实际参数。<br>引用数据类型：形式参数的改变会直接影响到实际参数。</p><h2 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h2><p>匿名对象：就是没有名字的对象。<br>匿名对象的使用场景：<br>1、调用方法的时候，仅仅调用一次的时候，调用多次的时候，不适合。<br>为什么会存在匿名对象？<br>因为匿名调用完毕之后，由于栈内存中没有引用指向它，那么调用完毕之后就是垃圾，可以被垃圾回收器回收。<br>2、匿名对象可以作为实际参数进行传递。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;手机可以打电话。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone1Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">(Phone1 p)</span> </span>&#123;</span><br><span class="line">        p.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个Phone1对象</span></span><br><span class="line">        Phone1 p = <span class="keyword">new</span> Phone1();</span><br><span class="line">        p.call();</span><br><span class="line">        <span class="comment">//创建一个Phone1Demo对象</span></span><br><span class="line">        Phone1Demo p1 = <span class="keyword">new</span> Phone1Demo();</span><br><span class="line">        p1.function(p);</span><br><span class="line">        System.out.println(<span class="string">&quot;******************使用匿名类进行改进***********************&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Phone1().call();</span><br><span class="line">        <span class="keyword">new</span> Phone1Demo().function(p);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//手机可以打电话。</span></span><br><span class="line"><span class="comment">//手机可以打电话。</span></span><br><span class="line"><span class="comment">//******************使用匿名类进行改进***********************</span></span><br><span class="line"><span class="comment">//手机可以打电话。</span></span><br><span class="line"><span class="comment">//手机可以打电话。</span></span><br></pre></td></tr></table></figure><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h3 id="封装：其实就是指隐藏对象的属性和相关实现细节，仅仅对外提供公共访问的方式。Java中提供了一个关键字：private"><a href="#封装：其实就是指隐藏对象的属性和相关实现细节，仅仅对外提供公共访问的方式。Java中提供了一个关键字：private" class="headerlink" title="封装：其实就是指隐藏对象的属性和相关实现细节，仅仅对外提供公共访问的方式。Java中提供了一个关键字：private"></a>封装：其实就是指隐藏对象的属性和相关实现细节，仅仅对外提供公共访问的方式。Java中提供了一个关键字：private</h3><p>private：私有的，可以修饰成员变量和成员方法。<br>注意：被private修饰的成员变量或者是成员方法，只能在本类中访问</p><blockquote><p>对private的使用<br>1、对成员变量用private进行修饰<br>2、提供对应的getXxx()和setXxx()方法</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student2</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义成员变量</span></span><br><span class="line">    <span class="comment">//年龄</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age ;</span><br><span class="line">    <span class="comment">//姓名</span></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> a )</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;<span class="number">0</span> || a&gt;=<span class="number">200</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;赋值的年龄有问题&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            age = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄是：&quot;</span>+age);</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名是：&quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student2 stu2 = <span class="keyword">new</span> Student2();</span><br><span class="line">        stu2.setAge(<span class="number">22</span>);</span><br><span class="line"><span class="comment">//        stu2.age = 1000;    //这时，这一行直接报错，因为age被定义为私有属性，不能被直接访问</span></span><br><span class="line">        stu2.name = <span class="string">&quot;酷酷的涛&quot;</span>;</span><br><span class="line">        stu2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//年龄是：22</span></span><br><span class="line"><span class="comment">//姓名是：酷酷的涛</span></span><br></pre></td></tr></table></figure><h2 id="This关键字"><a href="#This关键字" class="headerlink" title="This关键字"></a>This关键字</h2><p>变量的使用原则：就近原则<br>直接通过类名.成员变量是报错的<br>如果这个Student3这个对象存在，它就代表着一个学生对象<br>但是，谁可以代表这个当前类的对象呢<br>Java中提供了一个关键字：this<br>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student3</span></span>&#123;</span><br><span class="line">    <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//年龄</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对name成员变量进行赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="comment">//变量的使用原则：就近原则</span></span><br><span class="line">        <span class="comment">//直接通过类名.成员变量是报错的，目前还没有说过类似的用法，所以这个是有问题的</span></span><br><span class="line">        <span class="comment">//如果这个Student3这个对象存在，他就代表着一个学生对象</span></span><br><span class="line">        <span class="comment">//但是，谁可以代表这个当前类的对象呢？</span></span><br><span class="line">        <span class="comment">//Java就提供了一个关键字：this</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student3 stu3 = <span class="keyword">new</span> Student3();</span><br><span class="line">        stu3.setAge(<span class="number">22</span>);</span><br><span class="line">        stu3.setName(<span class="string">&quot;酷酷的涛&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> age = stu3.getAge();</span><br><span class="line">        String name = stu3.getName();</span><br><span class="line">        System.out.println(name+<span class="string">&quot;**********&quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//酷酷的涛**********22</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据加密---Java实现</title>
      <link href="/2020/09/02/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86-Java%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/09/02/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86-Java%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="数据加密–Java实现"><a href="#数据加密–Java实现" class="headerlink" title="数据加密–Java实现"></a>数据加密–Java实现</h1><p>某个公司采用公用电话传递数据信息，数据是小于8位的整数，为了确保安全，在传递过程中需要加密，加密规则如下：<br>首先将数据倒序，然后将每位数字都加上5，再用和除以10的余数代替该数字，<br>最后将第一位和最后一位数字交换。 请任意给定一个小于8位的整数，<br>然后，把加密后的结果在控制台打印出来。<br>代码实现如下所示:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShuJuJiaMiDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个数据</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">123456</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个数组</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];</span><br><span class="line">        <span class="comment">//把数据上的每一位数字按照顺序放到数组中</span></span><br><span class="line">        <span class="comment">//由于，我们已经获取到了每一个数字了，所以我们干脆直接逆序赋值</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        int index = 0;</span></span><br><span class="line"><span class="comment">        arr[index] = num%10;</span></span><br><span class="line"><span class="comment">        index++;</span></span><br><span class="line"><span class="comment">        arr[index] = num/10%10;</span></span><br><span class="line"><span class="comment">        index++;</span></span><br><span class="line"><span class="comment">        arr[index] = num/10/10%10;</span></span><br><span class="line"><span class="comment">        index++;</span></span><br><span class="line"><span class="comment">        arr[index] = num/10/10/10%10;</span></span><br><span class="line"><span class="comment">        index++;</span></span><br><span class="line"><span class="comment">        arr[index] = num/10/10/10/10%10;</span></span><br><span class="line"><span class="comment">        index++;</span></span><br><span class="line"><span class="comment">        arr[index] = num/10/10/10/10/10%10;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">//用while循环改进，由于今后我们会手动输入整数，不确定长度</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            arr[index] = num%<span class="number">10</span>;</span><br><span class="line">            index++;</span><br><span class="line">            num = num/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将每位数字都加上5，再用和除以10的余数代替该数字</span></span><br><span class="line">        <span class="comment">//由于我们在给数组赋值的时候，循环结束的条件是num &gt; 0，index的变化只变化到数据的长度对应的索引+1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">            arr[i]+=<span class="number">5</span>;</span><br><span class="line">            arr[i]%=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">//最后将第一位和最后一位数字交换</span></span><br><span class="line">        <span class="keyword">int</span> tmp = arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>]=arr[index-<span class="number">1</span>];</span><br><span class="line">        arr[index-<span class="number">1</span>] = tmp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;123456加密后的数据是：&quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">            System.out.print(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类与对象</title>
      <link href="/2020/09/02/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/09/02/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><h2 id="引入面向对象的思想："><a href="#引入面向对象的思想：" class="headerlink" title="引入面向对象的思想："></a>引入面向对象的思想：</h2><p>当我们有多个数组需要遍历时，我们可以将遍历的代码封装到方法中，需要遍历时，只需要调用相应的方法即可，提高代码的复用性。<br>但当我们对数组做更多的操作时，比如对数组获取最值，数值逆序，就需要将更多的功能封装到相应的方法中，封装的方法越来越多，我们就可以将这些方法继续封装，将来再做数组的操作时，就不用找具体的方法，先找到这个类，再使用这个类中的方法，这就是面向对象思想的编程。</p><h3 id="面向对象的思想："><a href="#面向对象的思想：" class="headerlink" title="面向对象的思想："></a>面向对象的思想：</h3><p>面向对象的思想是基于面向过程的编程思想</p><h3 id="面向过程：强调的是每个功能的步骤（比如C语言）"><a href="#面向过程：强调的是每个功能的步骤（比如C语言）" class="headerlink" title="面向过程：强调的是每个功能的步骤（比如C语言）"></a>面向过程：强调的是每个功能的步骤（比如C语言）</h3><h3 id="面向对象：强调的是对象，然后让这个对象去调用功能"><a href="#面向对象：强调的是对象，然后让这个对象去调用功能" class="headerlink" title="面向对象：强调的是对象，然后让这个对象去调用功能"></a>面向对象：强调的是对象，然后让这个对象去调用功能</h3><p>面向对象的特点：<br>1）是一种更符合我们思想习惯的概念<br>2）可以将复杂的事情简单化<br>3）将我们从执行者变成了指挥者</p><p>举例：<br>吃饭：<br>面向过程：先去超市买菜–洗菜–切菜–炒菜–装盘–吃<br>面向对象：去饭店吃–你（点菜）–厨师（做菜）–服务员（上菜）–你（吃）<br>打水：<br>面向过程：拿起水杯–走到饮水机面前–选择热水还是冷水–接水–喝<br>面向对象：你祈求同桌去接水–同桌接水–你喝水</p><p>将大象装进冰箱<br>面向过程的思路：<br>1、打开冰箱门<br>2、把大象装进冰箱<br>3、关闭冰箱门<br>代码体现：</p><p>代码体现：  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">              <span class="comment">//System.out.println(&quot;打开冰箱门&quot;);</span></span><br><span class="line">              <span class="comment">//打开冰箱门这个动作，肯定不是这么一个简单输出语句就完事了</span></span><br><span class="line">              <span class="comment">//现在是仅仅是为了演示，就写了这么一个输出语句</span></span><br><span class="line">              <span class="comment">//假设我们要打开很多次冰箱门，就要写很多次这个代码</span></span><br><span class="line">              <span class="comment">//需要用方法改进</span></span><br><span class="line">          open();</span><br><span class="line">          zhuang();</span><br><span class="line">          close();</span><br><span class="line">  </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;打开冰箱门&quot;</span>);​       </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zhuang</span><span class="params">()</span></span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;把大象装进冰箱&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;关闭冰箱门&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="面向对象的思想体现："><a href="#面向对象的思想体现：" class="headerlink" title="面向对象的思想体现："></a>面向对象的思想体现：</h3><p>我们怎么才能更符合面向对象的思想呢？<br>1、我们要考虑有哪些类？<br>2、这些每个类里面都有些什么呢？<br>3、类与类之间的关系是什么样子的呢？</p><p>把大象装进冰箱的分析：（如何分析有哪些类呢？UML 名词提取法）<br>1、有哪些类呢？<br>大象<br>冰箱<br>测试类<br>2、这些每个类里面都有些什么呢？<br>大象：<br>进冰箱<br>冰箱：<br>打开冰箱门<br>关闭冰箱门<br>测试类：<br>main方法<br>代码体现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Elephant</span></span>&#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toBingXiang</span><span class="params">()</span></span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;装进冰箱&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Refrigerator</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;打开冰箱门&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;关闭冰箱门&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">            调用冰箱类中的打开冰箱门的open()方法</span><br><span class="line">            调用大象类中的装进冰箱的toBingXiang()方法</span><br><span class="line">            调用冰箱类中的关闭冰箱门的close()方法</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="面向对象的开发、设计、特征"><a href="#面向对象的开发、设计、特征" class="headerlink" title="面向对象的开发、设计、特征"></a>面向对象的开发、设计、特征</h3><p>面向对象的开发<br>就是不断的创建对象，使用对象，指挥对象做事情。</p><p>面向对象的设计<br>实就是在管理和维护对象之间的关系</p><h4 id="面向对象的特征"><a href="#面向对象的特征" class="headerlink" title="面向对象的特征"></a>面向对象的特征</h4><p>封装<br>继承<br>多态</p><h3 id="类与对象的概述："><a href="#类与对象的概述：" class="headerlink" title="类与对象的概述："></a>类与对象的概述：</h3><p>现实世界中是如何让描述一个事物呢？<br>举例：人<br>五官、姓名、年龄、性别…<br>吃饭、喝水、学习、玩…</p><blockquote><p>属性：事物的描述信息<br>行为：就是事物能够做什么</p></blockquote><p>我们学习编程语言，就是为了模拟现实世界的事物的。<br>而我们现在学习的语言是：java<br>而java中最基本的单位是：类<br>所以，我们通过java把事物用类给描述出来<br>由此可见，我们就可以得到现实生活中的事物与类之间的对应关系：</p><p>事物： 类：<br>属性：事物的描述信息 成员变量<br>行为：就是事物能够做什么 成员方法</p><p>类：是一组相关的属性和行为的集合。是一个抽象的概念。<br>对象：是该类事物的具体表现体现。具体到存在的个体。<br>举例：<br>事物：人 类：Person<br>属性：姓名、年龄、性别 成员变量：name、age、gender<br>行为：吃饭、喝水、学习 成员方法：eat、drink、study</p><p>对象：是该类事物的具体体现 举例：学生、老师、医生、程序员…</p><h4 id="类与对象举例展示"><a href="#类与对象举例展示" class="headerlink" title="类与对象举例展示"></a>类与对象举例展示</h4><p>定义一个手机类来进行测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pho</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义成员变量</span></span><br><span class="line">    <span class="comment">//品牌</span></span><br><span class="line">    String brand;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    String color;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义成员方法</span></span><br><span class="line">    <span class="comment">//打电话</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;给&quot;</span>+s+<span class="string">&quot;打电话...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发短信</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;群发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//玩游戏</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;玩游戏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过手机类创建手机对象</span></span><br><span class="line">        Pho p1 = <span class="keyword">new</span> Pho();</span><br><span class="line">        <span class="comment">//通过实例化出来的p1对象调用属性</span></span><br><span class="line">        System.out.println(p1.brand); <span class="comment">//null</span></span><br><span class="line">        System.out.println(p1.price); <span class="comment">//0</span></span><br><span class="line">        System.out.println(p1.color); <span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//给对象的成员变量赋值</span></span><br><span class="line">        p1.brand = <span class="string">&quot;华为&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        p1.price = &quot;9999&quot;; //注意  赋值需要注意成员变量的数据类型</span></span><br><span class="line">        p1.price = <span class="number">9999</span>;</span><br><span class="line">        p1.color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;手机的牌子是：&quot;</span>+p1.brand); <span class="comment">//&quot;华为&quot;</span></span><br><span class="line">        System.out.println(p1.brand+<span class="string">&quot;的价格是：&quot;</span>+p1.price); <span class="comment">//9999</span></span><br><span class="line">        System.out.println(p1.brand+<span class="string">&quot;的颜色是：&quot;</span>+p1.color); <span class="comment">//&quot;blue&quot;</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">//通过对象调用成员方法</span></span><br><span class="line">        p1.call(<span class="string">&quot;马云&quot;</span>); <span class="comment">//注意 调用对象的成员方法的时候，需要注意有无传参</span></span><br><span class="line">        p1.sendMessage();</span><br><span class="line">        p1.playGame();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">手机的牌子是：华为</span><br><span class="line">华为的价格是：<span class="number">9999</span></span><br><span class="line">华为的颜色是：blue</span><br><span class="line">给马云打电话...</span><br><span class="line">群发短信</span><br><span class="line">玩游戏</span><br></pre></td></tr></table></figure><p>一个对象的内存图解如下所示:</p><p><img src="https://i.loli.net/2021/09/02/7kA8BK4wqRy6nic.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pho1</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义成员变量</span></span><br><span class="line">    <span class="comment">//品牌</span></span><br><span class="line">    String brand;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    String color;</span><br><span class="line">    <span class="comment">//定义成员方法</span></span><br><span class="line">    <span class="comment">//打电话</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;给&quot;</span>+s+<span class="string">&quot;打电话...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发短信</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;群发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//玩游戏</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;玩游戏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建手机对象</span></span><br><span class="line">    Pho1 p1 = <span class="keyword">new</span> Pho1();</span><br><span class="line">    <span class="comment">//给对象的成员变量赋值</span></span><br><span class="line">    p1.brand = <span class="string">&quot;华为&quot;</span>;</span><br><span class="line"><span class="comment">//        p1.price = &quot;9999&quot;; //注意  赋值需要注意成员变量的数据类型</span></span><br><span class="line">    p1.price = <span class="number">9999</span>;</span><br><span class="line">    p1.color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">    System.out.println(p1.brand+<span class="string">&quot;,&quot;</span>+p1.price+<span class="string">&quot;,&quot;</span>+p1.color);</span><br><span class="line">    p1.call(<span class="string">&quot;小方&quot;</span>);</span><br><span class="line">    p1.sendMessage();</span><br><span class="line">    p1.playGame();</span><br><span class="line">    Pho1 p2 = <span class="keyword">new</span> Pho1();</span><br><span class="line">    <span class="comment">//给对象的成员变量赋值</span></span><br><span class="line">    p2.brand = <span class="string">&quot;小米&quot;</span>;</span><br><span class="line"><span class="comment">//        p1.price = &quot;9999&quot;; //注意  赋值需要注意成员变量的数据类型</span></span><br><span class="line">    p2.price = <span class="number">1999</span>;</span><br><span class="line">    p2.color = <span class="string">&quot;black&quot;</span>;</span><br><span class="line">    System.out.println(p2.brand+<span class="string">&quot;,&quot;</span>+p2.price+<span class="string">&quot;,&quot;</span>+p2.color);</span><br><span class="line">    p2.call(<span class="string">&quot;雷军&quot;</span>);</span><br><span class="line">    p2.sendMessage();</span><br><span class="line">    p2.playGame();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//华为,9999,blue</span></span><br><span class="line"><span class="comment">//给小方打电话...</span></span><br><span class="line"><span class="comment">//群发短信</span></span><br><span class="line"><span class="comment">//玩游戏</span></span><br><span class="line"><span class="comment">//小米,1999,black</span></span><br><span class="line"><span class="comment">//给雷军打电话...</span></span><br><span class="line"><span class="comment">//群发短信</span></span><br><span class="line"><span class="comment">//玩游戏</span></span><br></pre></td></tr></table></figure><p>两个对象的内存图解如下所示:</p><p><img src="https://i.loli.net/2021/09/02/w1CfPstNVqBx3ce.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pho2</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义成员变量</span></span><br><span class="line">    <span class="comment">//品牌</span></span><br><span class="line">    String brand;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    String color;</span><br><span class="line">    <span class="comment">//定义成员方法</span></span><br><span class="line">    <span class="comment">//打电话</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;给&quot;</span>+s+<span class="string">&quot;打电话...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发短信</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;群发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//玩游戏</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;玩游戏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建手机对象</span></span><br><span class="line">        Pho2 p1 = <span class="keyword">new</span> Pho2();</span><br><span class="line">        <span class="comment">//给对象的成员变量赋值</span></span><br><span class="line">        p1.brand = <span class="string">&quot;华为&quot;</span>;</span><br><span class="line"><span class="comment">//        p1.price = &quot;9999&quot;; //注意  赋值需要注意成员变量的数据类型</span></span><br><span class="line">        p1.price = <span class="number">9999</span>;</span><br><span class="line">        p1.color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">        System.out.println(p1.brand+<span class="string">&quot;,&quot;</span>+p1.price+<span class="string">&quot;,&quot;</span>+p1.color);</span><br><span class="line">        p1.call(<span class="string">&quot;杨老板&quot;</span>);</span><br><span class="line">        p1.sendMessage();</span><br><span class="line">        p1.playGame();</span><br><span class="line">        Pho2 p2 = <span class="keyword">new</span> Pho2();</span><br><span class="line">        <span class="comment">//给对象的成员变量赋值</span></span><br><span class="line">        p2.brand = <span class="string">&quot;小米&quot;</span>;</span><br><span class="line"><span class="comment">//        p1.price = &quot;9999&quot;; //注意  赋值需要注意成员变量的数据类型</span></span><br><span class="line">        p2.price = <span class="number">1999</span>;</span><br><span class="line">        p2.color = <span class="string">&quot;black&quot;</span>;</span><br><span class="line">        System.out.println(p2.brand+<span class="string">&quot;,&quot;</span>+p2.price+<span class="string">&quot;,&quot;</span>+p2.color);</span><br><span class="line">        p2.call(<span class="string">&quot;雷军&quot;</span>);</span><br><span class="line">        p2.sendMessage();</span><br><span class="line">        p2.playGame();</span><br><span class="line">        <span class="comment">//创建第三个对象</span></span><br><span class="line">        Pho2 p3 = p1;</span><br><span class="line">        p3.price = <span class="number">999</span>;</span><br><span class="line">        System.out.println(p1.price); <span class="comment">//999</span></span><br><span class="line">        System.out.println(p3.brand+<span class="string">&quot;,&quot;</span>+p3.price+<span class="string">&quot;,&quot;</span>+p3.color); <span class="comment">//&quot;华为&quot;，999，&quot;blue&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//华为,9999,blue</span></span><br><span class="line"><span class="comment">//给杨老板打电话...</span></span><br><span class="line"><span class="comment">//群发短信</span></span><br><span class="line"><span class="comment">//玩游戏</span></span><br><span class="line"><span class="comment">//小米,1999,black</span></span><br><span class="line"><span class="comment">//给雷军打电话...</span></span><br><span class="line"><span class="comment">//群发短信</span></span><br><span class="line"><span class="comment">//玩游戏</span></span><br><span class="line"><span class="comment">//999</span></span><br><span class="line"><span class="comment">//华为,999,blue</span></span><br></pre></td></tr></table></figure><p>3个对象的内存图解如下所示:</p><p><img src="https://i.loli.net/2021/09/02/5mIu9GOyUEBfVQn.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组以及Java中的内存分配</title>
      <link href="/2020/09/02/%E6%95%B0%E7%BB%84%E4%BB%A5%E5%8F%8AJava%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
      <url>/2020/09/02/%E6%95%B0%E7%BB%84%E4%BB%A5%E5%8F%8AJava%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="一维数组以及Java中的内存分配"><a href="#一维数组以及Java中的内存分配" class="headerlink" title="一维数组以及Java中的内存分配"></a>一维数组以及Java中的内存分配</h1><h2 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h2><p>1、数组是存储同一种数据类型多个元素的集合。也可以看成是一个容器。<br>2、数组既可以存储基本数据类型，也可以存储引用数据类型。</p><p>语句定义格式：<br>  1、数据类型[] 数组名<br>    举例：int[] arr1  推荐使用第一种定义方式<br>  2、数据类型 数组名[]<br>    举例：long arr2[]<br>  注意事项：<br>    针对数组定义两种格式，推荐使用第一种格式。因为第一种的可读性更强。<br>    第二种可以早期的时候确实有很多人这样用。不过，现在这样用的人越来越少了。</p><p>如果只是单纯地定义了数组是没有任何意义的，因为里面没有值，想要使用它，必须先初始化。<br>那么如何初始化呢？<br>Java中的数组必须先初始化,然后才能使用。</p><h3 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h3><p>​    所谓初始化：就是为数组中的数组元素分配内存空间，并为每个数组元素赋值。<br>数组初始化：<br>  1、动态初始化：初始化时只指定数组长度，由系统自动为数组分配初始值。<br>​    先不赋值<br>  2、静态初始化：初始化时指定每个数组元素的初始值，由系统决定数组长度。<br>​    先赋值</p><p>动态初始化：初始化时只指定数组长度，由系统为数组分配初始值。<br>动态初始化的格式：数据类型[] 数组名 = new 数据类型[数组长度];<br>举例：int[] arr = new int[3];<br>解释：定义了一个int类型的数组，这个数组中可以存放3个int类型的值。</p><h2 id="Java中的内存地址的分配"><a href="#Java中的内存地址的分配" class="headerlink" title="Java中的内存地址的分配"></a>Java中的内存地址的分配</h2><p><img src="https://i.loli.net/2021/09/02/IBuvZSPGCpkEjFw.png"></p><p>例如:定义一个数组，并为其赋值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//定义一个数组</span></span><br><span class="line">        <span class="keyword">int</span> []arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        System.out.println(arr);</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//为数组赋初值</span></span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="number">200</span>;</span><br><span class="line">        <span class="comment">//输出数组名</span></span><br><span class="line">        System.out.println(arr);</span><br><span class="line">        <span class="comment">//输出元素值</span></span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[I@28d93b30</span></span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="comment">//[I@28d93b30</span></span><br><span class="line"><span class="comment">//100</span></span><br><span class="line"><span class="comment">//200</span></span><br><span class="line"><span class="comment">//0</span></span><br></pre></td></tr></table></figure><h3 id="定义两个数组，分别动态初始化后，手动赋值，并打印数组名和个元素值"><a href="#定义两个数组，分别动态初始化后，手动赋值，并打印数组名和个元素值" class="headerlink" title="定义两个数组，分别动态初始化后，手动赋值，并打印数组名和个元素值"></a>定义两个数组，分别动态初始化后，手动赋值，并打印数组名和个元素值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义第一个数组</span></span><br><span class="line">        <span class="keyword">int</span> []arr = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">3</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="number">22</span>;</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="number">33</span>;</span><br><span class="line">        System.out.println(arr);</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">        <span class="comment">//定义第二个数组</span></span><br><span class="line">        <span class="keyword">int</span> []arr1 = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">2</span>];</span><br><span class="line">        arr1[<span class="number">0</span>] = <span class="number">44</span>;</span><br><span class="line">        arr1[<span class="number">1</span>] = <span class="number">55</span>;</span><br><span class="line">        System.out.println(arr1[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(arr1[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[I@28d93b30</span></span><br><span class="line"><span class="comment">//11</span></span><br><span class="line"><span class="comment">//22</span></span><br><span class="line"><span class="comment">//33</span></span><br><span class="line"><span class="comment">//44</span></span><br><span class="line"><span class="comment">//55</span></span><br></pre></td></tr></table></figure><p>图解如下:</p><p><img src="https://i.loli.net/2021/09/02/m1OMxWhKFL7cDaw.png"></p><p>举例<br>定义第一个数组，动态初始化，并手动赋值，并打印数组名词以及各元素值<br>定义第二个数组，动态初始化，并手动赋值，并打印数组名词以及各元素值<br>定义第三个数组，将第一个数组的地址值赋给第三个数组。（注意：数组的数据类型要一致）<br>并手动赋值，并打印数组名词以及各元素值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义第一个数组</span></span><br><span class="line">        <span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        arr1[<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">        arr1[<span class="number">1</span>] = <span class="number">22</span>;</span><br><span class="line">        arr1[<span class="number">2</span>] = <span class="number">33</span>;</span><br><span class="line">        System.out.println(arr1);</span><br><span class="line">        System.out.println(arr1[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(arr1[<span class="number">1</span>]);</span><br><span class="line">        System.out.println(arr1[<span class="number">2</span>]);</span><br><span class="line">        <span class="comment">//定义第二个数组</span></span><br><span class="line">        <span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        arr2[<span class="number">0</span>] = <span class="number">44</span>;</span><br><span class="line">        arr2[<span class="number">1</span>] = <span class="number">55</span>;</span><br><span class="line">        arr2[<span class="number">2</span>] = <span class="number">66</span>;</span><br><span class="line">        System.out.println(arr2);</span><br><span class="line">        System.out.println(arr2[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(arr2[<span class="number">1</span>]);</span><br><span class="line">        System.out.println(arr2[<span class="number">2</span>]);</span><br><span class="line">        <span class="comment">//这是第三个数组</span></span><br><span class="line">        <span class="keyword">int</span>[] arr3 = arr1;</span><br><span class="line">        arr3[<span class="number">0</span>] = <span class="number">77</span>;</span><br><span class="line">        arr3[<span class="number">1</span>] = <span class="number">88</span>;</span><br><span class="line">        System.out.println(arr3); <span class="comment">//打印的是arr1的地址值</span></span><br><span class="line">        System.out.println(arr1[<span class="number">0</span>]); <span class="comment">//77</span></span><br><span class="line">        System.out.println(arr1[<span class="number">1</span>]); <span class="comment">//88</span></span><br><span class="line">        System.out.println(arr1[<span class="number">2</span>]); <span class="comment">//33</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[I@28d93b30</span></span><br><span class="line"><span class="comment">//11</span></span><br><span class="line"><span class="comment">//22</span></span><br><span class="line"><span class="comment">//33</span></span><br><span class="line"><span class="comment">//[I@1b6d3586</span></span><br><span class="line"><span class="comment">//44</span></span><br><span class="line"><span class="comment">//55</span></span><br><span class="line"><span class="comment">//66</span></span><br><span class="line"><span class="comment">//[I@28d93b30</span></span><br><span class="line"><span class="comment">//77</span></span><br><span class="line"><span class="comment">//88</span></span><br><span class="line"><span class="comment">//33</span></span><br></pre></td></tr></table></figure><p>图解如下:</p><p><img src="https://i.loli.net/2021/09/02/ZpSVckT7IwLyC91.png"></p><h2 id="数组的静态初始化"><a href="#数组的静态初始化" class="headerlink" title="数组的静态初始化"></a>数组的静态初始化</h2><p>数组的静态初始化：<br>格式：数据类型[] 数组名 = new 数据类型[]{元素1,元素2,…};<br>简化格式：数据类型[] 数组名 = {元素1,元素2,…}</p><blockquote><p>举例：<br>    int[] arr = new int[]{1,2,3,4,5};</p><p>简化格式的举例：<br>        int[] arr1 = {6,7,8,9,10};</p><p>注意事项：<br>    1、不能同时使用动态初始化和静态初始化<br>        举例：<br>            int[] arr2 = new int[3]{1,2,3}; //错误</p></blockquote><h2 id="数组使用常见的异常"><a href="#数组使用常见的异常" class="headerlink" title="数组使用常见的异常"></a>数组使用常见的异常</h2><p>（1）数组索引越界<br><code>ArrayIndexOutOfBoundsException</code><br>访问到了数组中的不存在的索引时发生。<br>（2）空指针异常<br><code>NullPointerException</code><br>数组引用没有指向实体，却在操作实体中的元素时。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">40</span>&#125;;</span><br><span class="line">    </span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(arr[4]);</span></span><br><span class="line"></span><br><span class="line">        arr = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(arr[0]);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//40</span></span><br><span class="line"><span class="comment">//null</span></span><br></pre></td></tr></table></figure><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>二维数组：<br>就是元素是一维数组的数组</p><h3 id="格式1："><a href="#格式1：" class="headerlink" title="格式1："></a>格式1：</h3><blockquote><p>数据类型[][] 变量名 = new 数据类型[m][n]</p></blockquote><blockquote><p>​    m:表示这个二维数组有多少个元素，其中这个元素是一维数组<br>​    n:表示每个一维数组的元素有多少个<br>注意：<br>​    一下格式也可以表示一个二维数组<br>​    a:数据类型 数组名称[][] = new 数据类型[m][n];<br>​    b:数据类型[] 数组名称[] = new 数据类型[m][n];<br>举例：<br>​    int x;<br>​    int y;<br>​    int x,y;<br>​    int[] x;<br>​    int[][] x;<br>​    int[] x[];<br>​    int x[][];</p></blockquote><p>例如:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//定义了一个二维数组arr</span></span><br><span class="line">        <span class="comment">//这里的3代表是有3个一维数组</span></span><br><span class="line">        <span class="comment">//这里的2代表每个一维数组有2个元素</span></span><br><span class="line">        <span class="comment">//输出二维数组的名称</span></span><br><span class="line">        System.out.println(arr);    <span class="comment">//输出的是二维数组在堆内存对应的地址值</span></span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]); <span class="comment">//输出的是第一个一维数组在堆内存对应的地址值</span></span><br><span class="line">        System.out.println(arr[<span class="number">1</span>]); <span class="comment">//输出的是第二个一维数组在堆内存对应的地址值</span></span><br><span class="line">        System.out.println(arr[<span class="number">2</span>]); <span class="comment">//输出的是第三个一维数组在堆内存对应的地址值</span></span><br><span class="line">        <span class="comment">//输出二维数组对应的某几个元素</span></span><br><span class="line">        System.out.println(arr[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(arr[0][3]);</span></span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">[[I@28d93b30</span><br><span class="line">[I@1b6d3586</span><br><span class="line">[I@4554617c</span><br><span class="line">[I@74a14482</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><h3 id="格式二："><a href="#格式二：" class="headerlink" title="格式二："></a>格式二：</h3><p>数据类型[][] 变量名 = new 数据类型[m][n]</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][];</span><br><span class="line">        System.out.println(arr);  <span class="comment">//二维数组的地址值 [[I@4554617c</span></span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]); <span class="comment">//第一个元素的一维数组的地址值  null</span></span><br><span class="line">        System.out.println(arr[<span class="number">1</span>]); <span class="comment">//第二个元素的一维数组的地址值  null</span></span><br><span class="line">        System.out.println(arr[<span class="number">2</span>]); <span class="comment">//第三个元素的一维数组的地址值  null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//动态地为每一个一维数组分配空间</span></span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]); <span class="comment">//第一个元素的一维数组的地址值 //[I@74a14482</span></span><br><span class="line">        System.out.println(arr[<span class="number">1</span>]); <span class="comment">//第二个元素的一维数组的地址值 //[I@1540e19d</span></span><br><span class="line">        System.out.println(arr[<span class="number">2</span>]); <span class="comment">//第三个元素的一维数组的地址值 //[I@677327b6</span></span><br><span class="line">    </span><br><span class="line">        System.out.println(arr[<span class="number">0</span>][<span class="number">0</span>]); <span class="comment">//0</span></span><br><span class="line">        System.out.println(arr[<span class="number">0</span>][<span class="number">1</span>]); <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">[[I@28d93b30</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line"><span class="keyword">null</span></span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">[I@1b6d3586</span><br><span class="line">[I@4554617c</span><br><span class="line">[I@74a14482</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>图解如下:</p><p><img src="https://i.loli.net/2021/09/02/x2YTtalgIEAmeRn.png"></p><h3 id="二维数组定义格式3："><a href="#二维数组定义格式3：" class="headerlink" title="二维数组定义格式3："></a>二维数组定义格式3：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(arr); <span class="comment">//二维数组的地址值</span></span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]); <span class="comment">//二维数组的第一个元素，一维数组的地址值</span></span><br><span class="line">        System.out.println(arr[<span class="number">1</span>]); <span class="comment">//二维数组的第二个元素，一维数组的地址值</span></span><br><span class="line">        System.out.println(arr[<span class="number">2</span>]); <span class="comment">//二维数组的第三个元素，一维数组的地址值</span></span><br><span class="line">    </span><br><span class="line">        System.out.println(arr[<span class="number">0</span>][<span class="number">0</span>]); <span class="comment">//打印的是第1个一维数组的第1个元素值</span></span><br><span class="line">        System.out.println(arr[<span class="number">0</span>][<span class="number">1</span>]); <span class="comment">//打印的是第1个一维数组的第2个元素值</span></span><br><span class="line">    </span><br><span class="line">        System.out.println(arr[<span class="number">1</span>][<span class="number">0</span>]); <span class="comment">//打印的是第2个一维数组的第1个元素值</span></span><br><span class="line">        System.out.println(arr[<span class="number">1</span>][<span class="number">1</span>]); <span class="comment">//打印的是第2个一维数组的第2个元素值</span></span><br><span class="line">        System.out.println(arr[<span class="number">1</span>][<span class="number">2</span>]); <span class="comment">//打印的是第2个一维数组的第3个元素值</span></span><br><span class="line">    </span><br><span class="line">        System.out.println(arr[<span class="number">2</span>][<span class="number">0</span>]); <span class="comment">//打印的是第3个一维数组的第1个元素值</span></span><br><span class="line">        System.out.println(arr[<span class="number">2</span>][<span class="number">1</span>]); <span class="comment">//打印的是第3个一维数组的第2个元素值</span></span><br><span class="line">        System.out.println(arr[<span class="number">2</span>][<span class="number">2</span>]); <span class="comment">//打印的是第3个一维数组的第3个元素值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[[I@28d93b30</span></span><br><span class="line"><span class="comment">//[I@1b6d3586</span></span><br><span class="line"><span class="comment">//[I@4554617c</span></span><br><span class="line"><span class="comment">//[I@74a14482</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="comment">//5</span></span><br><span class="line"><span class="comment">//6</span></span><br><span class="line"><span class="comment">//7</span></span><br><span class="line"><span class="comment">//8</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流程控制语句和跳转控制语句</title>
      <link href="/2020/09/02/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%E5%92%8C%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"/>
      <url>/2020/09/02/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%E5%92%8C%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="流程控制语句和跳转语句"><a href="#流程控制语句和跳转语句" class="headerlink" title="流程控制语句和跳转语句"></a>流程控制语句和跳转语句</h1><h2 id="循环结构-while循环结构"><a href="#循环结构-while循环结构" class="headerlink" title="循环结构(while循环结构)"></a>循环结构(while循环结构)</h2><p>while循环语句的基本格式：<br>基本格式：<br>while(判断条件语句){<br>循环体语句;<br>}<br>扩展格式：<br>while(判断条件语句){<br>循环体语句;<br>控制条件语句;<br>}</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhileDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;*************使用for循环改进********************&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;***********使用while循环改进*****************&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;<span class="number">3</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//HelloWorld</span></span><br><span class="line"><span class="comment">//HelloWorld</span></span><br><span class="line"><span class="comment">//HelloWorld</span></span><br><span class="line"><span class="comment">//*************使用for循环改进********************</span></span><br><span class="line"><span class="comment">//HelloWorld</span></span><br><span class="line"><span class="comment">//HelloWorld</span></span><br><span class="line"><span class="comment">//HelloWorld</span></span><br><span class="line"><span class="comment">//***********使用while循环改进*****************</span></span><br><span class="line"><span class="comment">//HelloWorld</span></span><br><span class="line"><span class="comment">//HelloWorld</span></span><br><span class="line"><span class="comment">//HelloWorld</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">            用while循环实现1-100之和</span></span><br><span class="line"><span class="comment">            注意：for循环与while循环之间的小区别：</span></span><br><span class="line"><span class="comment">                1、使用区别：控制条件语句所控制的那个变量，在for循环结束后，就不能再被访问到了，</span></span><br><span class="line"><span class="comment">                    而while循环结束还可以继续使用，如果你想继续使用，就用while，否则推荐使用for。</span></span><br><span class="line"><span class="comment">                    原因是for循环结束，该变量就从内存中消失，能够提高内存的使用效率。</span></span><br><span class="line"><span class="comment">                2、场景区别：</span></span><br><span class="line"><span class="comment">                    for循环适合针对一个范围判断进行操作</span></span><br><span class="line"><span class="comment">                    while循环适合判断次数不明确操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhileDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;1-100的和为：&quot;</span>+sum);</span><br><span class="line">        System.out.println(<span class="string">&quot;**********************使用while循环进行改进*********************&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">1</span>;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;1-100的和为：&quot;</span>+sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1-100的和为：5050</span></span><br><span class="line"><span class="comment">//**********************使用while循环进行改进*********************</span></span><br><span class="line"><span class="comment">//1-100的和为：5050</span></span><br></pre></td></tr></table></figure><h2 id="循环结构-do…while循环语句"><a href="#循环结构-do…while循环语句" class="headerlink" title="循环结构(do…while循环语句)"></a>循环结构(do…while循环语句)</h2><p>do…while循环语句格式：<br>基本格式：<br>do{<br>循环体语句;<br>}while(判断条件语句);<br>扩展格式：<br>do{<br>循环体语句;<br>控制条件语句;<br>}while(判断条件语句);</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoWhileDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//求1-100的和</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//定义的是循环的次数</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//定义的是总和</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">while</span>(i&lt;=<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1-100的和为：&quot;</span>+sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1-100的和为：5050</span></span><br></pre></td></tr></table></figure><h2 id="跳转控制语句"><a href="#跳转控制语句" class="headerlink" title="跳转控制语句"></a>跳转控制语句</h2><p>主要有三个跳转语句：</p><pre><code> break    中断 continue    继续 return    返回</code></pre><h3 id="break："><a href="#break：" class="headerlink" title="break："></a>break：</h3><p>​    使用场景：<br>​            1、在选择结构switch语句中<br>​            2、在循环语句中，加入了if判断的情况<br>​            3、离开使用场景的存在是没有意义的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControlDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入你想要的星期的数字（1-7）&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> num = sc.nextInt();</span><br><span class="line">        <span class="comment">//break跳出当前控制语句</span></span><br><span class="line">        <span class="keyword">switch</span> (num)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期一&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期二&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期三&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;程序没有匹配&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;*********************************&quot;</span>);</span><br><span class="line">        <span class="comment">//循环打印1-10，加入break，并在3的时候停止for循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>break的作用：<br>跳出单层循环：<br>跳出多层循环：<br>带标签的跳出：<br>格式：标签名: 循环语句</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControlDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                System.out.print(i+<span class="string">&quot;*&quot;</span>+j+<span class="string">&quot;=&quot;</span>+(i*j)+<span class="string">&#x27;\t&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*******加入break循环*********&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">4</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(i+<span class="string">&quot;*&quot;</span>+j+<span class="string">&quot;=&quot;</span>+(i*j)+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;*****加入break带标签跳出多层循环******&quot;</span>);</span><br><span class="line">        wc:<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">            nc:<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">4</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span> wc;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(i+<span class="string">&quot;*&quot;</span>+j+<span class="string">&quot;=&quot;</span>+(i*j)+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span>*<span class="number">1</span>=<span class="number">1</span></span><br><span class="line"><span class="number">2</span>*<span class="number">1</span>=<span class="number">2</span><span class="number">2</span>*<span class="number">2</span>=<span class="number">4</span></span><br><span class="line"><span class="number">3</span>*<span class="number">1</span>=<span class="number">3</span><span class="number">3</span>*<span class="number">2</span>=<span class="number">6</span><span class="number">3</span>*<span class="number">3</span>=<span class="number">9</span></span><br><span class="line"><span class="number">4</span>*<span class="number">1</span>=<span class="number">4</span><span class="number">4</span>*<span class="number">2</span>=<span class="number">8</span><span class="number">4</span>*<span class="number">3</span>=<span class="number">12</span><span class="number">4</span>*<span class="number">4</span>=<span class="number">16</span></span><br><span class="line"><span class="number">5</span>*<span class="number">1</span>=<span class="number">5</span><span class="number">5</span>*<span class="number">2</span>=<span class="number">10</span><span class="number">5</span>*<span class="number">3</span>=<span class="number">15</span><span class="number">5</span>*<span class="number">4</span>=<span class="number">20</span><span class="number">5</span>*<span class="number">5</span>=<span class="number">25</span></span><br><span class="line"><span class="number">6</span>*<span class="number">1</span>=<span class="number">6</span><span class="number">6</span>*<span class="number">2</span>=<span class="number">12</span><span class="number">6</span>*<span class="number">3</span>=<span class="number">18</span><span class="number">6</span>*<span class="number">4</span>=<span class="number">24</span><span class="number">6</span>*<span class="number">5</span>=<span class="number">30</span><span class="number">6</span>*<span class="number">6</span>=<span class="number">36</span></span><br><span class="line"><span class="number">7</span>*<span class="number">1</span>=<span class="number">7</span><span class="number">7</span>*<span class="number">2</span>=<span class="number">14</span><span class="number">7</span>*<span class="number">3</span>=<span class="number">21</span><span class="number">7</span>*<span class="number">4</span>=<span class="number">28</span><span class="number">7</span>*<span class="number">5</span>=<span class="number">35</span><span class="number">7</span>*<span class="number">6</span>=<span class="number">42</span><span class="number">7</span>*<span class="number">7</span>=<span class="number">49</span></span><br><span class="line"><span class="number">8</span>*<span class="number">1</span>=<span class="number">8</span><span class="number">8</span>*<span class="number">2</span>=<span class="number">16</span><span class="number">8</span>*<span class="number">3</span>=<span class="number">24</span><span class="number">8</span>*<span class="number">4</span>=<span class="number">32</span><span class="number">8</span>*<span class="number">5</span>=<span class="number">40</span><span class="number">8</span>*<span class="number">6</span>=<span class="number">48</span><span class="number">8</span>*<span class="number">7</span>=<span class="number">56</span><span class="number">8</span>*<span class="number">8</span>=<span class="number">64</span></span><br><span class="line"><span class="number">9</span>*<span class="number">1</span>=<span class="number">9</span><span class="number">9</span>*<span class="number">2</span>=<span class="number">18</span><span class="number">9</span>*<span class="number">3</span>=<span class="number">27</span><span class="number">9</span>*<span class="number">4</span>=<span class="number">36</span><span class="number">9</span>*<span class="number">5</span>=<span class="number">45</span><span class="number">9</span>*<span class="number">6</span>=<span class="number">54</span><span class="number">9</span>*<span class="number">7</span>=<span class="number">63</span><span class="number">9</span>*<span class="number">8</span>=<span class="number">72</span><span class="number">9</span>*<span class="number">9</span>=<span class="number">81</span></span><br><span class="line">*******加入<span class="keyword">break</span>循环*********</span><br><span class="line"><span class="number">1</span>*<span class="number">1</span>=<span class="number">1</span></span><br><span class="line"><span class="number">2</span>*<span class="number">1</span>=<span class="number">2</span><span class="number">2</span>*<span class="number">2</span>=<span class="number">4</span></span><br><span class="line"><span class="number">3</span>*<span class="number">1</span>=<span class="number">3</span><span class="number">3</span>*<span class="number">2</span>=<span class="number">6</span><span class="number">3</span>*<span class="number">3</span>=<span class="number">9</span></span><br><span class="line"><span class="number">4</span>*<span class="number">1</span>=<span class="number">4</span><span class="number">4</span>*<span class="number">2</span>=<span class="number">8</span><span class="number">4</span>*<span class="number">3</span>=<span class="number">12</span></span><br><span class="line"><span class="number">5</span>*<span class="number">1</span>=<span class="number">5</span><span class="number">5</span>*<span class="number">2</span>=<span class="number">10</span><span class="number">5</span>*<span class="number">3</span>=<span class="number">15</span></span><br><span class="line"><span class="number">6</span>*<span class="number">1</span>=<span class="number">6</span><span class="number">6</span>*<span class="number">2</span>=<span class="number">12</span><span class="number">6</span>*<span class="number">3</span>=<span class="number">18</span></span><br><span class="line"><span class="number">7</span>*<span class="number">1</span>=<span class="number">7</span><span class="number">7</span>*<span class="number">2</span>=<span class="number">14</span><span class="number">7</span>*<span class="number">3</span>=<span class="number">21</span></span><br><span class="line"><span class="number">8</span>*<span class="number">1</span>=<span class="number">8</span><span class="number">8</span>*<span class="number">2</span>=<span class="number">16</span><span class="number">8</span>*<span class="number">3</span>=<span class="number">24</span></span><br><span class="line"><span class="number">9</span>*<span class="number">1</span>=<span class="number">9</span><span class="number">9</span>*<span class="number">2</span>=<span class="number">18</span><span class="number">9</span>*<span class="number">3</span>=<span class="number">27</span></span><br><span class="line">*****加入<span class="keyword">break</span>带标签跳出多层循环******</span><br><span class="line"><span class="number">1</span>*<span class="number">1</span>=<span class="number">1</span></span><br><span class="line"><span class="number">2</span>*<span class="number">1</span>=<span class="number">2</span><span class="number">2</span>*<span class="number">2</span>=<span class="number">4</span></span><br><span class="line"><span class="number">3</span>*<span class="number">1</span>=<span class="number">3</span><span class="number">3</span>*<span class="number">2</span>=<span class="number">6</span><span class="number">3</span>*<span class="number">3</span>=<span class="number">9</span></span><br><span class="line"><span class="number">4</span>*<span class="number">1</span>=<span class="number">4</span><span class="number">4</span>*<span class="number">2</span>=<span class="number">8</span><span class="number">4</span>*<span class="number">3</span>=<span class="number">12</span></span><br></pre></td></tr></table></figure><h3 id="continue："><a href="#continue：" class="headerlink" title="continue："></a>continue：</h3><p>使用场景：<br>1、在循环语句中<br>2、离开使用场景的存在是没有意义的</p><h3 id="return："><a href="#return：" class="headerlink" title="return："></a>return：</h3><p>结束循环其实是结束了main方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControlDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//循环打印1-10，加入continue</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;<span class="comment">//跳出当前此次循环，继续后面循环</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;<span class="comment">//在这里面 3 就被抽走了</span></span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;********改为return*********&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="comment">//5</span></span><br><span class="line"><span class="comment">//6</span></span><br><span class="line"><span class="comment">//7</span></span><br><span class="line"><span class="comment">//8</span></span><br><span class="line"><span class="comment">//9</span></span><br><span class="line"><span class="comment">//10</span></span><br><span class="line"><span class="comment">//********改为return*********</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法：<br>方法就是完成特定功能的代码块<br>在很多语言里面都有函数的定义<br>函数在Java中被称为方法<br>语句格式：<br>修饰符 返回值类型 方法名(参数类型 参数名1，参数类型 参数名2…) {<br>函数体;<br>return 返回值;<br>}<br>名词解释：<br>修饰符：修饰符 比较多，后面会详细介绍。目前public static<br>返回值类型：<br>就是return返回的值的类型<br>方法名：<br>一个名称，为了方便我们调用方法，自己起的名字，方便我们调用。</p><blockquote><p>参数：<br>        1、形参<br>            定义在方法上的参数名<br>        2、实参<br>            实际调用方法的时候传入的值<br>    参数类型：<br>        限定调用方法时传入参数的数据类型<br>    参数名：（形参）<br>        是一个变量，接收调用方法时传入的参数。<br>    函数体：<br>        完成功能的代码，实现方法的主要逻辑功能<br>    return：<br>        结束方法以及返回方法指定类型的值<br>    返回值：<br>        程序被return带回的结果，返回给调用者</p></blockquote><p>注意:方法和方法是平级关系，不能被嵌套使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">20</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> result = sum(x,y);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = x+y;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//30</span></span><br></pre></td></tr></table></figure><p>上式图解</p><p><img src="https://i.loli.net/2021/09/02/yjn6WK4NCUPFwd7.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入行数&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> x = sc.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入列数&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> y = sc.nextInt();</span><br><span class="line">    </span><br><span class="line">        printStar(x,y);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printStar</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=b;j++)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//请输入行数</span></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="comment">//请输入列数</span></span><br><span class="line"><span class="comment">//5</span></span><br><span class="line"><span class="comment">//* ****</span></span><br><span class="line"><span class="comment">//*    ****</span></span><br><span class="line"><span class="comment">//*    ****</span></span><br><span class="line"><span class="comment">//*    ****</span></span><br></pre></td></tr></table></figure><h2 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h2><p>方法的重载：<br>在同一个类中，允许存在一个以上的同名方法，<br>只要它们的参数个数或者参数类型不同即可。</p><p>方法重载的特点：<br>1、与返回值类型无关，只看方法名和参数列表<br>2、在调用时，虚拟机通过参数列表的不同来区分同名方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionDemo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//求加法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">byte</span> e = <span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = x+y;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x+y+z);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x+y+z+i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum3</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">byte</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x+y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中键盘录入以及循环结构</title>
      <link href="/2020/09/02/Java%E4%B8%AD%E9%94%AE%E7%9B%98%E5%BD%95%E5%85%A5%E4%BB%A5%E5%8F%8A%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/"/>
      <url>/2020/09/02/Java%E4%B8%AD%E9%94%AE%E7%9B%98%E5%BD%95%E5%85%A5%E4%BB%A5%E5%8F%8A%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Java中键盘录入以及循环结构"><a href="#Java中键盘录入以及循环结构" class="headerlink" title="Java中键盘录入以及循环结构"></a>Java中键盘录入以及循环结构</h1><h2 id="键盘录入"><a href="#键盘录入" class="headerlink" title="键盘录入"></a>键盘录入</h2><p>把数据改为键盘录入，可以提高程序的灵活性。<br>如何进行键盘录入：<br>1、导包（位置放到class定义的上面）<br><code>import java.util.Scanner;</code><br>2、创建对象<br><code>Scanner sc = new Scanner(System.in);</code><br>3、接收数据<br><code>int x = sc.nextInt();</code><br>    键盘录入两个数据，并对两个数据求和，输出结果<br>    键盘录入两个数据，获取两个结果中的最大值</p><p>  分析：<br>    1.导包<br>    2.创建Scanner对象<br>    3.使用对象的方法，输出两个值<br>    4.输出两个值相加的结果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建Scanner对象</span></span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">​    System.out.println(<span class="string">&quot;请输入第一个数据&quot;</span>);</span><br><span class="line">​    <span class="keyword">int</span> x = sc.nextInt();</span><br><span class="line"></span><br><span class="line">​    System.out.println(<span class="string">&quot;请输入第二个数据&quot;</span>);</span><br><span class="line">​    <span class="keyword">int</span> y = sc.nextInt();</span><br><span class="line"></span><br><span class="line">​    System.out.println(<span class="string">&quot;两值相加的结果为：&quot;</span>+(x+y));</span><br><span class="line"></span><br><span class="line">​    System.out.println(<span class="string">&quot;********************************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">​    <span class="comment">//键盘录入两个数据，获取两个数据中的最大值</span></span><br><span class="line">​    System.out.println(<span class="string">&quot;请输入第二题的第一个数据&quot;</span>);</span><br><span class="line">​    <span class="keyword">int</span> a = sc.nextInt();</span><br><span class="line"></span><br><span class="line">​    System.out.println(<span class="string">&quot;请输入第二题的第二个数据&quot;</span>);</span><br><span class="line">​    <span class="keyword">int</span> b = sc.nextInt();</span><br><span class="line"></span><br><span class="line">​    <span class="comment">//使用三目运算符求最大值</span></span><br><span class="line">​    <span class="keyword">int</span> result = (a&gt;b)?a:b;</span><br><span class="line">​    System.out.println(<span class="string">&quot;最大值为：&quot;</span>+result);</span><br></pre></td></tr></table></figure><h2 id="流程控制语句中的-顺序结构"><a href="#流程控制语句中的-顺序结构" class="headerlink" title="流程控制语句中的 顺序结构"></a>流程控制语句中的 顺序结构</h2><p>顺序结构是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。<br>总的来说：写在前面的先执行，写在后面的后执行。</p><p>流程控制语句中的 选择结构<br>选择结构也被称为 分支结构。<br>选择结构有特定的语法规则，代码要执行具体的逻辑运算进行判断，逻辑运算的结果有两个，所以产生选择，按照不同的选择执行不同的代码。</p><p>Java中提供两种选择结构语句：<br>if语句<br>switch语句</p><p>if语句的三种格式：</p><h3 id="（1）if-关系表达式"><a href="#（1）if-关系表达式" class="headerlink" title="（1）if(关系表达式){"></a>（1）if(关系表达式){</h3><p>语句体<br>}</p><p>执行流程：<br>首先判断关系表达式里的结果值，无论关系表达式里面简单还是复杂，最后结果一定要是Boolean类型<br>如果是true就进入if大括号内，执行语句体<br>如果是false就不进入if大括号，继续执行后面的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IfDemo1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;<span class="number">90</span>)&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;a是小于90的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;程序执行完毕&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序执行完毕</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>if语句编写的注意事项<br>1、if判断里面的关系表达式一定要严格遵循结果是Boolean类型的规则<br>2、if语句控制的语句体如果是一条语句，大括号可以省略；<br>如果是多条语句，就不能省略，建议永远不省略<br>3、一般来说：有左大括号就没有分号，有分号就没有左大括号</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IfDemo2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">3</span>);<span class="comment">//这就默认有了一个空的语句体</span></span><br><span class="line">    <span class="comment">//这是一个普通的代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;x是大于3的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;程序执行完毕&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//x是大于3的</span></span><br><span class="line"><span class="comment">//程序执行完毕</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br></pre></td></tr></table></figure><h3 id="（2）if-关系表达式"><a href="#（2）if-关系表达式" class="headerlink" title="（2）if(关系表达式){"></a>（2）if(关系表达式){</h3><p>语句体1;<br>}else{<br>语句体2;<br>}</p><p>执行流程：<br>1、先判断关系表达式里面的结果值，无论关系表达式里面是简单还是复杂，最后结果一定是Boolean类型<br>2、如果关系表达式的结果是true，那么就执行语句体1，不会执行else后面的语句体<br>3、如果关系表达式的结果是false，那么就执行else里面的语句体2</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IfDemo3</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> a = <span class="number">13965873016L</span>;</span><br><span class="line">    <span class="keyword">if</span>(!(a==<span class="number">13965873016L</span>))&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure><h4 id="这里讲解一种三元运算符和if语句的第二种格式相转换的问题。"><a href="#这里讲解一种三元运算符和if语句的第二种格式相转换的问题。" class="headerlink" title="这里讲解一种三元运算符和if语句的第二种格式相转换的问题。"></a>这里讲解一种三元运算符和if语句的第二种格式相转换的问题。</h4><p>三元运算符，它根据比较判断后，给出的也是两个结果，所以，这种情况和if语句的第二种格式很相似，他们在某些情况下应该是可以相互转换的。<br>1、当选择结构存在最后输出的语句是控制台输出，就无法改进成三元运算符<br>2、当if第二种结构的最后输出语句是一个结果值的时候，可以使用三元运算符进行改进</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IfDemo6</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建Scanner对象</span></span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入第一个数&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> x = sc.nextInt();</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入第二个数&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> y = sc.nextInt();</span><br><span class="line">    <span class="keyword">if</span>(x&gt;y)&#123;<span class="comment">//不考虑相等的情况</span></span><br><span class="line">      System.out.println(<span class="string">&quot;最大值x：&quot;</span>+x);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;最大值y：&quot;</span>+y);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;*********************************&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;三元运算符进行改进&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> max = (x&gt;y)?x:y;</span><br><span class="line">    System.out.println(<span class="string">&quot;最大值：&quot;</span>+max);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//请输入第一个数</span></span><br><span class="line"><span class="comment">//34</span></span><br><span class="line"><span class="comment">//请输入第二个数</span></span><br><span class="line"><span class="comment">//45</span></span><br><span class="line"><span class="comment">//最大值y：45</span></span><br><span class="line"><span class="comment">//*********************************</span></span><br><span class="line"><span class="comment">//三元运算符进行改进</span></span><br><span class="line"><span class="comment">//最大值：45</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">26</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">28</span></span><br></pre></td></tr></table></figure><h3 id="（3）if语句的第三种格式："><a href="#（3）if语句的第三种格式：" class="headerlink" title="（3）if语句的第三种格式："></a>（3）if语句的第三种格式：</h3><p>if(关系表达式1){<br>语句体1;<br>}else if(关系表达式){<br>语句体2;<br>}<br>…<br>else{<br>语句体n+1;<br>}</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IfDemo5</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建Scanner对象</span></span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入第一个数&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> x = sc.nextInt();</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入第二个数&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> y = sc.nextInt();</span><br><span class="line">    <span class="keyword">if</span>(x&gt;y)&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;最大值x:&quot;</span>+x);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (x==y)&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;两个数相等&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;最大值y:&quot;</span>+y);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//请输入第一个数</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//请输入第二个数</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//最大值y:2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">23</span></span><br></pre></td></tr></table></figure><p>这里补充一个小知识点：第三种情况下的else可以省去，但就不属于if中的格式了</p><pre><code> #### 练习题：使用if嵌套输出三个数中的最大值</code></pre><p>1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IfDemo7</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入第一个数&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> x1 = sc.nextInt();</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入第二个数&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> x2 = sc.nextInt();</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入第三个数&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> x3 = sc.nextInt();</span><br><span class="line">    <span class="keyword">if</span>(x1 &gt; x2)&#123;</span><br><span class="line">      <span class="keyword">if</span>(x1 &gt; x3)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;最大值是x1:&quot;</span>+x1);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x2 &gt; x3)&#123;   <span class="comment">//潜台词就是x1&lt;x3，x1&gt;x2</span></span><br><span class="line">      System.out.println(<span class="string">&quot;最大值是x2:&quot;</span>+x2);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;     <span class="comment">//潜台词就是x2&lt;x3，x1&lt;x3，x1&gt;x2</span></span><br><span class="line">      System.out.println(<span class="string">&quot;最大值是x3:&quot;</span>+x3);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//请输入第一个数</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//请输入第二个数</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//请输入第三个数</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//最大值是x3:3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">26</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">28</span></span><br></pre></td></tr></table></figure><h2 id="流程控制语句中的-switch选择结构"><a href="#流程控制语句中的-switch选择结构" class="headerlink" title="流程控制语句中的 switch选择结构"></a>流程控制语句中的 switch选择结构</h2><p>switch语句格式：<br>switch(表达式){<br>case 值1：<br>语句体1;<br>break;<br>case 值2：<br>语句体2;<br>break;<br>…<br>default:<br>语句体n+1;<br>break;<br>}</p><p>switch表达式的一些注意点：<br>表达式的取值：byte、short、int（没有long）、char（不能有浮点数）<br>JDK5(1.5)之后可以是枚举<br>JDK7(1.7)之后可以是String<br>case后面跟的是要和表达式进行比较的值<br>语句体部分可以是一条或者多条语句<br>break表示中断，结束的意思，可以结束switch语句<br>default语句表示所有情况都不匹配的时候，就执行该处的内容，和if语句的else相似</p><p>执行流程：<br>1、首先计算表达式的值<br>2、拿着计算好的值与case对应值按照从上到下的顺序进行比较，如有相同，开始执行该case对应的语句体<br>3、当语句体执行完之后，会执行紧接着的break语句，执行break语句就代表着switch选择结构结束（跳出switch选择）<br>4、当从上到下依次寻找case对应的值的时候，没有找到相匹配的值，就会执行default中的语句体，最后跳出循环</p><h3 id="switch语句的注意事项"><a href="#switch语句的注意事项" class="headerlink" title="switch语句的注意事项:"></a>switch语句的注意事项:</h3><p>case 后面只能是常量，不能是变量，而且，多个case后面的值不能出现相同的<br>default可以省略吗?<br>可以省略。一般不建议。除非判断的值是固定的。(单选题)<br>break可以省略吗?<br>可以省略，一般不建议。否则结果可能不是你想要的<br>当所有break语句都省略的时候，表达式的值与case的值进行匹配，从匹配到的那个case语句体开始执行，一直执行到结尾，直到最后一个语句<br>default的位置一定要在最后吗?<br>可以出现在switch语句任意位置。<br>1、当计算完表达式的值后，先与每一个case按照顺序去匹配，如果所有的case都补匹配，那么最后再执行default,这个和你default放再哪里的<br>位置并没有关系。<br>2、即使你放在了第一个，某些case没有写break语句，那么也会先去匹配case，记住一句话，只有当所有case都不匹配的时候，才会去执行<br>default;<br>switch语句的结束条件<br>遇到break<br>执行到程序的末尾</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwitchDemo5</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">switch</span>(x)&#123;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        y++; <span class="comment">// 4</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        y++; <span class="comment">// 5</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        y++; <span class="comment">// 6</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;y=&quot;</span>+y); <span class="comment">// 6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure><h2 id="流程控制语句-for循环"><a href="#流程控制语句-for循环" class="headerlink" title="流程控制语句 for循环"></a>流程控制语句 for循环</h2><p>for(初始化语句;判断条件语句;控制条件语句) {<br>循环体语句;<br>}<br>/*<br>循环结构：<br>循环语句可以在满足循环条件的情况下，反复执行某一段代码，<br>这段被重复执行的代码被称为循环体语句，当反复执行这个循环体时，<br>需要在合适的时候把循环判断条件修改为false，从而结束循环，否则循环将一直执行下去，形成死循环。</p><h3 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h3><p>1、for循环<br>2、while循环</p><h3 id="循环的组成："><a href="#循环的组成：" class="headerlink" title="循环的组成："></a>循环的组成：</h3><p>初始化语句：<br>一条或者多条语句，这些语句完成一些初始化操作。<br>判断条件语句：<br>这是一个boolean 表达式，这个表达式能决定是否执行循环体。<br>循环体语句：<br>这个部分是循环体语句，也就是我们要多次做的事情。<br>控制条件语句：<br>这个部分在一次循环体结束后，下一次循环判断条件执行前执行。通过用于控制循环条件中的变量，使得循环在合适的时候结束。</p><p>for循环：<br>语句格式：<br>for(初始化语句;判断语句;控制条件语句){<br>语句体;<br>}</p><p> 执行流程：<br>  1、先初始化语句<br>  2、执行判断语句，判断语句一般返回的结果是boolean类型<br>    如果判断语句返回的是true,则执行语句体；<br>    如果判断语句返回的是false,则跳出当前for循环<br>  3、如果判断语句是true,且执行完了语句体，接着去执行控制条件语句<br>  4、再者去执行判断语句，如果是true，继续执行第二步。<br>使用for循环的注意事项：<br>1、判断条件语句的结果是一个boolean类型<br>2、循环体语句如果是一条语句，大括号可以省略；<br>如果是多条语句，大括号不能省略。建议永远不要省略，如果省略，循环只对第一条语句有效。<br>3、一般来说：有左大括号就没有分号，有分号就没有左大括号<br>4、初始化语句可以不在for循环的语句结构中出现，但是必须在其执行之前定义。<br>5、判断语句一定不能不能省略，否则就是死循环<br>6、控制条件语句可以不在for循环的语句结构中出现，但是，必须在语句体中进行变化。<br>*/</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForDemo2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;=<span class="number">10</span>;) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;HelloWorld!&quot;</span>);</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//想要终止for的死循环，就将判断条件的结果写为false即可。</span></span><br><span class="line">    <span class="keyword">for</span>(;i&lt;<span class="number">0</span>;)&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;这是死循环&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java数据类型和运算符</title>
      <link href="/2020/09/02/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2020/09/02/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="Java数据类型和运算符"><a href="#Java数据类型和运算符" class="headerlink" title="Java数据类型和运算符"></a>Java数据类型和运算符</h1><h2 id="以下是数据类型以及Java中运算符的一些理解"><a href="#以下是数据类型以及Java中运算符的一些理解" class="headerlink" title="以下是数据类型以及Java中运算符的一些理解"></a>以下是数据类型以及Java中运算符的一些理解</h2><p>Java是一种 强类型 的语言，每种数据都定义了一种具体的数据类型，并且在内存中分配了不同大小空间。<br>数据类型分为基本数据类型以及引用数据类型，这里暂时只提及基本数据类型。</p><p>（由小到大）<br>整数类型   byte、short、int、long<br>浮点类型   float、double<br>字符型   char<br>布尔型   boolean</p><p>数据类型的大小范围：<br>类型                 占用存储空间             表数范围<br>byte                 1字节                   -128<del>127     (2的八次幂)<br>short               2字节                   -2^15</del>2^15-1   （2的十六次幂，但从零开始）<br>int                 4字节                   -2^31<del>2^31-1<br>long                 8字节                   -2^63</del>2^63-1<br>float                 4字节                   -3.403E38<del>3.403E38<br>double               8字节                   -1.798E308</del>1.798E308</p><p>作用域：<br>   变量定义在哪一级大括号中，哪个大括号的范围就是这个变量的作用域。相同的作用域中不能定义两个同名变量。</p><p>初始化值：<br>   没有初始化值不能直接使用<br>2.运算符<br>运算符包括算术运算符、赋值运算符、比较运算符、逻辑运算符、位运算符、三目运算符<br>+的作用：<br>加法<br>正数<br>字符串连接符</p><p>3.关系运算符<br>== 相等于 4==3 false<br>!= 不等于 4!=3 true<br>&lt; 小于 4&lt;3 false<br>&gt; 大于 4&gt;3 true<br>&lt;= 小于等于 4&lt;=3 false<br>&gt;= 大于等于 4&gt;=3 false</p><p>关系运算符的计算结果是一个Boolean值，true或false</p><p>4.逻辑运算符<br>运算符 运算 范例 结果<br>&amp; AND(与) false&amp;true false<br>| OR(或) false|true true<br>^ XOR(异或) true^false true<br>! Not(非) !true false<br>&amp;&amp; AND(短路) false&amp;true false<br>|| OR(短路) false||true true</p><p>特点：一般用于连接Boolean类型的表达式或值<br>结论：<br>&amp; 逻辑与：有false则false<br>| 逻辑或：有true则true<br>^ 逻辑异或 相同为false，不同为true<br>！非：就是非<br>&amp;&amp;，||<br>&amp;&amp;和&amp;的区别，||和|的区别<br>A：最终结果是一样的<br>B：&amp;&amp;具有短路效果，左边为false时，右边不执行<br>||具有短路效果，左边为true时，右边不执行</p><p>5.位运算符<br>&lt;&lt; 左移 3&lt;&lt;2 = 12 –&gt;322=12<br>&gt;&gt; 右移 3&gt;&gt;1 = 1 –&gt;3/2=1<br>&gt;&gt;&gt; 无符号右移 3&gt;&gt;&gt;1 = 1 –&gt; 3/2=1<br>&amp; 与运算 6&amp;3 = 2<br>| 或运算 6|3 = 7<br>^ 异或运算 6^3 = 5<br>~ 反码 ~6 = -7</p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java打印1000以内的完数</title>
      <link href="/2020/09/02/Java%E6%89%93%E5%8D%B01000%E4%BB%A5%E5%86%85%E7%9A%84%E5%AE%8C%E6%95%B0/"/>
      <url>/2020/09/02/Java%E6%89%93%E5%8D%B01000%E4%BB%A5%E5%86%85%E7%9A%84%E5%AE%8C%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Java实现1000以内完数的输出"><a href="#Java实现1000以内完数的输出" class="headerlink" title="Java实现1000以内完数的输出"></a>Java实现1000以内完数的输出</h1><h2 id="实现代码如下所示"><a href="#实现代码如下所示" class="headerlink" title="实现代码如下所示"></a>实现代码如下所示</h2><p>实现代码如下所示:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">wanshu</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">1000</span>;i++)&#123;<span class="comment">//遍历1000以内的数</span></span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= i/<span class="number">2</span>;j++)&#123;<span class="comment">//优化1：只需要和i/2相比较，优化了时间。</span></span><br><span class="line">                <span class="keyword">if</span>(i % j == <span class="number">0</span>)&#123;</span><br><span class="line">                    sum += j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == sum)&#123;<span class="comment">//如果输入的i和累加之后的数值相同，那就说明这个数是完数。</span></span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>引用图片</title>
      <link href="/2020/09/02/title/"/>
      <url>/2020/09/02/title/</url>
      
        <content type="html"><![CDATA[<h1 id="这是本地引用格式"><a href="#这是本地引用格式" class="headerlink" title="这是本地引用格式"></a>这是本地引用格式</h1><img src="/2020/09/02/title/aisi.jpg" class><p>引用图片的格式</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
