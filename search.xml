<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HiveSQL练习题</title>
      <link href="/2021/10/08/HiveSQL%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
      <url>/2021/10/08/HiveSQL%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="HiveSQL练习题"><a href="#HiveSQL练习题" class="headerlink" title="HiveSQL练习题"></a>HiveSQL练习题</h1><p>建表语句：<br><strong>员工信息表emp：</strong><br>字段：员工id,员工名字,工作岗位,部门经理,受雇日期,薪水,奖金,部门编号<br>英文名：EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,BONUS,DEPTNO</p><p>create table emp(<br>EMPNO int<br>,ENAME string<br>,JOB string<br>,MGR int<br>,HIREDATE string<br>,SAL int<br>,BONUS int<br>,DEPTNO int<br>)<br>row format delimited<br>fields terminated by ‘,’;</p><p>7369,SMITH,CLERK,7902,1980-12-17,800,null,20<br>7499,ALLEN,SALESMAN,7698,1981-02-20,1600,300,30<br>7521,WARD,SALESMAN,7698,1981-02-22,1250,500,30<br>7566,JONES,MANAGER,7839,1981-04-02,2975,null,20,<br>7654,MARTIN,SALESMAN,7698,1981-09-28,1250,1400,30<br>7698,BLAKE,MANAGER,7839,1981-05-01,2850,null,30<br>7782,CLARK,MANAGER,7839,1981-06-09,2450,null,10<br>7788,SCOTT,ANALYST,7566,1987-04-19,3000,null,20<br>7839,KING,PRESIDENT,null,1981-11-17,5000,null,10<br>7844,TURNER,SALESMAN,7698,1981-09-08,1500,0,30<br>7876,ADAMS,CLERK,7788,1987-05-23,1100,null,20<br>7900,JAMES,CLERK,7698,1981-12-03,950,null,30<br>7902,FORD,ANALYST,7566,1981-12-03,3000,null,20<br>7934,MILLER,CLERK,7782,1982-01-23,1300,null,10</p><p><strong>部门信息表dept：</strong><br>字段：部门编号,部门名称,部门地点<br>英文名：DEPTNO,DEPTNAME,DEPTADDR</p><p>create table dept(<br>DEPTNO int<br>,DEPTNAME string<br>,DEPTADDR string<br>)<br>row format delimited<br>fields terminated by ‘,’;</p><p>10,ACCOUNTING,NEW YORK<br>10,ACCOUNTING,shanghai<br>20,RESEARCH,DALLAS<br>30,SALES,CHICAGO<br>40,OPERATIONS,BOSTON</p><h2 id="题目与答案"><a href="#题目与答案" class="headerlink" title="题目与答案"></a>题目与答案</h2><p>1． 列出至少有一个员工的所有部门。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(*) as c,deptno from emp group by deptno having c &gt;= 1;</span><br></pre></td></tr></table></figure><p>2． 列出薪金比“SMITH”多的所有员工。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MySQL:</span><br><span class="line">select * from emp where sal &gt; (select sal from emp where ename = &#x27;SMITH&#x27;);</span><br><span class="line"></span><br><span class="line">Hive:</span><br><span class="line">select a.ename,a.sal from</span><br><span class="line">(select ename,sal,1 as cid from emp) as a</span><br><span class="line">left join</span><br><span class="line">(select sal ,1 as cid from emp where ename=‘SMITH’) as b</span><br><span class="line">on a.cid=b.cid where a.sal&gt;b.sal;</span><br></pre></td></tr></table></figure><p>3． 列出所有员工的姓名及其直接上级的姓名。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MySQL:</span><br><span class="line">select worker.ename,boss.ename from emp as worker left join emp as boss on worker.mgr = boss.empno;</span><br><span class="line"></span><br><span class="line">Hive:</span><br><span class="line">select a.ename,b.ename from</span><br><span class="line">(select ename,mgr from emp) as a</span><br><span class="line">left join</span><br><span class="line">(select ename,empno from emp) as b</span><br><span class="line">on a.mgr=b.empno</span><br></pre></td></tr></table></figure><p>4． 列出受雇日期早于其直接上级的所有员工。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select worker.ename,boss.ename</span><br><span class="line">from</span><br><span class="line">(select empno,ename,hiredate from emp) as boss</span><br><span class="line">right join</span><br><span class="line">(select mgr,ename,hiredate from emp) as worker</span><br><span class="line">on boss.empno=worker.mgr</span><br><span class="line">where boss.hiredate&gt;worker.hiredate</span><br></pre></td></tr></table></figure><p>5． 列出部门名称和这些部门的员工信息，同时列出那些没有员工的部门。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp as t1</span><br><span class="line">left join dept as t2</span><br><span class="line">on t1.deptno=t2.deptno</span><br></pre></td></tr></table></figure><p>6． 列出所有“CLERK”（办事员）的姓名及其部门名称。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select t1.ename,t2.deptname</span><br><span class="line">from</span><br><span class="line">(select ename,deptno from emp where job=‘CLERK’) as t1</span><br><span class="line">left join</span><br><span class="line">dept as t2</span><br><span class="line">on t1.deptno=t2.deptno</span><br></pre></td></tr></table></figure><p>7． 列出最低薪金大于1500的各种工作。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select job</span><br><span class="line">from</span><br><span class="line">(select job,min(sal) as min_sal from emp group by job) as t</span><br><span class="line">where min_sal &gt; 1500</span><br></pre></td></tr></table></figure><p>8． 列出在部门“SALES”（销售部）工作的员工的姓名，假定不知道销售部的部门编号</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select t1.ename</span><br><span class="line">from emp t1</span><br><span class="line">join</span><br><span class="line">dept t2</span><br><span class="line">on t1.deptno=t2.deptno</span><br><span class="line">where t2.deptname=‘SALES’</span><br><span class="line"></span><br><span class="line">select t1.name</span><br><span class="line">from emp t1</span><br><span class="line">join</span><br><span class="line">(select deptno from dept where deptname=‘SALES’) t2</span><br><span class="line">on t1.deptno=t2.deptno</span><br></pre></td></tr></table></figure><p>9． 列出薪金高于公司平均薪金的所有员工。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select t1.ename,t1.sal ,t2.avg_sal</span><br><span class="line">from</span><br><span class="line">(select ename,sal,1 as cid from emp) as t1</span><br><span class="line">join</span><br><span class="line">(select avg(sal) as avg_sal,1 as cid from emp) as t2</span><br><span class="line">on t1.cid=t2.cid</span><br><span class="line">where t1.sal&gt;t2.avg_sal</span><br></pre></td></tr></table></figure><p>10．列出与“SCOTT”从事相同工作的所有员工。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select t1.ename</span><br><span class="line">from</span><br><span class="line">(select ename,job,1 as cid from emp) as t1</span><br><span class="line">join</span><br><span class="line">(select job,1 as cid from emp where ename=‘SCOTT’) as t2</span><br><span class="line">on t1.cid=t2.cid</span><br><span class="line">where t1.job=t2.job and t1.ename!=‘SCOTT’</span><br></pre></td></tr></table></figure><p>11．列出薪金 等于部门30中 员工的薪金 的所有员工的姓名和薪金。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select t1.ename,t1.sal</span><br><span class="line">from emp as t1</span><br><span class="line">join</span><br><span class="line">(select distinct SAL from emp where DEPTNO = 30) t2</span><br><span class="line">on t1.sal=t2.sal</span><br><span class="line">where t1.deptno!=30</span><br></pre></td></tr></table></figure><p>12．列出薪金高于在部门30工作的所有员工的薪金的员工姓名和薪金。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select t1.ename,t1.sal</span><br><span class="line">from (select ename,sal,1 as cid from emp where deptno!=30) as t1</span><br><span class="line">left join</span><br><span class="line">(select max(sal) as max_sal,1 as cid from emp where deptno=30) as t2</span><br><span class="line">on t1.cid=t2.cid</span><br><span class="line">where t1.sal&gt;t2.max_sal</span><br></pre></td></tr></table></figure><p>13．列出在每个部门工作的员工数量、平均工资和平均服务期限。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select t1.deptno,t1.people,t2.avg_sal,t3.avg_time</span><br><span class="line">from</span><br><span class="line">(select count(*) as people,deptno from emp group by deptno) as t1</span><br><span class="line">left join</span><br><span class="line">(select round(avg(sal),2) as avg_sal,deptno from emp group by deptno) as t2</span><br><span class="line">on t1.deptno=t2.deptno</span><br><span class="line">left join</span><br><span class="line">(select round(avg(datediff(current_date,hiredate)),2) as avg_time,deptno from emp group by deptno) as t3</span><br><span class="line">on t2.deptno=t3.deptno</span><br></pre></td></tr></table></figure><p>14．列出所有员工的姓名、部门名称和工资。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select t1.ename,t2.deptname,t1.sal</span><br><span class="line">from emp as t1</span><br><span class="line">left join</span><br><span class="line">dept as t2</span><br><span class="line">on t1.deptno=t2.deptno</span><br></pre></td></tr></table></figure><p>15．列出所有部门的详细信息和部门人数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select *</span><br><span class="line">from</span><br><span class="line">(select * from dept) as t1</span><br><span class="line">left join</span><br><span class="line">(select deptno,count(*) from emp group by deptno) as t2</span><br><span class="line">on t1.deptno=t2.deptno</span><br></pre></td></tr></table></figure><p>16．列出各种工作的最低工资。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select job,min(sal) from emp group by job</span><br></pre></td></tr></table></figure><p>17．列出各个部门的MANAGER（经理）的最低薪金。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select deptno,ename,min(sal) from emp where job=‘MANAGER’ group by deptno,ename</span><br></pre></td></tr></table></figure><p>18．列出所有员工的年工资,按年薪从低到高排序。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ename,(sal+if(bonus is null,0,bonus))*12 as year_sal from emp</span><br><span class="line">order by year_sal</span><br></pre></td></tr></table></figure><ol start="19"><li>列出每个部门薪水最高的前两名人员名称以及薪水。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ename,sal</span><br><span class="line">from</span><br><span class="line">(select ename,sal,deptno,row_number() over(partition by deptno order by sal desc) as rk</span><br><span class="line">from emp) as t</span><br><span class="line">where rk&lt;=2</span><br></pre></td></tr></table></figure><ol start="20"><li>列出每个员工从受雇开始到2018-12-12 为止共受雇了多少天。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ename,datediff(‘2018-12-12’,hiredate) from emp</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大数据学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive学习小结</title>
      <link href="/2021/09/26/Hive%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
      <url>/2021/09/26/Hive%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Hive学习小结"><a href="#Hive学习小结" class="headerlink" title="Hive学习小结"></a>Hive学习小结</h1><h2 id="Hive概述"><a href="#Hive概述" class="headerlink" title="Hive概述"></a>Hive概述</h2><p>Hive：由Facebook开源用于解决<font color="red">海量结构化日志</font>的数据统计。</p><p>Hive时基于Hadoop的一个<font color="red">数据仓库工具</font>,可以将<font color="red">结构化的数据文件映射为一张表</font>，并且提供<font color="red">类SQL</font>查询功能。</p><p><font color="red">本质是：将HQL转化成MapReduce程序。</font></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210926161107566.png" alt="image-20210926161107566"></p><ul><li>Hive处理的数据存储在HDFS上</li><li>Hive分析数据底层的默认实现时MapReduce</li><li>执行程序运行在Yarn上</li></ul><h2 id="Hive优缺点"><a href="#Hive优缺点" class="headerlink" title="Hive优缺点"></a>Hive优缺点</h2><p><strong>优点：</strong></p><ul><li>操作接口采用类SQL语法，提供快速开发的能力(简单、容易上手)</li><li>避免了去写MapReduce，减少开发人员的学习成本</li><li>Hive的执行延迟比较高，因此Hive常用于数据分析，对实时性要求不高的场合</li><li>Hive优势在于处理大数据，对于处理小数据没有优势，因为Hive的执行延迟比较高</li><li>Hive支持用户自定义函数，用户可以根据自己的需求来实现自己的函数</li></ul><p><strong>缺点：</strong></p><ul><li>Hive的HQL表达能力有限<ul><li>迭代式算法无法表达</li><li>数据挖掘方面不擅长</li></ul></li><li>Hive的效率比较低<ul><li>Hive自动生成的MapReduce作业，通常情况下不够智能化</li><li>Hive调优比较困难，粒度较粗</li></ul></li></ul><h2 id="Hive架构原理"><a href="#Hive架构原理" class="headerlink" title="Hive架构原理"></a>Hive架构原理</h2><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210926162659494.png" alt="image-20210926162659494"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210926163152731.png" alt="image-20210926163152731"></p><h2 id="数据上传"><a href="#数据上传" class="headerlink" title="数据上传"></a>数据上传</h2><p>将本地数据上传可以用两种方法</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法一：</span></span><br><span class="line">hadoop dfs -put xxx---本地数据的绝对路径 /user/hive/warehouse/xx--这个xx是你自己闯的数据库</span><br><span class="line"></span><br><span class="line"><span class="comment">#方法二：</span></span><br><span class="line">直接在hive里面输入</span><br><span class="line">load data <span class="built_in">local</span> inpath <span class="string">&#x27;xxx--本地数据的绝对路径&#x27;</span> into table xxx--你自己c</span><br></pre></td></tr></table></figure><h2 id="数据导出"><a href="#数据导出" class="headerlink" title="数据导出"></a>数据导出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert overwrite local directory &#x27;xxx--本地路径&#x27; select查询语句；</span><br></pre></td></tr></table></figure><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><h3 id="创表相关z"><a href="#创表相关z" class="headerlink" title="创表相关z"></a>创表相关z</h3><p>Hive表的默认分割符是：\001</p><p>以后创建表肯定要做分割的，所以需要在创表语句之后加上。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">row format delimited fields terminated by <span class="string">&#x27;xxx--你需要按照什么去分割&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="查看数据库更多详细信息：desc"><a href="#查看数据库更多详细信息：desc" class="headerlink" title="查看数据库更多详细信息：desc"></a>查看数据库更多详细信息：desc</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">desc database extended xxx--你需要删除的数据库名字</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210927210449453.png" alt="image-20210927210449453"></p><h3 id="删除数据库：drop"><a href="#删除数据库：drop" class="headerlink" title="删除数据库：drop"></a>删除数据库：drop</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">drop database xxx--你需要删除的数据库名字</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210927210838970.png" alt="image-20210927210838970"></p><h3 id="数据库表的操作"><a href="#数据库表的操作" class="headerlink" title="数据库表的操作"></a>数据库表的操作</h3><h4 id="内部表操作"><a href="#内部表操作" class="headerlink" title="内部表操作"></a>内部表操作</h4><h5 id="创建表的语法"><a href="#创建表的语法" class="headerlink" title="创建表的语法"></a>创建表的语法</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create [external] table [<span class="keyword">if</span> not exists] table_name(</span><br><span class="line">col_name data_type [comment <span class="string">&#x27;字段描述信息&#x27;</span>]</span><br><span class="line">col_name data_type [comment <span class="string">&#x27;字段描述信息&#x27;</span>]</span><br><span class="line">[comment <span class="string">&#x27;表的描述信息&#x27;</span>]</span><br><span class="line">[partitioned by (col_name data_type),...]</span><br><span class="line">[clustered by (col_name,col_name,...]</span><br><span class="line">[sorted by (col_name [asc|desc],...) into num_buckets buckets]</span><br><span class="line">[row format row_format]</span><br><span class="line">[storted as ...]</span><br><span class="line">[location <span class="string">&#x27;指定表的路径&#x27;</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>create table<ul><li>创建一个指定名字的表。如果相同名字的表已经存在，则抛出异常；用户可以用IF NOT EXISTS 选项来忽略这个一场</li></ul></li><li>external<ul><li>可以让用户创建一个外部表，在建表的同时指定一个指向实际数据的路径(LOCATION)，<font color="red">Hive创建内部表时，会将数据移动到数据仓库指向的路径；若创建外部表，仅记录数据所在的路径，不对数据的位置做任何改变。在删除表的时候，内部表的元数据和数据会被一起删除，而外部表只删除元数据，不删除数据。</font></li></ul></li><li>comment<ul><li>表示注释，默认不能使用中文</li></ul></li><li>partitioned by<ul><li>表示使用表分区，一个表可以拥有一个或者多个分区，每一个分区单独存在一个目录下</li></ul></li><li>clustered by<ul><li>对于每一个表分文件，Hive可以进行组织成桶，也就是说桶是更为细粒度的数据范围划分。Hive也是针对某一列进行桶的组织</li></ul></li><li>sorted by<ul><li>指定排序字段和排序规则</li></ul></li><li>row format<ul><li>指定表文件字段分隔符</li></ul></li><li>storted as<ul><li>指定表文件的存储格式。常用格式：SEQUENCEFILE,TEXTFILE,RCFILE,如果数据是纯文本，可以使用STORED AS TEXTFILE。如果数据需要压缩，使用storted as SEQUENCEFILE。</li></ul></li><li>location<ul><li>指定表文件的存储路径</li></ul></li></ul><h5 id="创建表并且指定文件的存放路径"><a href="#创建表并且指定文件的存放路径" class="headerlink" title="创建表并且指定文件的存放路径"></a>创建表并且指定文件的存放路径</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create table <span class="keyword">if</span> not exists table_name(id int,name string,...) row format delimited fields terminated by <span class="string">&#x27;,&#x27;</span> location <span class="string">&#x27;xxx--你需要存放的路径&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="根据查询结果创建表"><a href="#根据查询结果创建表" class="headerlink" title="根据查询结果创建表"></a>根据查询结果创建表</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create table table_name as select * from table_name1; <span class="comment"># 通过复制表结构和表内容创建新表</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210927220531314.png" alt="image-20210927220531314"></p><h5 id="根据已经存在的表结构创建表"><a href="#根据已经存在的表结构创建表" class="headerlink" title="根据已经存在的表结构创建表"></a>根据已经存在的表结构创建表</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create table table_name like table_name1; <span class="comment"># 只会创建出表的结构，并不会同时创建表中的数据</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210927220740030.png" alt="image-20210927220740030"></p><h5 id="查看表的详细信息"><a href="#查看表的详细信息" class="headerlink" title="查看表的详细信息"></a>查看表的详细信息</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">desc formatted xxx--你表的名字</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210928194521758.png" alt="image-20210928194521758"></p><h5 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">drop table xxx--你表的名字</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210928194636315.png" alt="image-20210928194636315"></p><p>其实是将数据移动到了回收站。</p><h4 id="外部表操作"><a href="#外部表操作" class="headerlink" title="外部表操作"></a>外部表操作</h4><h5 id="外部表说明"><a href="#外部表说明" class="headerlink" title="外部表说明"></a>外部表说明</h5><p>外部表因为是指定其他的hdfs路径的数据加载到表当中来，所以hive表会认为自己不完全独占这份数据，所以删除hive表的时候，数据仍然存放在hdfs当中，不会删掉。</p><h5 id="内部表和外部表的使用场景"><a href="#内部表和外部表的使用场景" class="headerlink" title="内部表和外部表的使用场景"></a>内部表和外部表的使用场景</h5><p>例如：每天需要将收集到的网站日志定期流入HDFS文本文件中。然后在这个基础上对数据做大量分析，而这个数据可能要对很多部门进行共享，那么这个时候我们就需要用到外部表。而每个部门经过分析之后得到了属于自己的一些结果，那么我们就可以将生成的一些中间表，结果表使用内部表存储。数据通过SELECT+INSERT进入内部表。</p><p><strong>创建外部表的时候只需要加上external关键字即可。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210928195839473.png" alt="image-20210928195839473"></p><p>此时创建的这张表就是外部表。</p><h5 id="查询表的类型"><a href="#查询表的类型" class="headerlink" title="查询表的类型"></a>查询表的类型</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">desc formatted xx--你的表的名字</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211005104849992.png" alt="image-20211005104849992"></p><h5 id="修改表为外部表"><a href="#修改表为外部表" class="headerlink" title="修改表为外部表"></a>修改表为外部表</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alter table xx--你需要修改表的名字 <span class="built_in">set</span> tblproperties(<span class="string">&#x27;EXTERNAL&#x27;</span>=<span class="string">&#x27;TRUE&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211005105148917.png" alt="image-20211005105148917"></p><p>此时就能很直观的看到已经修改为外部表了。</p><p><font color="red">注意：’EXTERNAL’=’TRUE’必须是大写！！！</font></p><h4 id="分区表的操作"><a href="#分区表的操作" class="headerlink" title="分区表的操作"></a>分区表的操作</h4><p>在大数据中，最常用的一种思想就是分治，我们可以把大的文件切割划分成一个个的小的文件，这样每次操作一个小的文件就会很容易了，同样的道理，在hive当中也是支持这种思想的，就是我们可以把大的数据，按照每月，或者天进行切分成一个个的小的文件，存放在不同的文件夹中。</p><p><strong>关键字：partitioned by</strong></p><p>例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create table fst(id int,name string) partitioned by (xxx--你要以什么作为分区) row format delimited fields terminated by <span class="string">&#x27;\t&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210928220614714.png" alt="image-20210928220614714"></p><h5 id="加载数据到分区"><a href="#加载数据到分区" class="headerlink" title="加载数据到分区"></a>加载数据到分区</h5><p>因为之前已经分过区了，所以加载数据进去的时候需要指明以什么作为分区。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210928220907209.png" alt="image-20210928220907209"></p><h5 id="增加分区"><a href="#增加分区" class="headerlink" title="增加分区"></a>增加分区</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alter table xx--你的表 add partition (xxx--你的分区)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211005111122502.png" alt="image-20211005111122502"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211005111139585.png" alt="image-20211005111139585"></p><h5 id="查看分区"><a href="#查看分区" class="headerlink" title="查看分区"></a>查看分区</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">show partitions xxx--你自己的数据表</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210928221225302.png" alt="image-20210928221225302"></p><h5 id="删除分区"><a href="#删除分区" class="headerlink" title="删除分区"></a>删除分区</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alter table xxx--你自己的表 drop partition(xxx--你刚刚创的分区);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210928221456978.png" alt="image-20210928221456978"></p><p>可以清楚的看到我刚创的分区已经被我给删除了。</p><h5 id="修复表"><a href="#修复表" class="headerlink" title="修复表"></a>修复表</h5><p>当表与数据文件之间的映射关系没有建立起来时，可以对表进行修复，重新建立映射关系。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msck repair table xxx--你自己表的名称;</span><br></pre></td></tr></table></figure><h4 id="动态分区"><a href="#动态分区" class="headerlink" title="动态分区"></a>动态分区</h4><p>动态分区：根据数据中某几列的不同的取值划分不同的分区。但是在Hive中是默认不开启动态分区的。我们要想进行动态分区，就需要开启它。</p><h5 id="开启Hive的动态分区功能"><a href="#开启Hive的动态分区功能" class="headerlink" title="开启Hive的动态分区功能"></a>开启Hive的动态分区功能</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> hive.exec.dynamic.partition=<span class="literal">true</span>;<span class="comment"># 表示开启动态分区set hive.exec.dynamic.partition.mode=nostrict;# 表示动态分区模式：strict（需要配合静态分区一起使用）、nostrictset hive.exec.max.dynamic.partitions.pernode=1000;# 表示支持的最大的分区数量为1000，可以根据业务自己调整</span></span><br></pre></td></tr></table></figure><h4 id="分桶表操作"><a href="#分桶表操作" class="headerlink" title="分桶表操作"></a>分桶表操作</h4><p><font color="red">分区针对的是数据的存储路径，分桶针对的是数据文件</font></p><p>分桶，就是将数据按照指定的字段进行划分到多个文件当中去，分桶就是MapReduce中的分区。</p><p>Hive默认的是关闭了分桶功能，此时我们要想进行分桶操作，就要开启它。</p><h5 id="开启Hive的分桶功能"><a href="#开启Hive的分桶功能" class="headerlink" title="开启Hive的分桶功能"></a>开启Hive的分桶功能</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> hive.enforce.bucketing=<span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h5 id="设置Reduce个数"><a href="#设置Reduce个数" class="headerlink" title="设置Reduce个数"></a>设置Reduce个数</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> mapreduce.job.reduce=3;</span><br></pre></td></tr></table></figure><h5 id="创建分桶表"><a href="#创建分桶表" class="headerlink" title="创建分桶表"></a>创建分桶表</h5><p><strong>关键字：clustered by</strong></p><p>例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create table course(c_id string,c_name string,t_id string) clustered by (c_id) into 3 buckets row format delimited fields terminated by <span class="string">&#x27;\t&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>桶表中的数据加载，由于桶表的数据加载通过hdfs dfs -put文件或者通过load data均不好使，只能通过insert overwrite。</p><p>创建普通表，并通过insert overwrite的方式将普通表通过查询的方式加载到桶表当中去。</p><h5 id="创建普通表"><a href="#创建普通表" class="headerlink" title="创建普通表"></a>创建普通表</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create table course_common(c_id string,c_name string,t_id string) row format delimited fields terminated by <span class="string">&#x27;\t&#x27;</span>;</span><br></pre></td></tr></table></figure><h5 id="普通表中加载数据"><a href="#普通表中加载数据" class="headerlink" title="普通表中加载数据"></a>普通表中加载数据</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">load data <span class="built_in">local</span> inpath <span class="string">&#x27;xxx--你自己数据的路径&#x27;</span> into table course_common;</span><br></pre></td></tr></table></figure><h5 id="通过insert-overwrite给桶表中加载数据"><a href="#通过insert-overwrite给桶表中加载数据" class="headerlink" title="通过insert overwrite给桶表中加载数据"></a>通过insert overwrite给桶表中加载数据</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">insert overwrite table course select * from course_common cluster by (c_id);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210929194140298.png" alt="image-20210929194140298"></p><p>可以很直观的看到确实将数据分成了3份。</p><h3 id="修改表的结构"><a href="#修改表的结构" class="headerlink" title="修改表的结构"></a>修改表的结构</h3><h4 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alter table old_table_name rename to new_table_name;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210929194651269.png" alt="image-20210929194651269"></p><p>可以很明确的看到已经修改成功了。</p><h4 id="添加列"><a href="#添加列" class="headerlink" title="添加列"></a>添加列</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alter table xxx--你需要添加的列的表 add columns (xxx--这是你需要添加的字段)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210929195327460.png" alt="image-20210929195327460"></p><p>可以很清楚的看到添加成功了。</p><h4 id="更新列"><a href="#更新列" class="headerlink" title="更新列"></a>更新列</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alter table xxx---你需要修改的列的表 change column x--原来列的名字 xx--新的列名字 xxx--新的列属性</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210929195801325.png" alt="image-20210929195801325"></p><h2 id="Hive语法"><a href="#Hive语法" class="headerlink" title="Hive语法"></a>Hive语法</h2><p>和MySQL中的基本类似。</p><ul><li>order by会对输入做全局排序，因此只有一个reducer，会导致当输入规模较大时，需要较长的计算时间。</li><li>sort by不是全局排序，其在数据进入reducer前完成排序。因此，如果使用sort by进行排序，并且设置mapred.reduce.task&gt;1,则sort by只保证每个reducer的输出有序，不保证全局有序。</li><li>distribute by(字段)根据指定的字段将数据分到不同的reducer，且分发算法是hash散列。</li><li>cluster by(字段)除了具有distribute by的功能外，还会对该字段进行排序。</li></ul><p>因此，如果distribute和sort字段是同一个时，此时，<font color="red">cluster by = distribute by + sort by。</font></p><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><ul><li>count()：求总行数</li><li>max：求最大值</li><li>min：求最小值</li><li>sum：求和</li><li>avg：求平均值</li></ul><h3 id="LIMIT语句"><a href="#LIMIT语句" class="headerlink" title="LIMIT语句"></a>LIMIT语句</h3><p>典型的查询会返回多行数据。LIMIT子句用于限制返回的行数。和MySQL中的一样。</p><h3 id="WHERE语句"><a href="#WHERE语句" class="headerlink" title="WHERE语句"></a>WHERE语句</h3><p>和MySQL中用法一样。</p><h3 id="GROUP-BY语句"><a href="#GROUP-BY语句" class="headerlink" title="GROUP BY语句"></a>GROUP BY语句</h3><p>和MySQL中一样，值得注意的是：在hive中，select后面的字段必须和分组的字段一样，也可以省略不写，这点和MySQL中的有点区别。</p><h3 id="HIVING语句"><a href="#HIVING语句" class="headerlink" title="HIVING语句"></a>HIVING语句</h3><ul><li>having与where不同点<ul><li>where针对表中的列发挥作用，查询数据；having针对查询结果中的列发挥作用，筛选数据。</li><li>where后面不能写分组函数，而having后面可以使用分组函数。</li><li>having只用于group by分组统计语句</li></ul></li></ul><h3 id="表的别名"><a href="#表的别名" class="headerlink" title="表的别名"></a>表的别名</h3><ul><li>好处<ul><li>使用别名可以简化查询</li><li>使用别名前缀可以提高执行效率</li></ul></li></ul><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="全局排序"><a href="#全局排序" class="headerlink" title="全局排序"></a>全局排序</h4><p>Order By：全局排序，只能有一个reduce；</p><ul><li>使用order by子句排序默认升序：ASC;降序：DESC</li><li>order by子句在select语句的结尾。</li></ul><h4 id="每个MapReduce内部排序-sort-by-局部排序"><a href="#每个MapReduce内部排序-sort-by-局部排序" class="headerlink" title="每个MapReduce内部排序(sort by)局部排序"></a>每个MapReduce内部排序(sort by)局部排序</h4><p>sort by：每个MapReduce内部进行排序，对全局结果集来说不是排序。</p><p>设置reduce个数</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> mapreduce.job.reduce=3;</span><br></pre></td></tr></table></figure><p>查看设置reduce个数</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> mapreduce.job.reduces;</span><br></pre></td></tr></table></figure><p>将查询结果文件导入到本地</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert overwrite local directory &#x27;xxx--本地路径&#x27; select查询语句；</span><br></pre></td></tr></table></figure><h4 id="分区排序-DISTRIBUTE-BY"><a href="#分区排序-DISTRIBUTE-BY" class="headerlink" title="分区排序(DISTRIBUTE BY)"></a>分区排序(DISTRIBUTE BY)</h4><p>Distribute By：类似MR中的partition，进行分区，结合sort by使用。</p><p>注意：Hive要求distribute by语句要写在sort by语句之前</p><p>对于distribute by进行测试，一定要分配多个reduce进行处理，否则无法看到distribute by的效果。</p><p>设置reduce的个数，将我们对应的文件划分到对应的reduce中去。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> mapreduce.job.reduces=xx--你想设置的个数；</span><br></pre></td></tr></table></figure><h4 id="Cluster-By"><a href="#Cluster-By" class="headerlink" title="Cluster By"></a>Cluster By</h4><p>当distribute by和sort by字段相同时，可以使用cluster by方式。</p><p>cluster by除了具有distribute by的功能外还兼具sort by的功能。但是排序<font color="red">只能是升序排序，</font>不能指定排序规则为ASC或者DESC。</p><h2 id="Hive函数"><a href="#Hive函数" class="headerlink" title="Hive函数"></a>Hive函数</h2><h3 id="空字段赋值"><a href="#空字段赋值" class="headerlink" title="空字段赋值"></a>空字段赋值</h3><p>NVL：给值为NULL的数据赋值，它的格式是NVL(string1，replace_with)。它的功能是如果string1为NULL，则NVL函数返回replace_with，否则返回string1的值，如果两个参数都为NULL，则返回NULL。</p><h3 id="时间类"><a href="#时间类" class="headerlink" title="时间类"></a>时间类</h3><ul><li>date_format:格式化时间</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211005143243726.png" alt="image-20211005143243726"></p><ul><li>date_add:时间跟天数相加</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211005143310544.png" alt="image-20211005143310544"></p><ul><li>date_sub:时间跟天数相减</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211005143349752.png" alt="image-20211005143349752"></p><ul><li>datediff:两个时间相减</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211005143430189.png" alt="image-20211005143430189"></p><h3 id="行转列"><a href="#行转列" class="headerlink" title="行转列"></a>行转列</h3><p>CONCAT(string A/col, string B/col…)：返回输入字符串连接后的结果，支持任意个输入字符串;</p><p>CONCAT_WS(separator, str1, str2,…)：它是一个特殊形式的 CONCAT()。第一个参数剩余参数间的分隔符。分隔符可以是与剩余参数一样的字符串。如果分隔符是 NULL，返回值也将为 NULL。这个函数会跳过分隔符参数后的任何 NULL 和空字符串。分隔符将被加到被连接的字符串之间;</p><p>COLLECT_SET(col)：函数只接受基本数据类型，它的主要作用是将某字段的值进行去重汇总，产生 array 类型字段。</p><h4 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h4><p>拼接任意字符串</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211005154504775.png" alt="image-20211005154504775"></p><h4 id="concat-ws"><a href="#concat-ws" class="headerlink" title="concat_ws"></a>concat_ws</h4><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211005155520173.png" alt="image-20211005155520173"></p><h3 id="列转行"><a href="#列转行" class="headerlink" title="列转行"></a>列转行</h3><p>EXPLODE(col)：将 hive 一列中复杂的 array 或者 map 结构拆分成多行。</p><p>LATERAL VIEW</p><p>用法：LATERAL VIEW udtf(expression) tableAlias AS columnAlias</p><p>解释：用于和 split, explode 等 UDTF 一起使用，它能够将一列数据拆成多行数据，在此基础上可以对拆分后的数据进行聚合。</p><p>例如：</p><p>这里的数据是我自己准备好的。需要将电影分类中的数组数据展开成如下结果</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211005182142031.png" alt="image-20211005182142031"></p><p><strong>原数据：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211005182206876.png" alt="image-20211005182206876"></p><p>导入数据如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211005182650003.png" alt="image-20211005182650003"></p><p>结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select movie,category_name from movie_info lateral view explode(category) table_tmp as category_name;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211005183846684.png" alt="image-20211005183846684"></p><h3 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h3><p>OVER()：指定分析函数工作的数据窗口大小，这个数据窗口大小可能会随着行的变化</p><p>而变化；</p><p>CURRENT ROW：当前行； </p><p>n PRECEDING：往前 n 行数据； </p><p>n FOLLOWING：往后 n 行数据；</p><p>UNBOUNDED：起点，UNBOUNDED PRECEDING 表示从前面的起点，UNBOUNDED FOLLOWING 表示到后面的终点； </p><p>LAG(col,n)：往前第 n 行数据；</p><p>LEAD(col,n)：往后第 n 行数据；</p><p>NTILE(n)：把有序分区中的行分发到指定数据的组中，各个组有编号，编号从 1 开始，</p><p>对于每一行，NTILE 返回此行所属的组的编号。注意：n 必须为 int 类型</p><h3 id="RANK"><a href="#RANK" class="headerlink" title="RANK"></a>RANK</h3><p>RANK() 排序相同时会重复，总数不会变</p><p>DENSE_RANK() 排序相同时会重复，总数会减少</p><p>ROW_NUMBER() 会根据顺序计算</p><p>举例说明，以下数据是为了计算排名：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">RANK()DENSE_RANK()ROW_NUMBER()</span><br><span class="line">90 111</span><br><span class="line">90     112</span><br><span class="line">80 323</span><br><span class="line">70 434</span><br></pre></td></tr></table></figure><h3 id="窗口帧格式-即滑动窗口"><a href="#窗口帧格式-即滑动窗口" class="headerlink" title="窗口帧格式(即滑动窗口)"></a>窗口帧格式(即滑动窗口)</h3><p>窗口帧格式<br>    格式1:按照行的记录取值<br>        ROWS  BETWEEN (UNBOUNDED | [num]) PRECEDING AND ([num] PRECEDING | CURRENT ROW | (UNBOUNDED | [num]) FOLLOWING)<br>    格式2:当前所指定值的范围取值<br>        RANGE BETWEEN (UNBOUNDED | [num]) PRECEDING AND ([num] PRECEDING | CURRENT ROW | (UNBOUNDED | [num]) FOLLOWING)<br>    注意:<br>        UNBOUNDED:无界限<br>        CURRENT ROW:当前行</p><p>rows格式1:前2行+当前行+后两行<br>    sum(score) over (partition by clazz order by score desc rows between 2 PRECEDING and 2 FOLLOWING)<br>rows格式2:前记录到最末尾的总和<br>    sum(score) over (partition by clazz order by score desc rows between CURRENT ROW and UNBOUNDED FOLLOWING)</p><p>range格式1: 如果当前值在80,取值就会落在范围在80-2=78和80+2=82组件之内的行<br>    max(score) over (partition by clazz order by score desc range between 2 PRECEDING and 2 FOLLOWING)</p><h2 id="自定义函数UDF"><a href="#自定义函数UDF" class="headerlink" title="自定义函数UDF"></a>自定义函数UDF</h2><p>Hive 提供的内置函数无法满足你的业务处理需要时,此时就可以考虑使用用户自定义函数。</p><h3 id="UDF一进一出"><a href="#UDF一进一出" class="headerlink" title="UDF一进一出"></a>UDF一进一出</h3><h4 id="一个参数"><a href="#一个参数" class="headerlink" title="一个参数"></a>一个参数</h4><p>1.首先创建maven项目并添加依赖</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.hive&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;hive-exec&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.2.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>2.编写代码，继承org.apache.hadoop.hive.ql.exec.UDF <strong>实现evaluate方法</strong>，在evaluate方法中实现自己的逻辑</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import org.apache.hadoop.hive.ql.exec.UDF;</span><br><span class="line"></span><br><span class="line">public class HiveUDF extends UDF &#123;</span><br><span class="line">    public String evaluate(String str)&#123;</span><br><span class="line">        String s = <span class="string">&quot;---&quot;</span>+str+<span class="string">&quot;---&quot;</span>;</span><br><span class="line">        <span class="built_in">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.打成jar包上传至虚拟机</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211008211855026.png" alt="image-20211008211855026"></p><p>上传至存放包的路径下</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20211008211934906.png" alt="image-20211008211934906"></p><p>4.进入hive客户端添加jar包</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/c02a3abffa7e4d768f952d272011eff1.png" alt="在这里插入图片描述"></p><p>5.创建临时函数：hive&gt;CREATE TEMPORARY FUNCTION f_up as ‘name’;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/21b4a5344b6f4f918f6447c761b653d5.png" alt="img"></p><p>6.使用HiveUDF函数</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/345a07fd7f734a4697c3bfe1d7ae223b.png" alt="img"></p><h4 id="多个参数"><a href="#多个参数" class="headerlink" title="多个参数"></a>多个参数</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import org.apache.hadoop.hive.ql.exec.UDF;</span><br><span class="line"></span><br><span class="line">public class HiveUDF01 extends UDF &#123;</span><br><span class="line">    public String evaluate(String str1,String str2)&#123;</span><br><span class="line">        String s = str1+<span class="string">&quot;---&quot;</span>+str2;</span><br><span class="line">        <span class="built_in">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现有多个参数的时候，也是可以只输出一个结果，所以UDAF（多进一出就不常用）</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/611d43e45ca5421cabb045bea9163c5d.png" alt="img"></p><h3 id="UDTF一进多出"><a href="#UDTF一进多出" class="headerlink" title="UDTF一进多出"></a>UDTF一进多出</h3><p>大致的步骤差不多，这里只给出关键代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.exec.UDFArgumentException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.metadata.HiveException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.udf.generic.GenericUDTF;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HiveUDTF</span> <span class="keyword">extends</span> <span class="title">GenericUDTF</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.3.1之后不需要写</span></span><br><span class="line">    <span class="comment">//初始化：指定输出的数量和输出的格式</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StructObjectInspector <span class="title">initialize</span><span class="params">(StructObjectInspector argOIs)</span> <span class="keyword">throws</span> UDFArgumentException </span>&#123;</span><br><span class="line">        <span class="comment">//指定输出多少列（操作列的数量和名称）</span></span><br><span class="line">        ArrayList&lt;String&gt; fieldName = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">//操作列的类型</span></span><br><span class="line">        ArrayList&lt;ObjectInspector&gt; fieldObj = <span class="keyword">new</span> ArrayList&lt;ObjectInspector&gt;();<span class="comment">//检测当前给的是什么类型</span></span><br><span class="line">        <span class="comment">//输出两列</span></span><br><span class="line">        <span class="comment">//第一列</span></span><br><span class="line">        fieldName.add(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">        fieldObj.add(PrimitiveObjectInspectorFactory.javaStringObjectInspector);<span class="comment">//检查给的是不是String类型</span></span><br><span class="line">        <span class="comment">//第二列</span></span><br><span class="line">        fieldName.add(<span class="string">&quot;y&quot;</span>);</span><br><span class="line">        fieldObj.add(PrimitiveObjectInspectorFactory.javaStringObjectInspector);</span><br><span class="line">        <span class="keyword">return</span> ObjectInspectorFactory.getStandardStructObjectInspector(fieldName,fieldObj);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//假设进来的格式为：(&quot;k1:v1,k2:v2,k3:v3&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Object[] objects)</span> <span class="keyword">throws</span> HiveException </span>&#123;</span><br><span class="line">        String s = objects[<span class="number">0</span>].toString();<span class="comment">//这里的参数0，指的就是上面进来的格式</span></span><br><span class="line">        <span class="comment">//切分出来每行数据</span></span><br><span class="line">        String[] rows = s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String row : rows) &#123;</span><br><span class="line">            String[] split = row.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">            <span class="comment">//通过forward()输出</span></span><br><span class="line">            forward(split);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打包上传并且注册函数并执行</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/f2a0c5d6b2564b0bb54e3d06c212b6b6.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/3fa04a84a9e84e989187a19668f94f8c.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 大数据学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive环境搭建</title>
      <link href="/2021/09/25/Hive%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2021/09/25/Hive%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Hive搭建"><a href="#Hive搭建" class="headerlink" title="Hive搭建"></a>Hive搭建</h1><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>安装的前提首先需要先将相应的环境都搭建完毕。Hadoop，mysql啥的，详情请见之前的服务搭建步骤。</p><p>其次就是<font color="red">Hadoop和mysql必须要先启动</font>。</p><h2 id="将压缩包上传并且解压"><a href="#将压缩包上传并且解压" class="headerlink" title="将压缩包上传并且解压"></a>将压缩包上传并且解压</h2><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210925133220212.png" alt="image-20210925133220212"></p><p><strong>解压</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf /usr/<span class="built_in">local</span>/module/apache-hive-1.2.1-bin.tar.gz -C /usr/<span class="built_in">local</span>/soft/</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210925133746320.png" alt="image-20210925133746320"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210925133906664.png" alt="image-20210925133906664"></p><p>可以看到解压已经完成。我这里名字太长了，所以重起了一个名字。</p><p>修改目录名称</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv apache-hive-1.2.1-bin/ hive-1.2.1</span><br></pre></td></tr></table></figure><h2 id="修改Hive配置文件"><a href="#修改Hive配置文件" class="headerlink" title="修改Hive配置文件"></a>修改Hive配置文件</h2><h3 id="备份配置文件"><a href="#备份配置文件" class="headerlink" title="备份配置文件"></a>备份配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp hive-env.sh.template hive-env.sh</span><br><span class="line">cp hive-default.xml.template hive-site.xml</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210925134245026.png" alt="image-20210925134245026"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210925135746445.png" alt="image-20210925135746445"></p><h3 id="修改hive-env-sh配置文件"><a href="#修改hive-env-sh配置文件" class="headerlink" title="修改hive-env.sh配置文件"></a>修改hive-env.sh配置文件</h3><p>在里面加入三行内容(视个人配置情况而定)</p><p>HADOOP_HOME=/usr/local/soft/hadoop-2.7.6<br>JAVA_HOME=/usr/local/soft/jdk1.8.0_171<br>HIVE_HOME=/usr/local/soft/hive-1.2.1</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210925135019048.png" alt="image-20210925135019048"></p><h3 id="修改hive-site-xml配置文件"><a href="#修改hive-site-xml配置文件" class="headerlink" title="修改hive-site.xml配置文件"></a>修改hive-site.xml配置文件</h3><h4 id="分别修改如下的配置即可"><a href="#分别修改如下的配置即可" class="headerlink" title="分别修改如下的配置即可"></a>分别修改如下的配置即可</h4><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210925150535899.png" alt="image-20210925150535899"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210925140535136.png" alt="image-20210925140535136"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210925140600103.png" alt="image-20210925140600103"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210925140638638.png" alt="image-20210925140638638"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210925140757786.png" alt="image-20210925140757786"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210925140918229.png" alt="image-20210925140918229"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210925140958829.png" alt="image-20210925140958829"></p><h4 id="配置文件总代码如下"><a href="#配置文件总代码如下" class="headerlink" title="配置文件总代码如下"></a>配置文件总代码如下</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;</span><br><span class="line">&lt;value&gt;jdbc:mysql://master:3306/hive?characterEncoding=UTF-8&amp;amp;createDatabaseIfNotExist=<span class="literal">true</span>&amp;amp;useSSL=<span class="literal">false</span>&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;</span><br><span class="line">&lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;</span><br><span class="line">&lt;value&gt;root&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;</span><br><span class="line">&lt;value&gt;123456&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;hive.querylog.location&lt;/name&gt;</span><br><span class="line">&lt;value&gt;/usr/<span class="built_in">local</span>/soft/hive-1.2.1/tmp&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;hive.exec.local.scratchdir&lt;/name&gt;</span><br><span class="line">&lt;value&gt;/usr/<span class="built_in">local</span>/soft/hive-1.2.1/tmp&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;hive.downloaded.resources.dir&lt;/name&gt;</span><br><span class="line">&lt;value&gt;/usr/<span class="built_in">local</span>/soft/hive-1.2.1/tmp&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><h3 id="拷贝mysql驱动到-HIVE-HOME-lib目录下"><a href="#拷贝mysql驱动到-HIVE-HOME-lib目录下" class="headerlink" title="拷贝mysql驱动到$HIVE_HOME/lib目录下"></a>拷贝mysql驱动到$HIVE_HOME/lib目录下</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210925141405552.png" alt="image-20210925141405552"></p><p>在这个路径下面去执行拷贝</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp /usr/<span class="built_in">local</span>/module/mysql-connector-java-5.1.49.jar /usr/<span class="built_in">local</span>/soft/hive-1.2.1/lib/</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210925141529946.png" alt="image-20210925141529946"></p><h3 id="将hadoop的jline-2-12-jar的jar替换成hive的版本"><a href="#将hadoop的jline-2-12-jar的jar替换成hive的版本" class="headerlink" title="将hadoop的jline-2.12.jar的jar替换成hive的版本"></a>将hadoop的jline-2.12.jar的jar替换成hive的版本</h3><p>先将hadoop中的jline-2.12.jar给删除，因为怕冲突。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -rf /usr/<span class="built_in">local</span>/soft/hadoop-2.7.6/share/hadoop/yarn/lib/jline-2.12.jar</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210925143753792.png" alt="image-20210925143753792"></p><p>接着执行拷贝命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp /usr/<span class="built_in">local</span>/soft/hive-1.2.1/lib/jline-2.12.jar /usr/<span class="built_in">local</span>/soft/hadoop-2.7.6/share/hadoop/yarn/lib/</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210925142213278.png" alt="image-20210925142213278"></p><h2 id="至此Hive已经搭建完成"><a href="#至此Hive已经搭建完成" class="headerlink" title="至此Hive已经搭建完成"></a>至此Hive已经搭建完成</h2><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210925145907191.png" alt="image-20210925145907191"></p>]]></content>
      
      
      <categories>
          
          <category> 大数据学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadooop-HA安装步骤</title>
      <link href="/2021/09/24/Hadooop-HA%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/"/>
      <url>/2021/09/24/Hadooop-HA%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Hadoop——HA"><a href="#Hadoop——HA" class="headerlink" title="Hadoop——HA"></a>Hadoop——HA</h1><p>之前的博客写了搭建hadoop集群环境，今天写一写搭建高可用（HA）环境。Hadoop-HA模式大致分为两个(个人在学习中的理解)：</p><ul><li>namenode 高可用</li><li>yarn 高可用</li><li>主备切换</li></ul><p>在之前的博客中，Hadoop分布式环境搭建有教程，zookeeper集群搭建也有教程，这里是在这两个要求的前提下进行的。</p><p>Namenode在HDFS中是一个非常重要的组件，相当于HDFS文件系统的心脏，在显示分布式集群环境中，还是会有可能出现Namenode的崩溃或各种意外。所以，高可用模式就体现出作用了。<br>namenode HA配置大概流程(个人理解)：</p><ul><li>在启动namenode之前，需要启动hadoop2.x中新引入的（QJM）Quorum Journal Manager，QJM主要用来管理namenode之间的数据同步，当active namenode数据更新时会传递给QJM，QJM在所有的namenode之间同步，最后QJM将active namenode 更新的数据同步到了standby namenode中。</li><li>启动多个namenode时，并配置namenode的主机地址，还要配置隔离机制，因为容易出现SB（split-brain）状况，所谓的sb状况意思就是当多个namenode正常状态时，一台active，多台standby。如果某段时间因为网络等非namenode自身关系导致namenode间交流阻断了，这样容易出现多台active的设备，容易抢占资源等。</li><li>引入zookeeper来对namenode进行监听，因为在一般情况下，active 的namenode崩溃了的话，需要人工切换standby Namenode为active。非常不人性化。通过zookeeper可以监听多个namenode，当active namenode崩溃的话，zookeeper监听到后马上通知zookeeper的leader进行主备选举，在standby namenode中选举出一台，并将它置为active模式替换崩溃的namenode。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924202821954.png" alt="image-20210924202821954"></p><h2 id="HDFS搭建步骤如下所示"><a href="#HDFS搭建步骤如下所示" class="headerlink" title="HDFS搭建步骤如下所示"></a>HDFS搭建步骤如下所示</h2><h3 id="设置免密"><a href="#设置免密" class="headerlink" title="设置免密"></a>设置免密</h3><p>先设置免密，在node1下面设置。因为之前master已经设置过了，现在需要的是高可用版本，需要进行主备切换。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line"><span class="comment"># 分别发送</span></span><br><span class="line">ssh-copy-id -i master</span><br><span class="line">ssh-copy-id -i node1</span><br><span class="line">ssh-copy-id -i node1</span><br></pre></td></tr></table></figure><h3 id="修改hadoop配置文件"><a href="#修改hadoop配置文件" class="headerlink" title="修改hadoop配置文件"></a>修改hadoop配置文件</h3><p>修改两个文件：core-site.xml和hdfs-site.xml。并且修改之后同步到其他两个节点</p><p>scp * master:/usr/local/soft/hadoop-2.7.6/etc/hadoop/</p><p>scp * node2:/usr/local/soft/hadoop-2.7.6/etc/hadoop/</p><p><strong>core-site.xml修改配置如下</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;?xml-stylesheet <span class="built_in">type</span>=<span class="string">&quot;text/xsl&quot;</span> href=<span class="string">&quot;configuration.xsl&quot;</span>?&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">  Licensed under the Apache License, Version 2.0 (the <span class="string">&quot;License&quot;</span>);</span><br><span class="line">  you may not use this file except <span class="keyword">in</span> compliance with the License.</span><br><span class="line">  You may obtain a copy of the License at</span><br><span class="line"></span><br><span class="line">    http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"></span><br><span class="line">  Unless required by applicable law or agreed to <span class="keyword">in</span> writing, software</span><br><span class="line">  distributed under the License is distributed on an <span class="string">&quot;AS IS&quot;</span> BASIS,</span><br><span class="line">  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">  See the License <span class="keyword">for</span> the specific language governing permissions and</span><br><span class="line">  limitations under the License. See accompanying LICENSE file.</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Put site-specific property overrides <span class="keyword">in</span> this file. --&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">&lt;value&gt;hdfs://cluster&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">&lt;value&gt;/usr/<span class="built_in">local</span>/soft/hadoop-2.7.6/tmp&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;fs.trash.interval&lt;/name&gt;</span><br><span class="line">&lt;value&gt;1440&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">      &lt;name&gt;ha.zookeeper.quorum&lt;/name&gt;</span><br><span class="line">      &lt;value&gt;master:2181,node1:2181,node2:2181&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>hdfs-site.xml修改配置如下</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;?xml-stylesheet <span class="built_in">type</span>=<span class="string">&quot;text/xsl&quot;</span> href=<span class="string">&quot;configuration.xsl&quot;</span>?&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">  Licensed under the Apache License, Version 2.0 (the <span class="string">&quot;License&quot;</span>);</span><br><span class="line">  you may not use this file except <span class="keyword">in</span> compliance with the License.</span><br><span class="line">  You may obtain a copy of the License at</span><br><span class="line"></span><br><span class="line">    http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"></span><br><span class="line">  Unless required by applicable law or agreed to <span class="keyword">in</span> writing, software</span><br><span class="line">  distributed under the License is distributed on an <span class="string">&quot;AS IS&quot;</span> BASIS,</span><br><span class="line">  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">  See the License <span class="keyword">for</span> the specific language governing permissions and</span><br><span class="line">  limitations under the License. See accompanying LICENSE file.</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Put site-specific property overrides <span class="keyword">in</span> this file. --&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;!-- 指定hdfs元数据存储的路径 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;</span><br><span class="line">&lt;value&gt;/usr/<span class="built_in">local</span>/soft/hadoop-2.7.6/data/namenode&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 指定hdfs数据存储的路径 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;</span><br><span class="line">&lt;value&gt;/usr/<span class="built_in">local</span>/soft/hadoop-2.7.6/data/datanode&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 数据备份的个数 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">&lt;value&gt;1&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 关闭权限验证 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.permissions.enabled&lt;/name&gt;</span><br><span class="line">&lt;value&gt;<span class="literal">false</span>&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 开启WebHDFS功能（基于REST的接口服务） --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.webhdfs.enabled&lt;/name&gt;</span><br><span class="line">&lt;value&gt;<span class="literal">true</span>&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- //////////////以下为HDFS HA的配置////////////// --&gt;</span><br><span class="line">&lt;!-- 指定hdfs的nameservices名称为mycluster --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.nameservices&lt;/name&gt;</span><br><span class="line">&lt;value&gt;cluster&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 指定cluster的两个namenode的名称分别为nn1,nn2 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.ha.namenodes.cluster&lt;/name&gt;</span><br><span class="line">&lt;value&gt;nn1,nn2&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置nn1,nn2的rpc通信端口 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.namenode.rpc-address.cluster.nn1&lt;/name&gt;</span><br><span class="line">&lt;value&gt;master:8020&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.namenode.rpc-address.cluster.nn2&lt;/name&gt;</span><br><span class="line">&lt;value&gt;node1:8020&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置nn1,nn2的http通信端口 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.namenode.http-address.cluster.nn1&lt;/name&gt;</span><br><span class="line">&lt;value&gt;master:50070&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.namenode.http-address.cluster.nn2&lt;/name&gt;</span><br><span class="line">&lt;value&gt;node1:50070&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 指定namenode元数据存储在journalnode中的路径 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.namenode.shared.edits.dir&lt;/name&gt;</span><br><span class="line">&lt;value&gt;qjournal://master:8485;node1:8485;node2:8485/cluster&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 指定journalnode日志文件存储的路径 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.journalnode.edits.dir&lt;/name&gt;</span><br><span class="line">&lt;value&gt;/usr/<span class="built_in">local</span>/soft/hadoop-2.7.6/data/journal&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 指定HDFS客户端连接active namenode的java类 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.client.failover.proxy.provider.cluster&lt;/name&gt;</span><br><span class="line">&lt;value&gt;org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置隔离机制为ssh --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.ha.fencing.methods&lt;/name&gt;</span><br><span class="line">&lt;value&gt;sshfence&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 指定秘钥的位置 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.ha.fencing.ssh.private-key-files&lt;/name&gt;</span><br><span class="line">&lt;value&gt;/root/.ssh/id_rsa&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 开启自动故障转移 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.ha.automatic-failover.enabled&lt;/name&gt;</span><br><span class="line">&lt;value&gt;<span class="literal">true</span>&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><h3 id="删除hadoop数据存储目录下的文件，每个节点都要删除"><a href="#删除hadoop数据存储目录下的文件，每个节点都要删除" class="headerlink" title="删除hadoop数据存储目录下的文件，每个节点都要删除"></a>删除hadoop数据存储目录下的文件，每个节点都要删除</h3><p>rm -rf /usr/local/soft/hadoop-2.7.6/tmp</p><h3 id="启动zookeeper-三台都需要启动"><a href="#启动zookeeper-三台都需要启动" class="headerlink" title="启动zookeeper  三台都需要启动"></a>启动zookeeper  三台都需要启动</h3><p>zkServer.sh start<br>zkServer.sh status</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924210642900.png" alt="image-20210924210642900"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924210659308.png" alt="image-20210924210659308"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924210722205.png" alt="image-20210924210722205"></p><h3 id="启动JN，存储HDFS元数据"><a href="#启动JN，存储HDFS元数据" class="headerlink" title="启动JN，存储HDFS元数据"></a>启动JN，存储HDFS元数据</h3><p>注意：这步骤的前提是Hadoop没有启动</p><p>三台JN上执行 启动命令：<br> hadoop-daemon.sh start journalnode</p><h3 id="注意：此时执行到这个步骤时，节点应该一共有6个"><a href="#注意：此时执行到这个步骤时，节点应该一共有6个" class="headerlink" title="注意：此时执行到这个步骤时，节点应该一共有6个"></a>注意：此时执行到这个步骤时，节点应该一共有6个</h3><p>如图所示：分别是 master，node1，node2</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924211430002.png" alt="image-20210924211430002"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924211605477.png" alt="image-20210924211605477"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924211651077.png" alt="image-20210924211651077"></p><h3 id="格式化-在一台NN上执行"><a href="#格式化-在一台NN上执行" class="headerlink" title="格式化 在一台NN上执行"></a>格式化 在一台NN上执行</h3><p>​      hdfs namenode -format<br>​      启动当前的NN<br>​      hadoop-daemon.sh start namenode</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924212022062.png" alt="image-20210924212022062"></p><p>可以很直观的查看到高可用版本已经启动，并且主节点master上面已经有了NameNode</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924212146389.png" alt="image-20210924212146389"></p><h3 id="执行同步"><a href="#执行同步" class="headerlink" title="执行同步"></a>执行同步</h3><p>在没有格式化的NN上执行，在另外一个namenode上面执行。这里我是在node1上执行的。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924212302053.png" alt="image-20210924212302053"></p><p>可以看出已经绑定了</p><h3 id="格式化ZK"><a href="#格式化ZK" class="headerlink" title="格式化ZK"></a>格式化ZK</h3><p>在已经启动的namenode上执行！！！一定要先把ZK集群正常启动起来</p><p>hdfs zkfc -formatZK</p><h3 id="启动hdfs集群"><a href="#启动hdfs集群" class="headerlink" title="启动hdfs集群"></a>启动hdfs集群</h3><p>在启动了namenode的节点上执行</p><p>start-dfs.sh</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924213103725.png" alt="image-20210924213103725"></p><h3 id="注意：此时执行到这个步骤时，节点个数应该是一共有12个"><a href="#注意：此时执行到这个步骤时，节点个数应该是一共有12个" class="headerlink" title="注意：此时执行到这个步骤时，节点个数应该是一共有12个"></a>注意：此时执行到这个步骤时，节点个数应该是一共有12个</h3><p>如图所示：分别是 master，node1，node2</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924213338789.png" alt="image-20210924213338789"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924213418582.png" alt="image-20210924213418582"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924213439389.png" alt="image-20210924213439389"></p><p>接下来执行YARN的搭建步骤。</p><h2 id="YARN高可用搭建步骤如下所示"><a href="#YARN高可用搭建步骤如下所示" class="headerlink" title="YARN高可用搭建步骤如下所示"></a>YARN高可用搭建步骤如下所示</h2><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>修改yarn-site.xml和mapred-site.xml两个配置文件。并且修改之后同步到其他两个节点</p><p>scp * node1:/usr/local/soft/hadoop-2.7.6/etc/hadoop/</p><p>scp * node2:/usr/local/soft/hadoop-2.7.6/etc/hadoop/</p><p><strong>yarn-site.xml修改配置如下：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">  Licensed under the Apache License, Version 2.0 (the <span class="string">&quot;License&quot;</span>);</span><br><span class="line">  you may not use this file except <span class="keyword">in</span> compliance with the License.</span><br><span class="line">  You may obtain a copy of the License at</span><br><span class="line"></span><br><span class="line">    http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"></span><br><span class="line">  Unless required by applicable law or agreed to <span class="keyword">in</span> writing, software</span><br><span class="line">  distributed under the License is distributed on an <span class="string">&quot;AS IS&quot;</span> BASIS,</span><br><span class="line">  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">  See the License <span class="keyword">for</span> the specific language governing permissions and</span><br><span class="line">  limitations under the License. See accompanying LICENSE file.</span><br><span class="line">--&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;!-- NodeManager上运行的附属服务，需配置成mapreduce_shuffle才可运行MapReduce程序 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">&lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置Web Application Proxy安全代理（防止yarn被攻击） --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.web-proxy.address&lt;/name&gt;</span><br><span class="line">&lt;value&gt;master:8888&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 开启日志 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.log-aggregation-enable&lt;/name&gt;</span><br><span class="line">&lt;value&gt;<span class="literal">true</span>&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置日志删除时间为7天，-1为禁用，单位为秒 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.log-aggregation.retain-seconds&lt;/name&gt;</span><br><span class="line">&lt;value&gt;604800&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 修改日志目录 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.nodemanager.remote-app-log-dir&lt;/name&gt;</span><br><span class="line">&lt;value&gt;/logs&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置nodemanager可用的资源内存 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.nodemanager.resource.memory-mb&lt;/name&gt;</span><br><span class="line">&lt;value&gt;2048&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置nodemanager可用的资源CPU --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.nodemanager.resource.cpu-vcores&lt;/name&gt;</span><br><span class="line">&lt;value&gt;2&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- //////////////以下为YARN HA的配置////////////// --&gt;</span><br><span class="line">&lt;!-- 开启YARN HA --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.resourcemanager.ha.enabled&lt;/name&gt;</span><br><span class="line">&lt;value&gt;<span class="literal">true</span>&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 启用自动故障转移 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.resourcemanager.ha.automatic-failover.enabled&lt;/name&gt;</span><br><span class="line">&lt;value&gt;<span class="literal">true</span>&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 指定YARN HA的名称 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.resourcemanager.cluster-id&lt;/name&gt;</span><br><span class="line">&lt;value&gt;yarncluster&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 指定两个resourcemanager的名称 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.resourcemanager.ha.rm-ids&lt;/name&gt;</span><br><span class="line">&lt;value&gt;rm1,rm2&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置rm1，rm2的主机 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.resourcemanager.hostname.rm1&lt;/name&gt;</span><br><span class="line">&lt;value&gt;master&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.resourcemanager.hostname.rm2&lt;/name&gt;</span><br><span class="line">&lt;value&gt;node1&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置YARN的http端口 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.resourcemanager.webapp.address.rm1&lt;/name&gt;</span><br><span class="line">&lt;value&gt;master:8088&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.resourcemanager.webapp.address.rm2&lt;/name&gt;</span><br><span class="line">&lt;value&gt;node1:8088&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置zookeeper的地址 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.resourcemanager.zk-address&lt;/name&gt;</span><br><span class="line">&lt;value&gt;master:2181,node1:2181,node2:2181&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置zookeeper的存储位置 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.resourcemanager.zk-state-store.parent-path&lt;/name&gt;</span><br><span class="line">&lt;value&gt;/rmstore&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 开启yarn resourcemanager restart --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.resourcemanager.recovery.enabled&lt;/name&gt;</span><br><span class="line">&lt;value&gt;<span class="literal">true</span>&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置resourcemanager的状态存储到zookeeper中 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.resourcemanager.store.class&lt;/name&gt;</span><br><span class="line">&lt;value&gt;org.apache.hadoop.yarn.server.resourcemanager.recovery.ZKRMStateStore&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 开启yarn nodemanager restart --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.nodemanager.recovery.enabled&lt;/name&gt;</span><br><span class="line">&lt;value&gt;<span class="literal">true</span>&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置nodemanager IPC的通信端口 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.nodemanager.address&lt;/name&gt;</span><br><span class="line">&lt;value&gt;0.0.0.0:45454&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p><strong>mapred-site.xml修改配置如下：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span><br><span class="line">&lt;?xml-stylesheet <span class="built_in">type</span>=<span class="string">&quot;text/xsl&quot;</span> href=<span class="string">&quot;configuration.xsl&quot;</span>?&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">  Licensed under the Apache License, Version 2.0 (the <span class="string">&quot;License&quot;</span>);</span><br><span class="line">  you may not use this file except <span class="keyword">in</span> compliance with the License.</span><br><span class="line">  You may obtain a copy of the License at</span><br><span class="line"></span><br><span class="line">    http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"></span><br><span class="line">  Unless required by applicable law or agreed to <span class="keyword">in</span> writing, software</span><br><span class="line">  distributed under the License is distributed on an <span class="string">&quot;AS IS&quot;</span> BASIS,</span><br><span class="line">  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">  See the License <span class="keyword">for</span> the specific language governing permissions and</span><br><span class="line">  limitations under the License. See accompanying LICENSE file.</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Put site-specific property overrides <span class="keyword">in</span> this file. --&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;!-- 指定MapReduce计算框架使用YARN --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">&lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 指定jobhistory server的rpc地址 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt;</span><br><span class="line">&lt;value&gt;node1:10020&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 指定jobhistory server的http地址 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt;</span><br><span class="line">&lt;value&gt;node1:19888&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 开启uber模式（针对小作业的优化） --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;mapreduce.job.ubertask.enable&lt;/name&gt;</span><br><span class="line">&lt;value&gt;<span class="literal">true</span>&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置启动uber模式的最大map数 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;mapreduce.job.ubertask.maxmaps&lt;/name&gt;</span><br><span class="line">&lt;value&gt;9&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置启动uber模式的最大reduce数 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;mapreduce.job.ubertask.maxreduces&lt;/name&gt;</span><br><span class="line">&lt;value&gt;1&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>连接ZK，可以看到多了一个 hadoop-ha。起到一个监控作用。如果节点挂了，那么会启动回调函数，然后自动启动备用的节点。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924220849376.png" alt="image-20210924220849376"></p><h3 id="启动yarn"><a href="#启动yarn" class="headerlink" title="启动yarn"></a>启动yarn</h3><p>在master启动</p><p>start-yarn.sh</p><h3 id="在另外一台主节点上启动RM"><a href="#在另外一台主节点上启动RM" class="headerlink" title="在另外一台主节点上启动RM"></a>在另外一台主节点上启动RM</h3><p>yarn-daemon.sh start resourcemanager</p><h2 id="至此Hadoop——HA高可用已经全部弄好了，此时节点一共会有16个节点"><a href="#至此Hadoop——HA高可用已经全部弄好了，此时节点一共会有16个节点" class="headerlink" title="至此Hadoop——HA高可用已经全部弄好了，此时节点一共会有16个节点"></a>至此Hadoop——HA高可用已经全部弄好了，此时节点一共会有16个节点</h2><p>如图所示：分别是 master，node1，node2</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924221436253.png" alt="image-20210924221436253"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924221514774.png" alt="image-20210924221514774"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924221541718.png" alt="image-20210924221541718"></p>]]></content>
      
      
      <categories>
          
          <category> 大数据学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop——HA安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper</title>
      <link href="/2021/09/23/Zookeeper/"/>
      <url>/2021/09/23/Zookeeper/</url>
      
        <content type="html"><![CDATA[<h1 id="Zookeeper组件"><a href="#Zookeeper组件" class="headerlink" title="Zookeeper组件"></a>Zookeeper组件</h1><h2 id="Zookeeper安装"><a href="#Zookeeper安装" class="headerlink" title="Zookeeper安装"></a>Zookeeper安装</h2><p>上传zookeeper压缩包并且解压之后就要进行相应的环境变量的修改了。</p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>​    vim /etc/profile</p><h3 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210923184946776.png" alt="image-20210923184946776"></p><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp  zoo_sample.cfg zoo.cfg<span class="comment"># 拷贝一份进行修改</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210923185117479.png" alt="image-20210923185117479"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210923185212440.png" alt="image-20210923185212440"></p><h3 id="随后同步到其他节点上面。接着source一下。"><a href="#随后同步到其他节点上面。接着source一下。" class="headerlink" title="随后同步到其他节点上面。接着source一下。"></a>随后同步到其他节点上面。接着source一下。</h3><p>scp -r zookeeper-3.4.6路径 node1:新路径<br>scp -r zookeeper-3.4.6路径 node2:新路径</p><p>scp /etc/profile node1:/etc/<br>scp /etc/profile node2:/etc/</p><p>并且source。</p><h3 id="创建-usr-local-soft-zookeeper-3-4-6-data目录-所有节点都要创建"><a href="#创建-usr-local-soft-zookeeper-3-4-6-data目录-所有节点都要创建" class="headerlink" title="创建/usr/local/soft/zookeeper-3.4.6/data目录,所有节点都要创建"></a>创建/usr/local/soft/zookeeper-3.4.6/data目录,所有节点都要创建</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /usr/<span class="built_in">local</span>/soft/zookeeper-3.4.6/data</span><br></pre></td></tr></table></figure><p>在data目录下创建myid文件<br>    vim myid<br>    master,node1,node2分别加上0，1，2</p><h3 id="启动Zookeeper"><a href="#启动Zookeeper" class="headerlink" title="启动Zookeeper"></a>启动Zookeeper</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zkServer.sh start  三台都需要执行</span><br><span class="line">zkServer.sh status 查看状态</span><br><span class="line"></span><br><span class="line">当有一个leader的时候启动成功</span><br></pre></td></tr></table></figure><h3 id="连接Zookeeper"><a href="#连接Zookeeper" class="headerlink" title="连接Zookeeper"></a>连接Zookeeper</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zkCli.sh</span><br><span class="line">zk  是一个目录结构 ，每个节点可以存数据，同时可以有子节点</span><br></pre></td></tr></table></figure><h2 id="Zookeeper的概述"><a href="#Zookeeper的概述" class="headerlink" title="Zookeeper的概述"></a>Zookeeper的概述</h2><p>Zookeeper是一个开源的分布式协调服务框架，主要用来解决分布式集群中应用系统的一致性问题和数据管理问题。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210912153120466.png" alt="image-20210912153120466"></p><h2 id="Zookeeper的特点"><a href="#Zookeeper的特点" class="headerlink" title="Zookeeper的特点"></a>Zookeeper的特点</h2><p>Zookeeper本质上是一个分布式文件系统，适合存放小文件，也可以理解为一个数据库</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210912161631045.png" alt="image-20210912161631045"></p><ul><li>在上图左侧，Zookeeper中存储的其实是一个又一个Znode，Znode是Zookeeper中的节点。<ul><li>Znode也是有路径的，例如/data/host1，/data/host2，这个路径也可以理解为是Znode的Name</li><li>Znode也可以携带数据，例如某个Znode的路径是/data/host1，其值是一个字符串”192.168.0.1”</li></ul></li><li>正因为Znode的特性，所以Zookeeper可以对外提供出一个类似于文件系统的试图，可以通过操作文件系统的方式操作Zookeeper<ul><li>使用路径获取Znode</li><li>获取Znode携带的数据</li><li>修改Znode携带的数据</li><li>删除Znode</li><li>添加Znode</li></ul></li></ul><h2 id="Zookeeper的架构"><a href="#Zookeeper的架构" class="headerlink" title="Zookeeper的架构"></a>Zookeeper的架构</h2><p>其实Zookeeper本身也是一个集群，Zookeeper集群是一个基于主从架构的高可用集群。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210912163628667.png" alt="image-20210912163628667"></p><p>每个服务器承担如下三种角色中的一种</p><ul><li><strong>Leader</strong>一个Zookeeper集群同一时间只会有一个实际工作的Leader，它会发起并维护与各Follwer及Observer间的心跳。所有的写操作必须要通过Leader完成再由Leader将写操作广播给其他服务器。</li><li><strong>Follower</strong>一个Zookeeper集群可能同时存在多个Follower，它会响应Leader的心跳。Follower可直接处理并返回客户端的读请求，同时会将写请求转发给Leader处理，并且负责在Leader处理写请求时对请求进行投票。</li><li><strong>Observer</strong>角色与Follower类似，但是无投票权。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210912164448359.png" alt="image-20210912164448359"></p><h2 id="Zookeeper的选举机制"><a href="#Zookeeper的选举机制" class="headerlink" title="Zookeeper的选举机制"></a>Zookeeper的选举机制</h2><p>Zookeeper的选举又叫做Leader选举。Leader选举是保证分布式数据一致性的关键所在。当Zookeeper集群中的一台服务器出现以下两种情况之一时，需要进入Leader选举。</p><h3 id="服务器启动时期的Leader选举"><a href="#服务器启动时期的Leader选举" class="headerlink" title="服务器启动时期的Leader选举"></a>服务器启动时期的Leader选举</h3><p>若进行Leader选举，则至少需要两台机器，这里选取3台机器组成的服务器集群为例。在集群初始化阶段，当有一台服务器Server1启动时，其单独无法进行和完成Leader选举，当第二台服务器Server2启动时，此时两台机器可以相互通信，每台机器都试图找到Leader，于是进入Leader选举过程，选举过程如下</p><p>(1)<strong>每个Server发出一个投票</strong>。由于是初始情况，Server1和Server2都会将自己作为Leader服务器来进行投票，每次投票会包含所推举的服务器的myid和ZXID，使用(myid,ZXID)来表示，此时Server1的投票为(1，0)，Server2的投票为(2，0).然后各自将这个投票发给集群中的其他机器。</p><blockquote><p>myid:每台服务器的编号，值越大就表示机器越强，在选举中越占优势</p><p>ZXID:事务ID，值越大表示数据越新，越强大，在选举中越占优势</p></blockquote><p>(2)<strong>接受来自各个服务器的投票</strong>。集群中的每个服务器收到投票后，首先判断该投票的有效性，如检查是否是本轮投票，是否来自LOOKING状态的服务器</p><p>(3)<strong>处理投票。</strong>针对每一个投票，服务器都需要将别人的投票和自己的投票进行OK，PK规则如下所示:</p><ul><li><strong>优先检查ZXID</strong>。ZXID比较大的服务器优先作为Leader(注意:前提是投票的票数必须过半)</li><li><strong>如果ZXID相同，那么就比较myid</strong>。myid较大的服务器作为Leader服务器(注意:前提是投票的票数必须过半)</li></ul><p>对于Server1而言，它的投票是(1，0)，接收Server2的投票为(2，0)，首先会比较两者的ZXID，均为0。对于Server2而言，其无须更新自己的投票，只是再次向集群中所有机器发出上一次投票信息即可。</p><p>(4)<strong>统计投票</strong>。每次投票后，服务器都会统计投票信息，判断是否已经有过半机器接收到相同的投票信息，对于Server1，Server2而言，都统计出集群中已经有两台机器接受了(2,0)的投票信息，此时便认为已经选出了Leader。</p><p>(5)<strong>改变服务器状态</strong>。一旦确定了Leader，每个服务器就会更新自己的状态，如果是Follower，那么就变更为FOLLOWING，如果是Leader，就变更为LEADING。</p><h3 id="服务器运行时期的Leader选举"><a href="#服务器运行时期的Leader选举" class="headerlink" title="服务器运行时期的Leader选举"></a>服务器运行时期的Leader选举</h3><p>在Zookeeper运行期间，Leader与非Leader服务器各司其职，即便当有非Leader服务器宕机或新加入，此时也不会影响Leader，但是一旦Leader服务器挂了，那么整个集群将暂停对外服务，进入新一轮Leader选举，其过程和启动时期的Leader选举过程基本一致，过程相同。</p><h2 id="Zookeeper的数据模型"><a href="#Zookeeper的数据模型" class="headerlink" title="Zookeeper的数据模型"></a>Zookeeper的数据模型</h2><p>Zookeeper的数据模型，在结构上和标准文件系统的非常相似，拥有一个层次的命名空间，都是采用树形结构。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210913194642506.png" alt="image-20210913194642506"></p><p>Zookeeper树中的每个节点被称为一个Znode。和文件系统的目录树一样，Zookeeper树中的每个节点可以拥有子节点。</p><p>但也有不同之处:</p><p><strong>Znode兼具文件和目录两种特点</strong>。既像文件一样维护着数据，元信息，ACL，时间戳等数据结构，又像目录一样可以作为路径标识的一部分，并可以具有子Znode。用户对Znode具有增删改查等操作(权限允许的情况下)</p><p><strong>Znode存储数据大小有限制</strong>。Zookeeper虽然可以关联一些数据，但并没有被设计为常规的数据库或者大数据存储，相反的是，它用来管理调度数据，比如分布式应用中的配置文件信息，状态信息，汇聚位置等等。这些数据的共同特性就是它们都是很小的数据，通常以KB为大小单位。Zookeeper的服务器和客户端都被设计为严格检查并限制，每个Znode的数据大小至多为1M，常规使用中应该远远小于此值。</p><p><strong>Znode通过路径引用</strong>，如上图所示，路径并且必须要是绝对的。因此他们必须由斜杠字符来开头。除此之外，他们必须是唯一的，也就是说每一个路径只有一个表示，因此这些路径不能改变。在Zookeeper中，路径由Unicode字符串组成，并且有一些限制。字符串”/Zookeeper”用以保存管理信息，比如关键配额信息。</p><p><strong>每个Znode由3部分组成</strong></p><p>stat:此为状态信息，描述该Znode的版本，权限等信息</p><p>data:与该Znode关联的数据</p><p>children:该Znode下的子节点</p><h2 id="Znode节点类型"><a href="#Znode节点类型" class="headerlink" title="Znode节点类型"></a>Znode节点类型</h2><p>Znode有两种，分别为临时节点和永久节点。节点的类型在创建时即被确定，并且不能改变。</p><p><strong>临时节点</strong>:该节点的生命周期依赖于创建他们的会话。一旦会话结束，临时节点将被自动删除。当然也可以手动删除。临时节点不允许拥有子节点。</p><p><strong>永久节点</strong>:该节点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作的时候，他们才能被删除。</p><p><strong>Znode还有一个序列化的特性</strong>，如果创建的时候指定的话，该Znode的名字后面会自动追加一个不断增加的序列号。序列号对于此节点的父节点来说是唯一的，这样便会记录每一个子节点创建的先后顺序。</p><p>Znode四种类型的节点:</p><p>PERSISTENT:永久节点</p><p>EPHEMERAL:临时节点</p><p>FERSISTENT_SEQUENTIAL:永久节点，序列化</p><p>EPHEMERAL_SEQUENTIAL:临时节点，序列化</p><h1 id="Zookeeper-JAVA-API操作"><a href="#Zookeeper-JAVA-API操作" class="headerlink" title="Zookeeper JAVA API操作"></a>Zookeeper JAVA API操作</h1><h2 id="创建Zookeeper连接"><a href="#创建Zookeeper连接" class="headerlink" title="创建Zookeeper连接"></a>创建Zookeeper连接</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String connectionString = <span class="string">&quot;127.0.0.1:2181&quot;</span>; <span class="keyword">int</span> sessionTimeout = <span class="number">30000</span>; ZooKeeper zk = <span class="keyword">new</span> ZooKeeper(connectionString,sessionTimeout,<span class="keyword">null</span> &#125;);</span><br></pre></td></tr></table></figure><p> connectionString是连接信息，当为集群的时候，使用”,”分隔，如 </p><p>“192.168.1.1:2181,192.168.1.2:2181”</p><p> sessionTimeout指会话过期时间，其值minSessionTimeout最小为tickTime的2倍，最大值 maxSessionTimeout为tickTime的20倍；即使传入的值不在此范围实际起作用的也是minSessionTimeout至maxSessionTimeout</p><p><strong>例如在我自己电脑上面创建Zookeeper连接就是如下所示</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ZooKeeper zooKeeper = <span class="keyword">new</span> ZooKeeper(<span class="string">&quot;master:2181,node1:2181,node2:2181&quot;</span>,<span class="number">3000</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h2 id="创建节点-create"><a href="#创建节点-create" class="headerlink" title="创建节点(create)"></a>创建节点(create)</h2><p>zk.create(“/testRoot”,”testRoot”.getBytes(),       ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);</p><p><strong>例如在我自己电脑上我创建了一个show节点</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">zooKeeper.create(<span class="string">&quot;/show&quot;</span>,<span class="string">&quot;show&quot;</span>.getBytes(StandardCharsets.UTF_8),</span><br><span class="line">                ZooDefs.Ids.OPEN_ACL_UNSAFE,</span><br><span class="line">                CreateMode.PERSISTENT);</span><br></pre></td></tr></table></figure><p>可以很清楚的看到是创建成功了的</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924193943269.png" alt="image-20210924193943269"></p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>CreateMode.PERSISTENT</td><td>永久性节点</td></tr><tr><td>CreateMode.PERSISTENT_SEQUENTIAL</td><td>永久性序列节点</td></tr><tr><td>CreateMode.EPHEMERAL</td><td>临时节点，会话断开或过期时会删除此节点</td></tr><tr><td>CreateMode.PERSISTENT_SEQUENTIAL</td><td>临时序列节点，会话断开或过期时会删除此节点</td></tr></tbody></table><h2 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h2><p>Stat stat = new Stat(); zk.getData(“/testRoot”,true,stat);</p><p><strong>例如在我自己电脑上就是这样操作</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stat stat = new Stat();</span><br><span class="line">      byte[] data = zooKeeper.getData(&quot;/show&quot;, true, stat);</span><br><span class="line">      System.out.println(Arrays.toString(data));</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210924195519706.png" alt="image-20210924195519706"></p><h2 id="修改节点数据"><a href="#修改节点数据" class="headerlink" title="修改节点数据"></a>修改节点数据</h2><p>// -1表示忽略版本 zk.setData(“/testRoot”, “testRoot_modified”.getBytes(), -1);</p><h2 id="创建子节点"><a href="#创建子节点" class="headerlink" title="创建子节点"></a>创建子节点</h2><p>zk.create(“/testRoot/child1”,”child1_data”.getBytes(),        ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);</p><h2 id="获取子节点"><a href="#获取子节点" class="headerlink" title="获取子节点"></a>获取子节点</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; children = zk.getChildren(<span class="string">&quot;/testRoot&quot;</span>,<span class="keyword">new</span> Watcher()</span><br><span class="line"> &#123;    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span></span><br><span class="line"><span class="function"></span>&#123;       </span><br><span class="line">System.out.println(<span class="string">&quot;this is children node event&quot;</span>); </span><br><span class="line"></span><br><span class="line">      System.out.println(event);     &#125;  </span><br><span class="line"></span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p><em>注：getChildren方法会在子点有变化时触发Watcher()这个监听器</em></p><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><p>zk.delete(“/testRoot”, -1); zk.delete(“/testRoot/child1”, -1);</p><h2 id="关闭连连接"><a href="#关闭连连接" class="headerlink" title="关闭连连接"></a>关闭连连接</h2><p>zk.close();</p><h2 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Zookeeper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooDefs;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.data.Stat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperTest01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException, KeeperException </span>&#123;</span><br><span class="line">        <span class="comment">//创建zk连接</span></span><br><span class="line">        ZooKeeper zooKeeper = <span class="keyword">new</span> ZooKeeper(<span class="string">&quot;master:2181,node1:2181,node2:2181&quot;</span>,<span class="number">3000</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//调用create</span></span><br><span class="line"><span class="comment">//        zooKeeper.create(&quot;/show&quot;,&quot;show&quot;.getBytes(StandardCharsets.UTF_8),</span></span><br><span class="line"><span class="comment">//                ZooDefs.Ids.OPEN_ACL_UNSAFE,</span></span><br><span class="line"><span class="comment">//                CreateMode.PERSISTENT);</span></span><br><span class="line">        <span class="comment">//获取节点</span></span><br><span class="line">        Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line">        <span class="keyword">byte</span>[] data = zooKeeper.getData(<span class="string">&quot;/show&quot;</span>, <span class="keyword">true</span>, stat);</span><br><span class="line">        System.out.println(Arrays.toString(data));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大数据学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MapReduce学习小结</title>
      <link href="/2021/09/22/MapReduce%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
      <url>/2021/09/22/MapReduce%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h1><h2 id="MapReduce概述"><a href="#MapReduce概述" class="headerlink" title="MapReduce概述"></a>MapReduce概述</h2><ul><li>MapReduce是一种分布式计算模型，由Google提出，主要用于搜索领域，解决海量数据的计算问题。</li><li>MapReduce是分布式运行的，由两个阶段组成：Map和Reduce。Map阶段是一个独立的程序，有很多个节点同时运行，每个节点处理一部分数据。Reduce阶段是一个独立的程序，有很多个节点同时运行，每个节点处理一部分数据(在这先把reduce理解为一个单独的聚合程序即可)</li><li>MapReduce框架都有默认实现，用户只需要覆盖map()和reduce()两个函数，即可实现分布式计算，非常简单。</li><li>这两个函数的形参和返回值都是&lt;key、value&gt;，使用的时候一定要注意构造&lt;k,v&gt;</li></ul><h2 id="MapReduce优缺点"><a href="#MapReduce优缺点" class="headerlink" title="MapReduce优缺点"></a>MapReduce优缺点</h2><p><strong>优点：</strong></p><ul><li>1.MapReduce易于编程<ul><li><font color="red">它简单的实现一些接口，就可以完成一个分布式程序，</font>这个分布式程序可以分布到大量廉价的PC机器上运行。也就是说你写一个分布式程序，跟写一个简单的串行程序是一模一样的。就是因为这个特点使得MapReduce编程变得非常流行。</li></ul></li><li>2.良好的拓展性<ul><li>当你的计算资源不能得到满足的时候，你可以通过简单的增加机器来扩展它的计算能力。</li></ul></li><li>3.高容错性<ul><li>MapReduce设计的初衷就是使程序能够部署在廉价的PC机器上，这就要求它具有很高的容错性。比如<font color="red">其中一台机器挂了，它就可以把上面的计算任务转移到另外一个节点上运行，不至于这个任务运行失败，</font>而且这个过程不需要人工参与，而完全是由Hadoop内部完成的。</li></ul></li><li>4.适合PB级别以上的海量数据的离线处理<ul><li>可以实现上千台服务器集群并发工作，提供数据处理能力。</li></ul></li></ul><p><strong>缺点：</strong></p><ul><li>1.不擅长实时计算<ul><li>MapReduce无法像MySQL一样，在毫秒或者秒级内返回结果</li></ul></li><li>2.不擅长流式计算<ul><li>流式计算的输入数据是动态的，而<font color="red">MapReduce的输入数据集是静态的，</font>不能动态变化。这是因为MapReduce自身的设计特点决定了数据源必须是静态的。</li></ul></li><li>3.不擅长DAG(有向图)计算<ul><li>多个应用程序存在依赖关系，后一个应用程序的输入为前一个的输出。在这种情况下，MapReduce并不是不能这么做，而是使用后，<font color="red">每个MapReduce作业的输出结果都会写入到磁盘，会造成大量的磁盘IO，导致性能非常的低下。</font></li></ul></li></ul><h2 id="MapReduce原理"><a href="#MapReduce原理" class="headerlink" title="MapReduce原理"></a>MapReduce原理</h2><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922195326324.png" alt="image-20210922195326324"></p><p>默认可以溢出1.1，即128M基础上溢出1.1就是140M</p><h2 id="MapReduce每个阶段的解释"><a href="#MapReduce每个阶段的解释" class="headerlink" title="MapReduce每个阶段的解释"></a>MapReduce每个阶段的解释</h2><h3 id="Map阶段"><a href="#Map阶段" class="headerlink" title="Map阶段"></a>Map阶段</h3><p>1.1 框架使用InputFormat类的子类把输入文件(夹)划分为很多InputSplit，默认，每个HDFS的block对应一个InputSplit。通过RecordReader类，把每个InputSplit解析成一个个&lt;k1,v1&gt;。默认，框架对每个InputSplit中的每一行，解析成一个&lt;k1,v1&gt;。<br>1.2 框架调用Mapper类中的map(…)函数，map函数的形参是&lt;k1,v1&gt;对，输出是&lt;k2,v2&gt;对。一个InputSplit对应一个map task。程序员可以覆盖map函数，实现自己的逻辑。<br>1.3<br>(假设reduce存在)框架对map输出的&lt;k2,v2&gt;进行分区。不同的分区中的&lt;k2,v2&gt;由不同的reduce task处理。默认只有1个分区。<br> (假设reduce不存在)框架对map结果直接输出到HDFS中。<br>1.4 (假设reduce存在)框架对每个分区中的数据，按照k2进行排序、分组。分组指的是相同k2的v2分成一个组。注意：分组不会减少&lt;k2,v2&gt;数量。<br>1.5 (假设reduce存在，可选)在map节点，框架可以执行reduce归约。<br>1.6 (假设reduce存在)框架会对map task输出的&lt;k2,v2&gt;写入到linux 的磁盘文件中。<br>至此，整个map阶段结束</p><h3 id="Reduce阶段"><a href="#Reduce阶段" class="headerlink" title="Reduce阶段"></a>Reduce阶段</h3><p>1.1 框架对多个map任务的输出，按照不同的分区，通过网络copy到不同的reduce节点。这个过程称作shuffle。<br>1.2 框架对reduce端接收的[map任务输出的]相同分区的&lt;k2,v2&gt;数据进行合并、排序、分组。<br>1.3 框架调用Reducer类中的reduce方法，reduce方法的形参是&lt;k2,{v2…}&gt;，输出是&lt;k3,v3&gt;。一个&lt;k2,{v2…}&gt;调用一次reduce函数。程序员可以覆盖reduce函数，实现自己的逻辑。<br>1.4 框架把reduce的输出保存到HDFS中。<br>至此，整个reduce阶段结束。</p><h3 id="Shuffle阶段"><a href="#Shuffle阶段" class="headerlink" title="Shuffle阶段"></a>Shuffle阶段</h3><p>1.每个map有一个环形内存缓冲区，用于存储map的输出。默认大小100MB（io.sort.mb属性），一旦达到阀值0.8（io.sort.spill.percent）,一个后台线程把内容溢写到(spilt)磁盘的指定目录（mapred.local.dir）下的一个新建文件中。<br>2.写磁盘前，要partition,sort。如果有combiner，combine排序后数据。<br>3.等最后记录写完，合并全部文件为一个分区且排序的文件。</p><p>1.Reducer通过Http方式得到输出文件的特定分区的数据。<br>2.排序阶段合并map输出。然后走Reduce阶段。<br>3.reduce执行完之后，写入到HDFS中。</p><p>mapreduce中，map阶段处理的数据如何传递给reduce阶段，是mapreduce框架中最关键的一个流程，这个流程就叫shuffle；</p><p>具体来说：就是将maptask输出的处理结果数据，分发给reducetask，并在分发的过程中，对数据按key进行了分区和排序；</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210923205558436.png" alt="image-20210923205558436"></p><p>Shuffle中的缓冲区大小会影响到mapreduce程序的执行效率，原则上说，缓冲区越大，磁盘io的次数越少，执行速度就越快。</p><p>随后将mr的程序开发好，并运行即可，这就涉及到一个问题。如何运行。</p><h2 id="MapReduce默认输入处理类"><a href="#MapReduce默认输入处理类" class="headerlink" title="MapReduce默认输入处理类"></a>MapReduce默认输入处理类</h2><ul><li>InputFormat<ul><li>抽象类，只是定义了两个方法。</li></ul></li><li>FileInputFormat<ul><li>FileInputFormat是所有以文件作为数据源的InputFormat实现的基类，FileInputFormat保存作为job输入的所有文件，并实现了对输入文件计算splits的方法。至于获得记录的方法是有不同的子类——TextInputFormat进行实现的。</li></ul></li><li>TextInputFormat<ul><li>是默认的处理类，处理普通文本文件</li><li>文件中每一行作为一个记录，他将每一行在文件中的起始偏移量作为key，每一行的内容作为value</li><li>默认以\n或回车键作为一行记录</li></ul></li></ul><h2 id="InputSplit"><a href="#InputSplit" class="headerlink" title="InputSplit"></a>InputSplit</h2><ul><li>在执行mapreduce之前，原始数据被分割成若干split，每个split作为一个map任务的输入。</li><li>当Hadoop处理很多小文件（文件大小小于hdfs block大小）的时候，由于FileInputFormat不会对小文件进行划分，所以每一个小文件都会被当做一个split并分配一个map任务，会有大量的map task运行，导致效率低下</li><li>例如：一个1G的文件，会被划分成8个128MB的split，并分配8个map任务处理，而10000个100kb的文件会被10000个map任务处理</li><li>Map任务的数量<ul><li>一个InputSplit对应一个Map task</li><li>InputSplit的大小是由Math.max(minSize, Math.min(maxSize,blockSize))决定</li><li>单节点建议运行10—100个map task</li><li>map task执行时长不建议低于1分钟，否则效率低</li></ul></li><li>通过对源码进行查看，可以知道一个split默认128M，可以有1.1的范围溢出，即140M</li></ul><h2 id="MapReduce实战"><a href="#MapReduce实战" class="headerlink" title="MapReduce实战"></a>MapReduce实战</h2><h3 id="WordCount单词统计-使用自带的mapreduce"><a href="#WordCount单词统计-使用自带的mapreduce" class="headerlink" title="WordCount单词统计(使用自带的mapreduce)"></a>WordCount单词统计(使用自带的mapreduce)</h3><p>先自定义一些数据用作测试</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922201933220.png" alt="image-20210922201933220"></p><p>进入hadoop中原装的mapreduce中，并且查看一下。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922202352930.png" alt="image-20210922202352930"></p><p>可以很明显的发现自带了一个jar，我们用刚刚的测试数据来测试下。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922203333957.png" alt="image-20210922203333957"></p><p>可以从生成的日志中很清楚的看到是成功了的，并且可以通过访问这个圈出来的网站去查看。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922203549181.png" alt="image-20210922203549181"></p><p>此时查看一下是否输出了单词统计</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922203829007.png" alt="image-20210922203829007"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922204032074.png" alt="image-20210922204032074"></p><p>可以很清楚的看到确实进行了一个单词统计。</p><h2 id="我们自己来定义MapReduce"><a href="#我们自己来定义MapReduce" class="headerlink" title="我们自己来定义MapReduce"></a>我们自己来定义MapReduce</h2><p>因为在实际开发过程中往往会面临很多种情况，因此需要我们来重写MapReduce。根据不同情况，写出来的代码也不一样</p><h3 id="先实现下刚刚上面的那个情况"><a href="#先实现下刚刚上面的那个情况" class="headerlink" title="先实现下刚刚上面的那个情况"></a>先实现下刚刚上面的那个情况</h3><h4 id="自定义Map"><a href="#自定义Map" class="headerlink" title="自定义Map"></a>自定义Map</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//map类</span></span><br><span class="line">   <span class="comment">//第一队k，v，是决定数据的输入格式</span></span><br><span class="line">   <span class="comment">//第二队k，v，是决定数据的输出格式</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * KEYIN</span></span><br><span class="line"><span class="comment">   *    ----&gt;k1 表示每一行的起始位置(偏移量offset)</span></span><br><span class="line"><span class="comment">   * VALUEIN</span></span><br><span class="line"><span class="comment">   *    ----&gt;V1 表示每一行的文本内容</span></span><br><span class="line"><span class="comment">   * KEYOUT</span></span><br><span class="line"><span class="comment">   *    ----&gt;k2 表示每一行中的每个单词</span></span><br><span class="line"><span class="comment">   * VALUEOUT</span></span><br><span class="line"><span class="comment">   *    ----&gt;V2 表示每一行中的每个单词的出现次数，固定值为1</span></span><br><span class="line"><span class="comment">   * */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>,<span class="title">Text</span>,<span class="title">LongWritable</span>&gt;</span>&#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * map阶段数据是一行一行过来的</span></span><br><span class="line"><span class="comment">       * 每一行数据都需要执行代码</span></span><br><span class="line"><span class="comment">       * */</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException,   InterruptedException </span>&#123;</span><br><span class="line">           <span class="comment">//通过Context输出 Text(一整行数据)，1</span></span><br><span class="line">           String line = value.toString();</span><br><span class="line">           context.write(<span class="keyword">new</span> Text(line),<span class="keyword">new</span> LongWritable(<span class="number">1</span>));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="自定义Reduce"><a href="#自定义Reduce" class="headerlink" title="自定义Reduce"></a>自定义Reduce</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//reduce类</span></span><br><span class="line">  <span class="comment">//用来接收map端输出的数据</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountReduce</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>,<span class="title">LongWritable</span>,<span class="title">Text</span>,<span class="title">LongWritable</span>&gt;</span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;LongWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">           * reduce 聚合程序 每一个k都会调用一次</span></span><br><span class="line"><span class="comment">           * 默认是一个节点</span></span><br><span class="line"><span class="comment">           * key:每一个单词</span></span><br><span class="line"><span class="comment">           * values:map端 当前k所对应的所有的v</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="keyword">long</span> sum = <span class="number">0l</span>;</span><br><span class="line">          <span class="keyword">for</span> (LongWritable value : values) &#123;</span><br><span class="line">                 sum += value.get();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 把计算结果输出到hdfs</span></span><br><span class="line">          context.write(key,<span class="keyword">new</span> LongWritable(sum));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="Main方法"><a href="#Main方法" class="headerlink" title="Main方法"></a>Main方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是当前mapreduce程序入口</span></span><br><span class="line"><span class="comment"> * 用来构建mapreduce程序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个job任务</span></span><br><span class="line">    Job job = Job.getInstance();</span><br><span class="line">    <span class="comment">//指定job名称</span></span><br><span class="line">    job.setJobName(<span class="string">&quot;第一个mapreduce程序，单词统计&quot;</span>);</span><br><span class="line">    <span class="comment">//构建mapreduce</span></span><br><span class="line">    <span class="comment">//指定当前main所在类名(识别具体的类)</span></span><br><span class="line">    job.setJarByClass(DemoWordCount1.class);</span><br><span class="line">    <span class="comment">//指定Map端的类</span></span><br><span class="line">    job.setMapperClass(WordCountMapper.class);</span><br><span class="line">    <span class="comment">//指定Map端输出的kv类型</span></span><br><span class="line">    job.setMapOutputKeyClass(Text.class);</span><br><span class="line">    job.setMapOutputValueClass(LongWritable.class);</span><br><span class="line">    <span class="comment">//指定Reduce端的类</span></span><br><span class="line">    job.setReducerClass(WordCountReduce.class);</span><br><span class="line">    <span class="comment">//指定Reduce端输出的kv类型</span></span><br><span class="line">    job.setOutputKeyClass(Text.class);</span><br><span class="line">    job.setOutputValueClass(LongWritable.class);</span><br><span class="line">    <span class="comment">//指定输入路径</span></span><br><span class="line">    Path in = <span class="keyword">new</span> Path(<span class="string">&quot;/word&quot;</span>);</span><br><span class="line">    FileInputFormat.addInputPath(job,in);</span><br><span class="line">    <span class="comment">//指定输出路径</span></span><br><span class="line">    Path out = <span class="keyword">new</span> Path(<span class="string">&quot;/out&quot;</span>);       <span class="comment">//是因为输出的路径是不能提前存在的</span></span><br><span class="line">    <span class="comment">//如果路径存在，就删除</span></span><br><span class="line">    FileSystem fs = FileSystem.get(<span class="keyword">new</span> Configuration());</span><br><span class="line">    <span class="keyword">if</span>(fs.exists(out))&#123;</span><br><span class="line">        fs.delete(out,<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    FileOutputFormat.setOutputPath(job,out);</span><br><span class="line">    <span class="comment">//启动任务</span></span><br><span class="line">    job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;mapreduce正在执行&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mapreduce;</span><br><span class="line"><span class="comment">//用来统计文件中单词个数</span></span><br><span class="line"><span class="comment">// 重写 覆盖mapreduce框架中的map()方法和reduce()方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoWordCount1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//map类</span></span><br><span class="line">    <span class="comment">//第一队k，v，是决定数据的输入格式</span></span><br><span class="line">    <span class="comment">//第二队k，v，是决定数据的输出格式</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * KEYIN</span></span><br><span class="line"><span class="comment">    *    ----&gt;k1 表示每一行的起始位置(偏移量offset)</span></span><br><span class="line"><span class="comment">    * VALUEIN</span></span><br><span class="line"><span class="comment">    *    ----&gt;V1 表示每一行的文本内容</span></span><br><span class="line"><span class="comment">    * KEYOUT</span></span><br><span class="line"><span class="comment">    *    ----&gt;k2 表示每一行中的每个单词</span></span><br><span class="line"><span class="comment">    * VALUEOUT</span></span><br><span class="line"><span class="comment">    *    ----&gt;V2 表示每一行中的每个单词的出现次数，固定值为1</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>,<span class="title">Text</span>,<span class="title">LongWritable</span>&gt;</span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * map阶段数据是一行一行过来的</span></span><br><span class="line"><span class="comment">        * 每一行数据都需要执行代码</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException,   InterruptedException </span>&#123;</span><br><span class="line">            <span class="comment">//通过Context输出 Text(一整行数据)，1</span></span><br><span class="line">            String line = value.toString();</span><br><span class="line">            context.write(<span class="keyword">new</span> Text(line),<span class="keyword">new</span> LongWritable(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//reduce类</span></span><br><span class="line">    <span class="comment">//用来接收map端输出的数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountReduce</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>,<span class="title">LongWritable</span>,<span class="title">Text</span>,<span class="title">LongWritable</span>&gt;</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;LongWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * reduce 聚合程序 每一个k都会调用一次</span></span><br><span class="line"><span class="comment">             * 默认是一个节点</span></span><br><span class="line"><span class="comment">             * key:每一个单词</span></span><br><span class="line"><span class="comment">             * values:map端 当前k所对应的所有的v</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">long</span> sum = <span class="number">0l</span>;</span><br><span class="line">            <span class="keyword">for</span> (LongWritable value : values) &#123;</span><br><span class="line">                   sum += value.get();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把计算结果输出到hdfs</span></span><br><span class="line">            context.write(key,<span class="keyword">new</span> LongWritable(sum));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是当前mapreduce程序入口</span></span><br><span class="line"><span class="comment">     * 用来构建mapreduce程序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个job任务</span></span><br><span class="line">        Job job = Job.getInstance();</span><br><span class="line">        <span class="comment">//指定job名称</span></span><br><span class="line">        job.setJobName(<span class="string">&quot;第一个mapreduce程序，单词统计&quot;</span>);</span><br><span class="line">        <span class="comment">//构建mapreduce</span></span><br><span class="line">        <span class="comment">//指定当前main所在类名(识别具体的类)</span></span><br><span class="line">        job.setJarByClass(DemoWordCount1.class);</span><br><span class="line">        <span class="comment">//指定Map端的类</span></span><br><span class="line">        job.setMapperClass(WordCountMapper.class);</span><br><span class="line">        <span class="comment">//指定Map端输出的kv类型</span></span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(LongWritable.class);</span><br><span class="line">        <span class="comment">//指定Reduce端的类</span></span><br><span class="line">        job.setReducerClass(WordCountReduce.class);</span><br><span class="line">        <span class="comment">//指定Reduce端输出的kv类型</span></span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(LongWritable.class);</span><br><span class="line">        <span class="comment">//指定输入路径</span></span><br><span class="line">        Path in = <span class="keyword">new</span> Path(<span class="string">&quot;/word&quot;</span>);</span><br><span class="line">        FileInputFormat.addInputPath(job,in);</span><br><span class="line">        <span class="comment">//指定输出路径</span></span><br><span class="line">        Path out = <span class="keyword">new</span> Path(<span class="string">&quot;/out&quot;</span>);       <span class="comment">//是因为输出的路径是不能提前存在的</span></span><br><span class="line">        <span class="comment">//如果路径存在，就删除</span></span><br><span class="line">        FileSystem fs = FileSystem.get(<span class="keyword">new</span> Configuration());</span><br><span class="line">        <span class="keyword">if</span>(fs.exists(out))&#123;</span><br><span class="line">            fs.delete(out,<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        FileOutputFormat.setOutputPath(job,out);</span><br><span class="line">        <span class="comment">//启动任务</span></span><br><span class="line">        job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;mapreduce正在执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922215132274.png" alt="image-20210922215132274"></p><p>此时用Maven里面的package打包上传到服务器，然后执行就可以了。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922220015535.png" alt="image-20210922220015535"></p><ul><li>提交任务<ul><li>通过maven中的package将项目打包上传服务器然后执行</li><li>执行任务 hadoop jar 刚刚自己上传的包 自己的项目路径 hdfs中的输入路径 输出路径(输入和输出路径我都已经在代码里面定义过了)</li></ul></li><li>例如我的就是:</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hadoop jar Hadoop-1.0-SNAPSHOT.jar mapreduce.DemoWordCount1 /word</span><br><span class="line"><span class="comment"># (输入和输出路径我都已经在代码里面定义过了，可以省略，我这输入的路径忘记省略了)</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922220745263.png" alt="image-20210922220745263"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922221141989.png" alt="image-20210922221141989"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922221208495.png" alt="image-20210922221208495"></p><p>可以很直观的看到是成功了的。我这里是因为程序中没去除空格，所以统计的时候也统计了空格的数量。</p><h3 id="切片分析"><a href="#切片分析" class="headerlink" title="切片分析"></a>切片分析</h3><p>刚刚上面的情况是一行只有一个数据，那么当一行中有多个数据该怎么办勒？此时就可以用切片方法。</p><p>先创建一些原始数据，可以看到一行有很多个单词。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922224631032.png" alt="image-20210922224631032"></p><h4 id="自定义Map-1"><a href="#自定义Map-1" class="headerlink" title="自定义Map"></a>自定义Map</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>,<span class="title">Text</span>,<span class="title">LongWritable</span>&gt; </span>&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">           String line = value.toString();</span><br><span class="line">           String[] split = line.split(<span class="string">&quot;,&quot;</span>); <span class="comment">//以逗号进行切分</span></span><br><span class="line">           <span class="keyword">for</span> (String s : split) &#123;</span><br><span class="line">               context.write(<span class="keyword">new</span> Text(s),<span class="keyword">new</span> LongWritable(<span class="number">1</span>));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="自定义Reduce-1"><a href="#自定义Reduce-1" class="headerlink" title="自定义Reduce"></a>自定义Reduce</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountReduce</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>,<span class="title">LongWritable</span>,<span class="title">Text</span>,<span class="title">LongWritable</span>&gt;</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;LongWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> sum = <span class="number">0l</span>;</span><br><span class="line">            <span class="keyword">for</span> (LongWritable value : values) &#123;</span><br><span class="line">                sum += value.get();</span><br><span class="line">            &#125;</span><br><span class="line">            context.write(key,<span class="keyword">new</span> LongWritable(sum));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Main方法-1"><a href="#Main方法-1" class="headerlink" title="Main方法"></a>Main方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个job任务</span></span><br><span class="line">    Job job = Job.getInstance();</span><br><span class="line">    <span class="comment">//指定job名称</span></span><br><span class="line">    job.setJobName(<span class="string">&quot;第二个mapreduce程序，单词统计&quot;</span>);</span><br><span class="line">    <span class="comment">//构建mapreduce</span></span><br><span class="line">    <span class="comment">//指定当前main所在类名(识别具体的类)</span></span><br><span class="line">    job.setJarByClass(DemoWordCount2.class);</span><br><span class="line">    <span class="comment">//指定Map端的类</span></span><br><span class="line">    job.setMapperClass(WordCountMapper.class);</span><br><span class="line">    <span class="comment">//指定Map端输出的kv类型</span></span><br><span class="line">    job.setMapOutputKeyClass(Text.class);</span><br><span class="line">    job.setMapOutputValueClass(LongWritable.class);</span><br><span class="line">    <span class="comment">//指定Reduce端的类</span></span><br><span class="line">    job.setReducerClass(WordCountReduce.class);</span><br><span class="line">    <span class="comment">//指定Reduce端输出的kv类型</span></span><br><span class="line">    job.setOutputKeyClass(Text.class);</span><br><span class="line">    job.setOutputValueClass(LongWritable.class);</span><br><span class="line">    <span class="comment">//指定输入路径</span></span><br><span class="line">    Path in = <span class="keyword">new</span> Path(<span class="string">&quot;/word&quot;</span>);</span><br><span class="line">    FileInputFormat.addInputPath(job,in);</span><br><span class="line">    <span class="comment">//指定输出路径</span></span><br><span class="line">    Path out = <span class="keyword">new</span> Path(<span class="string">&quot;/out&quot;</span>);       <span class="comment">//是因为输出的路径是不能提前存在的</span></span><br><span class="line">    <span class="comment">//如果路径存在，就删除</span></span><br><span class="line">    FileSystem fs = FileSystem.get(<span class="keyword">new</span> Configuration());</span><br><span class="line">    <span class="keyword">if</span>(fs.exists(out))&#123;</span><br><span class="line">        fs.delete(out,<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    FileOutputFormat.setOutputPath(job,out);</span><br><span class="line">    <span class="comment">//启动任务</span></span><br><span class="line">    job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;mapreduce正在执行&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总代码-1"><a href="#总代码-1" class="headerlink" title="总代码"></a>总代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mapreduce;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">//切片</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoWordCount2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>,<span class="title">Text</span>,<span class="title">LongWritable</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            String line = value.toString();</span><br><span class="line">            String[] split = line.split(<span class="string">&quot;,&quot;</span>); <span class="comment">//以逗号进行切分</span></span><br><span class="line">            <span class="keyword">for</span> (String s : split) &#123;</span><br><span class="line">                context.write(<span class="keyword">new</span> Text(s),<span class="keyword">new</span> LongWritable(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountReduce</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>,<span class="title">LongWritable</span>,<span class="title">Text</span>,<span class="title">LongWritable</span>&gt;</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;LongWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> sum = <span class="number">0l</span>;</span><br><span class="line">            <span class="keyword">for</span> (LongWritable value : values) &#123;</span><br><span class="line">                sum += value.get();</span><br><span class="line">            &#125;</span><br><span class="line">            context.write(key,<span class="keyword">new</span> LongWritable(sum));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个job任务</span></span><br><span class="line">        Job job = Job.getInstance();</span><br><span class="line">        <span class="comment">//指定job名称</span></span><br><span class="line">        job.setJobName(<span class="string">&quot;第二个mapreduce程序，单词统计&quot;</span>);</span><br><span class="line">        <span class="comment">//构建mapreduce</span></span><br><span class="line">        <span class="comment">//指定当前main所在类名(识别具体的类)</span></span><br><span class="line">        job.setJarByClass(DemoWordCount2.class);</span><br><span class="line">        <span class="comment">//指定Map端的类</span></span><br><span class="line">        job.setMapperClass(WordCountMapper.class);</span><br><span class="line">        <span class="comment">//指定Map端输出的kv类型</span></span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(LongWritable.class);</span><br><span class="line">        <span class="comment">//指定Reduce端的类</span></span><br><span class="line">        job.setReducerClass(WordCountReduce.class);</span><br><span class="line">        <span class="comment">//指定Reduce端输出的kv类型</span></span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(LongWritable.class);</span><br><span class="line">        <span class="comment">//指定输入路径</span></span><br><span class="line">        Path in = <span class="keyword">new</span> Path(<span class="string">&quot;/word&quot;</span>);</span><br><span class="line">        FileInputFormat.addInputPath(job,in);</span><br><span class="line">        <span class="comment">//指定输出路径</span></span><br><span class="line">        Path out = <span class="keyword">new</span> Path(<span class="string">&quot;/out&quot;</span>);       <span class="comment">//是因为输出的路径是不能提前存在的</span></span><br><span class="line">        <span class="comment">//如果路径存在，就删除</span></span><br><span class="line">        FileSystem fs = FileSystem.get(<span class="keyword">new</span> Configuration());</span><br><span class="line">        <span class="keyword">if</span>(fs.exists(out))&#123;</span><br><span class="line">            fs.delete(out,<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        FileOutputFormat.setOutputPath(job,out);</span><br><span class="line">        <span class="comment">//启动任务</span></span><br><span class="line">        job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;mapreduce正在执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922231243523.png" alt="image-20210922231243523"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922231526450.png" alt="image-20210922231526450"></p><p>可以很直观的查看到已经成功了，并且也已经做出了统计。</p><h2 id="GitHub地址"><a href="#GitHub地址" class="headerlink" title="GitHub地址"></a>GitHub地址</h2><p>更多代码请查看我的GitHub地址仓库地址</p><p><a href="https://github.com/Fang-gg/Hadoop.git">https://github.com/Fang-gg/Hadoop.git</a></p>]]></content>
      
      
      <categories>
          
          <category> 大数据学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDFS学习小结</title>
      <link href="/2021/09/22/HDFS%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
      <url>/2021/09/22/HDFS%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h1><h2 id="HDFS产生背景和定义"><a href="#HDFS产生背景和定义" class="headerlink" title="HDFS产生背景和定义"></a>HDFS产生背景和定义</h2><p>随着数据量越来越大，在一个操作系统存不下所有的数据，那么就分配到更多的操作系统管理的磁盘中，但是不方便管理和维护。<font color="red">迫切需要一种系统来管理多台机器上的文件，</font>这就是分布式文件管理系统。<font color="red">HDFS只是分布式文件管理系统中的一种。</font></p><p>定义：<font color="blue">HDFS，它是一个文件系统</font>，用于存储文件，通过目录树来定位文件；<font color="blue">其次，它是分布式的</font>,由很多服务器联合起来实现其功能，集群中的服务器有各自的角色。</p><p><font color="red">HDFS的使用场景：适合一次写入，多次读出的场景，且不支持文件的修改。</font>适合用来做数据分析，并不适合用来做网盘应用。</p><h2 id="HDFS优缺点"><a href="#HDFS优缺点" class="headerlink" title="HDFS优缺点"></a>HDFS优缺点</h2><p>优点：</p><ul><li>高容错性<ul><li>数据自动保存多个副本。它通过增加副本的形式，提高容错性</li><li>某一个副本丢失以后，它可以自动恢复</li></ul></li><li>适合处理大数据<ul><li>数据规模：能够处理数据规模达到GB、TB、甚至PB级别的数据</li><li>文件规模：能够处理百万规模以上的文件数量，数量相当之大</li></ul></li><li>可以构建在廉价机器上，通过多副本机制，提高可靠性。</li></ul><p>缺点：</p><ul><li><font color="red">不适合低延时数据访问</font>，比如毫秒级的存储数据，是做不到的</li><li><font color="red">无法高效的对大量小文件进行存储</font><ul><li>存储大量小文件的话，它会占用NameNode大量的内存来存储文件目录和块信息。这样是不可取的，因为NameNode的内存总是有限的</li><li>小文件存储的寻址时间会超过读取时间，它违反了HDFS的设计目标</li></ul></li><li>不支持并发写入，文件随即修改<ul><li>一个文件只能有一个写，不允许多个线程同时写</li><li><font color="red">仅支持数据append(追加)，</font>不支持文件的随即修改</li></ul></li></ul><h2 id="HDFS组成架构"><a href="#HDFS组成架构" class="headerlink" title="HDFS组成架构"></a>HDFS组成架构</h2><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210921105505867.png" alt="image-20210921105505867"></p><p><font color="blue">NameNode：就是Master，它是一个主管，管理者</font></p><ul><li>管理HDFS的名称空间</li><li>配置副本策略</li><li>管理数据块(Block)映射信息</li><li>处理客户端读写请求</li></ul><p><font color="blue">DataNode：就是Slave。NameNode下达命令，DataNode执行实际的操作</font></p><ul><li>存储实际的数据块</li><li>执行数据块的读/写操作</li></ul><p><font color="blue">Client：就是客户端</font></p><ul><li>文件切分。文件上传HDFS的时候，Client将文件切分成一个一个的Block，然后进行上传</li><li>与NameNode交互，获取文件的位置信息</li><li>与DataNode交互，读取或者写入数据</li><li>Client提供一些命令来管理HDFS，比如NameNode格式化</li><li>Client可以通过一些命令来访问HDFS，比如对HDFS增删改查操作</li></ul><p><font color="blue">Secondary NameNode：并非NameNode的热备。当NameNode挂掉的时候，它并不能马上替换NameNode并提供服务</font></p><ul><li>辅助NameNode，分担其工作量，比如定期合并Fsimage和Edits，并推送给NameNode</li><li>在紧急情况下，可辅助恢复NameNode</li></ul><h2 id="HDFS文件块大小-面试重点"><a href="#HDFS文件块大小-面试重点" class="headerlink" title="HDFS文件块大小(面试重点)"></a>HDFS文件块大小(面试重点)</h2><p>HDFS中的文件在物理上是分块存储(Block)，块的大小可以通过配置参数(dfs.blocksize)来规定，<font color="red">默认大小在Hadoop2.x版本中是128M，老版本是64M。</font></p><h3 id="思考：为什么块的大小不能设置太小，也不能设置太大？"><a href="#思考：为什么块的大小不能设置太小，也不能设置太大？" class="headerlink" title="思考：为什么块的大小不能设置太小，也不能设置太大？"></a>思考：为什么块的大小不能设置太小，也不能设置太大？</h3><ul><li>HDFS的块<font color="red">设置太小，会增加寻址时间，</font>程序一直在找块的开始位置</li><li>如果块<font color="red">设置的太大，从磁盘传输数据的时间会明显大于定位这个块开始位置所需的时间。</font>导致程序在处理这块数据的时候，或非常慢。</li></ul><p><font color="red">总结：HDFS块的大小设置主要取决于磁盘传输速率。</font></p><h2 id="HDFS的Shell操作-开发重点"><a href="#HDFS的Shell操作-开发重点" class="headerlink" title="HDFS的Shell操作(开发重点)"></a>HDFS的Shell操作(开发重点)</h2><ul><li><font color="red">hadoop dfs -ls /</font>，显示目录信息</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210921143153565.png" alt="image-20210921143153565"></p><p>然后我们去可视化界面查看以下是否正确</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210921143246306.png" alt="image-20210921143246306"></p><p>可以直观地看到和Linux界面显示的是一致的！</p><ul><li><font color="red">hadoop dfs -mkdir /</font>，在HDFS上创造目录</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210921144528651.png" alt="image-20210921144528651"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210921144626661.png" alt="image-20210921144626661"></p><p>可以很直观的看到创建成功</p><ul><li><font color="red">hadoop dfs -touchz</font>，创建一个文件</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210921145355674.png" alt="image-20210921145355674"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210921145457238.png" alt="image-20210921145457238"></p><p>可以很直观的看到在fst这个目录下面我创建成功了fangshitao.txt文件</p><ul><li><font color="red">hadoop dfs -appendToFile</font>，追加一个本地文件到已经存在的文件的末尾</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210921152517808.png" alt="image-20210921152517808"></p><p>此时我这个文件大小是0，这时候我追加一个进去。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210921152810988.png" alt="image-20210921152810988"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210921152831174.png" alt="image-20210921152831174"></p><p>此时就能很直观的查看到fangshitao.txt这个文件大小已经发生了变化。</p><ul><li><font color="red">hadoop dfs -cat </font>，查看文件内容</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210921153023790.png" alt="image-20210921153023790"></p><ul><li><font color="red">hadoop dfs -rm -r </font>，删除文件。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210921153327918.png" alt="image-20210921153327918"></p><p><strong>注意：</strong>此时这个删除会将文件放入回收站内，想要彻底删除还得将回收站清空</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210921153521433.png" alt="image-20210921153521433"></p><p>可以很直观的查看到此时删除的文件在Trash这个回收站中。</p><ul><li><font color="red">hadoop dfs -rm -r -skipTrash</font>，删除文件的时候会自动跳过回收站。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210921153717390.png" alt="image-20210921153717390"></p><p>此时的删除就不会再出现上面的那种问题了。因为直接跳过了垃圾回收。</p><p>其实总的来说，HDFS中的命令和Linux类似，唯一的不同点就是：<font color="blue">HDFS的命令需要在前面加上hadoop dfs -</font></p><ul><li><font color="red">hadoop dfs -setrep</font>，设置HDFS中文件的副本数</li></ul><h2 id="Java操作HDFS"><a href="#Java操作HDFS" class="headerlink" title="Java操作HDFS"></a>Java操作HDFS</h2><h3 id="创建连接"><a href="#创建连接" class="headerlink" title="创建连接"></a>创建连接</h3><p>使用Java操作HDFS，其实是使用hdfs的文件管理系统file system(在hdfs-site.xml中)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileSystem fs;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> URISyntaxException </span>&#123;</span><br><span class="line">        <span class="comment">//获得配置文件</span></span><br><span class="line">        Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">        <span class="comment">//设置副本数</span></span><br><span class="line">        conf.set(<span class="string">&quot;dfs.replication&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="comment">//获取指定的连接地址</span></span><br><span class="line">        <span class="comment">//端口号9000在core-site.xml中，50070只是一个前端的界面端口号</span></span><br><span class="line">        URI uri = <span class="keyword">new</span> URI(<span class="string">&quot;hdfs://master:9000&quot;</span>);</span><br><span class="line">        <span class="comment">//创建获取文件管理系统的对象，通过对象操作HDFS</span></span><br><span class="line">        fs = FileSystem.get(uri, conf);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="创建目录或者文件"><a href="#创建目录或者文件" class="headerlink" title="创建目录或者文件"></a>创建目录或者文件</h3><p>值得注意的是mkdirs方法里面需要的是Path，而不是一个直接的路径</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> mkdirs = fs.mkdirs(<span class="keyword">new</span> Path(<span class="string">&quot;/fst/fst&quot;</span>));</span><br><span class="line">        System.out.println(mkdirs);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="删除目录或者文件"><a href="#删除目录或者文件" class="headerlink" title="删除目录或者文件"></a>删除目录或者文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//boolean表示是否可以迭代删除</span></span><br><span class="line">       <span class="comment">//true表示可以迭代删除，false表示不行。</span></span><br><span class="line">       <span class="keyword">boolean</span> delete = fs.delete(<span class="keyword">new</span> Path(<span class="string">&quot;/fst/fst&quot;</span>),<span class="keyword">true</span>);</span><br><span class="line">       System.out.println(delete);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="查看HDFS上的文件"><a href="#查看HDFS上的文件" class="headerlink" title="查看HDFS上的文件"></a>查看HDFS上的文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FSDataInputStream open = fs.open(<span class="keyword">new</span> Path(<span class="string">&quot;/datas/score.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//封装成缓冲流</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(open));</span><br><span class="line">        String line=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line=br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="上传文件到HDFS"><a href="#上传文件到HDFS" class="headerlink" title="上传文件到HDFS"></a>上传文件到HDFS</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//hdfs上的文件默认不能被修改</span></span><br><span class="line">    <span class="comment">//上传文件</span></span><br><span class="line">    <span class="comment">//覆盖掉，没有追加的功能</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FSDataOutputStream fsDataOutputStream = fs.create(<span class="keyword">new</span> Path(<span class="string">&quot;/datas/score.txt&quot;</span>));</span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(fsDataOutputStream));</span><br><span class="line">        bw.write(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        bw.write(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        bw.flush();</span><br><span class="line">        bw.close();</span><br><span class="line">        fsDataOutputStream.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922191908697.png" alt="image-20210922191908697"></p><h2 id="HDFS读写数据"><a href="#HDFS读写数据" class="headerlink" title="HDFS读写数据"></a>HDFS读写数据</h2><h3 id="HDFS读数据流程"><a href="#HDFS读数据流程" class="headerlink" title="HDFS读数据流程"></a>HDFS读数据流程</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922184350441.png" alt="image-20210922184350441"></p><p><strong>简化描述</strong><br>1、open，打开HDFS的文件存储系统<br>2、向下找某一个具体的数据；这就需要去找namenode了，namenode里面存储了它的元数据信息（包括位置在哪，大小是多少等等）<br>3、开始读数据了（多个block就按顺序读）<br>挂了就找副本<br>4、读完就关闭</p><p><strong>原描述</strong><br>1.首先调用FileSystem对象的open方法，其实是一个DistributedFileSystem的实例<br>2.DistributedFileSystem通过rpc获得文件的第一个block的locations（namenode查出来的），同一block按照副本数（一个block的文件有三个备份）会返回多个locations（返回给open方法），这些locations按照hadoop拓扑结构（远近）排序，距离客户端近的排在前面.<br>3.前两步会返回一个（io流对象，封装成）FSDataInputStream对象，该对象会被封装成DFSInputStream对象，DFSInputStream可以方便的管理datanode和namenode数据流。客户端调用read方法，DFSInputStream最会找出离客户端最近的datanode并连接。<br>4.数据从datanode源源不断的流向客户端。<br>5.如果第一块的数据读完了，就会关闭指向第一块的datanode连接，接着读取下一块。（有多个block就还继续按照上面的顺序接着读取）这些操作对客户端来说是透明的（也就是用户不需要知道下面都做了什么），客户端的角度看来只是读一个持续不断的流。<br>6.如果第一批block都读完了，DFSInputStream就会去namenode拿下一批blocks的location，然后继续读，如果所有的块都读完，这时就会关闭掉所有的流。<br>如果在读数据的时候，DFSInputStream和datanode的通讯发生异常，就会尝试正在读的block的排第二近的datanode,并且会记录哪个datanode发生错误，剩余的blocks读的时候就会直接跳过该datanode。DFSInputStream也会检查block数据校验和，如果发现一个坏的block,就会先报告到namenode节点，然后DFSInputStream在其他的datanode上读该block的镜像<br>该设计的方向就是客户端直接连接datanode来检索数据并且namenode来负责为每一个block提供最优的datanode，namenode仅仅处理block location的请求，这些信息都加载在namenode的内存中，hdfs通过datanode集群可以承受大量客户端的并发访问。</p><h3 id="HDFS写数据流程"><a href="#HDFS写数据流程" class="headerlink" title="HDFS写数据流程"></a>HDFS写数据流程</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922184921488.png" alt="image-20210922184921488"></p><p>写数据的时候要注意副本问题，要么同时成功，要么同时失败，具有<strong>原子性</strong>；不存在一个副本写入成功，一个副本写入失败的问题。</p><p><strong>简化描述</strong><br>1、create，打开了FileSystem<br>2、打开namenode；namenode要了解这个新的文件的信息（文件写在了哪，大小多少等等）<br>3、写数据<br>4、包的形式做数据传输，namenode告诉流，哪个地方存储比较合适<br>5、返回做验证，验证是否写成功，要是一个失败，那就全部失败（原子性），打开ack，监听是否成功<br>6、关闭流<br>7、将数据传给namenode做分配</p><p><strong>原描述</strong><br>1.客户端通过调用DistributedFileSystem的create方法创建新文件<br>2.DistributedFileSystem通过RPC调用namenode去创建一个没有blocks关联的新文件（这时候还没有决定存在哪个位置），创建前，namenode会做各种校验，比如文件是否存在，客户端有无权限去创建等。如果校验通过，namenode就会记录下新文件，否则就会抛出IO异常.<br>3.前两步结束后会返回FSDataOutputStream的对象，像读文件的时候相似，FSDataOutputStream被封装成DFSOutputStream.DFSOutputStream可以协调namenode和datanode。客户端开始写数据到DFSOutputStream,DFSOutputStream会把数据切成一个个小packet，然后排成队列data quene（理解为缓存，将数据进行排列，有序的，方便切分，比如数据到了128MB，可以进行切分）。<br>4.DataStreamer会去处理接受data queue，他先问询namenode这个新的block最适合存储的在哪几个datanode里，比如副本数是3，那么就找到3个最适合的datanode（namenode告诉了数据流，存储到哪个地方比较合适），把他们排成一个pipeline（类似于队列中的出栈，出去就没了）.DataStreamer把packet按队列输出到管道的第一个datanode中，第一个datanode又把packet输出到第二个datanode中，以此类推。<br>5.DFSOutputStream还有一个对列叫ack queue（一个队列是传输数据，一个队列是验证），也是由packet组成，等待datanode的收到响应，当pipeline中的所有datanode都表示已经收到的时候，这时ack queue才会把对应的packet包移除掉。（ack就是把数据搞成了两个队列，防止数据发生错误；一个队列是出栈的，存储到datanode，一个队列是验证的，当验证没有问题之后，ack才会把自己的数据丢掉，留着就是为了防止出现问题，找不到数据了）<br>如果在写的过程中某个datanode发生错误，会采取以下几步：1) pipeline被关闭掉；2)为了防止丢包ack queue里的packet会同步到data queue里；3)把产生错误的datanode上当前在写但未完成的block删掉；4）block剩下的部分被写到剩下的两个正常的datanode中；5）namenode找到另外的datanode去创建这个块的复制（也是三个的）。当然，这些操作对客户端来说是无感知的。<br>6.客户端完成写数据后调用close方法关闭写入流<br>7.DataStreamer把剩余得包都刷到pipeline里然后等待ack信息，收到最后一个ack后，通知namenode把文件标示为已完成</p><h2 id="NameNode和SecondaryNameNode-面试开发重点"><a href="#NameNode和SecondaryNameNode-面试开发重点" class="headerlink" title="NameNode和SecondaryNameNode(面试开发重点)"></a>NameNode和SecondaryNameNode(面试开发重点)</h2><p>思考：NameNode中的元数据是存储在哪里的？</p><p>​        首先，我们做个假设，如果存储在NameNode节点的磁盘中，因为经常需要进行随机访问，还有响应客户请求，必然是效率过低。因此，元数据需要存放在内存中。但如果只存在内存中，一旦断电，源数据丢失，整个集群就无法工作了。<font color="red">因此产生在磁盘中备份元数据的FsImage。</font></p><p>​        这样又会带来新的问题，当在内存中的元数据更新时，如果同时更新FsImage，就会导致效率过低，但如果不更新，就会发生一致性问题，一旦NameNode节点断电，就会产生数据丢失。<font color="red">因此，引入Edits文件(只进行追加操作，效率很高)。每当元数据有更新或者添加元数据时，修改内存中的元数据并追加到Edits中。</font>这样，一旦NameNode节点断电，可以通过FsImage和Edits的合并，合成元数据。</p><p>​        但是，如果长时间添加数据到Edits中，会导致该文件数据过大，效率降低，而且一旦断电，恢复原数据需要的时间过长。因此，需要定期进行FsImage和Edits的合并，如果这个操作由NameNode节点完成，优惠效率过低。<font color="red">因此，引入一个新的节点SecondaryNameNode，专门用于FsImage和Edits的合并。</font></p><ul><li>fsimage:元数据镜像文件（<strong>备份</strong>）。存储某一时段NameNode内存元数据信息。</li><li>edits:操作日志文件，namenode启动后一些新增元信息日志。（存的是hdfs的操作记录）</li><li>fstime:保存最近一次checkpoint的时间</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922183416186.png" alt="image-20210922183416186"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922183845809.png" alt="image-20210922183845809"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922183857676.png" alt="image-20210922183857676"></p><h2 id="DataNode工作机制"><a href="#DataNode工作机制" class="headerlink" title="DataNode工作机制"></a>DataNode工作机制</h2><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210922184219645.png" alt="image-20210922184219645"></p><h2 id="集群安全模式"><a href="#集群安全模式" class="headerlink" title="集群安全模式"></a>集群安全模式</h2><ul><li><strong>NameNode启动</strong><ul><li>NameNode启动时，首先将镜像文件(Fsimage)载入到内存，并执行编辑日志(Edits)中的各项操作。一旦在内存中成功建立文件系统元数据的映像，则创建一个新的Fsimage文件和一个空的编辑日志。此时，NameNode开始监听DataNode请求。<font color="red">这个过程期间，NameNode一直运行在安全模式，即NameNode的文件系统对于客户端来说是只读的。</font></li></ul></li><li>DataNode启动<ul><li><font color="red">系统中的数据块的位置并不是由NameNode维护的，而是以块列表的形式存储在DataNode中。</font>在系统的正常操作期间，NameNode会在内存中保留所有块位置的映射信息。在安全模式下，各个DataNode会向NameNode发送最新的块列表信息，NameNode了解到足够多的块信息之后，即可高效运行文件系统。</li></ul></li><li>安全模式推出判断<ul><li>如果满足<font color="red">“最小副本条件”，NameNode会在30秒钟之后就退出安全模式。</font>所谓的最小副本条件指的是在整个文件系统中99.9%的块满足最小副本级别(默认值：dfs.replication.min=1)。<font color="red">在启动一个刚刚格式化的HDFS集群时，因为系统中还没有任何块，所以NameNode不会进入安全模式。</font></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 大数据学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop学习</title>
      <link href="/2021/09/20/Hadoop%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/09/20/Hadoop%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h1><p>学习Hadoop之前请先将对应的环境搭建好，可以参考我之前的Hadoop2.x版本安装</p><h2 id="Hadoop的优势"><a href="#Hadoop的优势" class="headerlink" title="Hadoop的优势"></a>Hadoop的优势</h2><p>1.高可靠性：Hadoop底层维护了多个数据副本，所以即使Hadoop某个计算元素或存储出现故障，也不会导致数据的丢失。</p><p>2.高扩展性：在集群间分配任务数据，可方便的扩展数以千计的节点。</p><p>3.高效性：在MapReduce的思想下，Hadoop是并行工作的，以加快任务处理速度</p><p>4.高容错性：能够自动将失败的任务重新分配。</p><h2 id="Hadoop1-x和Hadoop2-x区别"><a href="#Hadoop1-x和Hadoop2-x区别" class="headerlink" title="Hadoop1.x和Hadoop2.x区别"></a>Hadoop1.x和Hadoop2.x区别</h2><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210920104137821.png" alt="image-20210920104137821"></p><h2 id="HDFS架构概述"><a href="#HDFS架构概述" class="headerlink" title="HDFS架构概述"></a>HDFS架构概述</h2><p>1.NameNode：存储文件的元数据，如文件名，文件目录结构，文件属性(生成时间，副本数，文件权限)，以及每个文件的块列表和块所在的DataNode等。</p><p>2.DataNode：在本地文件系统存储文件块数据，以及块数据的校验和。</p><p>3.Secondary NameNode：用来监控HDFS状态的辅助后台程序，每隔一段时间获取HDFS元数据的快照。</p><h2 id="YARN架构"><a href="#YARN架构" class="headerlink" title="YARN架构"></a>YARN架构</h2><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210920105251286.png" alt="image-20210920105251286"></p><h2 id="MapReduce架构概述"><a href="#MapReduce架构概述" class="headerlink" title="MapReduce架构概述"></a>MapReduce架构概述</h2><p>MapReduce将计算过程分为两个阶段：Map和Reduce</p><p>1.Map阶段并行处理数据</p><p>2.Reduce阶段对Map结果进行汇总</p><h2 id="Hadoop运行模式"><a href="#Hadoop运行模式" class="headerlink" title="Hadoop运行模式"></a>Hadoop运行模式</h2><p>Hadoop运行模式包括：本地模式，伪分布式模式以及完全分布式模式</p>]]></content>
      
      
      <categories>
          
          <category> 大数据学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop2.x安装教程</title>
      <link href="/2021/09/17/Hadoop2-x%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
      <url>/2021/09/17/Hadoop2-x%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Hadoop2-x安装-完全分布式安装"><a href="#Hadoop2-x安装-完全分布式安装" class="headerlink" title="Hadoop2.x安装(完全分布式安装)"></a>Hadoop2.x安装(完全分布式安装)</h1><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 必须有3台虚拟机，然后密钥也需要弄!!!</span></span><br><span class="line"><span class="comment"># 如果没设置密钥，可以在master中生成密钥文件。</span></span><br><span class="line"><span class="comment"># 如果你的主机名字不是叫做master，在弄配置文件的时候，只需要将你的主机名替换掉我的master就可以了。</span></span><br><span class="line"></span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line">一直回车</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将密钥文件同步到所有节点</span></span><br><span class="line">ssh-copy-id master</span><br><span class="line">ssh-copy-id node1</span><br><span class="line">ssh-copy-id node2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我的电脑因为之前弄过了，所以密钥已经有了。</span></span><br></pre></td></tr></table></figure><h2 id="NO1-本地通过XFTP上传到Linux上"><a href="#NO1-本地通过XFTP上传到Linux上" class="headerlink" title="NO1.本地通过XFTP上传到Linux上"></a>NO1.本地通过XFTP上传到Linux上</h2><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917185804921.png" alt="image-20210917185804921"></p><p>我这里安装的是Hadoop-2.7.6版本的。</p><h2 id="NO2-解压到soft目录下面"><a href="#NO2-解压到soft目录下面" class="headerlink" title="NO2.解压到soft目录下面"></a>NO2.解压到soft目录下面</h2><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917185936742.png" alt="image-20210917185936742"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917190303756.png" alt="image-20210917190303756"></p><h2 id="NO3-配置环境变量"><a href="#NO3-配置环境变量" class="headerlink" title="NO3.配置环境变量"></a>NO3.配置环境变量</h2><p>在master下。使用命令  vim /etc/profile</p><p>增加hadoop环境变量，将bin和sbin都配置到PATH中</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917191204559.png" alt="image-20210917191204559"></p><p>然后记得刷新一下。使用命令   source /etc/profile</p><p>接着分发到将profile分发到两台从机上面去,同时也要刷新以下。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917191439519.png" alt="image-20210917191439519"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -r /etc/profile node1:/etc/profile</span><br><span class="line"></span><br><span class="line">scp -r /etc/profile node2:/etc/profile</span><br></pre></td></tr></table></figure><h2 id="NO4-修改配置文件-操作均在master上执行"><a href="#NO4-修改配置文件-操作均在master上执行" class="headerlink" title="NO4.修改配置文件(操作均在master上执行)"></a>NO4.修改配置文件(操作均在master上执行)</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hadoop 配置文件在/usr/<span class="built_in">local</span>/soft/hadoop-2.7.6/etc/hadoop/</span><br><span class="line"></span><br><span class="line">使用命令  <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/soft/hadoop-2.7.6/etc/hadoop</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-1-修改slaves"><a href="#4-1-修改slaves" class="headerlink" title="4.1 修改slaves"></a>4.1 修改slaves</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim slaves</span><br><span class="line">增加node1,node2</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917191935303.png" alt="image-20210917191935303"></p><h3 id="4-2-修改Hadoop环境配置文件"><a href="#4-2-修改Hadoop环境配置文件" class="headerlink" title="4.2 修改Hadoop环境配置文件"></a>4.2 修改Hadoop环境配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim hadoop-env.sh</span><br><span class="line"><span class="comment"># 修改JAVA_HOME</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/soft/jdk1.8.0_171</span><br><span class="line"><span class="comment"># 路径就是自己jdk安装的路径，然后jdk版本填写自己的。</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917192449991.png" alt="image-20210917192449991"></p><h3 id="4-3-修改core-site-xml这是Hadoop的核心配置文件"><a href="#4-3-修改core-site-xml这是Hadoop的核心配置文件" class="headerlink" title="4.3 修改core-site.xml这是Hadoop的核心配置文件"></a>4.3 修改core-site.xml这是Hadoop的核心配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim core-site.xml</span><br><span class="line"><span class="comment"># 在configuration中间增加以下内容</span></span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">&lt;value&gt;hdfs://master:9000&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">&lt;value&gt;/usr/<span class="built_in">local</span>/soft/hadoop-2.7.6/tmp&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;fs.trash.interval&lt;/name&gt;</span><br><span class="line">&lt;value&gt;1440&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917192835262.png" alt="image-20210917192835262"></p><h3 id="4-4-修改hdfs-site-xml-这是hdfs配置文件"><a href="#4-4-修改hdfs-site-xml-这是hdfs配置文件" class="headerlink" title="4.4 修改hdfs-site.xml 这是hdfs配置文件"></a>4.4 修改hdfs-site.xml 这是hdfs配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim hdfs-site.xml</span><br><span class="line"><span class="comment"># 在configuration中间增加以下内容</span></span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">&lt;value&gt;1&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.permissions&lt;/name&gt;</span><br><span class="line">&lt;value&gt;<span class="literal">false</span>&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917193335322.png" alt="image-20210917193335322"></p><h3 id="4-5-修改yarn-site-xml-这是yarn的配置文件"><a href="#4-5-修改yarn-site-xml-这是yarn的配置文件" class="headerlink" title="4.5 修改yarn-site.xml 这是yarn的配置文件"></a>4.5 修改yarn-site.xml 这是yarn的配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim yarn-site.xml</span><br><span class="line"><span class="comment"># 在configuration中间增加以下内容</span></span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;</span><br><span class="line">&lt;value&gt;master&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">&lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.log-aggregation-enable&lt;/name&gt;</span><br><span class="line">&lt;value&gt;<span class="literal">true</span>&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.log-aggregation.retain-seconds&lt;/name&gt;</span><br><span class="line">&lt;value&gt;604800&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;  </span><br><span class="line">&lt;name&gt;yarn.nodemanager.resource.memory-mb&lt;/name&gt;  </span><br><span class="line">&lt;value&gt;20480&lt;/value&gt;  </span><br><span class="line">&lt;/property&gt;  </span><br><span class="line"></span><br><span class="line">&lt;property&gt;  </span><br><span class="line">&lt;name&gt;yarn.scheduler.minimum-allocation-mb&lt;/name&gt;  </span><br><span class="line">&lt;value&gt;2048&lt;/value&gt;  </span><br><span class="line">&lt;/property&gt;  </span><br><span class="line"></span><br><span class="line">&lt;property&gt;  </span><br><span class="line">&lt;name&gt;yarn.nodemanager.vmem-pmem-ratio&lt;/name&gt;  </span><br><span class="line">&lt;value&gt;2.1&lt;/value&gt;  </span><br><span class="line">&lt;/property&gt; </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917194010581.png" alt="image-20210917194010581"></p><h3 id="4-6-修改mapred-site-xml-这是mapreduce的配置文件"><a href="#4-6-修改mapred-site-xml-这是mapreduce的配置文件" class="headerlink" title="4.6 修改mapred-site.xml 这是mapreduce的配置文件"></a>4.6 修改mapred-site.xml 这是mapreduce的配置文件</h3><p>在2.x版本中，会有一个mapred-site.xml.template这个文件，我们要给它重命名</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重命名</span></span><br><span class="line">mv mapred-site.xml.template mapred-site.xml</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917194118845.png" alt="image-20210917194118845"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim mapred-site.xml</span><br><span class="line"><span class="comment"># 在configuration中间增加以下内容</span></span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">&lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;  </span><br><span class="line">&lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt;  </span><br><span class="line">&lt;value&gt;master:10020&lt;/value&gt;  </span><br><span class="line">&lt;/property&gt;  </span><br><span class="line"></span><br><span class="line">&lt;property&gt;  </span><br><span class="line">&lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt;  </span><br><span class="line">&lt;value&gt;master:19888&lt;/value&gt;  </span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917194339898.png" alt="image-20210917194339898"></p><h2 id="NO5-将hadoop安装文件同步到子节点上"><a href="#NO5-将hadoop安装文件同步到子节点上" class="headerlink" title="NO5.将hadoop安装文件同步到子节点上"></a>NO5.将hadoop安装文件同步到子节点上</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -r /usr/<span class="built_in">local</span>/soft/hadoop-2.7.6/ node1:/usr/<span class="built_in">local</span>/soft/</span><br><span class="line">scp -r /usr/<span class="built_in">local</span>/soft/hadoop-2.7.6/ node2:/usr/<span class="built_in">local</span>/soft/</span><br></pre></td></tr></table></figure><p>同步之后就能在子节点中找到相应文件了</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917195046675.png" alt="image-20210917195046675"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917195124002.png" alt="image-20210917195124002"></p><h2 id="NO6-格式化namenode"><a href="#NO6-格式化namenode" class="headerlink" title="NO6.格式化namenode"></a>NO6.格式化namenode</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hdfs namenode -format </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917195354737.png" alt="image-20210917195354737"></p><h2 id="NO7-启动hadoop并且通过jps查看"><a href="#NO7-启动hadoop并且通过jps查看" class="headerlink" title="NO7.启动hadoop并且通过jps查看"></a>NO7.启动hadoop并且通过jps查看</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动hadoop，在hadoop的sbin目录下启动</span></span><br><span class="line">start-all.sh</span><br><span class="line"><span class="comment"># jps主机和从机都查看</span></span><br><span class="line">jps</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917200000230.png" alt="image-20210917200000230"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917200218711.png" alt="image-20210917200218711"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917200247802.png" alt="image-20210917200247802"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917200313588.png" alt="image-20210917200313588"></p><h2 id="NO7-访问hdfs页面验证是否安装成功"><a href="#NO7-访问hdfs页面验证是否安装成功" class="headerlink" title="NO7.访问hdfs页面验证是否安装成功"></a>NO7.访问hdfs页面验证是否安装成功</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在本地浏览器中输入</span></span><br><span class="line">http://192.168.30.66:50070</span><br><span class="line"><span class="comment"># 192.168.30.66是我自己的虚拟机的IP地址，要是修改只需要改成你们自己的就可以！！！</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917200713906.png" alt="image-20210917200713906"></p><p>要是能出现这样的页面就是说明成功了。</p><p>至此安装全部结束！！！</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 关闭集群</span></span><br><span class="line">stop-all.sh</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917201546951.png" alt="image-20210917201546951"></p>]]></content>
      
      
      <categories>
          
          <category> 大数据学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis学习小结</title>
      <link href="/2021/09/13/redis%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
      <url>/2021/09/13/redis%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Redis入门"><a href="#Redis入门" class="headerlink" title="Redis入门"></a>Redis入门</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>Redis是什么？</p></blockquote><p>Redis(Remote Dictionary Server),即远程字典服务！</p><p>是一个开源的使用ANSI C语言编写，支持网络，可基于内存亦可持久化的日志型，Key-Value数据库，并提供多种语言的API。</p><p>redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p><p>免费和开源！是当下最热门的NoSQL技术之一!也被人们称之为结构化数据库！</p><blockquote><p>Redis能干吗？</p></blockquote><p>1.内存存储，持久化。内存中是断电即失，所以说持久化很重要(rdb，aof)</p><p>2.效率高，可以用于高速缓存</p><p>3.发布订阅系统</p><p>4.地图信息分析</p><p>5.计时器，计数器(浏览量)</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>redis默认有16个数据库，同时Redis不区分大小写</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210914161113434.png" alt="image-20210914161113434"></p><p>默认使用的是第0个数据库。可以使用select进行切换数据库。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210914161237693.png" alt="image-20210914161237693"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; dbsize<span class="comment"># 查看当前数据库大小</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name fangshitao  <span class="comment"># 存值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name<span class="comment"># 取值</span></span><br><span class="line"><span class="string">&quot;fangshitao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; dbsize<span class="comment"># 查看当前数据库大小</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name1 fangshitao1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name1</span><br><span class="line"><span class="string">&quot;fangshitao1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; dbsize</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; keys *<span class="comment"># 查看数据库内所有的key</span></span><br><span class="line">1) <span class="string">&quot;name1&quot;</span></span><br><span class="line">2) <span class="string">&quot;name&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; dbsize</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;name1&quot;</span></span><br><span class="line">2) <span class="string">&quot;name&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; flushdb<span class="comment"># 清除当前数据库</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line">127.0.0.1:6379&gt; flushall<span class="comment"># 清除所有数据库</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>清除当前数据库 ==flushdb==</p><p>清除所有数据库 ==flushall==</p><blockquote><p>Redis是单线程的！！！</p></blockquote><p>官方表示，Redis是基于内存操作，CPU不是Redis性能瓶颈，Redis的瓶颈是根据机器的内存和网络带宽。既然可以使用单线程来实现，就是用单线程！</p><p><strong>Redis为什么单线程还这么快？</strong></p><p>1.误区1:高性能的服务器一定是多线程的？？？</p><p>2.误区2:多线程(CPU上下文会切换)一定比单线程效率高？？？</p><p>==CPU的速度&gt;内存&gt;硬盘==</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">核心:redis是将所有的数据全部放在内存里面，所以说使用单线程去操作效率就是最高的。因为多线程之间会产生CPU的上下文切换，这是一个耗时的操作。对于内存系统来说，如果没有上下文的切换，那它的效率就是最高的！多次读写都是在一个CPU上，在内存情况上来说，这个就是最佳方案。</span><br></pre></td></tr></table></figure><h2 id="五大数据类型"><a href="#五大数据类型" class="headerlink" title="五大数据类型"></a>五大数据类型</h2><h3 id="Redis-key"><a href="#Redis-key" class="headerlink" title="Redis-key"></a>Redis-key</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *<span class="comment"># 查看所有的key</span></span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line">127.0.0.1:6379&gt; flushall</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name fangshitao<span class="comment"># set key</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name1 fangshitao1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;name1&quot;</span></span><br><span class="line">2) <span class="string">&quot;name&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; exists name<span class="comment"># 判断当前key是否存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; move name 1<span class="comment"># 把当前的key移除到别的库中</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;name1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name fangshitao</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;fangshitao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; expire name 10<span class="comment"># 设置key的过期时间，单位是秒(s)</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl name<span class="comment"># 查看当前key的过期时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;name1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get name<span class="comment">#获得key</span></span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;name1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name fangshitao</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;name1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> name<span class="comment"># 查看当前key的类型</span></span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> name1</span><br><span class="line">string</span><br></pre></td></tr></table></figure><h3 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String(字符串)"></a>String(字符串)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name fangshitao<span class="comment"># 设置值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name<span class="comment"># 获得值</span></span><br><span class="line"><span class="string">&quot;fangshitao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; keys * <span class="comment"># 获得所有的key</span></span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;name1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; EXISTS name<span class="comment"># 判断某一个key是否存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; APPEND name xiaofang  <span class="comment"># 追加字符串，如果当前key不存在，就相当于是set key</span></span><br><span class="line">(<span class="built_in">integer</span>) 18</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;fangshitaoxiaofang&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; STRLEN name<span class="comment">#获取字符串长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 18</span><br><span class="line"></span><br><span class="line">*****************************************************************</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> views 0<span class="comment"># 初始views为0</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; incr views<span class="comment"># 自增1 views变为1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; incr views<span class="comment"># 自增1 views变为2</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; DECR views<span class="comment"># 自减1 views变为1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; DECR views</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; INCRBY views 10  <span class="comment"># 指定增量为10</span></span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;10&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; DECRBY views 10<span class="comment"># 指定减量为10</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;0&quot;</span></span><br><span class="line"></span><br><span class="line">*****************************************************************</span><br><span class="line"><span class="comment"># 字符串范围range</span></span><br><span class="line">127.0.0.1:6379&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key1 fangshitao<span class="comment"># 设置key1的值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; getrange key1 0 3<span class="comment"># 截取字符串[0,3]闭区间</span></span><br><span class="line"><span class="string">&quot;fang&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; getrange key1 0 -1<span class="comment"># 获取全部的字符串和get key一样</span></span><br><span class="line"><span class="string">&quot;fangshitao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key2 abcdefg</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key2</span><br><span class="line"><span class="string">&quot;abcdefg&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; setrange key2 1 fang<span class="comment"># 替换指定位置开始的字符串</span></span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">127.0.0.1:6379&gt; get key2</span><br><span class="line"><span class="string">&quot;afangfg&quot;</span></span><br><span class="line"></span><br><span class="line">*****************************************************************</span><br><span class="line"><span class="comment">#setex(set with expire) # 设置过期时间</span></span><br><span class="line"><span class="comment">#setnx(set if not exist) # key如果不存在就设置(在分布式锁中会常常使用！)</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; setex key3 30 woain<span class="comment"># 设置key3的值为woain，30秒后过期</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key3</span><br><span class="line">(<span class="built_in">integer</span>) 25</span><br><span class="line">127.0.0.1:6379&gt; get key3</span><br><span class="line"><span class="string">&quot;woain&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; setnx mykey redis<span class="comment"># 如果mykey不存在，则创建mykey</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl key3</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;key2&quot;</span></span><br><span class="line">2) <span class="string">&quot;mykey&quot;</span></span><br><span class="line">3) <span class="string">&quot;key1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; setnx mykey mongoDB<span class="comment"># 如果mykey存在，则创建失败</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; get mykey</span><br><span class="line"><span class="string">&quot;redis&quot;</span></span><br><span class="line"></span><br><span class="line">*****************************************************************</span><br><span class="line">mset:一次性设置多个值</span><br><span class="line">mget:一次性获取多个值</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3<span class="comment"># 一次性设置多个值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget k1 k2 k3<span class="comment"># 一次性获取多个值</span></span><br><span class="line">1) <span class="string">&quot;v1&quot;</span></span><br><span class="line">2) <span class="string">&quot;v2&quot;</span></span><br><span class="line">3) <span class="string">&quot;v3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; msetnx k1 v1 k4 v4<span class="comment"># msetnx是一个原子性的操作，要么一起成功，要么一起失败。</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; get k4</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>==所有的List命令都是用L开头的==</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; LPUSH list one<span class="comment"># 将一个值或多个值插入到列表头部(左)</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list two</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list three</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1  <span class="comment"># 获取list中的值</span></span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 1  <span class="comment"># 通过区间来获取具体的值</span></span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; RPUSH list right  <span class="comment"># 将一个值或多个值插入到列表尾部(右)</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">4) <span class="string">&quot;right&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LPOP list<span class="comment"># 移除list的第一个元素</span></span><br><span class="line"><span class="string">&quot;three&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LPOP list</span><br><span class="line"><span class="string">&quot;two&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;right&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; RPOP list<span class="comment"># 移除list最后的一个元素</span></span><br><span class="line"><span class="string">&quot;right&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line"></span><br><span class="line">*****************************************************************</span><br><span class="line">Lindex通过下标获取list中的某一个值</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LINDEX list 0<span class="comment"># 通过下标获取list中的某一个值</span></span><br><span class="line"><span class="string">&quot;one&quot;</span></span><br><span class="line"></span><br><span class="line">*****************************************************************</span><br><span class="line">Llen 获得当前list的长度</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LPUSH list one</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list two</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list three</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; LLEN list<span class="comment"># 此时返回的长度就是3</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">*****************************************************************</span><br><span class="line">Lrem:移除list集合中指定个数的value，精确匹配</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;three&quot;</span></span><br><span class="line">3) <span class="string">&quot;two&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LREM list 2 three  <span class="comment"># 这里的意思就是移除2各three</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line"></span><br><span class="line">*****************************************************************</span><br><span class="line">trim:截取</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello3&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello2&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello1&quot;</span></span><br><span class="line">4) <span class="string">&quot;hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LTRIM mylist 1 2<span class="comment">#通过下标截取指定的长度，只会剩下截取的元素，这里表示从1开始一直截取到2 [1,2]</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello2&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello1&quot;</span></span><br><span class="line"></span><br><span class="line">*****************************************************************</span><br><span class="line">rpoplpush:移除列表的最后一个元素，并且把它移动到新的列表中</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello2&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; RPOPLPUSH mylist myotherlist</span><br><span class="line"><span class="string">&quot;hello1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1<span class="comment"># 查看原来的列表</span></span><br><span class="line">1) <span class="string">&quot;hello2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE myotherlist 0 -1<span class="comment"># 查看目标列表</span></span><br><span class="line">1) <span class="string">&quot;hello1&quot;</span></span><br><span class="line"></span><br><span class="line">*****************************************************************</span><br><span class="line">lset:将列表中指定下标的值替换成另外一个值，相当于是更新操作</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; EXISTS list<span class="comment"># 判断这个列表是否存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; LSET list 0 item  <span class="comment"># 如果不存在我们去更新值就会报错</span></span><br><span class="line">(error) ERR no such key</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list value1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;value1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lset list 0 item<span class="comment"># 如果存在，更新当前下标的值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;item&quot;</span></span><br><span class="line"></span><br><span class="line">*****************************************************************</span><br><span class="line">linsert:将某个具体的value插入到列表中某个元素的前面或者后面</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;world&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LINSERT mylist before world nihao <span class="comment">#在world前面添加</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;nihao&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LINSERT mylist after hello nihao <span class="comment">#在hello后面添加</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;nihao&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello&quot;</span></span><br><span class="line">4) <span class="string">&quot;nihao&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>==小结==</p></blockquote><ul><li>它实际上是一个链表，left，right都可以插入值</li><li>如果key不存在，创建新的链表</li><li>如果key存在，新增内容</li><li>如果移除了所有值，空链表，也代表不存在</li><li>在两边插入或者改动值效率最高</li></ul><h3 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set(集合)"></a>Set(集合)</h3><p>==set中的值是不能重复的！！！==</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myset hello<span class="comment"># set集合中添加元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset fangshitao</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset nihao</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset<span class="comment"># 查看指定set中的所有值</span></span><br><span class="line">1) <span class="string">&quot;nihao&quot;</span></span><br><span class="line">2) <span class="string">&quot;fangshitao&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset nihao<span class="comment"># 判断某个值是不是在set集合中</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset f<span class="comment"># 存在为1，不存在为0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">*****************************************************************</span><br><span class="line">scard:获取<span class="built_in">set</span>集合中的内容元素个数</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; scard myset</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">*****************************************************************</span><br><span class="line">srem:移除<span class="built_in">set</span>集合中的指定元素</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; srem myset hello<span class="comment"># 移除指定元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; scard myset</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">&quot;nihao&quot;</span></span><br><span class="line">2) <span class="string">&quot;fangshitao&quot;</span></span><br><span class="line">*****************************************************************</span><br><span class="line"><span class="built_in">set</span>是无序且不重复的集合，可以用来抽随机！</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset<span class="comment"># 随机抽取一个元素</span></span><br><span class="line"><span class="string">&quot;nihao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset</span><br><span class="line"><span class="string">&quot;fangshitao&quot;</span></span><br><span class="line">*****************************************************************</span><br><span class="line">spop:随机移除<span class="built_in">set</span>集合中的元素</span><br><span class="line">127.0.0.1:6379&gt; spop myset</span><br><span class="line"><span class="string">&quot;nihao&quot;</span></span><br><span class="line">*****************************************************************</span><br><span class="line">smove:将一个集合中的元素移动到另外一个集中中去</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; sadd myset hello</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset fangshitao</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset world</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset2 set2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SMOVE myset myset2 hello  <span class="comment"># 将myset中的hello移动到myset2中</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset2</span><br><span class="line">1) <span class="string">&quot;set2&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">&quot;fangshitao&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br><span class="line">*****************************************************************</span><br><span class="line">- 差集:sdiff</span><br><span class="line">- 交集:sinter</span><br><span class="line">- 并集:sunion </span><br><span class="line">127.0.0.1:6379&gt; sadd key1 a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd key1 b</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd key1 c</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 c</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 d</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 e</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SDIFF key1 key2<span class="comment"># 差集</span></span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;b&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SINTER key1 key2<span class="comment"># 交集</span></span><br><span class="line">1) <span class="string">&quot;c&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SUNION key1 key2<span class="comment"># 并集</span></span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;b&quot;</span></span><br><span class="line">3) <span class="string">&quot;c&quot;</span></span><br><span class="line">4) <span class="string">&quot;e&quot;</span></span><br><span class="line">5) <span class="string">&quot;d&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Hash-哈希"><a href="#Hash-哈希" class="headerlink" title="Hash(哈希)"></a>Hash(哈希)</h3><p>Map集合，Key-map。这时候这个值是一个map集合</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset myhash name fangshitao<span class="comment">#set一个具体的key-value</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hget myhash name</span><br><span class="line"><span class="string">&quot;fangshitao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hmset myhash name1 xiaofang name2 xiaohua name3 xiaotao</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hmget myhash name1 name2 name3</span><br><span class="line">1) <span class="string">&quot;xiaofang&quot;</span></span><br><span class="line">2) <span class="string">&quot;xiaohua&quot;</span></span><br><span class="line">3) <span class="string">&quot;xiaotao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash<span class="comment"># 获取全部的数据 </span></span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;xiaotao&quot;</span></span><br><span class="line">3) <span class="string">&quot;name1&quot;</span></span><br><span class="line">4) <span class="string">&quot;xiaofang&quot;</span></span><br><span class="line">5) <span class="string">&quot;name2&quot;</span></span><br><span class="line">6) <span class="string">&quot;xiaohua&quot;</span></span><br><span class="line">7) <span class="string">&quot;name3&quot;</span></span><br><span class="line">8) <span class="string">&quot;xiaotao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hdel myhash name<span class="comment"># 删除hash指定的key字段，对应的value值也消失了</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) <span class="string">&quot;name1&quot;</span></span><br><span class="line">2) <span class="string">&quot;xiaofang&quot;</span></span><br><span class="line">3) <span class="string">&quot;name2&quot;</span></span><br><span class="line">4) <span class="string">&quot;xiaohua&quot;</span></span><br><span class="line">5) <span class="string">&quot;name3&quot;</span></span><br><span class="line"></span><br><span class="line">******************************************************************</span><br><span class="line">heln:获取<span class="built_in">hash</span>表的字段数量</span><br><span class="line">hexists:判断<span class="built_in">hash</span>中的指定字段是否存在</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; hlen myhash<span class="comment"># 获取字段数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; HEXISTS myhash name<span class="comment"># 不存在为0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; HEXISTS myhash name1<span class="comment"># 存在为1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><h3 id="Zset-有序集合"><a href="#Zset-有序集合" class="headerlink" title="Zset(有序集合)"></a>Zset(有序集合)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd myset 1 one<span class="comment"># 添加一个值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myset 2 two</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myset 3 three 4 four<span class="comment"># 添加多个值</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myset 0 -1<span class="comment"># 获得集合中所有的值··················</span></span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;three&quot;</span></span><br><span class="line">4) <span class="string">&quot;four&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZCARD myset<span class="comment"># 查看集合中的个数</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; zrem myset one<span class="comment"># 移除集合中指定的元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myset 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;three&quot;</span></span><br><span class="line">3) <span class="string">&quot;four&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZCOUNT myset 0 1<span class="comment"># 获取指定集合中的元素个数，因为上面移除了，所以返回0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; ZCOUNT myset 1 2<span class="comment"># 获取指定集合中的元素个数</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><h2 id="三种特殊的数据类型"><a href="#三种特殊的数据类型" class="headerlink" title="三种特殊的数据类型"></a>三种特殊的数据类型</h2><h3 id="Geospatial-地理位置"><a href="#Geospatial-地理位置" class="headerlink" title="Geospatial 地理位置"></a>Geospatial 地理位置</h3><p>Redis的Geo在Redis3.2版本就推出了！</p><p>具体看Redis官方操作文档~~~</p><p>==一共6个相关命令==</p><ul><li>getadd:添加地理位置</li><li>geodist:查看两个城市之间的距离</li><li>geohash:返回一个或者多个位置元素的Geohash表示</li><li>geopos:获取指定城市的经度和纬度</li><li>georadius:以给定的经纬度为中心，找出某一半径内的元素。</li><li>georadiusbymember:找出位于指定元素周围的其他元素</li></ul><h3 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h3><blockquote><p>什么是基数？</p></blockquote><p>例如: A{1，3，5，7，8，7}    B{1，3，5，7，8}</p><p>此时基数(不重复的数字) = 5，可以接受误差！</p><blockquote><p>简介</p></blockquote><p>Redis 2.8.9版本就更新了Hyperloglog数据结构</p><p>Redis Hyperloglog基数统计的算法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PFADD:添加元素</span><br><span class="line">PFCOUNT:统计元素个数</span><br></pre></td></tr></table></figure><h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h3><blockquote><p>位存储</p></blockquote><p>Bitmaps位图，都是操作二进制位来进行记录，就只有0和1两个状态！</p><p>能进行统计操作    bitcount</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>Redis事物本质:一组命令的集合！一个事务中的所有命令都会被序列化，在事务执行的过程中，会按照顺序执行！</p><p><font color="blue">一次性、顺序性、排他性！</font></p><p>==Redis单条命令是保证原子性的，但是Redis的事务是不保证原子性的==</p><p><font color="red">Redis事务没有隔离级别的概念</font></p><p>所有的命令在事务中，并没有直接被执行！只有发起执行命令的时候才会执行！Exec执行！</p><p>Redis的事务:</p><ul><li>开启事务()</li><li>命令入队()</li><li>执行事务()</li></ul><blockquote><p>正常执行事务！</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi<span class="comment"># 开启事务</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令入队</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span><span class="comment"># 执行事务</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) OK</span><br><span class="line">4) <span class="string">&quot;v3&quot;</span></span><br></pre></td></tr></table></figure><p>==每次事务执行之后就会自动结束，需要在重新开启事务！！！==</p><blockquote><p>放弃事务</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi<span class="comment"># 开启事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; DISCARD<span class="comment"># 取消事务，事务队列中的命令都不会被执行</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><blockquote><p>监控！</p></blockquote><p><strong>悲观锁</strong></p><ul><li>很悲观，什么时候都会出问题，无论做什么都会加锁！</li></ul><p><strong>乐观锁</strong></p><ul><li><p>很乐观，认为什么时候都不会出现问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据。</p></li><li><p>获取version</p></li><li><p>更新的时候比较version</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> out 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money<span class="comment"># 监视money对象</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi<span class="comment"># 事务正常结束，数据期间没有发生变动，这个时候就正常执行成功</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRBY money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY out 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 80</span><br><span class="line">2) (<span class="built_in">integer</span>) 20</span><br></pre></td></tr></table></figure><h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><blockquote><p>什么是Jedis？</p></blockquote><p><font color="red">Jedis是Redis官方推荐的java 连接开发工具！使用java操作Redis的中间件！如果你要是用java来操作Redis，那么一定要对Jedis十分熟悉！</font></p><p>例如:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">redisTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;master&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        String set = jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;fangshitao&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;master&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        Long name = jedis.del(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Redis-conf详解"><a href="#Redis-conf详解" class="headerlink" title="Redis.conf详解"></a>Redis.conf详解</h2><p>启动的时候，就通过配置文件来启动。</p><blockquote><p>单位</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210915200153799.png" alt="image-20210915200153799"></p><p>配置文件unit单位，对大小写不敏感</p><blockquote><p>包含</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210915200442633.png" alt="image-20210915200442633"></p><p>可以把多个配置文件包含在一起</p><blockquote><p>网络</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bind</span> 127.0.0.1<span class="comment"># 绑定的ip</span></span><br><span class="line">protected-mode yes<span class="comment"># 保护模式，默认是yes</span></span><br><span class="line">port 6379<span class="comment"># 端口设置，默认是6379</span></span><br></pre></td></tr></table></figure><blockquote><p>通用配置</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">daemonize no<span class="comment"># 以守护进程的方式运行，默认是no，我们需要自己开启为yes</span></span><br><span class="line">pidfile /var/run/redis.pid<span class="comment"># 如果以后台的方式运行，我们就需要指定一个pid文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志</span></span><br><span class="line"><span class="comment"># Specify the server verbosity level.</span></span><br><span class="line"><span class="comment"># This can be one of:</span></span><br><span class="line"><span class="comment"># debug (a lot of information, useful for development/testing)</span></span><br><span class="line"><span class="comment"># verbose (many rarely useful info, but not a mess like the debug level)</span></span><br><span class="line"><span class="comment"># notice (moderately verbose, what you want in production probably)</span></span><br><span class="line"><span class="comment"># warning (only very important / critical messages are logged)</span></span><br><span class="line">loglevel notice</span><br><span class="line">logfile <span class="string">&quot;&quot;</span>  <span class="comment"># 日志的文件名</span></span><br><span class="line">databases 16  <span class="comment"># 数据库的数量，默认是16个数据库</span></span><br><span class="line">always-show-logo yes  <span class="comment"># 是否总是显示LOGO</span></span><br></pre></td></tr></table></figure><blockquote><p>快照</p></blockquote><p>做持久化，在规定的时间内，执行了多少次操作，则会持久化到文件 .rab或者.aof</p><p>redis是内存数据库，如果没有持久化，那么数据就会断电即失！</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">save 900 1<span class="comment"># 如果900秒内，如果至少有1个key进行了修改，那么我们就进行持久化操作</span></span><br><span class="line">save 300 10<span class="comment"># 如果300秒内，如果至少有10个key进行了修改，我们就进行持久化操作</span></span><br><span class="line">save 60 10000<span class="comment"># 如果60秒内，如果至少有10000个key进行了修改，我们就进行持久化操作</span></span><br><span class="line"><span class="comment"># 我们之后学习持久化，会自己定义这个测试</span></span><br><span class="line"></span><br><span class="line">stop-writes-on-bgsave-error yes<span class="comment"># 持久化如果出错，是否还需要继续工作</span></span><br><span class="line"></span><br><span class="line">rdbcompression yes<span class="comment"># 是否压缩rdb文件，需要消耗一些CPU资源</span></span><br><span class="line"></span><br><span class="line">rdbchecksum yes<span class="comment"># 保存rdb文件的时候，进行错误的检查校验</span></span><br><span class="line"></span><br><span class="line">dir ./<span class="comment"># rdb 文件保存的目录</span></span><br></pre></td></tr></table></figure><blockquote><p>SECURITY 安全</p></blockquote><p>可以在这里设置redis的密码，默认是没有密码的！</p><blockquote><p>限制CLIENTS</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">maxclients 10000<span class="comment"># 设置能连接上redis的最大客户端的数量</span></span><br><span class="line">maxmemory &lt;bytes&gt;<span class="comment"># redis 配置最大的内存容量</span></span><br><span class="line">maxmemory-policy noeviction <span class="comment"># 内存到达上限之后的处理策略</span></span><br><span class="line"></span><br><span class="line">1.volatile-lru: 只对设置了过期时间的key进行LRU(默认值)</span><br><span class="line">2.allkeys-lru: 删除lru算法的key</span><br><span class="line">3.volatile-random: 随即删除即将过期的key</span><br><span class="line">4.allkeys-random: 随即删除</span><br><span class="line">5.volatile-ttl: 删除即将过期的</span><br><span class="line">6.noeviction: 永不过期，返回错误</span><br></pre></td></tr></table></figure><blockquote><p>APPEND ONLY模式 aof配置</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">appendonly no <span class="comment"># 默认是不开启aof模式，默认是使用rdb方式持久化的，在大部分所有的情况下，rdb完全够用</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span><span class="comment"># 持久化的文件的名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># appendfsync always# 每次修改都会 sync，消耗性能</span></span><br><span class="line">appendfsync everysec<span class="comment"># 每秒执行一次sync，可能会丢失这ls的数据</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><h3 id="RDB-Redis-DataBase"><a href="#RDB-Redis-DataBase" class="headerlink" title="RDB(Redis DataBase)"></a>RDB(Redis DataBase)</h3><blockquote><p>什么是RDB？</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210916194301806.png" alt="image-20210916194301806"></p><p>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件读到内存里。</p><p>Redis会单独创建(fork)一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。我们默认的就是RDB，一般情况下不需要修改这个配置！</p><p>==rdb保存的文件是dump.rdb==    都是在我们的配置文件的快照中进行配置的！</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210916204550600.png" alt="image-20210916204550600"></p><blockquote><p>触发机制</p></blockquote><p>1.save的规则满足的情况下，会自动触发rdb规则</p><p>2.执行flushall命令，也会触发我们的rdb规则！</p><p>3.退出redis，也会产生rdb文件！</p><p>备份就自动生成一个dump.rdb</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917211401569.png" alt="image-20210917211401569"></p><blockquote><p>如何恢复rdb文件？</p></blockquote><p>只需要将rdb文件放在我们的redis启动目录就可以，然后redis启动的时候会自动检查dump.rdb，并且恢复其中的数据。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># RDB优缺点</span></span><br><span class="line">优点:</span><br><span class="line">1.适合大规模的数据恢复</span><br><span class="line">2.对数据的完整性要求不高</span><br><span class="line"></span><br><span class="line">缺点:</span><br><span class="line">1.需要一定的时间间隔进行操作，如果redis意外宕机了，这个最后一次的修改数据就没有了</span><br><span class="line">2.fork进程的时候，会占用一定的内容空间</span><br></pre></td></tr></table></figure><h3 id="AOF-Append-Only-File"><a href="#AOF-Append-Only-File" class="headerlink" title="AOF(Append Only File)"></a>AOF(Append Only File)</h3><blockquote><p>什么是AOF</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917212053044.png" alt="image-20210917212053044"></p><p>以日志的形式来记录每个操作，将Redis执行过的所有记录记录下来(读操作不记录)，只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p><p>AOF保存的是 appendonly.aof文件</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210917212615674.png" alt="image-20210917212615674"></p><p>默认是不开启的，我们需要手动进行配置！只需要将no改为yes即可</p><p>如果这个aof文件有错误，这时候redis是启动不了的，我们需要修复这个aof文件。此时redis就给我们提供了一个工具<code>redis-check-aof --fix</code></p><blockquote><p>优点和缺点</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">appendonly no<span class="comment"># 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下，rdb完全够用</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span><span class="comment"># 持久化的文件的名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># appendfsync always# 每次修改都会sync，消耗性能</span></span><br><span class="line">appendfsync everysec<span class="comment"># 每秒执行一次sync，可能会对是这1s的数据</span></span><br><span class="line"><span class="comment"># appendfsync no# 不执行sync，这个时候操作系统自己同步数据，速度最快</span></span><br></pre></td></tr></table></figure><p>优点:</p><p>1.每一次修改都同步，文件的完整会更好</p><p>2.每秒同步一次，可能会丢失一秒的数据</p><p>3.从不同步，效率最高</p><p>缺点:<br>1.相对于数据文件来说，aof远远大于rdb，修复的速度也比rdb慢</p><p>2.aof运行效率也要比rdb慢，所以我们redis默认的设置就是rdb持久化而不是aof</p><h2 id="哨兵模式详解"><a href="#哨兵模式详解" class="headerlink" title="哨兵模式详解"></a>哨兵模式详解</h2><blockquote><p>概述</p></blockquote><p>主从切换技术的方法是:当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费时费力，还会造成一段时间内服务不可用。这不是一种推荐的方法，更多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提出了Sentinel(哨兵)架构来解决这个问题。</p><p>哨兵报模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立进行。其原理就是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210919152442534.png" alt="image-20210919152442534"></p><p>这里的哨兵有两个作用</p><ul><li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器</li><li>当哨兵检测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机</li></ul><p>然而一个哨兵进程对Redis服务器进行监控可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210919153624250.png" alt="image-20210919153624250"></p><p>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象称为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线。</strong></p><p>配置哨兵配置文件 sentine.conf</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sentinel monitor 被监控的名称 host  port 1</span></span><br><span class="line">sentinel monitor myredis 127.0.0.1 63791</span><br></pre></td></tr></table></figure><p>后面的这个数字1，代表主机挂了，slave投票看让谁接替成为主机，票数最多的，就会成为主机。</p><blockquote><p>哨兵模式</p></blockquote><p>优点:</p><p>1.哨兵集群，基于主从复制模式，所有的主从配置优点，它全有</p><p>2.主从可以切换，故障可以转移，系统的可用性就会更好</p><p>3.哨兵模式就是主从模式的升级，手动到自动，更加健壮！</p><p>缺点:</p><p>1.Redis不好在线扩容，如果集群容量一旦到达上限，在线扩容就十分麻烦</p><p>2.实现哨兵模式的配置其实是很麻烦的，里面有很多选择。</p><h2 id="Redis缓存穿透和雪崩-面试高频，工作常用！！！"><a href="#Redis缓存穿透和雪崩-面试高频，工作常用！！！" class="headerlink" title="Redis缓存穿透和雪崩(面试高频，工作常用！！！)"></a>Redis缓存穿透和雪崩(面试高频，工作常用！！！)</h2><p>Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。</p><p>另外的一些典型问题就是，缓存穿透，缓存雪崩和缓存击穿。目前，业界也都有比较流行的解决方案。</p><h3 id="缓存穿透-查不到数据导致的"><a href="#缓存穿透-查不到数据导致的" class="headerlink" title="缓存穿透(查不到数据导致的)"></a>缓存穿透(查不到数据导致的)</h3><blockquote><p>概念</p></blockquote><p>缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。</p><blockquote><p>解决方案</p></blockquote><p><strong>布隆过滤器</strong></p><p>布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进性校验，不符合则丢弃，从而避免了存储系统的查询压力</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210919213321517.png" alt="image-20210919213321517"></p><p><strong>缓存空对象</strong></p><p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210919213532550.png" alt="image-20210919213532550"></p><p>但是这种方法会存在两个问题:</p><p>1.如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因此这当中可能会有很多的空值的键</p><p>2.即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间的窗口的不一致，这对于需要保持一致性的业务会有影响。</p><h3 id="缓存击穿-量太大，缓存过期！！"><a href="#缓存击穿-量太大，缓存过期！！" class="headerlink" title="缓存击穿(量太大，缓存过期！！)"></a>缓存击穿(量太大，缓存过期！！)</h3><blockquote><p>概述</p></blockquote><p> 缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p><p>当某个key在过期的瞬间，会有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导致数据库瞬间压力过大。</p><blockquote><p>解决方案</p></blockquote><p><strong>设置热点数据永不过期</strong></p><p>从缓存层面来看，没有设置过期时间，所以不会出现热点key过期后产生的问题。</p><p><strong>加互斥锁</strong></p><p>分布式锁:使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210919214838400.png" alt="image-20210919214838400"></p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><blockquote><p>概念</p></blockquote><p>缓存雪崩，是指在某一个时间段，缓存集中过期失效/</p><p>产生雪崩的原因之一，比如在双十一零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时，那么到了凌晨1点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会到达存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210919215323673.png" alt="image-20210919215323673"></p><p>其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。</p><blockquote><p>解决方案</p></blockquote><p><strong>redis高可用</strong></p><p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后，其他的还可以继续工作，其实就是搭建的集群。</p><p><strong>限流降级</strong></p><p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p><p><strong>数据预热</strong></p><p>数据预热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习---day03</title>
      <link href="/2021/09/05/MySQL%E5%AD%A6%E4%B9%A0-day03/"/>
      <url>/2021/09/05/MySQL%E5%AD%A6%E4%B9%A0-day03/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="1-创建表"><a href="#1-创建表" class="headerlink" title="1.创建表"></a>1.<strong>创建表</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">建表语句格式    </span><br><span class="line">    create table 表名(    其实后面还有个约束，但是这里我们先不讲</span><br><span class="line">        字段名1 数据类型</span><br><span class="line">        字段名2 数据类型</span><br><span class="line">        字段名3 数据类型</span><br><span class="line">        ......</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">建议起名字要做到见名知意。</span><br></pre></td></tr></table></figure><p>关于MySQL当中字段的数据类型，以下只说几种最为常用的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int            整数型(对应java中的int)</span><br><span class="line">bigint         长整型(相当于是java中的long)</span><br><span class="line">float          浮点型(对应java中的float)</span><br><span class="line">double         浮点型(对应java中的double)</span><br><span class="line">char           定长字符串(对应java中的String)</span><br><span class="line">varchar        可变长字符串(最多存储255个字符，对应java中的StringBuffer/StringBuilder)</span><br><span class="line">date           日期类型(对应java中的java.sql.Date类型)</span><br><span class="line">BLOB           二进制大对象(存储图片,视频等流媒体信息)    Binary Large OBject</span><br><span class="line">CLOB           字符大对象(存储较大文本,比如，可以存储4G的字符串)    Character Large OBject</span><br><span class="line">.......</span><br></pre></td></tr></table></figure><h3 id="char和varchar怎么选择？"><a href="#char和varchar怎么选择？" class="headerlink" title="char和varchar怎么选择？"></a><strong>char和varchar怎么选择？</strong></h3><p>  <strong>在实际开发过程中，当某个字段中的数据长度不发生改变的时候，是定长的，用char。例如:性别，生日等都是采用char。<br>  当一个字段的数据长度不确定的时候，就用varchar。例如:简介，姓名等都是采用varchar。</strong></p><blockquote><p> 建议:表名在数据库中一般以:t_或者tbl_开始。见名知意。</p></blockquote><p>例如，现在新建一个表student</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table t_student(</span><br><span class="line"></span><br><span class="line">no bigint,</span><br><span class="line"></span><br><span class="line">name varchar(255),</span><br><span class="line"></span><br><span class="line">sex char(1),</span><br><span class="line"></span><br><span class="line">classno varchar(255),</span><br><span class="line"></span><br><span class="line">birth char(10)</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210905094625.png"></p><h2 id="2-insert语句插入数据"><a href="#2-insert语句插入数据" class="headerlink" title="2.insert语句插入数据"></a>2.<strong>insert语句插入数据</strong></h2><p>语法格式</p><p>insert into 表名(字段名1，字段名2…..) values(值1，值2……)</p><p>要求:字段的数量和值的数量相同，并且数据类型要对应相同。</p><p>例如开始往上表中插入数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into t_student(no,name,sex,classno,birth) values(1,&#x27;zhangsan&#x27;,&#x27;1&#x27;,&#x27;gaosan1&#x27;,&#x27;1999-1-1&#x27;);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210905095030.png"></p><p><strong>注意:当一条insert语句执行成功之后，表格当中必然会多一行记录。即是多的这一行记录当中某些字段是NULL，后期也没有办法在执行insert语句插入数据了，只能用update进行更新</strong></p><h2 id="3-表的复制"><a href="#3-表的复制" class="headerlink" title="3.表的复制"></a>3.<strong>表的复制</strong></h2><blockquote><p>语法:</p><p>create table 表名 as select语句;</p><p>将查询结果当作表创建出来</p></blockquote><p>例如:</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210905095917.png"></p><h2 id="4-将查询结果插入到一张表中"><a href="#4-将查询结果插入到一张表中" class="headerlink" title="4.将查询结果插入到一张表中"></a>4.<strong>将查询结果插入到一张表中</strong></h2><p>例如将查询dept中的结果插入到dept1中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into dept1 select * from dept;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210905100234.png"></p><p><strong>注意:两张表的字段都得相同</strong></p><h2 id="5-修改数据-update"><a href="#5-修改数据-update" class="headerlink" title="5.修改数据:update"></a>5.<strong>修改数据:update</strong></h2><p>语法格式:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update 表名 set 字段名1=值1，字段名2=值2，.....where 条件；</span><br></pre></td></tr></table></figure><p>例如，将dept1中的部门10的LOC修改为shanghai，将部门名称修改为人事部</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update dept1 set loc=&#x27;shanghai&#x27;,dname=&#x27;renshibu&#x27; where deptno = 10;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210905100839.png"></p><blockquote><p><strong>注意:当没有说明条件的时候，那将会更新表中所有记录！！！</strong></p></blockquote><h2 id="6-删除数据"><a href="#6-删除数据" class="headerlink" title="6.删除数据"></a>6.<strong>删除数据</strong></h2><p>语法格式:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from 表名 where 条件；</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意:当没有说明条件的时候，那么表中数据都会被删除！！！</strong></p></blockquote><p>例如:删除10部门的数据</p><p>delete from dept1 where deptno = 10;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210905101236.png"></p><p>删除所有记录</p><p>delete from dept1;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210905101334.png"></p><p><strong>怎么删除大表？(重点)</strong></p><p>关键字:truncate  <strong>表明表被截断，不可回滚，永久丢失</strong></p><p><strong>注意:使用truncate删除表的时候一定要注意！！！因为删除之后就恢复不了了。</strong></p><h2 id="7-增删改查有一个术语-CRUD操作"><a href="#7-增删改查有一个术语-CRUD操作" class="headerlink" title="7.增删改查有一个术语: CRUD操作"></a>7.<strong>增删改查有一个术语: CRUD操作</strong></h2><p>C: Create(增)    R: Retrieve(检索)    U: Update(修改)    D: Delete(删除)</p><h2 id="8-约束-Constraint"><a href="#8-约束-Constraint" class="headerlink" title="8.约束(Constraint)"></a>8.约束(Constraint)</h2><h3 id="8-1-什么是约束？常见的约束有哪些？"><a href="#8-1-什么是约束？常见的约束有哪些？" class="headerlink" title="8.1 什么是约束？常见的约束有哪些？"></a>8.1 什么是约束？常见的约束有哪些？</h3><p><strong>在创建表的时候，可以给表的字段添加相应的约束，添加约束的目的是为了保证表中数据的合法性，有效性，完整性。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">常见的约束:</span><br><span class="line"></span><br><span class="line">非空约束(not null):约束的字段不能为NULL</span><br><span class="line"></span><br><span class="line">唯一约束(unique):约束的字段不能重复</span><br><span class="line"></span><br><span class="line">主键约束(primary key):约束的字段既不能为NULL，也不能重复</span><br><span class="line"></span><br><span class="line">外键约束(foreign key)</span><br><span class="line"></span><br><span class="line">检查约束(check):注意: Oracle数据库中由check约束，但是mysql没有，目前mysql不支持该约束。</span><br></pre></td></tr></table></figure><h3 id="8-2-非空约束-not-null"><a href="#8-2-非空约束-not-null" class="headerlink" title="8.2 非空约束 not null"></a>8.2 非空约束 not null</h3><p>例如:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table if exists t_user;</span><br><span class="line"></span><br><span class="line">create table t_user(</span><br><span class="line"></span><br><span class="line">id int,</span><br><span class="line"></span><br><span class="line">username varchar(255) not null,</span><br><span class="line"></span><br><span class="line">password varchar(255),</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这里的not null 就是一个非空约束。</p><h3 id="8-3-唯一性约束-unique"><a href="#8-3-唯一性约束-unique" class="headerlink" title="8.3 唯一性约束(unique)"></a>8.3 唯一性约束(unique)</h3><p><strong>唯一约束修饰的字段具有唯一性，不能重复，但是可以为NULL</strong></p><p>例如:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table if exists t_user;</span><br><span class="line"></span><br><span class="line">create table t_user(</span><br><span class="line"></span><br><span class="line">id int,</span><br><span class="line"></span><br><span class="line">usename varchar(255) unique,</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>注意:如果是在每列后面添加unique，那么就叫做列级约束</strong></p><p>​        <strong>如果是等所有字段声明完之后再添加unique，那么就叫做表级约束。</strong></p><p><strong>not null约束只有列级约束，没有表级约束。</strong></p><h3 id="8-4-主键约束"><a href="#8-4-主键约束" class="headerlink" title="8.4 主键约束"></a>8.4 主键约束</h3><p>例如:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table if exists t_user;</span><br><span class="line"></span><br><span class="line">create table t_user(</span><br><span class="line"></span><br><span class="line">id int primary key,   //列级约束</span><br><span class="line"></span><br><span class="line">username varchar(255),</span><br><span class="line"></span><br><span class="line">email varchar(255),</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>当给一个字段添加主键约束之后，那么主键字段中的数据不能为NULL，也不能重复</p><p><strong>主键的特点:不能为NULL，也不能重复</strong></p><h4 id="主键相关的术语"><a href="#主键相关的术语" class="headerlink" title="主键相关的术语"></a>主键相关的术语</h4><p>主键约束: primary key</p><p>主键字段: id字段添加primary key之后，id叫做主键字段</p><p>主键值: id字段中的每一个值都是主键值</p><h4 id="主键有什么作用"><a href="#主键有什么作用" class="headerlink" title="主键有什么作用"></a>主键有什么作用</h4><p>表的设计三范式中有要求，第一范式就要求任何一张表都应该有主键</p><p><strong>主键的作用:</strong></p><p><strong>主键值是这行记录在这张表当中的唯一标识。(就像一个人的身份证号码一样)</strong></p><h4 id="主键的分类"><a href="#主键的分类" class="headerlink" title="主键的分类"></a>主键的分类</h4><p>根据主键字段和字段数量来划分:</p><p>​    <strong>单一主键</strong>(推荐的，常用的)</p><p>​    <strong>复合主键</strong>(多个字段联合起来添加一个主键约束)(复合主键不建议使用，因为复合主键违背了三范式)</p><p>根据主键性质来划分:</p><p>​    <strong>自然主键</strong>主键值最好就是一个和业务没有任何关系的自然数。</p><p><strong>业务主键</strong>主键值和系统的业务挂钩(不推荐用)</p><h4 id="注意！！！"><a href="#注意！！！" class="headerlink" title="注意！！！"></a>注意！！！</h4><p><strong>一张表的主键约束只能有1个！！！(必须记住)</strong></p><h4 id="mysql提供了主键值自增"><a href="#mysql提供了主键值自增" class="headerlink" title="mysql提供了主键值自增"></a>mysql提供了主键值自增</h4><p>关键字: auto_increment</p><h3 id="8-5-外键约束"><a href="#8-5-外键约束" class="headerlink" title="8.5 外键约束"></a>8.5 外键约束</h3><p>外键约束的相关术语；</p><p>​    外键约束: foreign key</p><p>​    外键字段: 添加有外键约束的字段</p><p>​    外键值: 外键字段中的每一个值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法格式: foreign key()  references tablename()</span><br></pre></td></tr></table></figure><h2 id="存储引擎-了解即可"><a href="#存储引擎-了解即可" class="headerlink" title="存储引擎(了解即可)"></a>存储引擎(了解即可)</h2><p>1.mysql默认使用的存储引擎是InnoDB方式，默认采用的字符集是UTF8。</p><p>2.什么是存储引擎？</p><p>存储引擎这个名字只有在mysql中存在。(Oracle中有对应的机制，但是不叫做存储引擎。Oracle中没有特殊的名字，就是”表的存储方式”)</p><p>mysql支持很多存储引擎，每一个存储引擎都对应了一种不同的存储方式。每一个存储引擎都有自己的优缺点，需要在合适的时机选择合适的存储引擎。</p><p>3.常见的存储引擎</p><blockquote><p>MYISAM存储引擎，不支持事务，是mysql常用的引擎，但是不是默认的。</p><p>优点:可被压缩，节省存储空间。并且可以转换为只读表，提高检索效率。</p><p>缺点: 不支持事务</p></blockquote><blockquote><p>InnoDB存储引擎</p><p>优点: 支持事务，行级锁，外键等。这种存储引擎数据的安全得到保障。</p><p>表的存储结构再xxx.frm文件中。数据存储在tablespace这样的表空间中(逻辑概念)，无法被压缩，无法转换成只读。</p><p>这种存储引擎可以在MySQL数据库崩溃之后提供自动恢复机制。同时它支持级联删除和级联更新。</p></blockquote><blockquote><p>MEMORY存储引擎</p><p>缺点: 不支持事务。数据容易丢失，因为所有数据和索引都是存储在内存当中的。</p><p>优点: 查询速度最快</p></blockquote><h2 id="事务-Transaction"><a href="#事务-Transaction" class="headerlink" title="事务(Transaction)"></a>事务(Transaction)</h2><p>1.什么是事务？</p><p>一个事务是一个完整的业务逻辑单元，不可再分。</p><p>2.<strong>只有DML语句(insert,delete,update)才和事务相关。</strong></p><p>因为只有这三个语句都是和数据库表当中的”数据”相关的。</p><p>事务的存在是为了保证数据的完整性，安全性。</p><p>3.事务的特性</p><p>事务的四大特性: ACID</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A: 原子性(事务是最小的工作单元，不可再分。)</span><br><span class="line">C: 一致性(事务必须保证多条DML语句同时成功或者同时失败)</span><br><span class="line">I: 隔离性(事务A与事务B之间具有隔离)</span><br><span class="line">D: 持久性(持久性说的是最终数据必须持久化到硬盘文件中，事务才算成功的)</span><br></pre></td></tr></table></figure><p>4.关于事务之间的隔离性</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">事务隔离性存在隔离级别。理论上隔离级别包括4个</span><br><span class="line"></span><br><span class="line">第一级别: 读未提交(read uncommitted)</span><br><span class="line"></span><br><span class="line">对方事务还没有提交，我们当前事务可以读取到对方未提交的数据。</span><br><span class="line"></span><br><span class="line">读未提交存在脏读(Dirty Read)现象: 表示读到了脏的数据</span><br><span class="line"></span><br><span class="line">第二级别: 读已提交(read committed)</span><br><span class="line"></span><br><span class="line">对方事务提交之后的数据我方可以读取到</span><br><span class="line"></span><br><span class="line">读已提交存在的问题是: 不可重复读。</span><br><span class="line"></span><br><span class="line">这种隔离级别解决了脏读现象</span><br><span class="line"></span><br><span class="line">第三级别: 可重复读(repeatable read)</span><br><span class="line"></span><br><span class="line">这种隔离级别解决了不可重复读问题。</span><br><span class="line"></span><br><span class="line">这种隔离级别存在的问题是: 读取到的数据是幻想</span><br><span class="line"></span><br><span class="line">第四级别: 序列化读/串行化读</span><br><span class="line"></span><br><span class="line">解决了所有问题，但是效率低，需要事务排队。</span><br><span class="line"></span><br><span class="line">oracle数据库默认的隔离级别是: 读已提交</span><br><span class="line"></span><br><span class="line">mysql数据库默认的隔离级别是: 可重复读</span><br></pre></td></tr></table></figure><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="1-什么是索引？有什么用？"><a href="#1-什么是索引？有什么用？" class="headerlink" title="1.什么是索引？有什么用？"></a>1.什么是索引？有什么用？</h3><p>​        索引就相当于一本书的目录，通过目录可以快速的找到对应的资源。<br>​        在数据库方面，查询一张表的时候有两种检索方式：<br>​            第一种方式：全表扫描<br>​            第二种方式：根据索引检索（效率很高）</p><p>​    索引为什么可以提高检索效率呢？<br>​        其实最根本的原理是缩小了扫描的范围。<br>​<br>​    索引虽然可以提高检索效率，但是不能随意的添加索引，因为索引也是数据库当中<br>​    的对象，也需要数据库不断的维护。是有维护成本的。比如，表中的数据经常被修改<br>​    这样就不适合添加索引，因为数据一旦修改，索引需要重新排序，进行维护。</p><p>​    添加索引是给某一个字段，或者说某些字段添加索引。</p><p>​    select ename,sal from emp where ename = ‘SMITH’;<br>​    当ename字段上没有添加索引的时候，以上sql语句会进行全表扫描，扫描ename字段中所有的值。<br>​    当ename字段上添加索引的时候，以上sql语句会根据索引扫描，快速定位。</p><h3 id="2、怎么创建索引对象？怎么删除索引对象？"><a href="#2、怎么创建索引对象？怎么删除索引对象？" class="headerlink" title="2、怎么创建索引对象？怎么删除索引对象？"></a>2、怎么创建索引对象？怎么删除索引对象？</h3><p>​    创建索引对象：<br>​        create index 索引名称 on 表名(字段名);<br>​    删除索引对象：<br>​        drop index 索引名称 on 表名;</p><h3 id="3、什么时候考虑给字段添加索引？（满足什么条件）"><a href="#3、什么时候考虑给字段添加索引？（满足什么条件）" class="headerlink" title="3、什么时候考虑给字段添加索引？（满足什么条件）"></a>3、什么时候考虑给字段添加索引？（满足什么条件）</h3><pre><code>* 数据量庞大。（根据客户的需求，根据线上的环境）* 该字段很少的DML操作。（因为字段进行修改操作，索引也需要维护）* 该字段经常出现在where子句中。（经常根据哪个字段查询）</code></pre><h3 id="4-注意：主键和具有unique约束的字段自动会添加索引。"><a href="#4-注意：主键和具有unique约束的字段自动会添加索引。" class="headerlink" title="4.注意：主键和具有unique约束的字段自动会添加索引。"></a>4.注意：主键和具有unique约束的字段自动会添加索引。</h3><p>​    根据主键查询效率较高。尽量根据主键检索。</p><h3 id="5-索引底层采用的数据结构是：B-Tree"><a href="#5-索引底层采用的数据结构是：B-Tree" class="headerlink" title="5.索引底层采用的数据结构是：B + Tree"></a>5.<strong>索引底层采用的数据结构是：B + Tree</strong></h3><h3 id="6-索引的实现原理？"><a href="#6-索引的实现原理？" class="headerlink" title="6.索引的实现原理？"></a>6.索引的实现原理？</h3><p>​    通过B Tree缩小扫描范围，底层索引进行了排序，分区，索引会携带数据在表中的“物理地址”，<br>​    最终通过索引检索到数据之后，获取到关联的物理地址，通过物理地址定位表中的数据，效率<br>​    是最高的。<br>​        select ename from emp where ename = ‘SMITH’;<br>​        通过索引转换为：<br>​        select ename from emp where 物理地址 = 0x3;</p><h3 id="7-索引的分类？"><a href="#7-索引的分类？" class="headerlink" title="7.索引的分类？"></a>7.索引的分类？</h3><p>​    单一索引：给单个字段添加索引<br>​    复合索引: 给多个字段联合起来添加1个索引<br>​    主键索引：主键上会自动添加索引<br>​    唯一索引：有unique约束的字段上会自动添加索引<br>​    ….</p><h3 id="8-索引什么时候失效？"><a href="#8-索引什么时候失效？" class="headerlink" title="8.索引什么时候失效？"></a>8.索引什么时候失效？</h3><p>​    select ename from emp where ename like ‘%A%’;<br>​    模糊查询的时候，第一个通配符使用的是%，这个时候索引是失效的。</p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>1.什么是视图？<br>        站在不同的角度去看到数据。（同一张表的数据，通过不同的角度去看待）。</p><p>2.怎么创建视图？怎么删除视图？<br>    create view myview as select empno,ename from emp;<br>    drop view myview;</p><p>​    注意：只有DQL语句才能以视图对象的方式创建出来。</p><p>3.对视图进行增删改查，会影响到原表数据。（通过视图影响原表数据的，不是直接操作的原表）<br>可以对视图进行CRUD操作。</p><p>4.视图的作用？<br>        视图可以隐藏表的实现细节。保密级别较高的系统，数据库只对外提供相关的视图，java程序员<br>        只对视图对象进行CRUD。</p><h2 id="数据库设计三范式（重点内容，面试经常问）"><a href="#数据库设计三范式（重点内容，面试经常问）" class="headerlink" title="数据库设计三范式（重点内容，面试经常问）"></a>数据库设计三范式（重点内容，面试经常问）</h2><h3 id="1、什么是设计范式？"><a href="#1、什么是设计范式？" class="headerlink" title="1、什么是设计范式？"></a>1、什么是设计范式？</h3><p>​    设计表的依据。按照这个三范式设计的表不会出现数据冗余。</p><h3 id="2、三范式都是哪些？"><a href="#2、三范式都是哪些？" class="headerlink" title="2、三范式都是哪些？"></a>2、三范式都是哪些？</h3><p>​    第一范式：任何一张表都应该有主键，并且每一个字段原子性不可再分。</p><p>​    第二范式：建立在第一范式的基础之上，所有非主键字段完全依赖主键，不能产生部分依赖。<br>​     第三范式：建立在第二范式的基础之上，所有非主键字段直接依赖主键，不能产生传递依赖。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL学习心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习---day02</title>
      <link href="/2021/09/02/MySQL%E5%AD%A6%E4%B9%A0-day02/"/>
      <url>/2021/09/02/MySQL%E5%AD%A6%E4%B9%A0-day02/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="关于查询结果集的去重，使用关键字distinct"><a href="#关于查询结果集的去重，使用关键字distinct" class="headerlink" title="关于查询结果集的去重，使用关键字distinct"></a>关于查询结果集的去重，使用关键字distinct</h2><p>例如:eg1去除emp中的重复记录</p><p>select distinct deptno,job from emp;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904212212.png"></p><blockquote><p><strong>注意:distinct只能出现在所有字段的最前面！！！</strong> </p></blockquote><p> eg2统计岗位的数量</p><p>select count(distinct job) from emp;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904212348.png"></p><h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><p><strong>2.1</strong>在实际开发过程中,大部分的情况都不是从单表之中查询，都是许多表关联起来查询。</p><p><strong>2.2</strong>连接查询的分类</p><p>内连接，包括等值连接，非等值连接，自连接</p><p>外连接，包括左外连接(左连接)，右外连接(右连接)</p><p>全连接</p><p><strong>2.3</strong>在表的连接查询中有一种现象叫做笛卡尔积现象</p><p>例如:找出每一个员工的部门名称，要求显示员工名和部门名。</p><p>select ename,dname from emp,dept;    //这里能看到一共有56条记录</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904212448.png"></p><blockquote><p><strong>笛卡尔乘积现象:当两张表进行连接查询的时候，没有任何条件进行限制，最终的查询结果条数是两张表记录条数的乘积。</strong></p></blockquote><p>但一般都是用表的别名这种语句进行查询</p><p>select e.ename,d.dname from emp e,dept d;</p><p>表的别名有什么好处？</p><p>No1.执行效率高 No2.可读性好</p><blockquote><p><strong>2.4</strong> <strong>避免笛卡尔积现象可以采用加条件过滤，但是避免笛卡尔积现象不会减少匹配次数，加条件只不过是显示出了有效记录。</strong></p></blockquote><p><strong>2.5 内连接中的等值连接</strong></p><p>最大的特点是:条件是等量关系 </p><p>常用语法 select e.ename,d.dname from emp e inner join dept d on e.deptno = d.deptno;//SQL99语法，这里的inner可以省略。效果如下所示</p><p>SQL99语法比较清晰，表的连接条件和之后的where条件分离了</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904212632.png"></p><p> <strong>2.6内连接中的非等值连接</strong></p><p>最大的特点是:连接条件中的关系是非等量关系</p><p>例如:找出每个员工的工资等级，要求显示员工名，工资，工资等级</p><p>select e.ename,e.sal,s.grade from emp e join salgrade s on e.sal between s.losal and s.hisal;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904212811.png"></p><p> <strong>2.7内连接中的自连接</strong></p><p>最大特点是:一张表可以看作两张表，自己连自己。</p><p>例如:找出每个员工的上级领导，要求显示员工名和对应的领导名。</p><p>select a.ename as ‘员工名’,b.ename as ‘领导名’ from emp a join emp b on a.mgr = b.empno;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904212837.png"></p><p> <strong>2.8外连接</strong></p><p>外连接和内连接的区别</p><p>​    内连接:假设A和B进行连接，使用内连接的话，凡是A表和B表能够匹配上的记录都查询出来，这就是内连接。AB两张表没有主副之分，两张表是平等的。</p><p>​    外连接:<br>​     假设A和B表进行连接，使用外连接的话，AB两张表中有一张表是主表，一张表是副表，主要查询主表中的数据，捎带着查询副表，当副表中的数据没有和主表中的数据匹配上，副表自动模拟出NULL与之匹配。</p><p>外连接的分类？<br>     左外连接（左连接）：表示左边的这张表是主表。<br>     右外连接（右连接）：表示右边的这张表是主表。</p><p>​     左连接有右连接的写法，右连接也会有对应的左连接的写法。</p><p>例如:找出每个员工的上级领导</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904212928.png"></p><p>select a.ename as ‘员工名’,b.ename as ‘领导名’ from emp a left join emp b on a.mgr = b.empno;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904212959.png"></p><p> 这里之所以比上面的查询数据多了一个KING，是因为KING也算是员工，但是他是大BOSS，没有上级领导。</p><blockquote><p><strong>外连接最重要的特点是:主表的数据无条件的全部都查出来</strong></p></blockquote><p>例如:找出哪个部门没有员工</p><p>select d.* from dept d left join emp e on d.deptno = e.deptno where e.empno is null;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904213100.png"></p><p> <strong>2.9三张表的连接查询</strong></p><p>例如:找出每一个员工的部门名称以及工资等级</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EMP e</span><br><span class="line">+-------+--------+---------+--------+</span><br><span class="line">| empno | ename  | sal     | deptno |</span><br><span class="line">+-------+--------+---------+--------+</span><br><span class="line">|  7369 | SMITH  |  800.00 |     20 |</span><br><span class="line">|  7499 | ALLEN  | 1600.00 |     30 |</span><br><span class="line">|  7521 | WARD   | 1250.00 |     30 |</span><br><span class="line">|  7566 | JONES  | 2975.00 |     20 |</span><br><span class="line">|  7654 | MARTIN | 1250.00 |     30 |</span><br><span class="line">|  7698 | BLAKE  | 2850.00 |     30 |</span><br><span class="line">|  7782 | CLARK  | 2450.00 |     10 |</span><br><span class="line">|  7788 | SCOTT  | 3000.00 |     20 |</span><br><span class="line">|  7839 | KING   | 5000.00 |     10 |</span><br><span class="line">|  7844 | TURNER | 1500.00 |     30 |</span><br><span class="line">|  7876 | ADAMS  | 1100.00 |     20 |</span><br><span class="line">|  7900 | JAMES  |  950.00 |     30 |</span><br><span class="line">|  7902 | FORD   | 3000.00 |     20 |</span><br><span class="line">|  7934 | MILLER | 1300.00 |     10 |</span><br><span class="line">+-------+--------+---------+--------+</span><br><span class="line">DEPT d</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">| DEPTNO | DNAME      | LOC      |</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">|     10 | ACCOUNTING | NEW YORK |</span><br><span class="line">|     20 | RESEARCH   | DALLAS   |</span><br><span class="line">|     30 | SALES      | CHICAGO  |</span><br><span class="line">|     40 | OPERATIONS | BOSTON   |</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">SALGRADE s</span><br><span class="line">+-------+-------+-------+</span><br><span class="line">| GRADE | LOSAL | HISAL |</span><br><span class="line">+-------+-------+-------+</span><br><span class="line">|     1 |   700 |  1200 |</span><br><span class="line">|     2 |  1201 |  1400 |</span><br><span class="line">|     3 |  1401 |  2000 |</span><br><span class="line">|     4 |  2001 |  3000 |</span><br><span class="line">|     5 |  3001 |  9999 |</span><br><span class="line">+-------+-------+-------+</span><br></pre></td></tr></table></figure><p> select e.ename,d.dname,s.grade from emp e left join dept d on e.deptno = d.deptno left join salgrade s on e.sal between s.losal and s.hisal;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904213435.png"></p><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p><strong>3.1什么是子查询？子查询都可以出现在哪里？</strong></p><p>select语句当中嵌套select语句，被嵌套的select语句是子查询。<br>   子查询可以出现在哪里？<br>     select<br>       ..(select).<br>     from<br>       ..(select).<br>     where<br>       ..(select).</p><p><strong>3.2where子句中使用子查询</strong></p><p>例如:找出高于平均薪资的员工信息</p><p>select * from emp where sal &gt; (select avg(sal) from emp);</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904213511.png"></p><p> <strong>3.3from后面嵌套子查询</strong></p><p>例如:找出每个部门平均薪水的薪资等级。</p><p>第一步:找出每个部门平均薪水(按照部门编号分组，求sal的平均值)</p><p>select deptno,avg(sal) as avgsal from emp group by deptno;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904213540.png"></p><p> 第二步:将以上的查询结果当作临时表t，让t表和salgrade s表连接，条件是:t.avgsal between s.losal and s.hisal;</p><p>select t.*,s.grade from (select deptno,avg(sal) as avgsal from emp group by deptno) t left join salgrade s on t.avgsal between s.losal and s.hisal;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904213613.png"></p><p> <strong>3.4在select后面嵌套子查询</strong></p><h2 id="union-可以将查询结果相加"><a href="#union-可以将查询结果相加" class="headerlink" title="union(可以将查询结果相加)"></a>union(可以将查询结果相加)</h2><p>例如:找出工作岗位是salesman和manager的员工</p><p>按照之前讲的也能写出来</p><p>第一种:select ename,job from emp where job = ‘salesman’ or job = ‘manager’;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904213711.png"></p><p>第二种:用in。select ename,job from emp where job in (‘manager’,’salesman’); </p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904213746.png"></p><p>第三种:用union。select ename,job from emp where job = ‘manager’ </p><p>​              union</p><p>​              select ename,job from emp where job = ‘salesman’;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904213902.png"></p><blockquote><p><strong>采用union就是将表与表之间的查询结果做拼接。 注意:用union查询时，必须保证前面的查询结果的列的数量和后一个查询结果的列的数量保持一致。</strong></p></blockquote><h2 id="limit-重点中的重点！！！以后分页查询就靠它"><a href="#limit-重点中的重点！！！以后分页查询就靠它" class="headerlink" title="limit(重点中的重点！！！以后分页查询就靠它)"></a>limit(重点中的重点！！！以后分页查询就靠它)</h2><p>5.1 limit是MySQL中所特有的，其他的数据库都没有，不通用。</p><p>5.2 limit取结果集中的部分数据，这是它的作用</p><p>5.3 语法机制</p><blockquote><p><strong>limit startIndex,length   startIndex表示起始位置，length表示取几个</strong></p></blockquote><p> 例如:取出工资前五名的员工</p><p>select ename,sal from emp order by sal limit 5;//我这里是按照升序排</p><p>也可以这样写:select ename,sal from emp order by sal limit 0,5;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904214034.png"></p><p><strong>5.4 limit是sql语句最后执行的一个环节！！！</strong> </p><p><strong>执行顺序如下:</strong></p><pre><code>select            5    ...from            1    ...        where            2    ...    group by        3    ...having            4    ...order by        6    ...limit            7    ...;</code></pre><p>例如:找出工资排名在第4到第9名的员工</p><p>select ename,sal from emp order by sal limit 3,6;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904214112.png"></p><p>5.6 通用的标准分页sql</p><p>例如:每页显示3条信息</p><p>第一页:0，3；</p><p>第二页:3, 3;</p><p>第三页:6，3；</p><p>此时就能发现规律</p><blockquote><p><strong>每页显示n条消息,那么规律如下</strong></p><p><strong>第pageNo页:(pageNo - 1) * n，n   //这里的pageNo就是显示第几页，n表示每页显示多少条记录</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MySQL学习心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习---day01</title>
      <link href="/2021/09/02/MySQL%E5%AD%A6%E4%B9%A0-day01/"/>
      <url>/2021/09/02/MySQL%E5%AD%A6%E4%B9%A0-day01/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>所有MySQL使用的sql文本内容都出自B站老杜，有需要的小伙伴可以加我QQ<strong>1845356586</strong>。</p><h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><p>SQL语句分为</p><p>​            DQL（数据查询语言）: 查询语句，凡是select语句都是DQL。<br>​            DML（数据操作语言）：insert delete update，对表当中的数据进行增删改。<br>​            DDL（数据定义语言）：create drop alter，对表结构的增删改。<br>​            TCL（事务控制语言）：commit提交事务，rollback回滚事务。(TCL中的T是Transaction)<br>​            DCL（数据控制语言）: grant授权、revoke撤销权限等。</p><h2 id="基本的MySQL指令"><a href="#基本的MySQL指令" class="headerlink" title="基本的MySQL指令"></a>基本的MySQL指令</h2><p>1.在dos窗口下登录MySQL:<strong>mysql -u root -p</strong>(这里是你的登陆密码)</p><p>2.查看数据库指令:<strong>show databases;</strong>(这个不是SQL语句，属于MySQL的命令。)</p><p>3.创建数据库指令:<strong>create database xxxx;</strong>(这个不是SQL语句，属于MySQL的命令。)</p><p>4.使用数据库指令:<strong>use xxxx;</strong>(这个不是SQL语句，属于MySQL的命令。)</p><p>5.查看当前的数据库有哪些表:<strong>show tables;</strong>(这个不是SQL语句，属于MySQL的命令。)</p><p>6.删除数据库指令:<strong>drop database xxxx;</strong></p><p>7.查看表中数据:<strong>select * from xxxx;</strong></p><blockquote><p><strong>由于我电脑本身已经有了相关数据，所以接下来的操作我会直接用数据进行操作。</strong></p></blockquote><p>8.查看当前使用的是哪个数据库:<strong>select database();</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/1.png"></p><p>9.查看当前数据库版本号:<strong>select version();</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/2.png"></p><p>10.查看创建表的语句:<strong>show create table emp;</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/3.png"></p><p> 11.给查询的列重命名:<strong>select ename,sal * 12 as ‘年薪’ from emp;</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904204409.png"></p><blockquote><p><strong>注意:标准sql语句中要求字符串使用单引号括起来，虽然mysql支持双引号，但是尽量别使用。</strong> </p></blockquote><p> 12.条件查询语法格式:<strong>select 字段，字段…. from 表名 where 条件;</strong></p><p>执行顺序**:先from，然后where，最后select**</p><p> 例如:eg1查询工资等于5000的员工姓名</p><p>select ename,sal from emp where sal = 5000;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904204729.png"></p><p> eg2查询工资不等于3000的员工姓名</p><p>select ename,sal from emp where sal &lt;&gt; 3000;或select ename,sal from emp where sal != 3000;</p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904204845.png"><p>eg3找出工资在1100和3000之间的员工</p><p>select ename,sal from emp where sal between 1100 and 3000;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904204938.png"></p><p><strong>注意:between …. and ….是闭区间，</strong>即上述例子是查 [1100,3000],包含1100和3000</p><p> 13.NULL，在数据库中NULL不是一个值，代表什么也没有，为空。空不是一个值，不能用等号衡量。必须使用is null 或 is not null。</p><p>例如:eg1找出哪些人的津贴不为NULL</p><p>select ename,sal,comm from emp where comm is not null;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904205125.png"></p><p> eg2找出哪些人没有津贴</p><p>select ename,sal,comm from emp where comm is null or comm = 0;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904205245.png"></p><p>eg3找出工作岗位是manager和salesman的员工</p><p> select ename,sal,job from emp where job = ‘manager’ or job = ‘salesman’;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904205321.png"></p><p>and和or联合起来用：找出薪资大于1000的并且部门编号是20或30部门的员工。</p><p>select ename,sal,deptno from emp where sal &gt; 1000 and (deptno = 20 or deptno = 30);</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904205359.png"></p><p>14.<strong>模糊查找like,(在模糊查询当中，必须掌握两个特殊的符号，一个是%，一个是）%代表任意多个字符，代表任意1个字符。</strong></p><p> eg1找出名字里面有o的</p><p>select ename from emp where ename like ‘%o%’;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904205636.png"></p><p>eg2找出第二个字母是A的</p><p>select ename from emp where ename like ‘_A%’;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904205731.png"></p><p>15.排序，升序</p><p>格式: <strong>select 字段名，字段名….  from 表名 order by 条件;</strong> </p><p> 例如:eg1 按照工资升序，找出员工名和薪资</p><p>select ename,sal from emp order by sal;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904210905.png"></p><blockquote><p><strong>注意:默认是升序，那怎么指定升序和降序勒？ asc升序，desc降序</strong> </p></blockquote><p> eg2 还是拿上面的例子</p><p>select ename,sal from emp order by sal;//升序</p><p>select ename,sal from emp order by sal asc;//升序</p><p>select ename,sal from emp order by sal desc;//降序</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904210957.png"></p><p> eg3按照工资的降序排，如果工资一样，那就按照名字的升序排。</p><p>select ename,sal from emp order by sal desc,ename asc;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904211114.png"></p><blockquote><p><strong>注意：多字段排序时，越靠前的字段越能起到主导作用。只有当前面的字段无法完成排序的时候，才会启用后面的字段。</strong> </p></blockquote><p> <strong>where和order by同时使用，格式</strong></p><p><strong>select 字段名，字段名…. from 表名 where 条件 order by ….</strong></p><p><strong>先执行 from 接着where 接着select 最后 order by排序。</strong></p><p>eg1查询工作是salesman的并且按照工资的升序排</p><p>select ename,sal,job from emp where job = ‘salesman’ order by sal;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904211234.png"></p><p>16.分组函数</p><p>count计数，sum求和会自动忽略NULL，max最大值，min最小值，avg平均值</p><p><strong>注:count(*)和count(具体的某个字段)，他们有什么区别？<br>     count(*):不是统计某个字段中数据的个数，而是统计总记录条数。（和某个字段无关）<br>     count(comm): 表示统计comm字段中不为NULL的数据总数量。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904211339.png"></p><p>注意:所有的分组函数都是对’某一组’数据进行操作的。</p><p>分组函数一共有5个，同时分组函数还有另外一个名字:多行处理函数。其特点是:输入多行，最终输出的结果是1行。并且分组函数会自动忽略NULL。</p><p>17.单行处理函数:输入一行，输出一行。</p><blockquote><p><strong>重点：所有数据库都是这样规定的，只要有NULL参与的运算结果一定是NULL。</strong> </p></blockquote><p>eg1计算所有工人的年薪</p><p>select ename,(sal+comm) * 12 as ‘年薪’ from emp;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904211524.png"></p><p>要想不出现NULL，就得使用ifnull() 空处理函数<br>ifnull(可能为NULL的数据,被当做什么处理) ： 属于单行处理函数。</p><p>eg2:如果津贴是NULL，那就当作0来处理</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904211618.png"></p><p>18.group by 和 having</p><p>group by:按照某个字段或者某些字段进行分组</p><p>having:having是对分组之后的数据进行再次过滤</p><p>eg1找出每个工作岗位的最高薪资</p><p>select max(sal) from emp group by job;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904211706.png"></p><blockquote><p> <strong>注意:分组函数一般和group by联合使用，这也是为什么它被称为分组函数的原因。</strong></p><p><strong>并且任何一个分组函数(sum,avg,max,min,count)都是在group by语句执行结束后才会执行。当一条sql语句没有group by的话，整张表的数据会自成一组。</strong></p><p><strong>另外:分组函数之所以不能用在where子句中，是因为group by是在where之后执行的</strong></p></blockquote><p> <strong>结论:当一条语句中有group by的话，select后面只能跟分组函数和参与分组的字段。</strong></p><p>eg2找出每个工作岗位的平均薪资</p><p>select avg(sal),job from emp group by job;</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904211737.png"></p><p>eg3找出每个部门的最高薪资，要求显示薪资大于2900的数据</p><p>select deptno,max(sal) from emp group by deptno having max(sal) &gt; 2900;//这种方式效率低</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904211911.png"></p><p> 可以直接使用where过滤</p><p>select deptno,max(sal) from emp where sal &gt; 2900 group by deptno;//效率较高，建议能使用where过滤尽量使用</p><p>19.总结一个完整的DQL语句怎么写</p><p>执行顺序如下:<br>         select         5<br>           ..<br>         from          1<br>           ..<br>         where        2<br>           ..<br>         group by     3<br>           ..<br>         having       4<br>           ..<br>         order by     6<br>           ..</p>]]></content>
      
      
      <categories>
          
          <category> MySQL学习心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2020/10/02/%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/10/02/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="链表——1"><a href="#链表——1" class="headerlink" title="链表——1"></a>链表——1</h1><p>与数组一样，链表也支持数据的查找、插入和删除操作。我们知道，在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是 O(n)。而在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为<strong>链表的存储空间本身就不是连续的</strong>。所以，在链表中插入和删除一个数据是非常快速的。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904182947.png"></p><p>从图中我们可以看出，针对链表的插入和删除操作，我们只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 O(1)。</p><p>但是有利就有弊，<strong>数组的特点是:查询快，增删慢;<strong>与之相对应的</strong>链表则是:查询慢，增删快</strong>。这是<strong>因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。</strong></p><p><strong>2.循环链表</strong></p><p><strong>循环链表是一种特殊的单链表。</strong>它跟单链表唯一的区别就在尾结点。我们知道，单链表的尾结点指针指向空地址，表示这就是最后的结点了。而<strong>循环链表的尾结点指针是指向链表的头结点</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904183045.png"></p><p>和单链表相比，<strong>循环链表的优点是从链尾到链头比较方便</strong>。<strong>当要处理的数据具有环型结构特点时，就特别适合采用循环链表。</strong>比如著名的<strong>约瑟夫问题</strong>。尽管用单链表也可以实现，但是用循环链表实现的话，代码就会简洁很多。</p><p><strong>3.双向链表(在实际软件开发中较为常用，主要用”空间换时间”的设计思想)</strong></p><p><strong>“空间换时间”思想:当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构。相反，如果内存比较紧缺，比如代码跑在手机或者单片机上，这个时候，就要反过来用时间换空间的设计思路。</strong></p><p>单向链表只有一个方向，结点只有一个后继指针 next 指向后面的结点。而双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904183126.png"></p><h2 id="单向链表和双向链表的区别"><a href="#单向链表和双向链表的区别" class="headerlink" title="单向链表和双向链表的区别?"></a><strong>单向链表和双向链表的区别?</strong></h2><p><strong>单向链表的结点只有两个域，一个是数据域，另外一个是存储后继结点地址的指针域。 而双向链表的结点有三个域，一个是数据域，一个是存储后继结点地址的指针域（后继指针next），还有一个是存储前驱结点地址的指针域（前驱指针prev）</strong></p><p><strong>从结构上来看，双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。</strong></p><p>当把双向链表和循环链表结合在一起，就会形成双向循环链表。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904183337.png"></p><p><strong>链表 VS 数组性能大比拼</strong></p><p>正是因为内存存储的区别，它们插入、删除、随机访问操作的时间复杂度正好相反。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904183423.png"></p><p> 不过，数组和链表的对比，并不能局限于时间复杂度。而且，在实际的软件开发中，不能仅仅利用复杂度分析就决定使用哪个数据结构来存储数据。</p><p>数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。</p><h2 id="CPU缓存机制"><a href="#CPU缓存机制" class="headerlink" title="CPU缓存机制:"></a><strong>CPU缓存机制</strong>:</h2><p><strong>CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中。而CPU每次从内存读取数据并不是只读取那个特定要访问的地址，而是读取一个数据块(一般64位cpu每次会读取64字节数据到缓存)并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取。这样就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义:为了弥补内存访问速度过慢与CPU执行速度快之间的差异而引入。 对于数组来说，存储空间是连续的，所以在加载某个下标的时候可以把以后的几个下标元素也加载到CPU缓存这样执行速度会快于存储空间不连续的链表存储。</strong></p><p><strong>数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。</strong></p><p>你可能会说，我们 Java 中的 ArrayList 容器，也可以支持动态扩容啊？但是当我们往支持动态扩容的数组中插入一个数据时，如果数组中没有空闲空间了，就会申请一个更大的空间，将数据拷贝过去，而数据拷贝的操作是非常耗时的。</p><p>我举一个稍微极端的例子。如果我们用 ArrayList 存储了了 1GB 大小的数据，这个时候已经没有空闲空间了，当我们再插入数据的时候，ArrayList 会申请一个 1.5GB 大小的存储空间，并且把原来那 1GB 的数据拷贝到新申请的空间上。听起来是不是就很耗时？</p><p>除此之外，如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）。</p><p>所以，在我们实际的开发中，针对不同类型的项目，要根据具体情况，权衡究竟是选择数组还是链表。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2020/10/02/%E6%95%B0%E7%BB%84/"/>
      <url>/2020/10/02/%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p><strong>1.什么是数组？</strong></p><p>数组(Array)是一种<strong>线性表数据结构</strong>。它是一组<strong>连续的</strong>内存空间，来存储<strong>具有相同类型</strong>的数据。</p><p>首先，剖析关键字。No.1 <strong>线性表</strong>。顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904181835.png"></p><p>与之相对立的概念就是非线性表，比如二叉树、堆、图等。之所以叫做非线性，是因为在非线性表中，数据之间并不是简单的前后关系。如下图</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904182053.png"></p><p>剖析第二个关键字，No.2 <strong>连续的内存空间和相同类型的数据。</strong> 正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“随机访问”。但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。</p><p>这里我要特别纠正一个“错误”。在面试的时候，常常HR会问数组和链表的区别，很多人都回答说，“链表适合插入、删除，时间复杂度 O(1)；数组适合查找，查找时间复杂度为 O(1)”。<strong>实际上，这种表述是不准确的。数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)。所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。</strong></p><p>低效的“插入”和“删除”前面概念部分我们提到，数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效。现在我们就来详细说一下，究竟为什么会导致低效？又有哪些改进方法呢？我们先来看插入操作。假设数组的长度为 n，现在，如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k～n 这部分的元素都顺序地往后挪一位。那插入操作的时间复杂度是多少呢？你可以自己先试着分析一下。如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 O(n)。 因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 (1+2+…n)/n=O(n)。如果数组中的数据是有序的，我们在某个位置插入一个新的元素时，就必须按照刚才的方法搬移 k 之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数据插入到第 k 个位置，为了避免大规模的数据搬移，我们还有一个简单的办法就是，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。为了更好地理解，我们举一个例子。假设数组 a[10]中存储了如下 5 个元素：a，b，c，d，e。我们现在需要将元素 x 插入到第 3 个位置。我们只需要将 c 放入到 a[5]，将 a[2]赋值为 x 即可。最后，数组中的元素如下： a，b，x，d，e，c。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904182238.png"></p><p>利用这种处理技巧，在特定场景下，在第 k 个位置插入一个元素的时间复杂度就会降为 O(1)。这个处理思想在快排中也会用到，我会在排序那一节具体来讲，这里就说到这儿。我们再来看删除操作。跟插入数据类似，如果我们要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)。实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率是不是会提高很多呢？我们继续来看例子。数组 a[10]中存储了 8 个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除 a，b，c 三个元素。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904182327.png"></p><p>为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。如果你了解 JVM，你会发现，这不就是 JVM 标记清除垃圾回收算法的核心思想吗？没错，数据结构和算法的魅力就在于此，很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的。如果你细心留意，不管是在软件开发还是架构设计中，总能找到某些算法和数据结构的影子。</p><p><strong>JVM标记清楚算法思想:1.复制算法. 2.标记清除算法. 3.标记整理算法. 简单思想: 数组中删除数据时,并不真正的删除,而是标记一下,先不进行数据的搬移工作,等数组空间不够用时,我们再执行删除操作.进行数据的搬移工作. –&gt; 这样可以减少因为删除操作导致的数据搬移. 这种思想在JVM垃圾回收算法的 标记清除算法中 也有体现. 第一遍扫描先标记垃圾对象,第二遍扫描再清除垃圾对象. –&gt; 这种垃圾回收算法 容易产生内存碎片,导致出现虽然内存空间充足,但是无法放置大对象的诡异现象.</strong></p><p><strong>容器能否完全替代数组？</strong></p><p>针对数组类型，很多语言都提供了容器类，比如 Java 中的 ArrayList、C++ STL 中的 vector。在项目开发中，什么时候适合用数组，什么时候适合用容器呢？这里我拿 Java 语言来举例。如果你是 Java 工程师，几乎天天都在用 ArrayList，对它应该非常熟悉。那它与数组相比，到底有哪些优势呢？我个人觉得，ArrayList 最大的优势就是<strong>可以将很多数组操作的细节封装起来</strong>。比如前面提到的数组插入、删除数据时需要搬移其他数据等。另外，它还有一个优势，就是<strong>支持动态扩容</strong>。数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间。如果我们申请了大小为 10 的数组，当第 11 个数据需要存储到数组中时，我们就需要重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。如果使用 ArrayList，我们就完全不需要关心底层的扩容逻辑，ArrayList 已经帮我们实现好了。每次存储空间不够的时候，它都会将空间自动扩容为 1.5 倍大小。不过，这里需要注意一点，因为扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好<strong>在创建 ArrayList 的时候事先指定数据大小</strong>。</p><p>作为高级语言编程者，是不是数组就无用武之地了呢？当然不是，有些时候，用数组会更合适些，我总结了几点自己的经验。</p><p>1.Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。</p><p>\2. 如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。</p><p>\3. 还有一个是我个人的喜好，当要表示多维数组时，用数组往往会更加直观。比如 Object[][] array；而用容器的话则需要这样定义：ArrayList &gt; array。</p><p>我总结一下，对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。</p><p><strong>总结:数组用一块连续的内存空间，来存储相同类型的一组数据，最大的特点就是支持随机访问，但插入、删除操作也因此变得比较低效，平均情况时间复杂度为 O(n)。在平时的业务开发中，我们可以直接使用编程语言提供的容器类，但是，如果是特别底层的开发，直接使用数组可能会更合适。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC操作数据库</title>
      <link href="/2020/09/11/JDBC%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2020/09/11/JDBC%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="JDBC操作数据库"><a href="#JDBC操作数据库" class="headerlink" title="JDBC操作数据库"></a>JDBC操作数据库</h1><h2 id="在idea中导包"><a href="#在idea中导包" class="headerlink" title="在idea中导包"></a>在idea中导包</h2><p>操作之前必须先把相关的mysql包导入。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210911154746193.png" alt="image-20210911154746193"></p><h2 id="JDBC操作"><a href="#JDBC操作" class="headerlink" title="JDBC操作"></a>JDBC操作</h2><h3 id="该操作执行器是createStatement-该执行器会有一个SQL注入问题，下面会细说"><a href="#该操作执行器是createStatement-该执行器会有一个SQL注入问题，下面会细说" class="headerlink" title="该操作执行器是createStatement(该执行器会有一个SQL注入问题，下面会细说)"></a>该操作执行器是createStatement(<strong>该执行器会有一个SQL注入问题，下面会细说</strong>)</h3><h4 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mysqlTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.加载驱动</span></span><br><span class="line">        Class.format(com.mysql.jdbc.Driver)</span><br><span class="line">        <span class="comment">//2.建立连接</span></span><br><span class="line">        Connection con = DriverManager.getConnection(</span><br><span class="line">            <span class="string">&quot;jdbc:mysql://master:3306/test&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;123456&quot;</span>)<span class="comment">//指定端口和需要操作的库</span></span><br><span class="line">    <span class="comment">//3.创建执行器来执行sql语句</span></span><br><span class="line">    <span class="comment">//3.1执行器createStatement</span></span><br><span class="line">    String sql = <span class="string">&quot;select * from dept&quot;</span>;</span><br><span class="line">    Statement statement = con.createStatement();</span><br><span class="line">    ResultSet resuletset = statement.executeQuery(sql);</span><br><span class="line">        <span class="keyword">while</span> (resultSet.next())&#123;</span><br><span class="line">            <span class="comment">//这里给的是String类型，表示的是字段名称</span></span><br><span class="line">            System.out.println(resultSet.getInt(<span class="string">&quot;deptno&quot;</span>));</span><br><span class="line">            System.out.println(resultSet.getString(<span class="string">&quot;dname&quot;</span>));</span><br><span class="line">            System.out.println(resultSet.getString(<span class="string">&quot;loc&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.获取结果</span></span><br><span class="line">        System.out.println(resultSet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.关闭</span></span><br><span class="line">        resultSet.close();</span><br><span class="line">        statement.close();</span><br><span class="line">        conn.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加操作"><a href="#添加操作" class="headerlink" title="添加操作"></a>添加操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mysqlInsert</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//直接插入信息</span></span><br><span class="line"><span class="comment">//        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span></span><br><span class="line"><span class="comment">//        Connection conn = DriverManager.getConnection(</span></span><br><span class="line"><span class="comment">//                &quot;jdbc:mysql://master:3306/test1&quot;,</span></span><br><span class="line"><span class="comment">//                &quot;root&quot;,</span></span><br><span class="line"><span class="comment">//                &quot;123456&quot;</span></span><br><span class="line"><span class="comment">//        );</span></span><br><span class="line"><span class="comment">//        Statement statement = conn.createStatement();</span></span><br><span class="line"><span class="comment">//        String sql = &quot;insert into dept values(50,&#x27;doctor&#x27;,&#x27;HuaiBei&#x27;)&quot;;</span></span><br><span class="line"><span class="comment">//        int i = statement.executeUpdate(sql);</span></span><br><span class="line"><span class="comment">//        if(i!=0)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;添加成功&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;else &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;添加失败&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        statement.close();</span></span><br><span class="line"><span class="comment">//        conn.close();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//键盘录入信息</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入部门编号&quot;</span>);</span><br><span class="line">        Integer deptno = sc.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入部门职责&quot;</span>);</span><br><span class="line">        String dname = sc.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入工作地点&quot;</span>);</span><br><span class="line">        String loc = sc.next();</span><br><span class="line"></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        Connection conn = DriverManager.getConnection(</span><br><span class="line">                <span class="string">&quot;jdbc:mysql://master:3306/test1&quot;</span>,</span><br><span class="line">                <span class="string">&quot;root&quot;</span>,</span><br><span class="line">                <span class="string">&quot;123456&quot;</span></span><br><span class="line">        );</span><br><span class="line">        Statement statement = conn.createStatement();</span><br><span class="line">        String sql = <span class="string">&quot;insert into dept values(&quot;</span></span><br><span class="line">                    +deptno+<span class="string">&quot;,&quot;</span>+</span><br><span class="line">                    <span class="string">&quot;\&quot;&quot;</span>+dname+<span class="string">&quot;\&quot;&quot;</span> + <span class="string">&quot;,&quot;</span>+</span><br><span class="line">                    <span class="string">&quot;\&quot;&quot;</span>+loc+<span class="string">&quot;\&quot;)&quot;</span>;</span><br><span class="line">        System.out.println(sql);</span><br><span class="line">        <span class="keyword">int</span> i = statement.executeUpdate(sql);</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;录入成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;录入失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        statement.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mysqlDelete</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        Connection conn = DriverManager.getConnection(</span><br><span class="line">                <span class="string">&quot;jdbc:mysql://master:3306/test1&quot;</span>,</span><br><span class="line">                <span class="string">&quot;root&quot;</span>,</span><br><span class="line">                <span class="string">&quot;123456&quot;</span></span><br><span class="line">        );</span><br><span class="line">        Statement statement = conn.createStatement();</span><br><span class="line">        String sql = <span class="string">&quot;delete from dept where deptno=10&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> i = statement.executeUpdate(sql);</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        statement.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mysqlUpdate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        Connection conn = DriverManager.getConnection(</span><br><span class="line">                <span class="string">&quot;jdbc:mysql://master:3306/test1&quot;</span>,</span><br><span class="line">                <span class="string">&quot;root&quot;</span>,</span><br><span class="line">                <span class="string">&quot;123456&quot;</span></span><br><span class="line">        );</span><br><span class="line">        Statement statement = conn.createStatement();</span><br><span class="line">        String sql = <span class="string">&quot;update dept set loc=&#x27;shanghai&#x27; where deptno=60&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> i = statement.executeUpdate(sql);</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;更新成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;更新失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        statement.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="执行器preparedStatement-能有效解决SQL注入问题"><a href="#执行器preparedStatement-能有效解决SQL注入问题" class="headerlink" title="执行器preparedStatement(能有效解决SQL注入问题)"></a>执行器preparedStatement(能有效解决SQL注入问题)</h3><h4 id="什么是SQL注入？"><a href="#什么是SQL注入？" class="headerlink" title="什么是SQL注入？"></a>什么是SQL注入？</h4><p>简单来说就是利用createStatement的一个漏洞，通过拼接字符串的形式来登录SQL</p><p>下面用代码来演示下SQL注入</p><p>(以下代码都是通过加载配置文件来操作的)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *   在JDBC中 以后使用PreparedStatement</span></span><br><span class="line"><span class="comment"> *   因为使用Statement时会存在SQL注入问题</span></span><br><span class="line"><span class="comment"> *   以下是SQL注入演示</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IOException, SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">//让用户输入管理员和密码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入管理员的名字:&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String admin_user = scanner.nextLine();<span class="comment">//如果需要看到SQL注入演示效果，就需要用nextLine()方法，因为next()方法会自动屏蔽掉空格</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入管理员的密码&quot;</span>);</span><br><span class="line">        String admin_pwd = scanner.nextLine();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//加载配置文件</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">        String user = properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        String password = properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        String url = properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        String driver = properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册驱动</span></span><br><span class="line">        Class.forName(driver);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//建立连接</span></span><br><span class="line">        Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">        <span class="comment">//获取Statement</span></span><br><span class="line">        Statement statement = connection.createStatement();</span><br><span class="line">        <span class="comment">//写sql</span></span><br><span class="line">        String sql = <span class="string">&quot;select ename,deptno from emp where ename = &#x27;&quot;</span> + admin_user + <span class="string">&quot;&#x27; and deptno = &#x27;&quot;</span>+ admin_pwd + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">        ResultSet resultSet = statement.executeQuery(sql);</span><br><span class="line">        <span class="keyword">if</span>(resultSet.next())&#123;<span class="comment">//如果查询到记录，就说明存在</span></span><br><span class="line">            System.out.println(<span class="string">&quot;登陆成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;登陆失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        resultSet.close();</span><br><span class="line">        statement.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我输入万能用户名和密码，就会出现如下情况</p><p>输入用户名 为 1’ or </p><p>输入万能密码 为 or ‘1’= ‘1 </p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210911193518196.png" alt="image-20210911193518196"></p><p>这就是SQL注入，通过万能账号和密码就能登录。</p><p>但是preparedStatement就能显著的解决这个问题</p><p>还是上面的代码，用prapareStatement加以修改，如下所示</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   使用 PreparedStatement处理</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, SQLException, ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">//让用户输入管理员和密码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入管理员的名字:&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String admin_user = scanner.nextLine();<span class="comment">//如果需要看到SQL注入演示效果，就需要用nextLine()方法，因为next()方法会自动屏蔽掉空格</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入管理员的密码&quot;</span>);</span><br><span class="line">        String admin_pwd = scanner.nextLine();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//加载配置文件</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">        String user = properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        String password = properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        String url = properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        String driver = properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册驱动</span></span><br><span class="line">        Class.forName(driver);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//建立连接</span></span><br><span class="line">        Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取PreparedStatement</span></span><br><span class="line">        <span class="comment">//1.1写sql</span></span><br><span class="line">        String sql = <span class="string">&quot;select ename,deptno from test where ename = ? and deptno = ?&quot;</span>;</span><br><span class="line">        <span class="comment">//1.2获取连接</span></span><br><span class="line">        PreparedStatement preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">        <span class="comment">//1.3 给?赋值</span></span><br><span class="line">        preparedStatement.setString(<span class="number">1</span>,admin_user);</span><br><span class="line">        preparedStatement.setString(<span class="number">2</span>,admin_pwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行select语句</span></span><br><span class="line">        ResultSet resultSet = preparedStatement.executeQuery();</span><br><span class="line">        <span class="keyword">if</span>(resultSet.next())&#123;<span class="comment">//如果查询到记录，就说明存在</span></span><br><span class="line">            System.out.println(<span class="string">&quot;登陆成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;登陆失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        resultSet.close();</span><br><span class="line">        preparedStatement.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/image-20210911193749029.png" alt="image-20210911193749029"></p><h4 id="如何解决SQL注入"><a href="#如何解决SQL注入" class="headerlink" title="如何解决SQL注入"></a>如何解决SQL注入</h4><p>此时还是用刚刚的账号和密码就会显示登陆错误。这是因为preparedStatement执行的SQL语句中的参数用问号(?)来表示，调用其对象的setXxx()方法来设置这些参数。setXxx()方法有两个参数，第一个参数是要设置的SQL语句中的参数的索引(从1开始)，第二个是设置的SQL语句中的参数的值</p><p>用预处理的好处就是:</p><p>1.不再使用+拼接sql语句，减少了语法错误</p><p>2.有效的解决了sql注入问题</p><p>3.大大减少了编译次数，效率较高</p>]]></content>
      
      
      
        <tags>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式以及网络编程</title>
      <link href="/2020/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2020/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式以及网络编程"><a href="#设计模式以及网络编程" class="headerlink" title="设计模式以及网络编程"></a>设计模式以及网络编程</h1><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>设计模式:是经过大量的经验积累得出的一个开发模板</p><p>设计模式：</p><ul><li>创建型 创建对象</li><li>结构型 对象的组成</li><li>行为型 对象的功能</li></ul><p>创建型模式：</p><ul><li>简单工厂模式</li><li>工厂方法模式</li><li>单例模式：<ul><li>饿汉式</li><li>懒汉式</li></ul></li></ul><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat1</span> <span class="keyword">extends</span> <span class="title">Animal1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog1</span> <span class="keyword">extends</span> <span class="title">Animal1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃肉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalFactory1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Animal <span class="title">createAnimal</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;dog&quot;</span>.equals(type))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Dog();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;cat&quot;</span>.equals(type))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal a1 = AnimalFactory1.createAnimal(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">        Animal a2 = AnimalFactory1.createAnimal(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">        a1.eat();</span><br><span class="line">        a2.eat();</span><br><span class="line">        Animal a3 = AnimalFactory1.createAnimal(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(a3!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            a3.eat();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;无法创建该动物&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">工厂方式模式</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Animal1 <span class="title">createAnimal</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat1Factory</span> <span class="keyword">implements</span> <span class="title">Factory1</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Animal1 <span class="title">createAnimal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cat1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog1Factory</span> <span class="keyword">implements</span> <span class="title">Factory1</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Animal1 <span class="title">createAnimal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Dog1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat1</span> <span class="keyword">extends</span> <span class="title">Animal1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog1</span> <span class="keyword">extends</span> <span class="title">Animal1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃肉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//我现在需要一只狗</span></span><br><span class="line">        Animal1 dog = <span class="keyword">new</span> Dog1Factory().createAnimal();</span><br><span class="line">        dog.eat();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//我现在需要一只猫</span></span><br><span class="line">        Animal1 cat = <span class="keyword">new</span> Cat1Factory().createAnimal();</span><br><span class="line">        cat.eat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式：保证类在内存中只有一个对象<br>单例模式：</p><h4 id="饿汉式：类一加载就创建对象"><a href="#饿汉式：类一加载就创建对象" class="headerlink" title="饿汉式：类一加载就创建对象"></a>饿汉式：类一加载就创建对象</h4><h4 id="懒汉式：用的时候，再去创建对象"><a href="#懒汉式：用的时候，再去创建对象" class="headerlink" title="懒汉式：用的时候，再去创建对象"></a>懒汉式：用的时候，再去创建对象</h4><p>懒加载（延迟加载）<br>线程安全问题<br>是否有多线程环境<br>是否有共享数据<br>是否有多条语句操作共享数据<br>饿汉式<br>如何保证内存中只有一个对象呢：</p><p>构造方法私有<br>在成员位置上自己创建一个对象<br>提供一个公共的方法给外界去访问<br>也就是说，随着类的加载，对象就已经创建好了<br>这样的特点，在单例模式中我们称之为：饿汉式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student1</span></span>&#123;</span><br><span class="line">    Student1()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Student1 s = <span class="keyword">new</span> Student1();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student1 <span class="title">getStudent1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这样创造出来的对象不是单例的</span></span><br><span class="line">        Student1 s1 = <span class="keyword">new</span> Student1();</span><br><span class="line">        Student1 s2 = <span class="keyword">new</span> Student1();</span><br><span class="line">        System.out.println(s1==s2);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//这样创造出来的对象是单例的</span></span><br><span class="line">        Student1 s3 = Student1.getStudent1();</span><br><span class="line">        Student1 s4 = Student1.getStudent1();</span><br><span class="line">        System.out.println(s3==s4);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">懒汉式</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Teacher1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Teacher1 teacher1 = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">synchronized</span> Teacher1 <span class="title">getTeacher1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (teacher1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            teacher1 = <span class="keyword">new</span> Teacher1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> teacher1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Teacher1 t1 = Teacher1.getTeacher1();</span><br><span class="line">        Teacher1 t2 = Teacher1.getTeacher1();</span><br><span class="line">        System.out.println(t1==t2);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="网络OSI参考模型"><a href="#网络OSI参考模型" class="headerlink" title="网络OSI参考模型"></a>网络OSI参考模型</h3><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904201129.png"></p><h3 id="网络编程三要素"><a href="#网络编程三要素" class="headerlink" title="网络编程三要素"></a>网络编程三要素</h3><p><strong>网络编程三要素</strong>：<br>1、IP地址<br>2、端口<br>3、协议</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904201242.png"></p><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>Socket：网络套接字</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904201339.png"></p><h4 id="UDP通信过程"><a href="#UDP通信过程" class="headerlink" title="UDP通信过程"></a>UDP通信过程</h4><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904201448.png"></p><h5 id="UDP协议发送数据"><a href="#UDP协议发送数据" class="headerlink" title="UDP协议发送数据"></a>UDP协议发送数据</h5><p>1、创建发送端Socket对象<br>2、创建数据，并且把数据打包<br>3、调用Socket对象的发送方法发送数据包<br>4、释放资源，关闭Socket</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建发送端的Socket对象</span></span><br><span class="line">        DatagramSocket ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建数据，并且把数据打包</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="string">&quot;helloworld&quot;</span>.getBytes();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//获取数组的长度</span></span><br><span class="line">        <span class="keyword">int</span> length = bytes.length;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//IP地址对象</span></span><br><span class="line">        InetAddress address = InetAddress.getByName(<span class="string">&quot;192.168.3.24&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//设置端口号</span></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">10086</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//DatagramPacket(byte[] buf,int length,InetAddress address,int port)</span></span><br><span class="line">        DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bytes, length, address, port);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//调用Socket对象的发送方法发送数据包</span></span><br><span class="line">        <span class="comment">//void send(DatagramPacket p)</span></span><br><span class="line">        ds.send(dp);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="UDP协议接收数据"><a href="#UDP协议接收数据" class="headerlink" title="UDP协议接收数据"></a>UDP协议接收数据</h5><p>1、创建接收端的Socket对象<br>2、创建一个数据包（接收容器）<br>3、调用Socket对象接收方法接收数据<br>4、解析数据包，并显示在控制台<br>5、释放资源，关闭Socket</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个接收端Socket对象</span></span><br><span class="line">        <span class="comment">//DatagramSocket(int port)</span></span><br><span class="line">        <span class="comment">//构造数据报套接字并将其绑定到本地主机上的指定端口</span></span><br><span class="line">        DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">10086</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个数据包（接收容器）</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//数组长度</span></span><br><span class="line">        <span class="keyword">int</span> length = bytes.length;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//构造一个DatagramPacket用于接收长度的数据包length</span></span><br><span class="line">        DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bytes, length);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//调用Socket对象接收方法接收数据</span></span><br><span class="line">        <span class="comment">//void receive(DatagramPacket p)    从此套接字中接收数据包</span></span><br><span class="line">        ds.receive(dp);<span class="comment">//该方法阻塞，直到接收到数据包</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">//InetAddress getAddress()</span></span><br><span class="line">        <span class="comment">//返回该数据包发送或接收数据包的计算机IP地址</span></span><br><span class="line">        InetAddress address = dp.getAddress();</span><br><span class="line">        String ip = address.getHostAddress();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//解析数据包，并显示在控制台</span></span><br><span class="line">        <span class="comment">//byte[] getDate()</span></span><br><span class="line">        <span class="comment">//返回数据缓冲区</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = dp.getData();</span><br><span class="line">        <span class="comment">//int getLength()</span></span><br><span class="line">        <span class="comment">//返回要发送的数据的长度或接收到的数据长度</span></span><br><span class="line">        <span class="keyword">int</span> length1 = dp.getLength();</span><br><span class="line">        String s = <span class="keyword">new</span> String(data, <span class="number">0</span>, length1);</span><br><span class="line">        System.out.println(ip+<span class="string">&quot;发送数据为：&quot;</span>+s);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TCP通信过程"><a href="#TCP通信过程" class="headerlink" title="TCP通信过程"></a>TCP通信过程</h4><h5 id="客户端-接收"><a href="#客户端-接收" class="headerlink" title="客户端    接收"></a><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904201635.png">客户端    接收</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">client</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.创建socket对象，指明服务器端的ip和端口号</span></span><br><span class="line">            InetAddress inet = InetAddress.getByName(<span class="string">&quot;192.168.3.27&quot;</span>);</span><br><span class="line">            socket = <span class="keyword">new</span> Socket(inet, <span class="number">888</span>);</span><br><span class="line">            <span class="comment">//2.获取一个输出流，用于输出数据</span></span><br><span class="line">            outputStream = socket.getOutputStream();</span><br><span class="line">            <span class="comment">//3.写出数据的操作</span></span><br><span class="line">            outputStream.write(<span class="string">&quot;你好，我是客户端&quot;</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(outputStream != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    outputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(socket != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="服务端-发送"><a href="#服务端-发送" class="headerlink" title="服务端   发送"></a>服务端   发送</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">    InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建服务器端的ServerSocket，指明自己的端口号</span></span><br><span class="line">        serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">888</span>);</span><br><span class="line">        <span class="comment">//2.调用accept()表示接受来自于客户端的socket</span></span><br><span class="line">        Socket accept = serverSocket.accept();</span><br><span class="line">        <span class="comment">//3.获取输入流中的数据，并且读取</span></span><br><span class="line">        inputStream = accept.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = inputStream.read(bytes) )!= -<span class="number">1</span>)&#123;</span><br><span class="line">            String s = <span class="keyword">new</span> String(bytes, <span class="number">0</span>, len);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(inputStream != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(serverSocket != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                serverSocket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TCP以及UDP区别"><a href="#TCP以及UDP区别" class="headerlink" title="TCP以及UDP区别"></a>TCP以及UDP区别</h4><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904201948.png"></p><h3 id="引入三次握手"><a href="#引入三次握手" class="headerlink" title="引入三次握手"></a>引入三次握手</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。</p><p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。<br>进行三次握手：</p><p>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN。此时客户端处于 SYN_SENT 状态。</p><p>首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。</p><p>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_RCVD 的状态。</p><p>在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。</p><p>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。</p><p>确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。</p><p>发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。</p><p>在socket编程中，客户端执行connect()时，将触发三次握手。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904202433.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904203355.png"></p><h5 id="为什么非得采用三次握手，两次不行吗"><a href="#为什么非得采用三次握手，两次不行吗" class="headerlink" title="为什么非得采用三次握手，两次不行吗?"></a>为什么非得采用三次握手，两次不行吗?</h5><p>弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。</p><p>第一次握手：客户端发送网络包，服务端收到了。<br>这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。<br>第二次握手：服务端发包，客户端收到了。<br>这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。<br>第三次握手：客户端发包，服务端收到了。<br>这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。<br>因此，需要三次握手才能确认双方的接收与发送能力是否正常。</p><h5 id="试想如果是用两次握手，则会出现下面这种情况："><a href="#试想如果是用两次握手，则会出现下面这种情况：" class="headerlink" title="试想如果是用两次握手，则会出现下面这种情况："></a>试想如果是用两次握手，则会出现下面这种情况：</h5><blockquote><p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p></blockquote><h3 id="引入四次挥手"><a href="#引入四次挥手" class="headerlink" title="引入四次挥手"></a>引入四次挥手</h3><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p><p>TCP 连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务端均可主动发起挥手动作。</p><p>刚开始双方都处于ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p><ul><li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。<br>即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</li><li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。<br>即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</li><li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。<br>即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</li><li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。<br>即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</li></ul><p>收到一个FIN只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。</p><p>在socket编程中，任何一方执行close()操作即可产生挥手操作。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904203216.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904203451.png"></p><h5 id="挥手为什么需要四次？"><a href="#挥手为什么需要四次？" class="headerlink" title="挥手为什么需要四次？"></a>挥手为什么需要四次？</h5><p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lock锁以及线程</title>
      <link href="/2020/09/02/Lock%E9%94%81%E4%BB%A5%E5%8F%8A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/09/02/Lock%E9%94%81%E4%BB%A5%E5%8F%8A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Lock锁以及线程"><a href="#Lock锁以及线程" class="headerlink" title="Lock锁以及线程"></a>Lock锁以及线程</h1><h2 id="Lock-接口"><a href="#Lock-接口" class="headerlink" title="Lock(接口)"></a>Lock(接口)</h2><p>void lock() 获得锁，加锁<br>void unlock() 释放锁</p><p>子类：<br>ReentrantLock<br>这是解决线程同步安全的第二种方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SellTick1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义票的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义锁对象</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span> (tickets&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在出售第&quot;</span>+</span><br><span class="line">                            (tickets--)+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//释放锁</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicketDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SellTick1 s = <span class="keyword">new</span> SellTick1();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建三个线程窗口</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(s, <span class="string">&quot;窗口一&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(s, <span class="string">&quot;窗口二&quot;</span>);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(s, <span class="string">&quot;窗口三&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>同步的弊端：<br>- 效率低<br>- 如果出现了同步嵌套，就容易产生死锁问题<br><strong>死锁：是指两个或者两个以上的线程在执行的过程中，因争夺资源产生的一种互相等待现象</strong></p><h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><h3 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h3><p>Java可以使用 ThreadGroup来表示线程组，它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制</p><p><strong>简单来说：线程组就是把多个线程组合到一起</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student4</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag;<span class="comment">//默认是false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置数据，相当于生产者，没有数据（false）就生产，有数据（true）就等待</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.flag)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.notify();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取数据，相当于消费者，没有数据（false）就等待（wait），有数据（true）就消费</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.flag)&#123;<span class="comment">//加感叹号是为了顺利进入循环</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name+<span class="string">&quot;---&quot;</span>+<span class="keyword">this</span>.age);</span><br><span class="line">        <span class="keyword">this</span>.flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SetThread4</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Student4 s;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SetThread4</span><span class="params">(Student4 s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                s.set(<span class="string">&quot;A&quot;</span>,<span class="number">21</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                s.set(<span class="string">&quot;B&quot;</span>,<span class="number">12</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetThread4</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Student4 s;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GetThread4</span><span class="params">(Student4 s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            s.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student4 s = <span class="keyword">new</span> Student4();</span><br><span class="line"></span><br><span class="line">        SetThread4 st = <span class="keyword">new</span> SetThread4(s);</span><br><span class="line">        GetThread4 gt = <span class="keyword">new</span> GetThread4(s);</span><br><span class="line">    </span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(st);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(gt);</span><br><span class="line">    </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="线程池的好处："><a href="#线程池的好处：" class="headerlink" title="线程池的好处："></a>线程池的好处：</h4><p>线程池的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用</p><h4 id="如何实现线程池："><a href="#如何实现线程池：" class="headerlink" title="如何实现线程池："></a>如何实现线程池：</h4><p>1、创建一个线程池对象，控制要创建几个线程对象<br>public static ExecutorServe newFixedThreadPool(int nThreads)<br>创建一个线程池，指定线程池大小<br>2、哪些线程可以放到线程池执行<br>可以执行Runnable对象或者Callable对象代表的线程<br>3、如何执行<br>Future&lt;?&gt; submit(Runnable task)<br>提交一个可运行的任务执行，并返回一个表示该任务的未来。<br>Future submit(Callable task)<br>提交值返回任务以执行，并返回代表任务待处理结果的Future。<br>4、想结束任务怎么办<br>void shutdown()<br>启动有序关闭，其中先前提交的任务将被执行，但是不会接受任何新任务</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个线程池对象，控制要创建几个线程对象</span></span><br><span class="line">        ExecutorService fixpool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用匿名内部类的形式将Runnable对象或者Callable对象放进去并执行</span></span><br><span class="line">        fixpool.submit(<span class="keyword">new</span> MyRunnable2());</span><br><span class="line">        fixpool.submit(<span class="keyword">new</span> MyRunnable2());</span><br><span class="line">    </span><br><span class="line">        fixpool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p><strong>定时器是一个应用十分广泛的线程工具，可用于调度多个定时任务以后台线程的方式执行，在Java中，可以通过Timer和TimerTask类来实现定义调度的功能</strong></p><p>Timer：定时<br>Timer() 创建一个新的计时器<br>void schedule(TimerTask task,long delay)在指定的延迟之后安排指定的任务执行<br>void schedule(TimerTask task,long delay,long period)在指定的延迟之后开始，重写执行<br>void cancel()终止此计数器，丢弃任何当前计划的任务<br>TimerTask：任务</p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程</title>
      <link href="/2020/09/02/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/09/02/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h1><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a><strong>什么是线程</strong></h3><p>如果程序只有一条执行路径，那么该程序就是单线程程序<br>如果程序有多条执行路径，那么该程序就是多线程程序。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904194721.png"></p><p><strong>进程与线程的描述</strong><br>线程是依赖于进程存在的</p><h3 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a><strong>什么是进程</strong></h3><p>通过任务管理器看到了进程的存在<br>但是，我们只发现了正在运行的进程，没有运行的程序，进程中就没有<br>进程：就是正在运行的程序<br>正在运行的程序，是系统进行资源分配和调用的独立单位<br>每一个进程都有它自己的内存空间和系统资源</p><h4 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h4><p>单进程，是计算机只能做一件事情，但是呢，现在，我们的计算机都可以做多件事情，<br>比如：一边玩游戏（游戏进程），一边听音乐（音乐进程）<br>也就是说，现在的计算机都是支持多进程的，可以在一个时间段内执行多个任务</p><p>那么：单CPU的时候，一边玩游戏一边听音乐是同时在进行的吗？<br>不是，因为单CPU在某个时间点上只能做一件事情<br>但是为什么我们感觉是同时进行的呢？<br>是因为CPU在做着程序之间高效切换让我们觉得是在同时进行</p><h4 id="什么是线程-1"><a href="#什么是线程-1" class="headerlink" title="什么是线程"></a>什么是线程</h4><p>在同一个进程中又可以执行多个任务，而这每一个任务，我们看作线程<br>线程：是进程中的单个顺序控制流，是一条执行路径，是程序的执行单元，执行路径是程序使用CPU的最基本单位<br>单线程：一个进程只有一条执行路径<br>多线程：一个进程有多条执行路径</p><h4 id="多线程有什么意义呢？"><a href="#多线程有什么意义呢？" class="headerlink" title="多线程有什么意义呢？"></a>多线程有什么意义呢？</h4><p>多线程的存在，不是提高程序的执行速度，是为了提高应用程序的使用率存在的<br>在学习过程中，我们常见两种使用CPU的方式，一种是分片调度，一种是抢占式调度，而我们的Java是抢占式调度<br>多线程就是某个进程在抢占资源的时候，执行路径比较多，有着更高的几率抢到，但是我们不能保证哪一个线程能够在哪一个时刻可以抢到CPU资源<br>所以线程的执行具有随机性</p><h4 id="并发与并行的描述"><a href="#并发与并行的描述" class="headerlink" title="并发与并行的描述"></a>并发与并行的描述</h4><p>并行：指的是逻辑上同时发生，指在某一个时间段内同时运行多个程序<br>并发：指的是物理上同时发生，指在某一个时间点内同时运行多个程序<br>Java程序的运行原理<br>由Java命令去启动一个JVM，JVM启动就相当于启动了一个进程<br>接着由该进程去创建一个主线程去调用main方法</p><h5 id="思考：JVM虚拟机启动的时候是单线程还是多线程呢"><a href="#思考：JVM虚拟机启动的时候是单线程还是多线程呢" class="headerlink" title="思考：JVM虚拟机启动的时候是单线程还是多线程呢"></a>思考：JVM虚拟机启动的时候是单线程还是多线程呢</h5><p>多线程<br>因为：垃圾回收线程也是需要启动的，否则就会出现内存溢出<br>所以JVM虚拟机启动的时候，最低启动两个线程，所以JVM虚拟机启动的时候是多线程</p><h5 id="实现多线程"><a href="#实现多线程" class="headerlink" title="实现多线程"></a>实现多线程</h5><p><strong>如何实现多线程呢</strong><br>由于线程是依赖于进程存在的，所以我们应该先创建一个进程出来，而进程最终是由系统创建的，所以我们就要想应该去调用系统的功能去创建进程<br>但是，Java并不能直接调用系统功能，所以我们就没办法实现多线程程序<br>但是，Java可以去调用C/C++写好的程序来实现多线程程序<br>由C/C++去调用系统功能创建进程，然后由Java去调用这样的东西就可以了<br>然后提供一些类给我们使用，我们就可以创建多线程程序了</p><p><strong>Java提供的类是什么呢</strong></p><h4 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h4><p>通过查看API文档，我们知道了有两种实现多线程程序的方式</p><h5 id="方式一：继承Thread类实现多线程"><a href="#方式一：继承Thread类实现多线程" class="headerlink" title="方式一：继承Thread类实现多线程"></a>方式一：继承Thread类实现多线程</h5><p>步骤：</p><p>自定义一个MyThread类继承Thread类<br>自定义重写Thread类中的run方法（类中的代码不是所有代码都需要被线程执行，只有当需要被线程执行的时候，再把代码加入到run方法中）<br>创建对象<br>启动线程</p><p>在多线程中获取和设置线程名称</p><ul><li>获取线程对象的名称：<br>public final String getName() 返回此线程的名称</li><li>设置线程对象的名称：<br>public final void setName(String name)将此线程的名称改为name</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        <span class="comment">//无参构造创建对象，开发中推荐这一招</span></span><br><span class="line"><span class="comment">//        MyThread2 m1 = new MyThread2();</span></span><br><span class="line"><span class="comment">//        MyThread2 m2 = new MyThread2();</span></span><br><span class="line"><span class="comment">//        m1.setName(&quot;zhangsan&quot;);</span></span><br><span class="line"><span class="comment">//        m2.setName(&quot;lisi&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//有参构造方法给线程对象起名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        MyThread2 m3 = new MyThread2(&quot;wangwu&quot;);</span></span><br><span class="line"><span class="comment">//        MyThread2 m4 = new MyThread2(&quot;zhaoliu&quot;);</span></span><br><span class="line"><span class="comment">//        m3.start();</span></span><br><span class="line"><span class="comment">//        m4.start();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(m1.getName());</span></span><br><span class="line"><span class="comment">//        m1.start();</span></span><br><span class="line"><span class="comment">//        m2.start();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取main方法所在的线程的名称</span></span><br><span class="line">        <span class="comment">//Thread提供了一个方法给我们，可以获取main方法的线程，也就是主线程</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h4><p><strong>如何获取线程对象的优先级</strong><br>public final int getPriority()返回此线程的优先级<br>如何设置线程对象的优先级<br>public final void setPriority(int newPriority)更改此线程的优先级<br>MIN_PRIORITY到MAX_PRIORITY之间（1-10）<br>IllegalArgumentException:抛出表示一种方法已经通过了非法或不正确的参数。非法参数异常<br><strong>注意：</strong><br>线程的默认优先级是5<br>线程的优先级范围是1-10<br>线程的优先级仅仅代表获取CPU时间片的几率，但是不是绝对会先获取<br>public final void join()：其他线程等待这个线程死亡</p><p>public final void setDaemon() 守护线程</p><p>线程的中断<br>public final void stop()：让线程停止（该方法已经过时了，但是还能用）<br>public void interrupt()：中断这个线程，并且抛出异常<br>InterruptedException: sleep interrupted<br>注意：stop是直接让方法结束了，interrupt是结束之后抛出异常</p><p>线程的生命周期</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904195253.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904195349.png"></p><h5 id="方式二：实现Runnable接口"><a href="#方式二：实现Runnable接口" class="headerlink" title="方式二：实现Runnable接口"></a>方式二：实现Runnable接口</h5><p>步骤：</p><ul><li>自定义MyRunnable类实现Runnable接口</li><li>重写run方法</li><li>创建MyRunnable对象</li><li>创建Thread对象，并把第三步的对象当作参数传入构造方法中</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//由于实现的Runnable接口没有getName()方法，就不能直接使用Thread类的方法了</span></span><br><span class="line">            <span class="comment">//但是可以间接使用</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyRunnable my = <span class="keyword">new</span> MyRunnable();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(my);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(my);</span><br><span class="line">    </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Thread-0:0</span></span><br><span class="line"><span class="comment">//Thread-1:0</span></span><br><span class="line"><span class="comment">//Thread-1:1</span></span><br><span class="line"><span class="comment">//Thread-0:1</span></span><br><span class="line"><span class="comment">//Thread-1:2</span></span><br><span class="line"><span class="comment">//Thread-1:3</span></span><br><span class="line"><span class="comment">//Thread-0:2</span></span><br><span class="line"><span class="comment">//Thread-0:3</span></span><br></pre></td></tr></table></figure><h4 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h4><ul><li>是否有多线程环境</li><li>是否有共享数据</li><li>是否有多条语句操作共享数据</li></ul><h4 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h4><p>同步代码块：<br>格式：<br>synchronized(对象){ //把需要同步的数据都放在这里面<br>需要同步的代码块;<br>}<br>1、对象是什么呢<br>我们可以随便创建一个对象试试<br>2、需要同步的代码块是什么呢<br>多条语句操作共享数据的代码部分包起来</p><h5 id="同步的好处："><a href="#同步的好处：" class="headerlink" title="同步的好处："></a>同步的好处：</h5><p>同步的出现解决了多线程的安全问题<br>同步的弊端：<br>当线程相当多的时候，因为每个线程都会取判断同步上的锁，这样会非常耗费资源，无形中降低了程序运行的效率</p><h5 id="同步代码块的锁对象是谁呢"><a href="#同步代码块的锁对象是谁呢" class="headerlink" title="同步代码块的锁对象是谁呢"></a>同步代码块的锁对象是谁呢</h5><p>任意对象</p><h5 id="同步方法："><a href="#同步方法：" class="headerlink" title="同步方法："></a>同步方法：</h5><p>就是把同步关键字加到方法上<br>private synchronized 加到权限修饰符后面</p><h5 id="同步方法的锁是什么呢"><a href="#同步方法的锁是什么呢" class="headerlink" title="同步方法的锁是什么呢"></a>同步方法的锁是什么呢</h5><p>this</p><h3 id="线程安全的类"><a href="#线程安全的类" class="headerlink" title="线程安全的类"></a>线程安全的类</h3><ul><li>Vector 不过，虽然它是线程安全的，但是我们也不用</li><li>StringBuffer</li><li>Hashtable</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符流和序列化</title>
      <link href="/2020/09/02/%E5%AD%97%E7%AC%A6%E6%B5%81%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2020/09/02/%E5%AD%97%E7%AC%A6%E6%B5%81%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="字符流和序列化"><a href="#字符流和序列化" class="headerlink" title="字符流和序列化"></a>字符流和序列化</h1><p><strong>编码表</strong></p><p>由字符及其对应的数值组成的一张表</p><p><strong>通过字符集解码字符数组</strong><br>public String(byte[] bytes,Charset charset)<br>public byte[] getBytes(Charset charset)<br><strong>总结：</strong><br>编码：把看的懂的变成看不懂的，类似于加密<br>String – byte[]<br>解码：把看不懂的变成看的懂的，根据编码表<br>byte[] – String</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;晚上&quot;</span>;</span><br><span class="line">        <span class="comment">//String -- byte[]</span></span><br><span class="line">        <span class="keyword">byte</span>[] gbk = s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">byte</span> b:gbk)&#123;</span><br><span class="line">            System.out.println(b);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] utf = s.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">byte</span> b1:utf)&#123;</span><br><span class="line">            System.out.println(b1);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] unicodes = s.getBytes(<span class="string">&quot;Unicode&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b2:unicodes) &#123;</span><br><span class="line">            System.out.println(b2);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line">        <span class="comment">//byte[] -- String</span></span><br><span class="line">        String s1 = <span class="keyword">new</span> String(unicodes,<span class="string">&quot;Unicode&quot;</span>);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//-51</span></span><br><span class="line"><span class="comment">//-19</span></span><br><span class="line"><span class="comment">//-55</span></span><br><span class="line"><span class="comment">//-49</span></span><br><span class="line"><span class="comment">//************************</span></span><br><span class="line"><span class="comment">//-26</span></span><br><span class="line"><span class="comment">//-103</span></span><br><span class="line"><span class="comment">//-102</span></span><br><span class="line"><span class="comment">//-28</span></span><br><span class="line"><span class="comment">//-72</span></span><br><span class="line"><span class="comment">//-118</span></span><br><span class="line"><span class="comment">//************************</span></span><br><span class="line"><span class="comment">//-2</span></span><br><span class="line"><span class="comment">//-1</span></span><br><span class="line"><span class="comment">//102</span></span><br><span class="line"><span class="comment">//90</span></span><br><span class="line"><span class="comment">//78</span></span><br><span class="line"><span class="comment">//10</span></span><br><span class="line"><span class="comment">//************************</span></span><br><span class="line"><span class="comment">//晚上</span></span><br></pre></td></tr></table></figure><h2 id="字符流（也叫做转换流）"><a href="#字符流（也叫做转换流）" class="headerlink" title="字符流（也叫做转换流）"></a>字符流（也叫做转换流）</h2><p><strong>字符流 = 字节流 + 编码表</strong></p><h3 id="字符输出流"><a href="#字符输出流" class="headerlink" title="字符输出流"></a>字符输出流</h3><p>public OutputStreamWriter(OutputStream out)<br>根据默认的编码用字符作为桥梁将字节流的数据转换成字符流<br>public OutputStreamWriter(OutputStream out,String charsetName)<br>根据指定的编码用字符作为桥梁将字节流的数据转换成字符流</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//设置写出的编码格式</span></span><br><span class="line"><span class="comment">//        OutputStreamWriter outputStreamWriter = new OutputStreamWriter(new FileOutputStream(&quot;b.txt&quot;),</span></span><br><span class="line"><span class="comment">//                &quot;GBK&quot;);</span></span><br><span class="line"><span class="comment">//        OutputStreamWriter outputStreamWriter = new OutputStreamWriter(new FileOutputStream(&quot;b.txt&quot;),</span></span><br><span class="line"><span class="comment">//                &quot;UTF-8&quot;);</span></span><br><span class="line">        OutputStreamWriter outputStreamWriter = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;b.txt&quot;</span>),</span><br><span class="line">                <span class="string">&quot;Unicode&quot;</span>);</span><br><span class="line"></span><br><span class="line">        outputStreamWriter.write(<span class="string">&quot;酷酷的涛&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        outputStreamWriter.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="OutputStreamWriter写数据"><a href="#OutputStreamWriter写数据" class="headerlink" title="OutputStreamWriter写数据"></a>OutputStreamWriter写数据</h4><p>public void write(int c)<br>public void write(char[] cbuf)<br>public void write(char[] cbuf,int off,int len)<br>public void write(String str)<br>public void write(String str,int off,int len)<br><strong>注意：close()与flush()的区别：</strong></p><p>close()关闭流对象，但是会先刷新一次缓冲区。关闭之后，就不能调用<br>flush()仅仅只是刷新，刷新之后还能继续调用<br><strong>字符输入流</strong><br>public InputStreamReader(InputStream in)<br>读取数据，根据默认的编码用字符作为桥梁将字节流数据转换成字符流<br>public InputStreamReader(InputStream in,String charsetName)<br>读取数据，根据指定的编码用字符作为桥梁将字节流数据转换成字符流</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//        InputStreamReader inputStreamReader = new InputStreamReader(new FileInputStream(&quot;b.txt&quot;));</span></span><br><span class="line"><span class="comment">//        InputStreamReader inputStreamReader = new InputStreamReader(new FileInputStream(&quot;b.txt&quot;),</span></span><br><span class="line"><span class="comment">//                &quot;GBK&quot;);</span></span><br><span class="line"><span class="comment">//        InputStreamReader inputStreamReader = new InputStreamReader(new FileInputStream(&quot;b.txt&quot;),</span></span><br><span class="line"><span class="comment">//                &quot;Unicode&quot;);</span></span><br><span class="line">        InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;b.txt&quot;</span>),</span><br><span class="line">                <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一次读取一个字符</span></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((b = inputStreamReader.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">        System.out.print((<span class="keyword">char</span>) b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inputStreamReader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="InputStreamReader读数据"><a href="#InputStreamReader读数据" class="headerlink" title="InputStreamReader读数据"></a>InputStreamReader读数据</h4><ul><li>public int read() 一次只读一个字符</li><li>public int read(char[] cbuf) 一次只读一个字符数组</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;b.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一次只读取一个字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        int b = 0;</span></span><br><span class="line"><span class="comment">//        while ((b = inputStreamReader.read()) != -1)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println((char)b);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//一次只读取一个字符数组</span></span><br><span class="line">    <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((len = inputStreamReader.read(chars)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(chars,<span class="number">0</span>,len));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    inputStreamReader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用字符流实现文本文件的复制</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        将当前项目目录下的a.txt内容复制到当前目录下</span></span><br><span class="line"><span class="comment">        数据源：</span></span><br><span class="line"><span class="comment">            a.txt -- 读取数据 -- 字符流 -- InputStreamReader</span></span><br><span class="line"><span class="comment">        目的地：</span></span><br><span class="line"><span class="comment">            aCopy.txt -- 写出数据 -- 字符流 -- InputStreamWriter</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">        OutputStreamWriter outputStreamWriter = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;aCopy.txt&quot;</span>));</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//读写数据</span></span><br><span class="line">        <span class="comment">//第一种方式 只读取一个字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        int b = 0;</span></span><br><span class="line"><span class="comment">//        while ((b = inputStreamReader.read()) != -1)&#123;</span></span><br><span class="line"><span class="comment">//            outputStreamWriter.write(b);</span></span><br><span class="line"><span class="comment">//            outputStreamWriter.flush();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"> <span class="comment">//第二种方式 读取一个字符数组</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> ((len = inputStreamReader.read(chars)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        outputStreamWriter.write(chars,<span class="number">0</span>,len);</span><br><span class="line">        outputStreamWriter.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    outputStreamWriter.close();</span><br><span class="line">    inputStreamReader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用字符流简化书写的方式复制文本文件<br>简化方式：FileReader、FileWriter</p><p>由于我们常见的操作都是使用本地默认的编码，我们基本上在使用的时候不去指定编码，而又因为字符流的名称有点长，所以Java就提供了子类给我们使用</p><p>字符流 = 字节流 + 编码表</p><p>OutputStreamWriter = FileOutputStream + 编码表<br>InputStreamReader = FileInputStream + 编码表</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//原先的写法</span></span><br><span class="line"><span class="comment">//        InputStreamReader inputStreamReader = new InputStreamReader(new FileInputStream(&quot;a.txt&quot;));</span></span><br><span class="line">        <span class="comment">//改进的写法</span></span><br><span class="line">        FileReader fileReader = <span class="keyword">new</span> FileReader(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//原先的写法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        OutputStreamWriter outputStreamWriter = new OutputStreamWriter(new FileOutputStream(&quot;aCopy.txt&quot;));</span></span><br><span class="line">        <span class="comment">//改进的写法</span></span><br><span class="line">        FileWriter fileWriter = <span class="keyword">new</span> FileWriter(<span class="string">&quot;aCopy.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一种方式     一次只读取一个字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        int b = 0;</span></span><br><span class="line"><span class="comment">//        while ((b = fileReader.read()) != -1)&#123;</span></span><br><span class="line"><span class="comment">//            fileWriter.write(b);</span></span><br><span class="line"><span class="comment">//            fileWriter.flush();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"> <span class="comment">//第二种方式     一次只读取一个字符数组</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> ((len = fileReader.read(chars)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        fileWriter.write(chars,<span class="number">0</span>,len);</span><br><span class="line">        fileWriter.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fileWriter.close();</span><br><span class="line">    fileReader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h3><p>BufferedWriter：字符缓冲输出流<br>将文本文件写入到字符输入流，缓冲各个字符，以提供单个字符，数组和字符串的高效写入。<br>可以指定缓冲区大小，或者接受默认大小<br>默认值足够大，可以不用再去指定了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"> <span class="comment">//原本的写法</span></span><br><span class="line"><span class="comment">//BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(&quot;a.txt&quot;)));</span></span><br><span class="line">     <span class="comment">//改进的写法</span></span><br><span class="line">    BufferedWriter bufferedWriter1 = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">    bufferedWriter1.write(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    bufferedWriter1.write(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    bufferedWriter1.flush();</span><br><span class="line"></span><br><span class="line">    bufferedWriter1.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>BufferedReader：字符缓冲输入流<ul><li>从字符输入流读取文本，缓冲字符，以提供字符，数组或行的高效读取</li><li>可以指定缓冲区的大小，或者可以使用默认大小</li><li>默认值足够大，不需要再做改变</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//原本的写法</span></span><br><span class="line"><span class="comment">//        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;a.txt&quot;)));</span></span><br><span class="line">        <span class="comment">//改进的写法</span></span><br><span class="line">        BufferedReader bufferedReader1 = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式一，一个字符的读取</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        int b = 0;</span></span><br><span class="line"><span class="comment">//        while ((b = bufferedReader1.read()) != -1)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println((char)b);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式二，一个字符数组的读取</span></span><br><span class="line">    <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((len = bufferedReader1.read(chars)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(chars,<span class="number">0</span>,len));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bufferedReader1.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>字符缓冲流复制文本文件</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">        BufferedWriter bufferedWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;aCopy.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一次读取一个字符</span></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((b = bufferedReader.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            bufferedWriter.write(b);</span><br><span class="line">            bufferedWriter.flush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        一次读取一个字符数组</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = bufferedReader.read(chars)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            bufferedWriter.write(chars,<span class="number">0</span>,len);</span><br><span class="line">            bufferedWriter.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">    bufferedReader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符缓冲流的特殊功能"><a href="#字符缓冲流的特殊功能" class="headerlink" title="字符缓冲流的特殊功能"></a>字符缓冲流的特殊功能</h4><p>BufferedWriter：void newLine()<br>写一行行分隔符，根据系统决定换行符的<br>行分隔符字符串由系统属性line.separator定义，并不一定是单个换行符(’\n’)字符<br>BufferedReader：void readLine()<br>读一行文字，一次读取一行数据<br>一行被视为由换行符(’\n’)，<br>回车符(’\r’)中的任何一个或者随后的换行符终止<br>包含行的内容的字符串，不包含任何终止字符，如果达到流的末尾，则为null</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        write();</span><br><span class="line">        read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建字符缓冲流</span></span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//public String readLine()      读一行文字，一次读取一行数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        String s = bufferedReader.readLine();</span></span><br><span class="line"><span class="comment">//        System.out.println(s);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//最终版本</span></span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        bufferedReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    </span><br><span class="line">        BufferedWriter bufferedWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            bufferedWriter.write(<span class="string">&quot;大数据&quot;</span>);</span><br><span class="line">            bufferedWriter.newLine();<span class="comment">//换行</span></span><br><span class="line">            bufferedWriter.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>字符缓冲流的特殊功能复制文本文件</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">        BufferedWriter bufferedWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;aCopy.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        String s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((s = bufferedReader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            bufferedWriter.write(s);</span><br><span class="line">            bufferedWriter.newLine();</span><br><span class="line">            bufferedWriter.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>总结</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904193951.png"></p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><ul><li>序列化流：把对象按照流一样的方式存到文本文件或者在网络中传输<br>对象 – 流数据(ObjectOutputStream)</li><li>反序列化：把文本文件中的流对象数据或者网络中的流数据还原成对象<br>流数据 – 对象（ObjectInputStream）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">301533426692145378L</span>;   <span class="comment">//加上这个之后，就可以读回来数据，怎么改变都可以了</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="comment">//    private transient int age;        //有了这个东西之后，就固定了，不被改变，比如写入年龄25，加上这个，就不改变了</span></span><br><span class="line"><span class="comment">//    int age;                  //这里第一次运行的是int age 之后 变成了 private int age 就读不回来了</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//由于我们我们要对对象进行序列化，所以定义一个类</span></span><br><span class="line">        <span class="comment">//序列化数据其实就是将对象持久化</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//            write();</span></span><br><span class="line">            read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException|ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//创建ObjectInputStream对象</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;oos.txt&quot;</span>));</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//Object readObject()</span></span><br><span class="line">        <span class="comment">//从ObjectInputStream读取一个对象。</span></span><br><span class="line">        Object o = ois.readObject();</span><br><span class="line">    </span><br><span class="line">        ois.close();</span><br><span class="line">    </span><br><span class="line">        System.out.println(o);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建ObjectOutputStream对象</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;oos.txt&quot;</span>));</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        Person zhangsan = <span class="keyword">new</span> Person(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">24</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//void writeObject(Object obj)</span></span><br><span class="line">        <span class="comment">//将指定的对象写入ObjectOutputStream。</span></span><br><span class="line">        oos.writeObject(zhangsan);</span><br><span class="line">    </span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归思想以及IO流</title>
      <link href="/2020/09/02/%E9%80%92%E5%BD%92%E6%80%9D%E6%83%B3%E4%BB%A5%E5%8F%8AIO%E6%B5%81/"/>
      <url>/2020/09/02/%E9%80%92%E5%BD%92%E6%80%9D%E6%83%B3%E4%BB%A5%E5%8F%8AIO%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="递归思想以及IO流"><a href="#递归思想以及IO流" class="headerlink" title="递归思想以及IO流"></a>递归思想以及IO流</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><strong>什么是递归</strong></p><p>方法定义中调用方法本身的现象</p><p><strong>注意</strong></p><ul><li>递归需要有出口，否则就是死递归</li><li>次数不能太多，否则就内存溢出</li><li>构造方法不能递归使用</li></ul><p>例如:求一个斐波那契数列</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1,1,2,3,5,8,13,21</span></span><br><span class="line">        <span class="comment">//第三个开始，后面的都是前面两个之和     求第二十个数</span></span><br><span class="line">    <span class="keyword">int</span> []arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        arr[i] = arr[i-<span class="number">2</span>]+arr[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(arr[arr.length-<span class="number">1</span>]);</span><br><span class="line">    System.out.println(<span class="string">&quot;***************&quot;</span>);</span><br><span class="line">    System.out.println(recursion(<span class="number">20</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span> || i==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        sum += recursion(i-<span class="number">1</span>) + recursion(i-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><p>用来解决设备之间数据传输的问题<br>简单一句话：<br><strong>如果用电脑的笔记本打开能看懂的东西，就用字符流，<br>笔记本打开看不懂，就用字节流</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904192052.png"></p><h3 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h3><p><strong>流向：</strong><br>输入流 读取数据<br>输出流 写出数据<br><strong>数据类型：</strong><br>字节流：<br>字节输入流 读取数据 InputStream<br>字节输出流 写入数据 OutputStream<br>字符流：<br>字符输入流 读取数据 Reader<br>字符输出流 写出数据 Writer<br><strong>写出</strong><br>往文件中写出一个数据<br>我们现在尝试着往文件中写入一个数据，使用记事本能看懂的，最好用字符流，但我们这里用的是字节流</p><h4 id="字节输出流的操作步骤："><a href="#字节输出流的操作步骤：" class="headerlink" title="字节输出流的操作步骤："></a>字节输出流的操作步骤：</h4><p>1、创建字节输出流对象<br>2、写入数据<br>3、释放资源</p><p>我们是通过程序写到文本文件，所以这里用的是OutputStream</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建字节输出流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>);<span class="comment">//文件如果不存在，自动创建</span></span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">        System.out.println(fileOutputStream);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        JVM创建字节输出流对象的时候，做了些什么</span></span><br><span class="line"><span class="comment">        1、调用系统功能创建文件</span></span><br><span class="line"><span class="comment">        2、创建fileOutputStream对象</span></span><br><span class="line"><span class="comment">        3、将fileOutputStream对象指向文件</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    </span><br><span class="line">        fileOutputStream.write(<span class="string">&quot;大数据&quot;</span>.getBytes());</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        为什么需要close文件</span></span><br><span class="line"><span class="comment">        1、让流对象变成垃圾，这样垃圾回收器就可以回收它了</span></span><br><span class="line"><span class="comment">        2、通知系统去释放跟该文件相关的资源</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="JVM创建字节输出流的时候，都做了些什么"><a href="#JVM创建字节输出流的时候，都做了些什么" class="headerlink" title="JVM创建字节输出流的时候，都做了些什么"></a>JVM创建字节输出流的时候，都做了些什么</h4><p>调用系统功能创建文件<br>创建fileOutputStream对象<br>将fileOutputStream对象指向该文件<br>为什么需要close文件<br>让流对象变成垃圾，这样垃圾回收器就可以回收它了<br>通知系统去释放跟该文件相关的资源<br><strong>三种使用字节输出流往文件中写入数据的方式</strong><br>public void write(int b)<br>public void write(byte[] b)<br>public void write(byte[] b,int off,int len)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        使用字节输出流写数据的方式</span></span><br><span class="line"><span class="comment">        1、创建字节输出流对象</span></span><br><span class="line"><span class="comment">        2、使用write方法写入数据</span></span><br><span class="line"><span class="comment">        3、释放资源</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//public void write(int b)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        fileOutputStream.write(97); //a.txt文件中的内容是a，可以看到这种方式，存入的是97的ASCII码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//public void write(byte[] b)</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">104</span>,<span class="number">105</span>,<span class="number">106</span>&#125;;<span class="comment">//a.txt中的内容是hij，存入的也是底层的ASCII码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        fileOutputStream.write(b);</span></span><br><span class="line"> <span class="comment">//public void write(byte[] b,int off,int len)</span></span><br><span class="line">    fileOutputStream.write(b,<span class="number">0</span>,<span class="number">2</span>);<span class="comment">//偏移量，也是ASCII码</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h4><h5 id="字节输入流的操作步骤"><a href="#字节输入流的操作步骤" class="headerlink" title="字节输入流的操作步骤"></a>字节输入流的操作步骤</h5><ul><li>创建字节输入对象</li><li>调用read方法读取数据，并把数据显示在控制台</li><li>释放资源</li></ul><h5 id="两种字节输入流读取数据的方式"><a href="#两种字节输入流读取数据的方式" class="headerlink" title="两种字节输入流读取数据的方式"></a>两种字节输入流读取数据的方式</h5><ul><li>public int read()</li><li>public int read(byte[] b)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904192438.png"></p><p><strong>缓冲区类（高效类）</strong><br>我们可以看到，在使用字节输入输出流的时候，复制照片或者视频的时候，速度非常慢，这里我们使用字节缓冲流</p><p><strong>字节缓冲输出流</strong><br>BufferedOutputStream<br><strong>字节缓冲输入流</strong><br>BufferedInputStream<br><strong>字节缓冲输出流</strong><br>BufferedOutputStream中要传入一个OutputStream的具体的子类实现对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        BufferedOutputStream bufferedOutputStream = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">    </span><br><span class="line">        bufferedOutputStream.write(<span class="string">&quot;大数据yyds&quot;</span>.getBytes());</span><br><span class="line">    </span><br><span class="line">        bufferedOutputStream.close();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字节缓冲输入流</span></span><br><span class="line"><span class="comment">//输入到控制台：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedInputStream bufferedInputStream = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = bufferedInputStream.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        bufferedInputStream.close();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">//大数据yyds</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Treeset以及Map</title>
      <link href="/2020/09/02/Treeset%E4%BB%A5%E5%8F%8AMap/"/>
      <url>/2020/09/02/Treeset%E4%BB%A5%E5%8F%8AMap/</url>
      
        <content type="html"><![CDATA[<h1 id="Treeset以及Map"><a href="#Treeset以及Map" class="headerlink" title="Treeset以及Map"></a>Treeset以及Map</h1><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p><strong>有关TreeSet</strong></p><ul><li>TreeSet：能够使元素按照某种规则进行排序</li><li>排序有两种：1、自然排序；2、选择器排序</li><li>TreeSet集合的特点：元素唯一、可以排序</li><li>通过观察TreeSet的add()方法，我们发现最终要看TreeMap的put()方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        <span class="comment">//现在这样的排序叫做 自然排序</span></span><br><span class="line">        TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;Integer&gt;();</span><br><span class="line">        set.add(<span class="number">10</span>);</span><br><span class="line">        set.add(<span class="number">20</span>);</span><br><span class="line">        set.add(<span class="number">23</span>);</span><br><span class="line">        set.add(<span class="number">90</span>);</span><br><span class="line">        set.add(<span class="number">13</span>);</span><br><span class="line">        set.add(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span>(Integer i:set)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//10</span></span><br><span class="line"><span class="comment">//13</span></span><br><span class="line"><span class="comment">//20</span></span><br><span class="line"><span class="comment">//23</span></span><br><span class="line"><span class="comment">//90</span></span><br></pre></td></tr></table></figure><p>同时Treeset底层是红黑树，主要采用的是中序遍历。</p><p>TreeSet中的add方法源码解析<br>add方法保证了元素的有序性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Interface NavigableMap&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span> <span class="keyword">implements</span> <span class="title">NavigableMap</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; t = root;</span><br><span class="line">        <span class="comment">//一开始添加元素的时候，一定是没有根的，所以第一个元素t一定是等于null的</span></span><br><span class="line">        <span class="comment">//造一个根节点</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line"></span><br><span class="line">            root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            modCount++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cmp;</span><br><span class="line">        Entry&lt;K,V&gt; parent;</span><br><span class="line">        <span class="comment">// split comparator and comparable paths</span></span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">        <span class="comment">//由于是无参构造，是自然比较，没有比较器，所以是==null的</span></span><br><span class="line">        <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                parent = t;</span><br><span class="line">                cmp = cpr.compare(key, t.key);</span><br><span class="line">                <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                    t = t.left;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                    t = t.right;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">            &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="comment">//通过观察API发现，Integer类实现了Comparable接口，所以可以向上转型</span></span><br><span class="line">            <span class="comment">//又发现了一点：无参构造虽然是自然排序，但是也需要有一个Comparable自然比较器</span></span><br><span class="line">                Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                parent = t;</span><br><span class="line">                cmp = k.compareTo(t.key);</span><br><span class="line">                <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                    t = t.left;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                    t = t.right;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">            &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            parent.left = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            parent.right = e;</span><br><span class="line">        fixAfterInsertion(e);</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeSet</span> <span class="keyword">implements</span> <span class="title">Set</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><p>通过查看API我们发现，Map集合的特点是将键映射到值的对象<br>Map中不能包含重复的键，每个键可以映射到最多一个值<br>&lt;K,V&gt;映射<br>Key Value<br>1001 zhangsan<br>1002 lisi<br>1003 wangwu<br>1004 zhaoliu<br>1001（重复了） tianqi</p><h3 id="Map集合的特点"><a href="#Map集合的特点" class="headerlink" title="Map集合的特点"></a>Map集合的特点</h3><p>将键映射到值的对象<br>一个映射不能包含重复的键<br>每个键最多只能映射到一个值</p><h3 id="Map接口和Collection接口的不同："><a href="#Map接口和Collection接口的不同：" class="headerlink" title="Map接口和Collection接口的不同："></a>Map接口和Collection接口的不同：</h3><p>Map集合的元素是成对出现的，Map集合的键是唯一的，值是可以重复的<br>Collection集合存储的元素是单独出现的，Collection的子接口Set中的元素是唯一的，List中的元素是可以重复的</p><p>Map集合的功能<br>1、添加功能：<br>V put(K key, V value) 将指定的值与该映射中的指定键相关联（可选操作）。<br>2、删除功能：<br>void clear() 从Map中删除所有的映射（可选操作）。<br>V remove(Object key) 如果存在（从可选的操作），从该地图中删除一个键的映射。<br>3、判断功能：<br>boolean containsKey(Object key) 如果此映射包含指定键的映射，则返回 true 。<br>boolean containsValue(Object value) 如果此地图将一个或多个键映射到指定的值，则返回 true 。<br>boolean isEmpty() 如果此地图不包含键值映射，则返回 true 。<br>4、获取功能：<br>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回Map中包含的映射的Set视图。<br>V get(Object key) 返回到指定键所映射的值，或 null如果此映射包含该键的映射。<br>Set keySet() 返回此地图中包含的键的Set视图。<br>Collection values() 返回Map中包含的值的Collection视图。<br>5、长度功能：<br>int size() 返回Map中键值映射的数量。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;String, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    </span><br><span class="line">        hashMap.put(<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;21&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;lisi&quot;</span>,<span class="string">&quot;22&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;wangwu&quot;</span>,<span class="string">&quot;23&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;zhaoliu&quot;</span>,<span class="string">&quot;24&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        System.out.println(hashMap);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        //void clear()</span></span><br><span class="line">        hashMap.clear();</span><br><span class="line">        System.out.println(hashMap);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //V remove(Object key)删除一个键的映射</span></span><br><span class="line">        hashMap.remove(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        System.out.println(hashMap);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        //containsKey(Object key)如果此映射包含指定键的映射，返回true</span></span><br><span class="line">        System.out.println(hashMap.containsKey(<span class="string">&quot;lisi&quot;</span>));</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //boolean isEmpty() 如果不包含键值的映射，返回true</span></span><br><span class="line">        System.out.println(hashMap.isEmpty());</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //int size() 返回Map集合中键值映射的数量</span></span><br><span class="line">        System.out.println(hashMap.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Map集合的获取功能</strong><br>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回Map中包含的映射的Set视图。<br>V get(Object key) 返回到指定键所映射的值，或 null如果此映射包含该键的映射。<br>Set keySet() 返回此地图中包含的键的Set视图。<br>Collection values() 返回Map中包含的值的Collection视图。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        HashMap&lt;String, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;String,String&gt;(); </span><br><span class="line">   <span class="comment">//创建元素并添加</span></span><br><span class="line">    hashMap.put(<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;21&quot;</span>);</span><br><span class="line">    hashMap.put(<span class="string">&quot;lisi&quot;</span>,<span class="string">&quot;22&quot;</span>);</span><br><span class="line">    hashMap.put(<span class="string">&quot;wangwu&quot;</span>,<span class="string">&quot;23&quot;</span>);</span><br><span class="line">    hashMap.put(<span class="string">&quot;zhaoliu&quot;</span>,<span class="string">&quot;24&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//V get(Object key)返回到指定键所映射的值，或null，如果此映射包含该键的映射</span></span><br><span class="line">    System.out.println(hashMap.get(<span class="string">&quot;zhangsan&quot;</span>));<span class="comment">//21</span></span><br><span class="line">    System.out.println(hashMap.get(<span class="string">&quot;lisi&quot;</span>));<span class="comment">//22</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Set&lt;K&gt; KeySet() 返回Map中包含所有键的Set集合</span></span><br><span class="line">    Set&lt;String&gt; strings = hashMap.keySet();</span><br><span class="line">    <span class="keyword">for</span>(String s : strings)&#123;</span><br><span class="line">        System.out.println(s);<span class="comment">//返回了所有的Key</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Collection&lt;V&gt; values() 返回Map中包含的值的Collection集合</span></span><br><span class="line">    Collection&lt;String&gt; values = hashMap.values();</span><br><span class="line">    <span class="keyword">for</span>(String s:values)&#123;</span><br><span class="line">        System.out.println(s);<span class="comment">//返回了所有的Value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><ul><li>基于哈希表的Map接口的实现</li><li>哈希表：用来保证键的唯一性</li><li>HashMap&lt;String,String&gt;<br>键：String<br>值：String</li></ul><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><ul><li>是哈希表和链表实现的Map接口，具有可预知的迭代顺序</li><li>由哈希表保证唯一性</li><li>由链表保证顺序，有序（存储和取出的顺序一致）</li><li>底层也是红黑树（结合红黑树、哈希表，查询速度不慢）</li></ul><h4 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h4><ul><li>HashMap中的键和值允许null，而Hashtable不允许键和值存在null</li><li>HashMap是线程不安全的，但是效率高；Hashtable是线程安全的，效率低</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型以及set集合</title>
      <link href="/2020/09/02/%E6%B3%9B%E5%9E%8B%E4%BB%A5%E5%8F%8Aset%E9%9B%86%E5%90%88/"/>
      <url>/2020/09/02/%E6%B3%9B%E5%9E%8B%E4%BB%A5%E5%8F%8Aset%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="泛型以及set集合"><a href="#泛型以及set集合" class="headerlink" title="泛型以及set集合"></a>泛型以及set集合</h1><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p><strong>泛型的介绍</strong><br>泛型：<br>一种把类型明确的工作推迟到创建对象或者调用方法的时候才去明确的类型。参数化类型，把类型当作参数一样传递</p><p><strong>格式：</strong><br>&lt;数据类型&gt;<br>注意：此处的数据类型只能是引用类型</p><p><strong>泛型的好处</strong></p><ul><li>把运行时期的问题提前到了编译时期</li><li>避免了强制类型转换</li><li>优化程序，消除黄色警告线</li><li>泛型的举例应用</li><li>泛型存储String类型数据举例</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    </span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        list.add(100);直接就报错了</span></span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            String r = iterator.next();</span><br><span class="line">            System.out.println(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//world</span></span><br></pre></td></tr></table></figure><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p><strong>泛型类：把泛型定义在类上</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTool</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getObj</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(T obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericTool genericTool = <span class="keyword">new</span> GenericTool();</span><br><span class="line">        genericTool.setObj(<span class="keyword">new</span> String(<span class="string">&quot;zhangsan&quot;</span>));</span><br><span class="line">        Object obj = genericTool.getObj();</span><br><span class="line">        String obj1 = (String) obj;</span><br><span class="line">        System.out.println(obj1);</span><br><span class="line"></span><br><span class="line">        genericTool.setObj(<span class="keyword">new</span> String(<span class="string">&quot;lisi&quot;</span>));</span><br><span class="line">        Object obj2 = genericTool.getObj();</span><br><span class="line">        String obj21 = (String) obj2;</span><br><span class="line">        System.out.println(obj21);</span><br><span class="line">    </span><br><span class="line">        GenericTool&lt;String&gt; stringGenericTool = <span class="keyword">new</span> GenericTool&lt;String&gt;();</span><br><span class="line">        stringGenericTool.setObj(<span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">        String obj3 = stringGenericTool.getObj();</span><br><span class="line">        System.out.println(obj3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//zhangsan</span></span><br><span class="line"><span class="comment">//lisi</span></span><br><span class="line"><span class="comment">//wangwu</span></span><br></pre></td></tr></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTool2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericTool2 genericTool2 = <span class="keyword">new</span> GenericTool2();</span><br><span class="line">        genericTool2.show(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        genericTool2.show(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        genericTool2.show(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//world</span></span><br><span class="line"><span class="comment">//java</span></span><br></pre></td></tr></table></figure><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericTool3</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTool3Impl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">GenericTool3</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一种情况测试</span></span><br><span class="line">        GenericTool3Impl&lt;String&gt; tool3 = <span class="keyword">new</span> GenericTool3Impl&lt;&gt;();</span><br><span class="line">        tool3.show(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种情况测试</span></span><br><span class="line">        GenericTool3Impl&lt;Integer&gt; tool31 = <span class="keyword">new</span> GenericTool3Impl&lt;&gt;();</span><br><span class="line">        tool31.show(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//100</span></span><br></pre></td></tr></table></figure><h3 id="泛型高级"><a href="#泛型高级" class="headerlink" title="泛型高级"></a>泛型高级</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 泛型高级用法（通配符）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 泛型通配符&lt;?&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 任意类型，如果没有明确，那么就是Object以及任意的Java类了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * ? extends E</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 向下限定，E及其子类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * ? super E</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 向上限定，E及其父类</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo2</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//如果用一个的时候，泛型如果明确了类型的时候，前后必须要写一致</span></span><br><span class="line">       ArrayList&lt;Object&gt; a1 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">   <span class="comment">//        ArrayList&lt;Object&gt; a2 = new ArrayList&lt;Animal&gt;();</span></span><br><span class="line">   <span class="comment">//        ArrayList&lt;Object&gt; a3 = new ArrayList&lt;Dog&gt;();</span></span><br><span class="line">   <span class="comment">//        ArrayList&lt;Object&gt; a4 = new ArrayList&lt;Cat&gt;();</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//型通配符&lt;?&gt;</span></span><br><span class="line">       <span class="comment">//  任意类型，如果没有明确，那么就是Object以及任意的Java类了</span></span><br><span class="line">       <span class="comment">//还没有明确类型</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//        ArrayList&lt;?&gt; list1 = new ArrayList&lt;Object&gt;();</span></span><br><span class="line">   <span class="comment">//        ArrayList&lt;?&gt; list2 = new ArrayList&lt;Dog&gt;();</span></span><br><span class="line">   <span class="comment">//        ArrayList&lt;?&gt; list3 = new ArrayList&lt;Cat&gt;();</span></span><br><span class="line">   <span class="comment">//        ArrayList&lt;?&gt; list4 = new ArrayList&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//? extends E</span></span><br><span class="line">        <span class="comment">//   向下限定，E及其子类</span></span><br><span class="line">        ArrayList&lt;? extends Animal&gt; o1 = <span class="keyword">new</span> ArrayList&lt;Animal&gt;();</span><br><span class="line">        ArrayList&lt;? extends Animal&gt; o2 = <span class="keyword">new</span> ArrayList&lt;Dog&gt;();</span><br><span class="line">        ArrayList&lt;? extends Animal&gt; o3 = <span class="keyword">new</span> ArrayList&lt;Cat&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        ArrayList&lt;? extends Animal&gt; o4 = new ArrayList&lt;Object&gt;();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//? super E</span></span><br><span class="line">        <span class="comment">//  向上限定，E及其父类</span></span><br><span class="line">        ArrayList&lt;? <span class="keyword">super</span> Animal&gt; alist1 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        ArrayList&lt;? super Animal&gt; alist2 = new ArrayList&lt;Dog&gt;();</span></span><br><span class="line"><span class="comment">//        ArrayList&lt;? super Animal&gt; alist3 = new ArrayList&lt;Cat&gt;();</span></span><br><span class="line">        ArrayList&lt;? <span class="keyword">super</span> Animal&gt; alist4 = <span class="keyword">new</span> ArrayList&lt;Animal&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h2><h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><p><strong>Set接口的引入</strong></p><p>Collection接口下有List和Set接口</p><p>List 元素有序（存储顺序和取出顺序一致，可以重复）<br>Set 无序（存储顺序和取出顺序不一致，元素唯一）<br>HashSet：底层是hash表，线程不安全，效率高，有时候，给的顺序正好好存储的顺序一致，但这并不代表有序，可以多试试看，元素唯一，无序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;String&gt; hashSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建字符串对象并添加到集合中</span></span><br><span class="line">        hashSet.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(String s:hashSet)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//world</span></span><br><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="comment">//hello</span></span><br></pre></td></tr></table></figure><h4 id="HashSet类"><a href="#HashSet类" class="headerlink" title="HashSet类"></a><strong>HashSet类</strong></h4><p>HashSet类概述<br>不保证set的迭代顺序<br>特别是不保证该顺序恒久不变</p><p><strong>HashSet如何保证元素的唯一性</strong><br>底层数据结构是哈希表（元素是链表的数组）<br>哈希表依赖于哈希值存储<br>添加功能底层依赖的两个方法<br>int hashCode()<br>boolean equals(Object obj)<br>public static void main(String[] args) {<br>HashSet中add方法的源码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//由哈希表（实际为HashMap实例）支持</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123; <span class="comment">//key -- e -- 要插入的元素</span></span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123; <span class="comment">//key -- e -- 要插入的元素</span></span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//HashSet中的add()方法，最终我们发现调用的是HashMap中的putVal()方法</span></span><br><span class="line">    <span class="comment">//hash的值与元素的HashCode()方法有关</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//哈希表存储的是一个个的节点数组</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//判断哈希表是否初始化，如果没有初始化就进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//根据元素对象的哈希值计算出存储位置，如果该元素的位置是null就代表，该位置没有</span></span><br><span class="line">        <span class="comment">//元素，就创建新的节点，就存储元素</span></span><br><span class="line">        <span class="comment">//通过源码我们发现，HashSet的add()方法一定和HashCode()方法有关系</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                存入的元素和以前的元素的哈希值进行比较</span></span><br><span class="line"><span class="comment">                    如果哈希值不同，继续向下执行，把元素添加到集合</span></span><br><span class="line"><span class="comment">                    如果哈希值一样，会调用对象的equals()方法进行比较</span></span><br><span class="line"><span class="comment">                        如果返回的是false，会继续向下执行，然后将元素添加到集合中</span></span><br><span class="line"><span class="comment">                        如果返回的是true,说明元素内容一样，重复了，就不存储</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p>LinkedHashSet：底层由哈希表和链表组成<br>哈希表保证元素的唯一性<br>链表保证元素的顺序，有序，（存储和取出的顺序一致）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        LinkedHashSet&lt;String&gt; strings = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;();</span><br><span class="line">    </span><br><span class="line">        strings.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        strings.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        strings.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(String s:strings)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//world</span></span><br><span class="line"><span class="comment">//java</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>List集合的练习</title>
      <link href="/2020/09/02/List%E9%9B%86%E5%90%88%E7%9A%84%E7%BB%83%E4%B9%A0/"/>
      <url>/2020/09/02/List%E9%9B%86%E5%90%88%E7%9A%84%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="List集合的练习"><a href="#List集合的练习" class="headerlink" title="List集合的练习"></a>List集合的练习</h1><h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h2><h3 id="List子集的特点"><a href="#List子集的特点" class="headerlink" title="List子集的特点"></a><strong>List子集的特点</strong></h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList:"></a><strong>ArrayList:</strong></h4><ul><li>底层结构是数组，查询快，增删慢</li><li>线程不是安全的，效率高</li></ul><p>ArrayList存储字符串并遍历代码举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList arr = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        arr.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        arr.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        arr.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        Iterator iterator = arr.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Object next = iterator.next();</span><br><span class="line">            String next1 = (String) next;</span><br><span class="line">            System.out.println(next1);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;*************&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.size();i++)&#123;</span><br><span class="line">            Object o = arr.get(i);</span><br><span class="line">            String o1 = (String) o;</span><br><span class="line">            System.out.println(o1);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//world</span></span><br><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="comment">//*************</span></span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//world</span></span><br><span class="line"><span class="comment">//java</span></span><br></pre></td></tr></table></figure><p>ArrayList存储自定义对象并遍历，代码举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    </span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        Student s3 = <span class="keyword">new</span> Student(<span class="string">&quot;王五&quot;</span>, <span class="number">23</span>);</span><br><span class="line">    </span><br><span class="line">        list.add(s1);</span><br><span class="line">        list.add(s2);</span><br><span class="line">        list.add(s3);</span><br><span class="line">    </span><br><span class="line">        Iterator iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Object next = iterator.next();</span><br><span class="line">            Student next1 = (Student) next;</span><br><span class="line">            System.out.println(next1.getName()+<span class="string">&quot;---&quot;</span>+next1.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;****************&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            Object o = list.get(i);</span><br><span class="line">            Student o1 = (Student) o;</span><br><span class="line">            System.out.println(o1.getName()+<span class="string">&quot;---&quot;</span>+o1.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//张三---21</span></span><br><span class="line"><span class="comment">//李四---22</span></span><br><span class="line"><span class="comment">//王五---23</span></span><br><span class="line"><span class="comment">//****************</span></span><br><span class="line"><span class="comment">//张三---21</span></span><br><span class="line"><span class="comment">//李四---22</span></span><br><span class="line"><span class="comment">//王五---23</span></span><br></pre></td></tr></table></figure><h5 id="使用ArrayList去除集合中字符串的重复值（字符串的内容相同）"><a href="#使用ArrayList去除集合中字符串的重复值（字符串的内容相同）" class="headerlink" title="使用ArrayList去除集合中字符串的重复值（字符串的内容相同）"></a>使用ArrayList去除集合中字符串的重复值（字符串的内容相同）</h5><h6 id="方式一：在不同的集合上操作"><a href="#方式一：在不同的集合上操作" class="headerlink" title="方式一：在不同的集合上操作"></a>方式一：在不同的集合上操作</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个集合对象，添加元素</span></span><br><span class="line">    <span class="comment">//创建一个新的集合对象</span></span><br><span class="line">    <span class="comment">//遍历旧的集合对象，获取到每个元素</span></span><br><span class="line">    <span class="comment">//拿新的集合去找，看有没有，没有就加进去，有，就跳过</span></span><br><span class="line">    <span class="comment">//遍历新的集合</span></span><br><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">ArrayList new_list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="comment">//遍历旧的集合</span></span><br><span class="line">Iterator iterator = list.iterator();</span><br><span class="line">System.out.println(<span class="string">&quot;原来的集合：&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    Object next = iterator.next();</span><br><span class="line">    String next1 = (String) next;</span><br><span class="line">    System.out.println(next1);</span><br><span class="line">    <span class="keyword">if</span>(!new_list.contains(next1))&#123;</span><br><span class="line">        new_list.add(next1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;去除集合中字符串的重复值之后的集合：&quot;</span>);</span><br><span class="line"><span class="comment">//遍历新的集合</span></span><br><span class="line">Iterator iterator1 = new_list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator1.hasNext())&#123;</span><br><span class="line">    Object next = iterator1.next();</span><br><span class="line">    String next1 = (String) next;</span><br><span class="line"></span><br><span class="line">    System.out.println(next1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="方式二：在同一个集合上操作"><a href="#方式二：在同一个集合上操作" class="headerlink" title="方式二：在同一个集合上操作"></a>方式二：在同一个集合上操作</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;spark&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;spark&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//利用选择排序的思想</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;list.size();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(list.get(i).equals(list.get(j)))&#123;</span><br><span class="line">                    list.remove(j);</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        Iterator iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Object next = iterator.next();</span><br><span class="line">            String next1 = (String) next;</span><br><span class="line">            System.out.println(next1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//world</span></span><br><span class="line"><span class="comment">//spark</span></span><br></pre></td></tr></table></figure><h5 id="使用ArrayList去除自定义类中的重复值"><a href="#使用ArrayList去除自定义类中的重复值" class="headerlink" title="使用ArrayList去除自定义类中的重复值"></a>使用ArrayList去除自定义类中的重复值</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    Student()&#123;&#125;</span><br><span class="line">    Student(String name,<span class="keyword">int</span> age)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListDemo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    </span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>,<span class="number">21</span>);</span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;李四&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        Student s3 = <span class="keyword">new</span> Student(<span class="string">&quot;王五&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        Student s4 = <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>,<span class="number">21</span>);</span><br><span class="line">    </span><br><span class="line">        list.add(s1);</span><br><span class="line">        list.add(s2);</span><br><span class="line">        list.add(s3);</span><br><span class="line">        list.add(s4);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//创建新的集合</span></span><br><span class="line">        ArrayList list1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    </span><br><span class="line">        Iterator iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Object next = iterator.next();</span><br><span class="line">            Student next1 = (Student) next;</span><br><span class="line">            <span class="keyword">if</span>(!list1.contains(next1))&#123;</span><br><span class="line">                list1.add(next1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        Iterator iterator1 = list1.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator1.hasNext())&#123;</span><br><span class="line">            Object next = iterator1.next();</span><br><span class="line">            Student next1 = (Student) next;</span><br><span class="line">            System.out.println(next1.getName()+<span class="string">&quot;---&quot;</span>+next1.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//张三---21</span></span><br><span class="line"><span class="comment">//李四---22</span></span><br><span class="line"><span class="comment">//王五---23</span></span><br><span class="line"><span class="comment">//张三---21</span></span><br></pre></td></tr></table></figure><p>但这里我们发现一个问题，我们按照规定的思维，发现并没有去除重复的元素<br>通过查看源码我们发现，contain()的方法底层依赖的是equals()方法，由于我们的Student1类中并没有重写equals()方法，所以它默认调用的是父亲Object的equals()方法，而父亲的equals()方法比较的是地址值，每个学生对象被new出来的时候，地址值是一定不同的，所以比较地址值都是true，所以结果没有生效。</p><p>解决办法：<br>   重写equals方法，不需要我们重写，自动生效即可<br>建议：<br>   每次创建类的时候，都重写一些equals方法</p><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p><strong>LinkedList集合</strong></p><ul><li>底层结构是链表，查询慢，增删快</li><li>线程是不安全的，效率高</li></ul><p><strong>LinkedList的特有功能</strong></p><ul><li>添加功能<ul><li>void addFirst(E e) 在该列表开头插入指定元素</li><li>void addLast(E e) 将指定的元素追加到此列表的末尾</li></ul></li><li>获取参数<ul><li>E getFirst() 返回此列表中的第一个元素</li><li>E getLast() 返回此列表中的最后一个元素</li></ul></li><li>删除功能<ul><li>E removeFirst() 从此列表中删除并返回第一个元素</li><li>E removeLast() 从此列表中删除并返回最后一个元素</li></ul></li></ul><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p><strong>Vector</strong></p><ul><li>底层结构是数组，查询快，增删慢</li><li>线程是安全的，效率低</li></ul><p><strong>Vector的特有功能</strong></p><ul><li><p>添加功能</p><ul><li>void addElement(Object object)将指定组件添加到此向量的末尾，将其大小增加1</li></ul></li><li><p>获取功能</p><ul><li>Object elementAt(int index) 返回指定索引处的元素 –get()</li><li>Enumeration elements() 返回此向量的组件的容器。–list.iterator()</li><li>boolean hasMoreElements() 测试此容器是否包含更多元素。 –hasNext()</li><li>E nextElement() 如果此容器对象至少有一个要提供的元素，则返回此容器的下一个元素。–next()</li></ul></li></ul><p>代码举例:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Vector vector = <span class="keyword">new</span> Vector();</span><br><span class="line">        vector.addElement(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        vector.addElement(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        vector.addElement(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        Enumeration elements = vector.elements();</span><br><span class="line">        <span class="keyword">while</span> (elements.hasMoreElements())&#123;</span><br><span class="line">            Object o = elements.nextElement();</span><br><span class="line">            String o1 = (String) o;</span><br><span class="line">            System.out.println(o1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//world</span></span><br><span class="line"><span class="comment">//java</span></span><br></pre></td></tr></table></figure><h4 id="List子类面试题（List子类的特点）"><a href="#List子类面试题（List子类的特点）" class="headerlink" title="List子类面试题（List子类的特点）"></a>List子类面试题（List子类的特点）</h4><p><strong>ArrayList：</strong><br>底层是数组，查询快，增删慢<br>线程不是安全的，效率高<br><strong>Vector：</strong><br>底层结构是数组，查询快，增删慢<br>线程是安全的，效率低<br><strong>LinkedList：</strong><br>底层结构是链表，查询慢，增删块<br>线程不是安全的，效率高<br>实际应用的时候，看实际需求：<br>需要线程安全：<br><strong>Vector</strong><br>不需要：ArrayList、Linkedlist<br>查询业务比较多：ArrayList<br>增删业务比较多：LinkedList<br>不知道选什么：ArrayList</p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合以及迭代器</title>
      <link href="/2020/09/02/%E9%9B%86%E5%90%88%E4%BB%A5%E5%8F%8A%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
      <url>/2020/09/02/%E9%9B%86%E5%90%88%E4%BB%A5%E5%8F%8A%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="集合以及迭代器"><a href="#集合以及迭代器" class="headerlink" title="集合以及迭代器"></a>集合以及迭代器</h1><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="集合的概述"><a href="#集合的概述" class="headerlink" title="集合的概述"></a>集合的概述</h3><p><strong>我们为什么要用集合</strong></p><p>我们所学的Java，是一门面向对象的语言，面向对象是基于描述现实事物而存在的，一旦我们所用的数据多了起来，我们就必须要对这些对象进行存储，我们存储之后，就不能是定义一个遍历了，我们需要一个类似于数组这样的容器来进行存储。<br>到现在为止，已经记录了数组、StringBuffer。但都有一些弊端，StringBuffer的结果是一个字符串，我们在显示业务中，大多数都是以对象的形式进行存储，这样的话，StringBuffer就不满足了，只能选择数组，而数组存储的是对象引用，这样的对象称之为对象数组。<br>对象数组也不能满足我们一些业务需求的变化，因为数组的长度唯一，这时，为了适应变化，Java提供了一个技术来解决这样的问题，也就是：集合。</p><h4 id="数组和集合的区别"><a href="#数组和集合的区别" class="headerlink" title="数组和集合的区别"></a>数组和集合的区别</h4><ul><li>长度：<br>数组的长度唯一<br>集合的长度不唯一、可变、弹性</li><li>内容不同：<br>数组存储的元素类型是一致的、统一的<br>集合可以存储不同类型的元素</li><li>元素的数据类型：<br>数组可以存储基本数据类型，也可以存储引用数据类型<br>集合只能存储引用数据类型</li></ul><p>有关集合的一个小图<br>我们可以看到Collection、List都是接口，下面的Arraylist、LinkedList才是实现类</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904135730.png"></p><h3 id="Connection集合"><a href="#Connection集合" class="headerlink" title="Connection集合"></a>Connection集合</h3><p>是所有集合的顶层接口，存在着一些可以重复元素的集合，一些不可以重复元素的集合，有些有序，有些无序</p><h4 id="添加功能"><a href="#添加功能" class="headerlink" title="添加功能"></a>添加功能</h4><ul><li>boolean add(E e) 确保此集合包含指定的元素（可选操作）。</li><li>boolean addAll(Collection&lt;? extends E&gt; c) 将指定集合中的所有元素添加到此集合（可选操作）</li></ul><p><strong>boolean add(E e) ：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接口不能被实例化</span></span><br><span class="line"><span class="comment">//        List list = new List();</span></span><br><span class="line">        Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//boolean add(E e)  确保此集合包含指定的元素（可选操作）</span></span><br><span class="line">    c.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">     c.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    System.out.println(c);<span class="comment">//[hello, world]</span></span><br></pre></td></tr></table></figure><p><strong>boolean addAll(Collection&lt;? extends E&gt; c)</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="comment">//boolean add(E e)  确保此集合包含指定的元素（可选操作）</span></span><br><span class="line">c.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">System.out.println(c);<span class="comment">//[hello, world]</span></span><br><span class="line"></span><br><span class="line">Collection c1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">c1.addAll(c);</span><br><span class="line">System.out.println(c1);<span class="comment">//[hello, world]</span></span><br></pre></td></tr></table></figure><h4 id="删除功能"><a href="#删除功能" class="headerlink" title="删除功能"></a>删除功能</h4><p>void clear() 从此集合中删除所有元素（可选操作）。</p><p>boolean remove(Object o) 从该集合中删除指定元素的单个实例（如果存在）（可选操作）。</p><p>boolean removeAll(Collection&lt;?&gt; c) 删除指定集合中包含的所有此集合的元素（可选操作）。</p><p><strong>void clear()</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        <span class="comment">//接口不能被实例化</span></span><br><span class="line"><span class="comment">//        List list = new List();</span></span><br><span class="line">        Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//boolean add(E e)  确保此集合包含指定的元素（可选操作）</span></span><br><span class="line">        c.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        System.out.println(c);<span class="comment">//[hello, world]</span></span><br><span class="line"></span><br><span class="line">        c.clear();</span><br><span class="line">        System.out.println(c);<span class="comment">//[]</span></span><br></pre></td></tr></table></figure><p><strong>boolean remove(Object o)</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">       <span class="comment">//接口不能被实例化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        List list = new List();</span></span><br><span class="line">        Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//boolean add(E e)  确保此集合包含指定的元素（可选操作）</span></span><br><span class="line">        c.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        System.out.println(c);<span class="comment">//[hello, world]</span></span><br><span class="line">    </span><br><span class="line">        c.remove(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(c);<span class="comment">//[world]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//只删除了hello</span></span><br></pre></td></tr></table></figure><p><strong>boolean removeAll(Collection&lt;?&gt; c)</strong><br>只删除包含该集合的元素：<br>c中只删除了c1中和它重复的元素</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//接口不能被实例化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        List list = new List();</span></span><br><span class="line">        Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        Collection c1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="comment">//boolean add(E e)  确保此集合包含指定的元素（可选操作）</span></span><br><span class="line">        c.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        System.out.println(c);<span class="comment">//[hello, world]</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;**********删除之后*************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        c1.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        c.removeAll(c1);</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[hello, world, java]</span></span><br><span class="line"><span class="comment">//**********删除之后*************</span></span><br><span class="line"><span class="comment">//[world, java]</span></span><br></pre></td></tr></table></figure><h4 id="判断功能"><a href="#判断功能" class="headerlink" title="判断功能"></a>判断功能</h4><p>boolean contains(Object o) 如果此集合包含指定的元素，则返回 true 。<br>boolean containsAll(Collection&lt;?&gt; c) 如果此集合包含指定 集合中的所有元素，则返回true。<br>boolean isEmpty() 如果此集合不包含元素，则返回 true 。</p><p><strong>boolean contains(Object o)</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//接口不能被实例化</span></span><br><span class="line"><span class="comment">//        List list = new List();</span></span><br><span class="line">        Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        Collection c1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="comment">//boolean add(E e)  确保此集合包含指定的元素（可选操作）</span></span><br><span class="line">        c.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        System.out.println(c);<span class="comment">//[hello, world]</span></span><br><span class="line"></span><br><span class="line">    System.out.println(c.contains(<span class="string">&quot;hello&quot;</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><strong>boolean containsAll</strong><br>c中包含了c1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">Collection c1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="comment">//boolean add(E e)  确保此集合包含指定的元素（可选操作）</span></span><br><span class="line">c.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">System.out.println(c);<span class="comment">//[hello, world]</span></span><br><span class="line"></span><br><span class="line">c1.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(c.containsAll(c1));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><strong>boolean isEmpty()</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">   Collection c1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">   <span class="comment">//boolean add(E e)  确保此集合包含指定的元素（可选操作）</span></span><br><span class="line">   c.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">   c.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">   c.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">   System.out.println(c);<span class="comment">//[hello, world]</span></span><br><span class="line">System.out.println(c.isEmpty());<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">c.clear();</span><br><span class="line"></span><br><span class="line">System.out.println(c.isEmpty());<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h4><p>按照顺序一个一个取出元素，Object[] toArray()把集合转化成数组，可以实现集合的遍历<br>注意：遍历集合中的元素，里面的元素获取到之后需要向下转型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection c = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        c.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        <span class="comment">//将集合转换成数组</span></span><br><span class="line">        Object[] objects = c.toArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;objects.length;i++)&#123;</span><br><span class="line">            <span class="comment">//输出的内容是String类型，但是上面的objects是Object类型，需要向下转型</span></span><br><span class="line">            String objects1 = (String) objects[i];</span><br><span class="line">            System.out.println(objects1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//world</span></span><br><span class="line"><span class="comment">//java</span></span><br></pre></td></tr></table></figure><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>Iterator iterator() 迭代器，集合的专用遍历方式<br>两个方法：</p><ul><li>boolean hasNext() 如果迭代具有更多的元素，就返回true</li><li>E next() 返回迭代中的下一个元素，获取元素<br>NoSuchElementException - 如果迭代没有更多的元素，报这个错</li></ul><p><strong>迭代器遍历</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        c.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        Iterator iterator = c.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Object next = iterator.next();</span><br><span class="line">            String next1 = (String) next;</span><br><span class="line">            System.out.println(next1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//world</span></span><br><span class="line"><span class="comment">//java</span></span><br></pre></td></tr></table></figure><p><strong>使用迭代器遍历集合中的元素</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        Student1 s1 = <span class="keyword">new</span> Student1(<span class="string">&quot;张三&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        Student1 s2 = <span class="keyword">new</span> Student1(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">        c.add(s1);</span><br><span class="line">        c.add(s2);</span><br><span class="line">    </span><br><span class="line">        Iterator iterator = c.iterator();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Object next = iterator.next();</span><br><span class="line">            Student1 next1 = (Student1) next;</span><br><span class="line">            System.out.println(next1.getName()+<span class="string">&quot;---&quot;</span>+next1.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//张三---21</span></span><br><span class="line"><span class="comment">//李四---22</span></span><br></pre></td></tr></table></figure><p><strong>使用迭代器遍历字符串中的元素</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        c.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Iterator iterator = c.iterator();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Object next = iterator.next();</span><br><span class="line">            String next1 = (String) next;</span><br><span class="line">            System.out.println(next1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//world</span></span><br><span class="line"><span class="comment">//java</span></span><br></pre></td></tr></table></figure><p>有关使用迭代器的一个小思考</p><p>我们可以看到，迭代器是遍历集合的一种方式，那为什么我们不把迭代器直接定义为一个类呢，这样直接用的话不是方便很多吗，为什么迭代器是一个接口呢。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210904150535.png"></p><p><strong>迭代器源码</strong><br>我们看到这里面，Collection和List一个继承于Iterable，一个继承于Collection，里面都有一个Iterator()方法，该方法时实现了Iterator接口，Iterator接口中有迭代器的hasNext()和next()方法，最后时Arraylist类中的Itr实现了迭代器的两个方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function">Object <span class="title">next</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span></span>&#123;</span><br><span class="line">    <span class="function">Iterator <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span> <span class="keyword">extends</span> <span class="title">Iterable</span></span>&#123;</span><br><span class="line">    <span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span> <span class="keyword">extends</span> <span class="title">Collection</span></span>&#123;</span><br><span class="line">    <span class="function">Iterator <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> <span class="keyword">implements</span> <span class="title">List</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h3><p>特点：有序集合（存储和取出的顺序一致），可以有重复元素</p><p><strong>List集合中字符串的遍历</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        Iterator iterator = list.iterator();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Object next = iterator.next();</span><br><span class="line">            String next1 = (String) next;</span><br><span class="line">            System.out.println(next1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//world</span></span><br><span class="line"><span class="comment">//java</span></span><br></pre></td></tr></table></figure><p><strong>存储自定义对象并遍历</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        Student1 s1 = <span class="keyword">new</span> Student1(<span class="string">&quot;张三&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        Student1 s2 = <span class="keyword">new</span> Student1(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>);</span><br><span class="line">    </span><br><span class="line">        list.add(s1);</span><br><span class="line">        list.add(s2);</span><br><span class="line">    </span><br><span class="line">        Iterator iterator = list.iterator();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Object next = iterator.next();</span><br><span class="line">            Student1 next1 = (Student1) next;</span><br><span class="line">            System.out.println(next1.getName()+<span class="string">&quot;---&quot;</span>+next1.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//张三---21</span></span><br><span class="line"><span class="comment">//李四---22</span></span><br></pre></td></tr></table></figure><h4 id="List集合添加功能"><a href="#List集合添加功能" class="headerlink" title="List集合添加功能"></a>List集合添加功能</h4><p>void add(int index, E element) 将指定的元素插入此列表中的指定位置（可选操作）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        System.out.println(list);<span class="comment">//[hello, world, java]</span></span><br><span class="line">        list.add(<span class="number">1</span>,<span class="string">&quot;hadoop&quot;</span>);</span><br><span class="line">        System.out.println(list);<span class="comment">//[hello, hadoop, world, java]</span></span><br></pre></td></tr></table></figure><h4 id="List集合获取功能"><a href="#List集合获取功能" class="headerlink" title="List集合获取功能"></a>List集合获取功能</h4><p>E get(int index) 返回此列表中指定位置的元素。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        System.out.println(list);<span class="comment">//[hello, world, java]</span></span><br><span class="line">        list.add(<span class="number">1</span>,<span class="string">&quot;hadoop&quot;</span>);</span><br><span class="line">        System.out.println(list);<span class="comment">//[hello, hadoop, world, java]</span></span><br><span class="line"></span><br><span class="line">        System.out.println(list.get(<span class="number">1</span>));<span class="comment">//hadoop</span></span><br></pre></td></tr></table></figure><h4 id="删除功能-1"><a href="#删除功能-1" class="headerlink" title="删除功能"></a>删除功能</h4><p>E remove(int index) 删除该列表中指定位置的元素（可选操作）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        System.out.println(list);<span class="comment">//[hello, world, java]</span></span><br><span class="line">        list.add(<span class="number">1</span>,<span class="string">&quot;hadoop&quot;</span>);</span><br><span class="line">        System.out.println(list);<span class="comment">//[hello, hadoop, world, java]</span></span><br><span class="line"></span><br><span class="line">    System.out.println(list.get(<span class="number">1</span>));<span class="comment">//hadoop</span></span><br><span class="line">    System.out.println(list.remove(<span class="number">1</span>));<span class="comment">//hadoop</span></span><br></pre></td></tr></table></figure><h4 id="修改功能"><a href="#修改功能" class="headerlink" title="修改功能"></a>修改功能</h4><p>E set(int index, E element) 用指定的元素（可选操作）替换此列表中指定位置的元素</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        System.out.println(list);<span class="comment">//[hello, world, java]</span></span><br><span class="line">        list.add(<span class="number">1</span>,<span class="string">&quot;hadoop&quot;</span>);</span><br><span class="line">        System.out.println(list);<span class="comment">//[hello, hadoop, world, java]</span></span><br><span class="line"></span><br><span class="line">    System.out.println(list.get(<span class="number">1</span>));<span class="comment">//hadoop</span></span><br><span class="line">    System.out.println(list.remove(<span class="number">1</span>));<span class="comment">//hadoop</span></span><br><span class="line">    System.out.println(list);<span class="comment">//[hello,world,java]</span></span><br><span class="line"></span><br><span class="line">    list.set(<span class="number">1</span>,<span class="string">&quot;hadoop&quot;</span>);</span><br><span class="line">    System.out.println(list);<span class="comment">//[hello,hadoop,java]</span></span><br></pre></td></tr></table></figure><p><strong>列表迭代器</strong><br>ListIterator listIterator() 返回列表中的列表迭代器（按适当的顺序）。<br>是List特有的迭代器，该迭代器继承了Iterator，所以也有hasNext和next方法<br>List是继承自Collection，有父类的功能，也有自己的特有功能：<br>E previous() 返回列表中的上一个元素，并向后移动光标位置。<br>boolean hasPrevious() 返回 true如果遍历反向列表，列表迭代器有多个元素。<br>注意：如果想要逆序遍历，必须先正序遍历一次，才能逆序遍历，一般情况下无意义，一般不使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        ListIterator listIterator = list.listIterator();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> (listIterator.hasNext())&#123;</span><br><span class="line">            Object next = listIterator.next();</span><br><span class="line">            String next1 = (String) next;</span><br><span class="line">            System.out.println(next1);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;*********************&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(listIterator.hasPrevious())&#123;</span><br><span class="line">            Object previous = listIterator.previous();</span><br><span class="line">            String previous1 = (String) previous;</span><br><span class="line">            System.out.println(previous1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//world</span></span><br><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="comment">//*********************</span></span><br><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="comment">//world</span></span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line">特有功能：get、size</span><br><span class="line"> List list = <span class="keyword">new</span> ArrayList();</span><br></pre></td></tr></table></figure><p><strong>并发修改异常</strong><br>我们现在有一个问题，我们打算判断集合中有没有“world”这个元素，如果有的话，我们就添加一个”hadoop”<br>ConcurrentModificationException:并发修改异常。当方法里面检测到对象的并发修改的时候但是，这里不允许修改时，就会抛出这种异常<br>为什么会出现这种异常呢？<br>迭代器是依赖于集合存在的，在判断成功之后，集合中添加了新的元素，但是迭代器不知道，所以就报错了，这就是并发修改异常。<br>也就是说，迭代器遍历元素的时候，集合是不能修改元素的</p><p>怎么解决呢<br>1、迭代器遍历元素，迭代器修改元素<br>添加的元素紧跟在刚刚迭代到的元素后面<br>2、集合遍历元素，集合修改元素<br>添加的元素在最后一个</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">            list.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Iterator iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        Object next = iterator.next();</span><br><span class="line">        String next1 = (String) next;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;world&quot;</span>.equals(next1))&#123;</span><br><span class="line">            list.add(<span class="string">&quot;hadoop&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这就会出现并发修改异常ConcurrentModificationException</span></span><br><span class="line">或者这种情况也会出现并发修改异常（正确的代码里面，Iterator it = c.iterator() 应该放到c.add()后面，放到前面的话，就意味着先有了迭代器，之后再去修改数组，也会出现并发修改异常，也就是迭代器和数组不是同时被改变）</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    Student1 s1 = <span class="keyword">new</span> Student1(<span class="string">&quot;张三&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    Student1 s2 = <span class="keyword">new</span> Student1(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>);</span><br><span class="line">    Student1 s3 = <span class="keyword">new</span> Student1(<span class="string">&quot;王五&quot;</span>, <span class="number">23</span>);</span><br><span class="line">    Student1 s4 = <span class="keyword">new</span> Student1(<span class="string">&quot;赵六&quot;</span>, <span class="number">24</span>);</span><br><span class="line">    Student1 s5 = <span class="keyword">new</span> Student1(<span class="string">&quot;张三&quot;</span>, <span class="number">28</span>);</span><br><span class="line"></span><br><span class="line">    Iterator it = c.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将Student类对象添加进集合中</span></span><br><span class="line">    c.add(s2);</span><br><span class="line">    c.add(s3);</span><br><span class="line">    c.add(s4);</span><br><span class="line">    c.add(s5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        Object next = it.next();</span><br><span class="line">        Student1 s = (Student1) next;</span><br><span class="line">        System.out.println(s.getName() + <span class="string">&quot;---&quot;</span> + s.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并发修改异常的解决办法"><a href="#并发修改异常的解决办法" class="headerlink" title="并发修改异常的解决办法"></a>并发修改异常的解决办法</h3><p><strong>使用集合遍历元素，集合修改元素<br>使用迭代器遍历元素，迭代器修改元素</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//迭代器遍历元素，迭代器修改元素</span></span><br><span class="line">         List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        ListIterator listIterator = list.listIterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            Object o = list.get(i);</span><br><span class="line">            String o1 = (String) o;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;world&quot;</span>.equals(o1))&#123;</span><br><span class="line">                list.add(<span class="string">&quot;hadoop&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里在使用的时候，要注意重新创建一个新的迭代器，原来修改的数据依旧在list中，需要一个新的迭代器来输出。</span></span><br><span class="line">        ListIterator listIterator1 = list.listIterator();</span><br><span class="line">        <span class="keyword">while</span> (listIterator1.hasNext())&#123;</span><br><span class="line">            Object next = listIterator1.next();</span><br><span class="line">            String next1 = (String) next;</span><br><span class="line">            System.out.println(next1);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String类以及StringBuffer类</title>
      <link href="/2020/09/02/String%E7%B1%BB%E4%BB%A5%E5%8F%8AStringBuffer%E7%B1%BB/"/>
      <url>/2020/09/02/String%E7%B1%BB%E4%BB%A5%E5%8F%8AStringBuffer%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="String类以及StringBuffer类"><a href="#String类以及StringBuffer类" class="headerlink" title="String类以及StringBuffer类"></a>String类以及StringBuffer类</h1><h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><ul><li>String类的转换功能<ul><li>byte[] getBytes()</li><li>char[] toCharArray()</li><li>static String valueOf(char[] chs)</li><li>static String valueOf(int i)</li><li>String toLowerCase()</li><li>String toUpperCase()</li><li>String toUpperCase()</li><li>String concat(String str)</li></ul></li></ul><p>例如:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo10</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将字符串转换为字节数组</span></span><br><span class="line">        <span class="comment">//byte[] getBytes()</span></span><br><span class="line">        String s = <span class="string">&quot;BigData&quot;</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = s.getBytes();</span><br><span class="line">        System.out.println(bytes);<span class="comment">//打印的只是地址，想要打印内容，需要遍历出来</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bytes.length;i++)&#123;</span><br><span class="line">            System.out.println(bytes[i]);<span class="comment">//打印出来的是ASCII码</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;****************************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将字符串转换为字符数组</span></span><br><span class="line">        <span class="comment">//char[] toCharArray()</span></span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        System.out.println(chars);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;chars.length;i++)&#123;</span><br><span class="line">            System.out.println(chars[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;****************************************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//将字符数组转换为字符串</span></span><br><span class="line">        <span class="comment">//static String valueOf(char[] chs)</span></span><br><span class="line">        String s1 = String.valueOf(chars);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(<span class="string">&quot;****************************************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//将int类型的数据转换成字符串</span></span><br><span class="line">        <span class="comment">//static String valueOf(int i)</span></span><br><span class="line">        String s2 = String.valueOf(<span class="number">100</span>);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(<span class="string">&quot;****************************************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//将字符串中的字符都转成小写</span></span><br><span class="line">        String s3 = s.toLowerCase();</span><br><span class="line">        System.out.println(s3);</span><br><span class="line">        System.out.println(<span class="string">&quot;****************************************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//将字符串中的字符都转成大写</span></span><br><span class="line">        String s4 = s.toUpperCase();</span><br><span class="line">        System.out.println(s4);</span><br><span class="line">        System.out.println(<span class="string">&quot;****************************************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//拼接字符串</span></span><br><span class="line">        <span class="comment">//String concat(String str)</span></span><br><span class="line">        String s5 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        String s6 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        String s7 = s5 + s6;</span><br><span class="line">        String s8 = s5.concat(s6);</span><br><span class="line">        System.out.println(<span class="string">&quot;s5:&quot;</span>+s5);</span><br><span class="line">        System.out.println(<span class="string">&quot;s6:&quot;</span>+s6);</span><br><span class="line">        System.out.println(<span class="string">&quot;s7:&quot;</span>+s7);</span><br><span class="line">        System.out.println(<span class="string">&quot;s8:&quot;</span>+s8);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[B@28d93b30</span></span><br><span class="line"><span class="comment">//66</span></span><br><span class="line"><span class="comment">//105</span></span><br><span class="line"><span class="comment">//103</span></span><br><span class="line"><span class="comment">//68</span></span><br><span class="line"><span class="comment">//97</span></span><br><span class="line"><span class="comment">//116</span></span><br><span class="line"><span class="comment">//97</span></span><br><span class="line"><span class="comment">//****************************************</span></span><br><span class="line"><span class="comment">//BigData</span></span><br><span class="line"><span class="comment">//B</span></span><br><span class="line"><span class="comment">//i</span></span><br><span class="line"><span class="comment">//g</span></span><br><span class="line"><span class="comment">//D</span></span><br><span class="line"><span class="comment">//a</span></span><br><span class="line"><span class="comment">//t</span></span><br><span class="line"><span class="comment">//a</span></span><br><span class="line"><span class="comment">//****************************************</span></span><br><span class="line"><span class="comment">//BigData</span></span><br><span class="line"><span class="comment">//****************************************</span></span><br><span class="line"><span class="comment">//100</span></span><br><span class="line"><span class="comment">//****************************************</span></span><br><span class="line"><span class="comment">//bigdata</span></span><br><span class="line"><span class="comment">//****************************************</span></span><br><span class="line"><span class="comment">//BIGDATA</span></span><br><span class="line"><span class="comment">//****************************************</span></span><br><span class="line"><span class="comment">//s5:hello</span></span><br><span class="line"><span class="comment">//s6:world</span></span><br><span class="line"><span class="comment">//s7:helloworld</span></span><br><span class="line"><span class="comment">//s8:helloworld</span></span><br></pre></td></tr></table></figure><h3 id="String类的其他功能"><a href="#String类的其他功能" class="headerlink" title="String类的其他功能"></a>String类的其他功能</h3><h4 id="替换功能"><a href="#替换功能" class="headerlink" title="替换功能"></a>替换功能</h4><ul><li>String replace(char old,char new)</li><li>String replace(String old,String new)</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line">        String replace = s.replace(<span class="string">&quot;l&quot;</span>, <span class="string">&quot;m&quot;</span>);</span><br><span class="line">        System.out.println(replace);<span class="comment">//HemmoWormd</span></span><br><span class="line">        String replace1 = s.replace(<span class="string">&quot;llo&quot;</span>, <span class="string">&quot;ppl&quot;</span>);</span><br><span class="line">        System.out.println(replace1);<span class="comment">//HepplWorld</span></span><br></pre></td></tr></table></figure><h4 id="去除字符串两空格"><a href="#去除字符串两空格" class="headerlink" title="去除字符串两空格"></a>去除字符串两空格</h4><ul><li>String trim()</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;  HelloWorld   &quot;</span>;</span><br><span class="line">        String trim = s1.trim();</span><br><span class="line">        System.out.println(trim);<span class="comment">//HelloWorld</span></span><br></pre></td></tr></table></figure><h4 id="按字典顺序比较两个字符串"><a href="#按字典顺序比较两个字符串" class="headerlink" title="按字典顺序比较两个字符串"></a>按字典顺序比较两个字符串</h4><ul><li>int compareTo(String str)</li><li>int compareToIgnoreCase(String str)</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s5 = <span class="string">&quot;hello&quot;</span>;<span class="comment">//h的ASCII码104</span></span><br><span class="line">        String s6 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        String s7 = <span class="string">&quot;abc&quot;</span>;<span class="comment">//a的ASCII码97</span></span><br><span class="line">        String s8 = <span class="string">&quot;qwe&quot;</span>;<span class="comment">//q的ASCII码113</span></span><br><span class="line">        String s9 = <span class="string">&quot;hel&quot;</span>;</span><br><span class="line">        System.out.println(s5.compareTo(s6));   <span class="comment">//两个相等，相减为0</span></span><br><span class="line">        System.out.println(s5.compareTo(s7));   <span class="comment">//h的ASCII码和a的ASCII码两个相减，结果是7</span></span><br><span class="line">        System.out.println(s5.compareTo(s8));   <span class="comment">//h的ASCII码和q的ASCII码两个相减，结果是-9</span></span><br><span class="line">        System.out.println(s5.compareTo(s9));   <span class="comment">//前面的都比较完了，剩下几个字符，结果就是几</span></span><br></pre></td></tr></table></figure><h4 id="统计大串中小串出现的次数"><a href="#统计大串中小串出现的次数" class="headerlink" title="统计大串中小串出现的次数"></a>统计大串中小串出现的次数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入大串&quot;</span>);</span><br><span class="line">        String maxString = sc.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入小串&quot;</span>);</span><br><span class="line">        String minString = sc.next();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = findString(maxString,minString);</span><br><span class="line">    System.out.println(<span class="string">&quot;大串中小串出现的次数为：&quot;</span>+result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findString</span><span class="params">(String maxString,String minString)</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义出现的次数</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//大串中小串的位置</span></span><br><span class="line">    <span class="keyword">int</span> index = maxString.indexOf(minString);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(index == -<span class="number">1</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;大串中没有这个小串&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (index != -<span class="number">1</span>)&#123;</span><br><span class="line">        count ++;</span><br><span class="line">        <span class="comment">//被截取的长度</span></span><br><span class="line">        <span class="keyword">int</span> startindex = index + minString.length();</span><br><span class="line">        maxString = maxString.substring(startindex);</span><br><span class="line">        index = maxString.indexOf(minString);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h2><h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><h4 id="StringBuffer："><a href="#StringBuffer：" class="headerlink" title="StringBuffer："></a>StringBuffer：</h4><p>线程安全，可变的字符序列。字符串缓冲区就像一个String，但可以修改<br>在任何时间点，它包含一些特定的字符序列<br>但可以通过某些方法调用来更改序列的长度和内容<br>简单来说：就是一个线程安全的可变字符串</p><h4 id="StringBuffer和String的区别"><a href="#StringBuffer和String的区别" class="headerlink" title="StringBuffer和String的区别"></a>StringBuffer和String的区别</h4><p>前者长度和内容都可以改变，后者不可改变<br>前者可以提前给出缓冲区，可以进行字符串拼接不会重新开辟空间；后者会开辟新的空间，会浪费太多资源</p><h4 id="StringBuffer的构造方法"><a href="#StringBuffer的构造方法" class="headerlink" title="StringBuffer的构造方法"></a>StringBuffer的构造方法</h4><p>public StringBuffer()<br>public StringBuffer(int capacity)<br>public StringBuffer(String str)</p><h4 id="StringBuffer的方法"><a href="#StringBuffer的方法" class="headerlink" title="StringBuffer的方法"></a>StringBuffer的方法</h4><p>public int capacity()返回当前容量（容量是新插入字符可用的存储量，超过此值将进行重新分配）<br>public int length()返回长度（字符数）</p><h4 id="线程安全简单描述："><a href="#线程安全简单描述：" class="headerlink" title="线程安全简单描述："></a>线程安全简单描述：</h4><p>线程是安全的；安全，代表着有同步存在，数据是安全的，效率不高<br>不安全，不同步，效率高<br>安全问题和效率问题，一直都是一个矛盾点<br>安全：售票、取号、银行业务（都是一个一个进行的）<br>效率：论坛（可以同步进行的）</p><h3 id="StringBuffer类的成员方法"><a href="#StringBuffer类的成员方法" class="headerlink" title="StringBuffer类的成员方法"></a>StringBuffer类的成员方法</h3><h4 id="添加功能"><a href="#添加功能" class="headerlink" title="添加功能"></a>添加功能</h4><ul><li><strong>public StringBuffer append(String str)</strong><br>可以把任意类型的数据添加到字符串缓冲区中，并且返回的是字符串缓冲区本身</li><li><strong>public StringBuffer insert(int offset,String str)</strong><br>在指定位置插入数据到字符串缓冲区</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        StringBuffer sb2 = sb.append(<span class="string">&quot;hello&quot;</span>);<span class="comment">//append将任意类型数据添加到字符串缓冲区，返回的是字符串缓冲区本身</span></span><br><span class="line"></span><br><span class="line">        System.out.println(sb);</span><br><span class="line">        System.out.println(sb2);</span><br><span class="line">        System.out.println(sb == sb2);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        sb.append(<span class="keyword">true</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        sb.append(<span class="number">123</span>);</span><br><span class="line">        <span class="comment">//这两个返回的是同一个内容，因为返回的都是字符串缓冲区本身</span></span><br><span class="line">        System.out.println(sb);<span class="comment">//hellotrueworld123</span></span><br><span class="line">        System.out.println(sb2);<span class="comment">//hellotrueworld123</span></span><br><span class="line">    </span><br><span class="line">        sb.append(<span class="number">12.34f</span>).append(<span class="string">&quot;java&quot;</span>).append(<span class="number">23</span>).append(<span class="keyword">false</span>);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">        System.out.println(sb2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//hellotrueworld123</span></span><br><span class="line"><span class="comment">//hellotrueworld123</span></span><br><span class="line"><span class="comment">//hellotrueworld12312.34java23false</span></span><br><span class="line"><span class="comment">//hellotrueworld12312.34java23false</span></span><br></pre></td></tr></table></figure><h4 id="删除功能"><a href="#删除功能" class="headerlink" title="删除功能"></a>删除功能</h4><ul><li><strong>public StringBuffer deleteCharAt(int index)</strong></li><li><strong>public StringBuffer delete(int start,int end)</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        sb.append(<span class="keyword">true</span>).append(<span class="number">12</span>).append(<span class="number">12.34f</span>).append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">        System.out.println(<span class="string">&quot;**********************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除指定范围的字符（左闭右开）</span></span><br><span class="line">    sb.delete(<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line">    System.out.println(sb);</span><br><span class="line">    System.out.println(<span class="string">&quot;**********************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除指定位置字符</span></span><br><span class="line">    sb.deleteCharAt(<span class="number">2</span>);</span><br><span class="line">    System.out.println(sb);</span><br><span class="line">    System.out.println(<span class="string">&quot;**********************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除所有字符串</span></span><br><span class="line">    sb.delete(<span class="number">0</span>,sb.length());</span><br><span class="line">    System.out.println(sb);</span><br><span class="line">    System.out.println(<span class="string">&quot;**********************************&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="替换功能-1"><a href="#替换功能-1" class="headerlink" title="替换功能"></a>替换功能</h4><p><strong>public StringBuffer replace(int start,int end,String str)</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(<span class="number">12</span>).append(<span class="keyword">true</span>).append(<span class="string">&quot;hello&quot;</span>).append(<span class="number">34.56f</span>);</span><br><span class="line">    System.out.println(sb);</span><br><span class="line">    System.out.println(<span class="string">&quot;*********************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sb.replace(<span class="number">2</span>,<span class="number">5</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    System.out.println(sb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//12truehello34.56</span></span><br><span class="line"><span class="comment">//*********************************</span></span><br><span class="line"><span class="comment">//12worldehello34.56</span></span><br></pre></td></tr></table></figure><h4 id="翻转功能"><a href="#翻转功能" class="headerlink" title="翻转功能"></a>翻转功能</h4><p>**public StringBuffer reverse()**（如果序列中包含任何替代对，则将它们视为单个字符进行反向操作）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        sb.append(<span class="string">&quot;StringBuffer&quot;</span>);</span><br><span class="line">        sb.reverse();</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//reffuBgnirtS</span></span><br></pre></td></tr></table></figure><h4 id="截取功能"><a href="#截取功能" class="headerlink" title="截取功能"></a>截取功能</h4><ul><li>public String substring(int start)</li><li>public String substring(int start,int end)<br>截取功能和前面几个功能的不同：返回值是String类型，本身没有发生改变</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        sb.append(<span class="number">12</span>).append(<span class="string">&quot;hello&quot;</span>).append(<span class="number">12.34f</span>).append(<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">        System.out.println(<span class="string">&quot;********************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String sb1 = sb.substring(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">        System.out.println(sb1);</span><br><span class="line">        System.out.println(<span class="string">&quot;********************************&quot;</span>);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//12hello12.34true</span></span><br><span class="line"><span class="comment">//********************************</span></span><br><span class="line"><span class="comment">//12he</span></span><br><span class="line"><span class="comment">//********************************</span></span><br><span class="line"><span class="comment">//12hello12.34true</span></span><br></pre></td></tr></table></figure><h4 id="面试题：String、StringBuffer、StringBuilder类的区别"><a href="#面试题：String、StringBuffer、StringBuilder类的区别" class="headerlink" title="面试题：String、StringBuffer、StringBuilder类的区别"></a>面试题：String、StringBuffer、StringBuilder类的区别</h4><p>1、String、StringBuffer、StringBuilder的区别<br>String的内容是不可变的，而StringBuffer、StringBuilder的内容是可变的<br>StringBuffer是同步线程安全的，数据安全，效率低<br>StringBuilder是不同步的，数据不安全，效率高<br>2、StringBuffer和数组的区别<br>两个都可以看作是一个容器，装一些数据，但是，StringBuffer最终存储的数据是一个字符串数据，而数组可以存放多宗数据，但是同一个数组里面的元素类型一致</p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中一些常用的类以及API帮助文档</title>
      <link href="/2020/09/02/Java%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E7%B1%BB%E4%BB%A5%E5%8F%8AAPI%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/"/>
      <url>/2020/09/02/Java%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E7%B1%BB%E4%BB%A5%E5%8F%8AAPI%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Java中的一些常用类以及API帮助文档"><a href="#Java中的一些常用类以及API帮助文档" class="headerlink" title="Java中的一些常用类以及API帮助文档"></a>Java中的一些常用类以及API帮助文档</h1><h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><p>Java中有一些常用的类，主要有这些:红色和蓝色字体的多掌握一下，这里主要带着帮助文档列举几个(Object类，String类)</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210903194346.png"></p><h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><ul><li>Object类的成员方法</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210903194507.png"></p><p><strong>Object：是类Object结构的根，每个class都有Object作为超类</strong><br>所有对象（包括数组）都实现了这个类的方法<br>每个类都直接或间接的继承自Object类</p><p><strong>Object类中的方法：hashCode()</strong><br>public int hashCode()返回对象的哈希值。 支持这种方法是为了散列表，如HashMap提供的那样<br>注意： 哈希值就是根据哈希算法计算出来的一个值，这个值跟地址有关系，但是不是实际的地址值。你可以简单的理解为就一种地址。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(student.hashCode());<span class="comment">//685325104</span></span><br><span class="line">        Student student1 = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(student1.hashCode());<span class="comment">//460141958</span></span><br><span class="line"></span><br><span class="line">        Student student2 = student;</span><br><span class="line">        System.out.println(student2.hashCode());<span class="comment">//685325104</span></span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;**************************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        Student student3 = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(student3.getClass());<span class="comment">//class com.bigdata.shujia15.Student</span></span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;**************************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        Class c = student3.getClass();</span><br><span class="line">        System.out.println(c.getName());<span class="comment">//com.bigdata.shujia15.Student</span></span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;**************************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        System.out.println(student3.getClass().getName());<span class="comment">//com.bigdata.shujia15.Student</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> **Object类中的方法：toString()**，介绍在代码中为什么要重写toString方法<br>public String toString() 返回对象的字符串表达形式，一般来说，toString方法返回一个对象的字符串<br>Integer类中提供了一个静态的方法：public static String toHexString(int i)返回整数参数的字符串表示形式，作为16位中的无符号整数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student2 student2 = <span class="keyword">new</span> Student2();</span><br><span class="line">        System.out.println(student2.hashCode());<span class="comment">//685325104</span></span><br><span class="line">        System.out.println(student2.getClass().getName());<span class="comment">//com.bigdata.shujia15.Student2</span></span><br><span class="line">        System.out.println(student2.toString());<span class="comment">//com.bigdata.shujia15.Student2@28d93b30</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;****************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//toString方法的值等价于以下内容，然而这样的输出没有意义，所以JVM中为我们重写了toString方法</span></span><br><span class="line">        <span class="comment">//student2.getClass().getName()+&quot;@&quot;+Integer.toHexString(student2.hashCode())</span></span><br><span class="line">    </span><br><span class="line">        System.out.println(student2.getClass().getName()+<span class="string">&quot;@&quot;</span>+Integer.toHexString(student2.hashCode()));</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//重写之后的toString方法</span></span><br><span class="line">        student2.setName(<span class="string">&quot;酷酷的涛&quot;</span>);</span><br><span class="line">        student2.setAge(<span class="number">22</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;重写之后的方法：&quot;</span>+student2.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//685325104</span></span><br><span class="line"><span class="comment">//com.bigdata.shujia15.Student2</span></span><br><span class="line"><span class="comment">//Student2&#123;name=&#x27;null&#x27;, age=0&#125;</span></span><br><span class="line"><span class="comment">//****************</span></span><br><span class="line"><span class="comment">//com.bigdata.shujia15.Student2@28d93b30</span></span><br><span class="line"><span class="comment">//重写之后的方法：Student2&#123;name=&#x27;酷酷的涛&#x27;, age=22&#125;</span></span><br></pre></td></tr></table></figure><p><strong>Object中的方法：equals（这个方法，要重写）</strong><br>public boolean equals(Object obj) 指示一些其他的对象是否等于此，这个方法，默认情况下，比较的是地址值，但是呢，比较地址值是没有意义的，更多情况下，我们比较对象中成员变量的值是否一样，所以想到的是重写方法</p><p><strong>==：</strong><br>基本类型：比较的是值是否相同<br>引用类型：比较的是地址值是否相同<br><strong>equals：</strong><br>引用类型：默认情况下，比较的是地址值。不过，根据情况重写，可以自己重写，也可以自动生成</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student3 s1 = <span class="keyword">new</span> Student3(<span class="string">&quot;张三&quot;</span>,<span class="number">21</span>);</span><br><span class="line">        Student3 s2 = <span class="keyword">new</span> Student3(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(s1==s2);<span class="comment">//false</span></span><br><span class="line">        Student3 s3 = s1;</span><br><span class="line">        System.out.println(s1==s3);<span class="comment">//true</span></span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;********&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        System.out.println(s1.equals(s2));<span class="comment">//false</span></span><br><span class="line">        System.out.println(s1.equals(s1));<span class="comment">//true</span></span><br><span class="line">        System.out.println(s1.equals(s3));<span class="comment">//true</span></span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;********&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        Student3 s4 = <span class="keyword">new</span> Student3(<span class="string">&quot;王五&quot;</span>, <span class="number">23</span>);</span><br><span class="line">        System.out.println(s1.equals(s4));<span class="comment">//false</span></span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;********&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">        System.out.println(s1.equals(demo));<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Object中的方法：finalize()、clone()<br>protected void finalize()<br>throws Throwable当垃圾回收器确定不再有对该对象的引用时，垃圾回收器在对象上调用该对象。一个子类覆盖了处理系统资源或执行其他清理的finalize方法。简单来说，它就是用于垃圾回收的，但是呢，什么时候回收不确定<br>protected Object clone()<br>throws CloneNotSupportedException创建并返回此对象的副本。返回的是这个实例的一个克隆。</li></ul><p>public interface Cloneable一个类实现Cloneable接口，以指示Object.clone()方法，该方法对于该类的实例进行现场赋值是合法的，也就是必须要实现Cloneable接口才能使用clone方法</p><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><h4 id="String类概述"><a href="#String类概述" class="headerlink" title="String类概述"></a>String类概述</h4><ul><li><p>字符串是由多个字符组成的一串数据（字符序列）<br>字符串可以看成是字符数组</p></li><li><p>通过查看API，发现</p><ul><li>String类代表字符串<br>Java程序中所有字符串文字（例如“abc”）都可以实现为此类的实例<br>字符串字面值“abc”也可以看成一个字符串对象<br>字符串是常量，一旦被赋值，就不能被改变</li></ul></li></ul><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><ul><li>public String()</li><li>public String(byte[] bytes)</li><li>public String(byte[] bytes,int offset,int length)</li><li>public String(char[] value)</li><li>public String(char[] value,int offset,int count)</li><li>public String(String original)</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="keyword">new</span> String();</span><br><span class="line">        System.out.println(<span class="string">&quot;s:&quot;</span>+s);</span><br><span class="line">        System.out.println(<span class="string">&quot;s的长度&quot;</span>+s.length());</span><br><span class="line">        System.out.println(<span class="string">&quot;******************&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//public String(byte[] bytes) 将字节数组转化成字符串</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">66</span>,<span class="number">77</span>,<span class="number">88</span>,<span class="number">99</span>&#125;;</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(b);</span><br><span class="line">        System.out.println(<span class="string">&quot;s1:&quot;</span>+s1);</span><br><span class="line">        System.out.println(s1.length());</span><br><span class="line">        System.out.println(<span class="string">&quot;******************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//public String(byte[] bytes,int offset,int length)</span></span><br><span class="line">        <span class="comment">//将字节数组的一部分截取成字符串</span></span><br><span class="line">        String s2 = <span class="keyword">new</span> String(b,<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;s2:&quot;</span>+s2);</span><br><span class="line">        System.out.println(s2.length());</span><br><span class="line">        System.out.println(<span class="string">&quot;******************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//public String(char[] value) 将字符数组转化成字符串</span></span><br><span class="line">        <span class="keyword">char</span>[] c = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;g&#x27;</span>&#125;;</span><br><span class="line">        String s3 = <span class="keyword">new</span> String(c);</span><br><span class="line">        System.out.println(<span class="string">&quot;s3:&quot;</span>+s3);</span><br><span class="line">        System.out.println(s3.length());</span><br><span class="line">        System.out.println(<span class="string">&quot;******************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//public String(char[] value,int offset,int count)</span></span><br><span class="line">        <span class="comment">//将字符数组的一部分转化成字符串</span></span><br><span class="line">        String s4 = <span class="keyword">new</span> String(c,<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;s4:&quot;</span>+s4);</span><br><span class="line">        System.out.println(s4.length());</span><br><span class="line">        System.out.println(<span class="string">&quot;******************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//public String(String original)</span></span><br><span class="line">        <span class="comment">//将字符串常量转化成字符串对象</span></span><br><span class="line">        String abcde = <span class="keyword">new</span> String(<span class="string">&quot;abcde&quot;</span>);</span><br><span class="line">        System.out.println(abcde);</span><br><span class="line">        System.out.println(abcde.length());</span><br><span class="line">    </span><br><span class="line">        String s6 = <span class="string">&quot;asdfghj&quot;</span>;</span><br><span class="line">        String s7 = <span class="keyword">new</span> String(s6);</span><br><span class="line">        System.out.println(<span class="string">&quot;s7:&quot;</span>+s7);</span><br><span class="line">        System.out.println(s7.length());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>字符串的特点：一旦被赋值，就不能被改变</strong><br>面试题：<br>但我们发现下面这个例子，s从Hello，变为了HelloWorld</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    s += <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;s:&quot;</span>+s);<span class="comment">//HelloWorld</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但实际上，我们可以发现，当我们创建“Hello”的时候，是在方法区里面的字符串常量池创建了一个空间，“World”也开辟了一个空间，“HelloWorld”也是一个新的空间，s是从“Hello”的地址，变成了“HelloWorld”的地址，但本身的字符串是不发生改变的。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210903195535.png"></p><ul><li><strong>String s = new String(“hello”) 和 String s = “hello”的区别</strong><ul><li>== 比较的是引用类型的地址值</li><li>equals默认比较的是地址值，但是String重写了equals方法，所以比较的是内容</li><li>前者会创建两个对象，后者创建一个对象</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        String s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(s == s1);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s1.equals(s));<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图解：<br>首先是在栈里面创建了一个s1对象，然后在堆里面开辟了一个空间，赋值了hello，存进了方法区的字符串常量池，s1指向的是堆内存里面的位置；接着在栈里面开辟了s2空间，指向的是方法区中字符串常量池的位置。</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210903195958.png"></p><ul><li>看程序写结果<ul><li><strong>字符串如果是变量相加，是先开辟空间，再拼接</strong></li><li><strong>字符串如果是常量相加，是先加，再去常量池中查找，如果找到就返回，否则就创建</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">        System.out.println(s3==s1+s2);  <span class="comment">//false</span></span><br><span class="line">        System.out.println(s3.equals(s1+s2));  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//经过编译，自动转化成System.out.println(s3 == &quot;helloworld&quot;);</span></span><br><span class="line">    System.out.println(s3 == <span class="string">&quot;hello&quot;</span>+<span class="string">&quot;world&quot;</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    System.out.println(s3.equals(<span class="string">&quot;hello&quot;</span>+<span class="string">&quot;world&quot;</span>)); <span class="comment">//true        </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断功能"><a href="#判断功能" class="headerlink" title="判断功能"></a>判断功能</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//注意事项：</span></span></span><br><span class="line"><span class="function">    String s </span>= <span class="string">&quot;&quot;</span>;</span><br><span class="line">    String s = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p> 以上为一些基本的判断功能，下面是相关代码展示:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//创建字符串对象</span></span><br><span class="line">        String s1 = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;Helloworld&quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//boolean equals(Object obj) 比较字符串的内容是否相同，区分大小写</span></span><br><span class="line">        System.out.println(s1.equals(s2)); <span class="comment">//false</span></span><br><span class="line">        System.out.println(s1.equals(s3)); <span class="comment">//false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;**********************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//boolean equalsIgnoreCase(String str)</span></span><br><span class="line">        <span class="comment">// 比较字符串的内容是否相同,忽略大小写</span></span><br><span class="line">        System.out.println(s1.equalsIgnoreCase(s2)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(s1.equalsIgnoreCase(s3)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;**********************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//boolean contains(String str)</span></span><br><span class="line">        <span class="comment">//判断大的字符串中是否包含小的字符串</span></span><br><span class="line">        System.out.println(s1.contains(<span class="string">&quot;Hello&quot;</span>));</span><br><span class="line">        System.out.println(s1.contains(<span class="string">&quot;lowo&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;**********************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//boolean startsWith(String str) 测试此字符串是否以指定的前缀开头。</span></span><br><span class="line">        System.out.println(s1.startsWith(<span class="string">&quot;h&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(s1.startsWith(<span class="string">&quot;he&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(s1.startsWith(<span class="string">&quot;world&quot;</span>)); <span class="comment">//false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;**********************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//boolean endsWith(String str)测试此字符串是否以指定的后缀结尾。</span></span><br><span class="line">        System.out.println(s1.endsWith(<span class="string">&quot;world&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(s1.endsWith(<span class="string">&quot;hello&quot;</span>)); <span class="comment">//false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;**********************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//boolean isEmpty() 判断字符串是不是空</span></span><br><span class="line">        System.out.println(s1.isEmpty());</span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;**********************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        String s4 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        String s5 = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(s4.isEmpty()); <span class="comment">//true</span></span><br><span class="line">        <span class="comment">//因为s5的对象都没有，所以不能够调用方法，空指针异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(s5.isEmpty()); //NullPointerException</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;asd&quot;</span>.equals(s1));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(s5.equals(&quot;asd&quot;));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较字符串的内容，推荐这种</span></span><br><span class="line">        System.out.println(<span class="string">&quot;asd&quot;</span>.equals(s5));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取功能"><a href="#获取功能" class="headerlink" title="获取功能"></a>获取功能</h4><p>int length():获取字符串的长度</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch,<span class="keyword">int</span> fromIndex)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str,<span class="keyword">int</span> fromIndex)</span></span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int length():获取字符串的长度</span></span><br><span class="line">    System.out.println(s.length());</span><br><span class="line">    System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//char charAt(int index)</span></span><br><span class="line">    <span class="comment">//返回char指定索引处的值。 指数范围为0至length() - 1</span></span><br><span class="line">    System.out.println(s.charAt(<span class="number">7</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int indexOf(int ch)</span></span><br><span class="line">    <span class="comment">//返回指定字符第一次出现的字符串内的索引。</span></span><br><span class="line">    System.out.println(s.indexOf(<span class="string">&#x27;l&#x27;</span>)); <span class="comment">//2</span></span><br><span class="line">    System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int indexOf(String str)</span></span><br><span class="line">    <span class="comment">//返回指定子字符串第一次出现的字符串内的索引。</span></span><br><span class="line">    System.out.println(s.indexOf(<span class="string">&quot;ello&quot;</span>)); <span class="comment">//1</span></span><br><span class="line">    System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int indexOf(int ch,int fromIndex)</span></span><br><span class="line">    <span class="comment">//返回指定字符第一次出现的字符串内的索引，以指定的索引开始搜索。</span></span><br><span class="line">    System.out.println(s.indexOf(<span class="string">&#x27;l&#x27;</span>,<span class="number">4</span>)); <span class="comment">//8</span></span><br><span class="line">    System.out.println(s.indexOf(<span class="string">&#x27;p&#x27;</span>,<span class="number">4</span>)); <span class="comment">//-1</span></span><br><span class="line">    System.out.println(s.indexOf(<span class="string">&#x27;l&#x27;</span>,<span class="number">40</span>)); <span class="comment">//-1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//int indexOf(String str,int fromIndex)</span></span><br><span class="line">    <span class="comment">//返回指定子串的第一次出现的字符串中的索引，从指定的索引开始</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//String substring(int start)</span></span><br><span class="line">    <span class="comment">//返回一个字符串，该字符串是此字符串的子字符串。</span></span><br><span class="line">    <span class="comment">// 子字符串以指定索引处的字符开头，并扩展到该字符串的末尾</span></span><br><span class="line">    <span class="comment">//截串</span></span><br><span class="line">    <span class="comment">//最大可以传的数值到length的值</span></span><br><span class="line">    System.out.println(s.substring(<span class="number">3</span>)); <span class="comment">//loworld</span></span><br><span class="line">    <span class="comment">//System.out.println(s.substring(11));//StringIndexOutOfBoundsException</span></span><br><span class="line">    System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//String substring(int start,int end)</span></span><br><span class="line">    <span class="comment">//返回一个字符串，该字符串是此字符串的子字符串。</span></span><br><span class="line">    <span class="comment">// 子串开始于指定beginIndex并延伸到字符索引endIndex - 1 。</span></span><br><span class="line">    <span class="comment">// 因此，子串的长度为endIndex-beginIndex 。</span></span><br><span class="line">    <span class="comment">//左闭右开</span></span><br><span class="line">    System.out.println(s.substring(<span class="number">1</span>,<span class="number">3</span>)); <span class="comment">//el</span></span><br><span class="line">    System.out.println(s.substring(<span class="number">4</span>,<span class="number">8</span>)); <span class="comment">//owor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>权限修饰符以及内部类</title>
      <link href="/2020/09/02/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%E4%BB%A5%E5%8F%8A%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2020/09/02/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%E4%BB%A5%E5%8F%8A%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="权限修饰符以及内部类"><a href="#权限修饰符以及内部类" class="headerlink" title="权限修饰符以及内部类"></a>权限修饰符以及内部类</h1><h2 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h2><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210903190340.png"></p><h3 id="同一个类下"><a href="#同一个类下" class="headerlink" title="同一个类下:"></a>同一个类下:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerDemo1</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> age = <span class="number">21</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> String id = <span class="string">&quot;001&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        PowerDemo1 powerDemo1 = <span class="keyword">new</span> PowerDemo1();</span><br><span class="line">        System.out.println(powerDemo1.name);</span><br><span class="line">        System.out.println(powerDemo1.age);</span><br><span class="line">        System.out.println(powerDemo1.flag);</span><br><span class="line">        System.out.println(powerDemo1.id);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//张三</span></span><br><span class="line"><span class="comment">//21</span></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//001</span></span><br></pre></td></tr></table></figure><h3 id="同一个包子类，其他类"><a href="#同一个包子类，其他类" class="headerlink" title="同一个包子类，其他类:"></a>同一个包子类，其他类:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Power</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> age = <span class="number">21</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> String id = <span class="string">&quot;001&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerDemo1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Power power = <span class="keyword">new</span> Power();</span><br><span class="line">        System.out.println(power.name);</span><br><span class="line">        System.out.println(power.age);</span><br><span class="line">        System.out.println(power.flag);</span><br><span class="line">        <span class="comment">//Error:(18, 33) java: id可以在com.bigdata.shujia14.Power中访问private</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(power.id);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//张三</span></span><br><span class="line"><span class="comment">//21</span></span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="不同包的子类"><a href="#不同包的子类" class="headerlink" title="不同包的子类:"></a>不同包的子类:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerTest1</span> <span class="keyword">extends</span> <span class="title">PowerDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PowerTest1 powerTest1 = <span class="keyword">new</span> PowerTest1();</span><br><span class="line">        System.out.println(powerTest1.name);    <span class="comment">//public修饰的</span></span><br><span class="line">        System.out.println(powerTest1.age);     <span class="comment">//protected修饰的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//张三</span></span><br><span class="line"><span class="comment">//21</span></span><br></pre></td></tr></table></figure><h3 id="不同包的其他类"><a href="#不同包的其他类" class="headerlink" title="不同包的其他类"></a>不同包的其他类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerTest1</span> <span class="keyword">extends</span> <span class="title">PowerDemo1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PowerDemo1 powerDemo1 = <span class="keyword">new</span> PowerDemo1();</span><br><span class="line">        System.out.println(powerDemo1.name);<span class="comment">//public修饰的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//张三</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>类及其成员修饰符</strong><br><strong>权限修饰符：private、默认的、protected、public<br>状态修饰符：static、final<br>抽象修饰符：abstract</strong></p></li><li><p>类：</p><p>权限修饰符：默认的、public</p><p>状态修饰符：final</p><p>抽象修饰符：abstract</p><p>最常用的是public</p><p><strong>成员变量：</strong><br>权限修饰符：private、默认的、protected、public<br>状态修饰符：static、final<br><strong>最常用的是public</strong></p></li><li><p><strong>构造方法：</strong><br>权限修饰符：private、默认的、protected、public<br><strong>最常用的是public</strong></p></li><li><p><strong>成员方法：</strong><br>权限修饰符：private、默认的、protected、public<br>状态修饰符：static、final<br>抽象修饰符：abstract<br><strong>最常用的是public</strong></p></li></ul><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul><li><p><strong>把类定义在其他类的内部，这个类就被称为内部类</strong><br>举例：在类A中定义了一个类B，类B就是内部类</p></li><li><p>内部类的访问特点：</p><ul><li>内部类可以访问外部类的成员，包括私有</li><li>外部类如果想要访问内部类的成员，就必须要创建对象</li></ul></li><li><p><strong>内部类的位置：</strong><br>按照内部类在类中定义的位置不同，分为如下两种格式<br>- 成员位置（成员内部类）<br>- 局部位置（局部内部类）</p></li><li><p>成员内部类：</p><ul><li>内部类可以访问外部类的成员，包括私有</li><li>如何创建对象呢<br>外部类名.内部类名 对象名 = new 外部类名.new 内部类名</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer3</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//想要访问内部类的show()方法，就必须要创建Inner对象</span></span><br><span class="line"><span class="comment">//        Inner inner = new Inner();</span></span><br><span class="line"><span class="comment">//        inner.show();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//正确创建内部类对象的格式：</span></span><br><span class="line">        Outer3.Inner i = <span class="keyword">new</span> Outer3().<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">        i.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//20</span></span><br></pre></td></tr></table></figure><p><strong>成员内部类常见修饰符：</strong><br>private：为了保证数据的安全性<br>static：为了方便访问数据<br>注意事项：静态内部类访问的外部数据必须由静态修饰</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer4</span></span>&#123;</span><br><span class="line">    <span class="comment">//局部变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成员内部类被静态修饰    访问的局部变量也只能是静态的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner4</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            System.out.println(num);</span></span><br><span class="line">            System.out.println(num2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            System.out.println(num);</span></span><br><span class="line">            System.out.println(num2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer4.Inner4 i = <span class="keyword">new</span> Outer4.Inner4();</span><br><span class="line">        i.show();<span class="comment">//20</span></span><br><span class="line">        i.show2();<span class="comment">//20</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//另一种创建内部类的方式，当成员变量被静态修饰后，访问的格式如下：</span></span><br><span class="line">        <span class="comment">//外部类名.内部类名 对象名 = new   外部类名.内部类名()</span></span><br><span class="line">        Outer4.Inner4 i1 = <span class="keyword">new</span> Outer4.Inner4();</span><br><span class="line">        i1.show();<span class="comment">//20</span></span><br><span class="line">        i1.show2();<span class="comment">//20</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">//调用show2()的另一种方式</span></span><br><span class="line">        Outer4.Inner4.show2();<span class="comment">//20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><ul><li>就是内部类的简化写法</li><li>前提：存在一个类或者接口<br>这里的类可以是具体类，也可以是抽象类</li><li>格式：new 类名或者接口名(){重写方法;}</li><li>本质是：是一个继承了这个类或者实现了这个接口的子类的匿名对象</li></ul><p>例如:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer7</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        new Inter() &#123;</span></span><br><span class="line"><span class="comment">//            public void show() &#123;</span></span><br><span class="line"><span class="comment">//                System.out.println(&quot;show()方法&quot;);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            public void show2() &#123;</span></span><br><span class="line"><span class="comment">//                System.out.println(&quot;这是show2()方法&quot;);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;.show2();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        new Inter()&#123;</span></span><br><span class="line"><span class="comment">//            public void show()&#123;</span></span><br><span class="line"><span class="comment">//                System.out.println(&quot;这是show()方法&quot;);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            public void show2()&#123;</span></span><br><span class="line"><span class="comment">//                System.out.println(&quot;这是show2()方法&quot;);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;.show();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//问题，如果我这个接口有很多方法，还需要使用匿名内部类的形式就很麻烦</span></span><br><span class="line">        <span class="comment">//怎么改进</span></span><br><span class="line">        Inter inter = <span class="keyword">new</span> Inter()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;这是show方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;这是show2方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        inter.show();</span><br><span class="line">        inter.show2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassDemo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer7 outer7 = <span class="keyword">new</span> Outer7();</span><br><span class="line">        outer7.fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是show方法</span></span><br><span class="line"><span class="comment">//这是show2方法</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象类，接口以及形式参数</title>
      <link href="/2020/09/02/%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%8C%E6%8E%A5%E5%8F%A3%E4%BB%A5%E5%8F%8A%E5%BD%A2%E5%BC%8F%E5%8F%82%E6%95%B0/"/>
      <url>/2020/09/02/%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%8C%E6%8E%A5%E5%8F%A3%E4%BB%A5%E5%8F%8A%E5%BD%A2%E5%BC%8F%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="抽象类，接口以及形式参数"><a href="#抽象类，接口以及形式参数" class="headerlink" title="抽象类，接口以及形式参数"></a>抽象类，接口以及形式参数</h1><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p><strong>概述：</strong><br>用之前的猫狗、动物举例，动物中不应该具体的东西，而且动物中的吃方法、睡觉方法这些等都不应该也是具体，我们把一个不具体的功能称之为抽象的功能，也叫做抽象方法，而类中如果有抽象方法，该类必须定义为抽象类。</p><p>例如:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"><span class="comment">//    public abstract void eat()&#123;&#125;  //这样写会报错，因为抽象方法不能有主体</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        Animal a = new Animal();  //Animal是抽象的，无法实例化</span></span><br><span class="line">        Animal a = <span class="keyword">new</span> Cat();</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//猫吃鱼</span></span><br></pre></td></tr></table></figure><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li><p>抽象类和抽象方法必须使用abstract关键字修饰<br>格式：abstract class 类名 {}</p></li><li><p>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类</p></li><li><p>抽象类不能实例化<br>那么，抽象类如何实例化呢？<br>按照多态的方式，由具体的子类实例化。其实这也是多态的一种，抽象类多态</p></li><li><p>抽象类的子类</p><ul><li>要么是抽象类，不需要重写父抽象类的抽象方法<br>要么重写抽象类中所有的抽象方法，那么这个时候子类是一个具体的类</li></ul></li><li><p>成员变量：可以是变量，也可以是常量</p></li><li><p>构造方法：有。可以有构造方法，但是抽象类又不能具体实例化，有什么用呢<br>用于子类访问父类的初始化</p></li><li><p>成员方法：可以是抽象方法，也可以不是抽象方法</p></li><li><p>如果抽象类中包含成员方法是抽象方法，那么就需要强制具体子类去重写</p></li><li><p>如果抽象类中包含成员方法是非抽象方法，那么继承的子类可以不去调用，提高了代码的复用性</p></li></ul><p>例如:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal2</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal2</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;<span class="comment">//抽象类中的抽象方法，就需要子类去强制重写</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;<span class="comment">//抽象类中的非抽象方法，继承的子类可以不去调用</span></span><br><span class="line">        System.out.println(<span class="string">&quot;这是抽象类中一个具体的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog2</span> <span class="keyword">extends</span> <span class="title">Animal2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是Dog2类继承Animal2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           Animal2 a = <span class="keyword">new</span> Dog2();</span><br><span class="line">           a.num = <span class="number">100</span>;</span><br><span class="line">           System.out.println(a.num);</span><br><span class="line"><span class="comment">//           a.num2 = 200;//无法改变final修饰的变量</span></span><br><span class="line">        System.out.println(<span class="string">&quot;*****************************&quot;</span>);</span><br><span class="line">            a.show();</span><br><span class="line">            a.show2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//100</span></span><br><span class="line"><span class="comment">//        *****************************</span></span><br><span class="line"><span class="comment">//        这是Dog2类继承Animal2</span></span><br><span class="line"><span class="comment">//        这是抽象类中一个具体的方法</span></span><br></pre></td></tr></table></figure><ul><li><strong>一个类如果没有抽象方法，可不可以定义为抽象类？如果可以，有什么意义？</strong><br>抽象类里面可以没有抽象方法<br>不能创建对象</li><li><strong>abstract不能和哪些关键字共存</strong><ul><li>private 冲突</li><li>final 冲突</li><li>static 冲突</li></ul></li></ul><p>例如:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line"><span class="comment">//    public abstract void show();</span></span><br><span class="line">    <span class="comment">//Error:(7, 27) java: 非法的修饰符组合: abstract和private</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    private abstract void show1();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Error:(10, 25) java: 非法的修饰符组合: abstract和final</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    final abstract void show3();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Error:(14, 26) java: 非法的修饰符组合: abstract和static</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    static abstract void show4();</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是继承的一个静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fu f = <span class="keyword">new</span> Zi();</span><br><span class="line">        f.show5();</span><br><span class="line">        Fu.show5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是一个静态方法</span></span><br><span class="line"><span class="comment">//这是一个静态方法</span></span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>牢记接口是来做额外的动作的，来体现事物的扩展性</p><ul><li>接口的特点<ul><li>接口用关键字interface表示<br>格式：interface 接口名 {}</li><li>类实现接口用implements表示<br>格式：class 类名 implements 接口名 {}</li><li>接口不能实例化<br>那么，接口如何实例化呢<br>按照多态的方式，由具体的子类实例化，这也是多态的一种，接口多态</li><li>接口的子类<br>要么是抽象类<br>要么重写接口中所有的抽象方法</li></ul></li><li>由此可见最常用的是<ul><li>接口多态<br>抽象类多态<br>具体的类多态</li></ul></li></ul><p>一个简单的接口举例：（可以理解为，使用接口，为cat猫类加了一个新的方法）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个动物训练接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AnimalTrain</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat1</span> <span class="keyword">implements</span> <span class="title">AnimalTrain</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫跳高&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        AnimalTrain animalTrain = new AnimalTrain();//抽象类无法实例化</span></span><br><span class="line">        AnimalTrain a = <span class="keyword">new</span> Cat1();<span class="comment">//就可以直接理解为使用接口为cat猫添加了一个新的方法</span></span><br><span class="line">        a.jump();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//猫跳高</span></span><br></pre></td></tr></table></figure><ul><li><strong>接口成员的特点</strong>：<br>成员变量：只能是常量，并且是静态的<br>它里面默认有修饰符：public static final<br>建议：全部手动给出<br>构造方法：接口里面没有构造方法<br>成员方法：只能是抽象方法，没有方法体<br>默认修饰符是：public abstract<br>建议：全部手动给出</li><li>注意：虽然接口里面没有构造方法，但是，所有的类都默认继承一个类：Object，Object是类Object结构的根，每个class都有Object作为超类，所有对象（包括数组）都实现了这个类的方法</li><li>成员接口的成员变量默认修饰符：public static final</li><li>成员接口的成员方法默认修饰符：public abstract</li><li><strong>类与类</strong><br>继承关系，只能<strong>单继承，但是可以多层继承</strong></li><li><strong>类与接口</strong><br>实现关系，<strong>可以单实现，可以多实现</strong>，还可以在继承一个类的同时实现多个接口</li><li><strong>接口与接口</strong><br>没有实现关系，只有继承关系，<strong>可以单继承，可以多继承</strong></li></ul><h2 id="形式参数和返回值"><a href="#形式参数和返回值" class="headerlink" title="形式参数和返回值"></a>形式参数和返回值</h2><h3 id="形式参数"><a href="#形式参数" class="headerlink" title="形式参数"></a>形式参数</h3><ul><li>形式参数：<br>基本数据类型<br>引用数据类型：<br>类：实际上需要的是该类的对象<br>抽象类<br>接口</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类实际上需要的是该类的对象代码举例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student3</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;好好学习&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student3Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(Student3 s)</span></span>&#123;</span><br><span class="line">        s.study();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student3 student3 = <span class="keyword">new</span> Student3();</span><br><span class="line">        Student3Demo student3Demo = <span class="keyword">new</span> Student3Demo();</span><br><span class="line">        student3Demo.fun(student3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//好好学习</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象类:当抽象类作为形式参数传入方法的时候，需要的是该抽象类的子类对象代码举例</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person3</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(Person3 p)</span></span>&#123;</span><br><span class="line">        p.study();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student4</span> <span class="keyword">extends</span> <span class="title">Person3</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生学习&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        Person3 person3 = new Person3();//抽象类不能实例化</span></span><br><span class="line"></span><br><span class="line">        Student4 student4 = <span class="keyword">new</span> Student4();</span><br><span class="line">        Person3 p =<span class="keyword">new</span> Student4();</span><br><span class="line">    </span><br><span class="line">        PersonDemo personDemo = <span class="keyword">new</span> PersonDemo();</span><br><span class="line">        personDemo.fun(student4);</span><br><span class="line">        personDemo.fun(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//学生学习</span></span><br><span class="line"><span class="comment">//学生学习</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当接口作为形式参数传入方法的时候，需要的是该接口具体的实现类对象</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person6</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person6Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(Person6 p)</span></span>&#123;</span><br><span class="line">        p.study();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher6</span> <span class="keyword">implements</span> <span class="title">Person6</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老师学习&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Teacher6 teacher6 = <span class="keyword">new</span> Teacher6();</span><br><span class="line">        Person6Demo person6Demo = <span class="keyword">new</span> Person6Demo();</span><br><span class="line">        person6Demo.fun(teacher6);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//老师学习</span></span><br></pre></td></tr></table></figure><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>返回值类型：<br>基本数据类型<br>引用数据类型<br>类：当一个类作为返回值类型的时候，需要的是该类的对象<br>抽象类<br>接口</p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>final关键字以及多态的概述</title>
      <link href="/2020/09/02/final%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%A4%9A%E6%80%81%E7%9A%84%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/09/02/final%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%A4%9A%E6%80%81%E7%9A%84%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Final关键字以及多态的概述"><a href="#Final关键字以及多态的概述" class="headerlink" title="Final关键字以及多态的概述"></a>Final关键字以及多态的概述</h1><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ul><li><p>final关键字是最终的意思，可以修饰 类、成员变量、成员方法</p><ul><li>修饰类，类不能被继承<br>修饰变量，变量就变成了常量，只能被赋值一次<br>修饰方法，方法不能被重写<br>在构造方法初始化完成之前赋值完毕（修饰的是非静态的常量）</li></ul></li><li><p>常量:</p><ul><li>字面值常量：<br>“java”、100、false<br>自定义常量：<br>修饰变量，变量就变成了常量<br>final int x = 100;//此刻的x就是一个常量</li></ul></li><li><p>final变量的引入：<br>由于继承中有一个现象，子类的方法和父类的方法声明一样，出现重写现象，所以，父类的功能就会被子类覆盖。但有时候，我们不想让子类覆盖父类的方法或者功能，只能让子类使用，这个时候，针对这种情况，Java就提供了一个关键字：final</p></li></ul><p>例如:子类无法重写父类中被final修饰的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是父类的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu1</span></span>&#123;</span><br><span class="line"><span class="comment">//    public void show()&#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;子类无法重写父类的方法&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZiDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Zi zi = <span class="keyword">new</span> Zi();</span><br><span class="line">        zi.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是父类的方法</span></span><br></pre></td></tr></table></figure><p>例如:final修饰的变量不能被修改</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu2</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是父类的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi2</span> <span class="keyword">extends</span> <span class="title">Fu2</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        num = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        num2 = 20;//这也是一个不能被重写的变量</span></span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(num2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public void fun()&#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;这是一个不能被重写的方法&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Zi2 zi2 = <span class="keyword">new</span> Zi2();</span><br><span class="line">        zi2.show();</span><br><span class="line">        zi2.fun();<span class="comment">//这里打印的是父类的方法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> x = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        x = 30;//这是一个不能被该的变量</span></span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//100</span></span><br><span class="line"><span class="comment">//20</span></span><br><span class="line"><span class="comment">//这是父类的方法</span></span><br><span class="line"><span class="comment">//20</span></span><br></pre></td></tr></table></figure><h3 id="面试题-final修饰局部变量"><a href="#面试题-final修饰局部变量" class="headerlink" title="面试题:final修饰局部变量"></a>面试题:final修饰局部变量</h3><p>1、在方法内部，该变量不能被改变<br>2、final修饰引用数据类型的时候，引用的地址值不能发生改变，但是，该对象的堆内存里面的值是可以改变的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student1</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">        x = <span class="number">100</span>;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> y = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//        y = 200;//Java无法为最终变量y分配值</span></span><br><span class="line">        System.out.println(y);</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Student1 student1 = <span class="keyword">new</span> Student1();</span><br><span class="line">        System.out.println(student1.age);</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> Student1 student2 = <span class="keyword">new</span> Student1();</span><br><span class="line">        System.out.println(student2.age);</span><br><span class="line">        student2.age = <span class="number">20</span>;</span><br><span class="line">        System.out.println(student2.age);</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        student2 = new Student1();//Java无法为最终变量s2分配值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//100</span></span><br><span class="line"><span class="comment">//------------------</span></span><br><span class="line"><span class="comment">//20</span></span><br><span class="line"><span class="comment">//------------------</span></span><br><span class="line"><span class="comment">//10</span></span><br><span class="line"><span class="comment">//------------------</span></span><br><span class="line"><span class="comment">//10</span></span><br><span class="line"><span class="comment">//20</span></span><br><span class="line"><span class="comment">//------------------</span></span><br></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul><li>多态概述：某一个事物，在不同时刻表现出来的不同状态</li><li>举例：<br>水：<br>固态、液态、气态<br>固态的水是水、液态的水是水、气态的水是水<br>水果：<br>苹果、香蕉、西瓜<br>苹果是水果、香蕉是水果、西瓜是水果<br>但不能说水果是苹果、水果是香蕉</li><li>我们通过观察这些例子发现，要想有多态，必须要有继承，继承是多态的前提</li><li>多态的条件：<ul><li>要有继承的关系</li><li>要有方法的重写<br>其实没有也可以，但是没有重写就没有意义</li><li>要有父类引用指向子类对象<br>父 f = new 子();</li></ul></li><li>多态中成员访问特点<ul><li>成员变量<br>编译看左边，运行看左边</li><li>构造方法<br>创建子类对象的时候，先访问父类的构造方法，对父类的数据先进行初始化</li><li>成员方法<br>编译看左边，运行看右边<br>因为成员方法存在重写，所以访问看右边</li><li>静态成员方法<br>编译看左边，运行看左边<br>由于被static修饰的都是与类相关的，算不上重写，所以，运行的时候，访问的还是左边的</li></ul></li></ul><p>例如:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu3</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是父类中的成员方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是父类中的静态成员方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi3</span> <span class="keyword">extends</span> <span class="title">Fu3</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">40</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是子类中的成员方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是子类中的另一个成员方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是子类中的静态成员方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Polymorphic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fu3 f = <span class="keyword">new</span> Zi3();</span><br><span class="line">        System.out.println(f.num2);<span class="comment">//成员变量，编译看左边，运行看左边</span></span><br><span class="line"></span><br><span class="line">        f.show();<span class="comment">//成员方法，编译看左边，运行看右边</span></span><br><span class="line">        f.show2();<span class="comment">//静态成员方法，编译看左边，运行还是看左边</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//20</span></span><br><span class="line"><span class="comment">//这是子类中的成员方法</span></span><br><span class="line"><span class="comment">//这是父类中的静态成员方法</span></span><br></pre></td></tr></table></figure><ul><li><strong>多态的好处</strong><br>1、提高了代码的维护性（这是继承保证的）<br>2、提高了程序的扩展性（这是多态决定的）</li><li><strong>多态的弊端</strong><br>不能访问子类的特有功能</li></ul><p> 正是因为不能访问子类中的特有功能，所以在多态中有了一个全新的概念:向下转型。</p><blockquote><p>多态中转型的使用：<br>向上转型：Fu5 f = new Zi5();<br>向下转型：Zi5 z = (Zi5) f2;<br>注意：这样的转型，必须要求f2必须是能够转换成z的，也就是说，他俩必须要是继承关系。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu5</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是父类的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi5</span> <span class="keyword">extends</span> <span class="title">Fu5</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是子类重写父类的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是子类特有的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolymorphicDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fu5 f = <span class="keyword">new</span> Zi5();</span><br><span class="line">        f.show();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//多态中的转型，我们既然可以将子类的对象赋值给父，为什么不能把父的引用赋值给子引用</span></span><br><span class="line">        <span class="comment">//将子的对象赋值给父</span></span><br><span class="line">        Fu5 f2 = <span class="keyword">new</span> Zi5();</span><br><span class="line">        <span class="comment">//将父的引用赋值给子的引用</span></span><br><span class="line">        Zi5 z = (Zi5)f2;</span><br><span class="line">        z.show();</span><br><span class="line">        z.function();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是子类重写父类的方法</span></span><br><span class="line"><span class="comment">//这是子类重写父类的方法</span></span><br><span class="line"><span class="comment">//这是子类特有的方法</span></span><br></pre></td></tr></table></figure><p>内存结构图如下所示:</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210903181523.png"></p><p> 但是要注意一点的就是，多态转型中有一种异常，如下所示</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal5</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog5</span> <span class="keyword">extends</span> <span class="title">Animal5</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lookDoor</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat5</span> <span class="keyword">extends</span> <span class="title">Animal5</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paShu</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolymorphicDemo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal5 a = <span class="keyword">new</span> Dog5();</span><br><span class="line">        a.eat();</span><br><span class="line"><span class="comment">//        a.lookDoor();</span></span><br><span class="line"></span><br><span class="line">        Dog5 d = (Dog5) a;  <span class="comment">//在我自己看来，这地方就直接相当于是：Dog5 d = new Dog5() ，就可以直接使用Dog5里面所有的东西了</span></span><br><span class="line">    </span><br><span class="line">        a = <span class="keyword">new</span> Cat5();</span><br><span class="line">        a.eat();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        ((Cat5) a).paShu();</span></span><br><span class="line"></span><br><span class="line">        Cat5 cat5 = (Cat5)a;</span><br><span class="line">        cat5.eat();</span><br><span class="line">        cat5.paShu();</span><br><span class="line">    </span><br><span class="line">        a = <span class="keyword">new</span> Animal5();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Dog5 dd = (Dog5)a;//因为这个a现在是赋给了cat，而这句话dog和cat，两个没有继承关系，所以报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存图如下所示:</p><p><img src="https://cdn.jsdelivr.net/gh/Fang-gg/picture/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210903181733.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的代码块以及方法的重写</title>
      <link href="/2020/09/02/Java%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BB%A5%E5%8F%8A%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99/"/>
      <url>/2020/09/02/Java%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BB%A5%E5%8F%8A%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h1 id="Java中的代码块，继承以及方法的重写"><a href="#Java中的代码块，继承以及方法的重写" class="headerlink" title="Java中的代码块，继承以及方法的重写"></a>Java中的代码块，继承以及方法的重写</h1><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>Java中，使用{}括起来的称为代码块，根据其位置和声明的不同，可以分为局部代码块、构造代码块、静态代码块、同步代码块（多线程再涉及）</p><h3 id="局部代码块"><a href="#局部代码块" class="headerlink" title="局部代码块"></a>局部代码块</h3><p>在方法中出现：限定变量的生命周期，及早释放，提高内存利用<br>只有这一种在一个类出现的时候执行顺序是自上而下的</p><h3 id="构造代码块："><a href="#构造代码块：" class="headerlink" title="构造代码块："></a>构造代码块：</h3><p>在类中方法外出现，多个构造方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行</p><h3 id="静态代码块："><a href="#静态代码块：" class="headerlink" title="静态代码块："></a>静态代码块：</h3><p>在方法外出现，加上static修饰，用于给类进行初始化，在加载的时候就执行，并且只执行一次</p><h4 id="执行顺序："><a href="#执行顺序：" class="headerlink" title="执行顺序："></a>执行顺序：</h4><p>局部代码块——静态代码块（有多少执行多少，只执行一次，自上而下）——构造代码块——构造方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Code</span></span>&#123;</span><br><span class="line">    <span class="comment">//静态代码块</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">200</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    Code()&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">300</span>;</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">100</span>;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">100</span>;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> y = <span class="number">200</span>;</span><br><span class="line">            System.out.println(y);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line">        Code c = <span class="keyword">new</span> Code();</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line">        Code c1 = <span class="keyword">new</span> Code();</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line">        Code c2 = <span class="keyword">new</span> Code();</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//100</span></span><br><span class="line"><span class="comment">//200</span></span><br><span class="line"><span class="comment">//----------------------</span></span><br><span class="line"><span class="comment">//200</span></span><br><span class="line"><span class="comment">//100</span></span><br><span class="line"><span class="comment">//300</span></span><br><span class="line"><span class="comment">//----------------------</span></span><br><span class="line"><span class="comment">//100</span></span><br><span class="line"><span class="comment">//300</span></span><br><span class="line"><span class="comment">//----------------------</span></span><br><span class="line"><span class="comment">//100</span></span><br><span class="line"><span class="comment">//300</span></span><br><span class="line"><span class="comment">//----------------------</span></span><br><span class="line"></span><br><span class="line">先执行主函数中的局部代码块，输出<span class="number">100</span>、<span class="number">200</span>，之后是<span class="keyword">new</span>了一个Code对象出来，执行的是静态代码块（一次），再到构造代码块，再到构造方法。</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h3><p>多个类中存在相同的属性和行为时，将这些内容抽取到单独的一个类，那么多个类无需再定义这些属性和行为，只要继承这个类即可<br>通过extends关键字可以实现类与类的继承</p><blockquote><pre><code>  class 子类名 extends 父类名 &#123;&#125;</code></pre></blockquote><p>单独的这个类称为父类，基类或者超类；这多个类可以称为子类或者派生类<br>有了继承之后，我们定义一个类的时候，可以在已经存在的类的基础上，还可以定义自己的新成员。</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处:"></a>好处:</h3><p>提高了代码的复用性</p><p>提高了代码的维护性</p><p>让类与类之间产生关系，为后面的多态做准备</p><h3 id="坏处"><a href="#坏处" class="headerlink" title="坏处:"></a>坏处:</h3><p>类的耦合性增强了<br>开发的原则：低耦合、高内聚<br>耦合：类与类之间的关系<br>内聚：就是自己完成某件事情的能力</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person1</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学习&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student1</span> <span class="keyword">extends</span> <span class="title">Person1</span></span>&#123; <span class="comment">//Student1是继承Person1来的，或者说是继承自Person1的子类</span></span><br><span class="line">    String stuId;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打游戏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher1</span> <span class="keyword">extends</span> <span class="title">Person1</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student1 student1 = <span class="keyword">new</span> Student1();</span><br><span class="line">        student1.eat();</span><br><span class="line">        student1.sleep();</span><br><span class="line">        student1.study();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        Teacher1 teacher1 = <span class="keyword">new</span> Teacher1();</span><br><span class="line">        teacher1.eat();</span><br><span class="line">        teacher1.sleep();</span><br><span class="line">        teacher1.study();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//吃饭</span></span><br><span class="line"><span class="comment">//睡觉</span></span><br><span class="line"><span class="comment">//学习</span></span><br><span class="line"><span class="comment">//----------------------------</span></span><br><span class="line"><span class="comment">//吃饭</span></span><br><span class="line"><span class="comment">//睡觉</span></span><br><span class="line"><span class="comment">//学习</span></span><br><span class="line"></span><br><span class="line">继承很好的提高了代码的复用性</span><br></pre></td></tr></table></figure><h3 id="Java中继承的特点："><a href="#Java中继承的特点：" class="headerlink" title="Java中继承的特点："></a>Java中继承的特点：</h3><p>  Java只支持单继承，不支持多继承</p><p>  Java支持多层基础（继承体系）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//class Father&#123;&#125;</span></span><br><span class="line"><span class="comment">//class Mother&#123;&#125;</span></span><br><span class="line"><span class="comment">//class Son extends Father&#123;&#125;</span></span><br><span class="line"><span class="comment">//class Son extends Father,Mother&#123;&#125;//错误</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrandFather</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是爷爷&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">GrandFather</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是爸爸&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是儿子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son son = <span class="keyword">new</span> Son();</span><br><span class="line">        son.show2();</span><br><span class="line">        son.show1();</span><br><span class="line">        son.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是儿子</span></span><br><span class="line"><span class="comment">//这是爸爸</span></span><br><span class="line"><span class="comment">//这是爷爷</span></span><br></pre></td></tr></table></figure><h3 id="使用继承的注意事项："><a href="#使用继承的注意事项：" class="headerlink" title="使用继承的注意事项："></a>使用继承的注意事项：</h3><p>  子类只能继承父类所有的非私有的成员（非私有的成员方法和非私有的成员变量）</p><p>  子类不能继承父类的构造方法，但是可以通过super关键字来访问父类的构造方法</p><p>  不要为了部分功能而去继承</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">通过观察发现，出现了一个show2()方法，在类A和类B中都出现了，用继承实现</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这样继承，我们发现show1()并不是我们B类中方法，但是我们一并继承过来了</span></span><br><span class="line"><span class="comment">//使用继承的情况：is a</span></span><br><span class="line"><span class="comment">//满足这一条件就可以使用继承</span></span><br><span class="line"><span class="comment">//Person</span></span><br><span class="line"><span class="comment">//Student</span></span><br><span class="line"><span class="comment">//Teacher</span></span><br><span class="line"><span class="comment">//Doctor</span></span><br></pre></td></tr></table></figure><h3 id="继承与成员变量的关系："><a href="#继承与成员变量的关系：" class="headerlink" title="继承与成员变量的关系："></a>继承与成员变量的关系：</h3><h4 id="类的组成："><a href="#类的组成：" class="headerlink" title="类的组成："></a>类的组成：</h4><p>成员变量<br>成员方法<br>构造方法<br>引入继承之后，我们开始考虑继承与这些的关系<br>1、当父类的成员变量与子类的成员变量不一样的时候<br>2、当父类的成员变量与子类的成员变量一样的时候<br>查找顺序：<br>1、在子类方法的局部范围找，找到返回<br>2、在子类方法的成员范围找，找到返回<br>3、在父类方法的成员范围找，找到返回<br>4、都找不到，报错</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father2</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num3 = <span class="number">50</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span> <span class="keyword">extends</span> <span class="title">Father2</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">30</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">40</span>;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(num2);</span><br><span class="line"><span class="comment">//        System.out.println(num3);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son2 son2 = <span class="keyword">new</span> Son2();</span><br><span class="line">        son2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//40</span></span><br><span class="line"><span class="comment">//20</span></span><br></pre></td></tr></table></figure><h2 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h2><p>当我们不仅想输出局部范围的num，还想输出父类中的num，我们应该怎么做呢<br>Java中提供了一个关键字：super</p><h4 id="super和this的区别是什么呢？（面试题）"><a href="#super和this的区别是什么呢？（面试题）" class="headerlink" title="super和this的区别是什么呢？（面试题）"></a>super和this的区别是什么呢？（面试题）</h4><p>this代表当前对象的引用<br>super代表的是父类存储空间的标识（可以操作父类的成员）</p><h4 id="怎么使用？"><a href="#怎么使用？" class="headerlink" title="怎么使用？"></a>怎么使用？</h4><h5 id="调用成员变量"><a href="#调用成员变量" class="headerlink" title="调用成员变量"></a>调用成员变量</h5><p>this.成员变量 调用的是本类的成员变量<br>super.成员变量 调用的是父类的成员变量<br>访问构造方法（子父类的构造方法）<br>this(…) super(…)<br>访问成员方法<br>this.成员方法() super.成员方法()<br>super关键字的使用举例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father3</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son3</span> <span class="keyword">extends</span> <span class="title">Father3</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">30</span>;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.num);</span><br><span class="line">        System.out.println(<span class="keyword">super</span>.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son3 son3 = <span class="keyword">new</span> Son3();</span><br><span class="line">        son3.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//30</span></span><br><span class="line"><span class="comment">//20</span></span><br><span class="line"><span class="comment">//10</span></span><br></pre></td></tr></table></figure><h3 id="继承与构造方法的关系"><a href="#继承与构造方法的关系" class="headerlink" title="继承与构造方法的关系"></a>继承与构造方法的关系</h3><p>   子类中所有的构造方法默认都会访问父类中空参的构造方法</p><p>   为什么？<br>   因为子类会继承父类的数据，可能还会使用父类的数据<br>   所以在初始化子类之前，一定会先完成父类的初始化</p><p> 注意：<br>   每一个子类的构造方法的第一句话默认都是super()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father4</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是父类的无参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father4</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是父类的有参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son4</span> <span class="keyword">extends</span> <span class="title">Father4</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是子类的无参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son4</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是子类的有参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son4 son4 = <span class="keyword">new</span> Son4();</span><br><span class="line">        Son4 son5 = <span class="keyword">new</span> Son4(<span class="string">&quot;祥哥&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是父类的无参构造方法</span></span><br><span class="line"><span class="comment">//这是子类的无参构造方法</span></span><br><span class="line"><span class="comment">//这是父类的无参构造方法</span></span><br><span class="line"><span class="comment">//这是子类的有参构造方法</span></span><br></pre></td></tr></table></figure><p>但是，当父类没有无参构造方法的时候，怎么办呢</p><p>使用super带参的形式去访问父类的带参构造方法<br>子类通过this去调用本类的其他构造方法<br>本类其他构造方法也必须首先访问父类的构造方法<br>使用this就是间接的调用super去访问父类的构造方法<br>注意事项：</p><p>super(…)或者this(…)必须出现在第一条语句上<br>否则，就会有父类数据的多次初始化，每个类只能初始化一次</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father5</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的无参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father5</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的有参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son5</span> <span class="keyword">extends</span> <span class="title">Father5</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();<span class="comment">//JVM虚拟机会默认在调用子类构造方法的时候添加一个super()，而且必须放在第一句</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类的无参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son5</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        this(&quot;hb&quot;);</span></span><br><span class="line">        <span class="keyword">super</span>(<span class="string">&quot;hb&quot;</span>);<span class="comment">//这是调用父类的有参构造方法</span></span><br><span class="line">        <span class="comment">//这里的this或者super只能出现一个，我的解释是：如果出现多个，或者同时出现</span></span><br><span class="line">        <span class="comment">//会造成父类数据的多次初始化，但每个类只能初始化一次</span></span><br><span class="line">        <span class="comment">//使用super可以理解是父类的带参的调用</span></span><br><span class="line">        <span class="comment">//使用this时，也需要继承父类，，也会有super的出现，所以也会造成父类的初始化</span></span><br><span class="line">        <span class="comment">//所以只能有一个</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类的带参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son5 son5 = <span class="keyword">new</span> Son5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承中成员方法的关系："><a href="#继承中成员方法的关系：" class="headerlink" title="继承中成员方法的关系："></a>继承中成员方法的关系：</h3><p>子类的成员方法与父类的成员方法不一样</p><p>子类的成员方法与父类的成员方法一样的时候，怎么办</p><p>​    先找到子类，有没有这个方法，如果有，就调用</p><p>​    如果子类中没有这个方法，就去父类中找，如果有，就调用</p><p>​    如果都没有，就报错 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father6</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is show()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son6</span> <span class="keyword">extends</span> <span class="title">Father6</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is son6 show2()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public void show()&#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;this is son6 show()&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son6 son6 = <span class="keyword">new</span> Son6();</span><br><span class="line">        son6.show();</span><br><span class="line">        son6.show2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//this is show()</span></span><br><span class="line"><span class="comment">//this is son6 show2()</span></span><br></pre></td></tr></table></figure><h2 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h2><p>方法的重写：<br>子类中如果出现了和父类中一模一样的方法声明，也被称为方法覆盖，方法复写</p><p>方法的重载：<br>本类中出现了方法名一样，参数列表不一样的方法，与返回值无关</p><p>子类的成员方法与父类的成员方法一样的时候，怎么办<br>1、先找子类中，有没有这个方法，如果有，就调用<br>2、如果子类中没有该方法，就去父类中查找，如果有，就调用<br>3、如果都没有，就报错</p><h3 id="方法重写的注意事项"><a href="#方法重写的注意事项" class="headerlink" title="方法重写的注意事项:"></a>方法重写的注意事项:</h3><p>1、父类的私有方法不能被重写<br>2、子类重写父类方法时，访问权限不能低<br>要么子类重写的方法比父类的权限高，要么一样<br>3、父类的静态方法，子类也必须通过静态方法进行重写（其实算不上重写）</p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造方法以及静态的main方法</title>
      <link href="/2020/09/02/%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E9%9D%99%E6%80%81%E7%9A%84main%E6%96%B9%E6%B3%95/"/>
      <url>/2020/09/02/%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E9%9D%99%E6%80%81%E7%9A%84main%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="构造方法以及静态的main方法"><a href="#构造方法以及静态的main方法" class="headerlink" title="构造方法以及静态的main方法"></a>构造方法以及静态的main方法</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>概述：<br>给对象的数据进行初始化。</p><h3 id="构造方法格式："><a href="#构造方法格式：" class="headerlink" title="构造方法格式："></a>构造方法格式：</h3><p>方法名和类名相同<br>没有返回值，连void都没有<br>没有具体的返回值</p><h3 id="构造方法的注意事项："><a href="#构造方法的注意事项：" class="headerlink" title="构造方法的注意事项："></a>构造方法的注意事项：</h3><p>如果不提供构造方法，系统会默认给出构造方法<br>如果自己提供了构造方法，系统将不再提供<br>构造方法也可以重载</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contruction</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    Contruction()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这就是一个构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContructionDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Contruction contruction = <span class="keyword">new</span> Contruction();</span><br><span class="line">        System.out.println(contruction);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这就是一个构造方法</span></span><br><span class="line"><span class="comment">//com.bigdata.shujia10.Contruction@28d93b30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我们可以看到，在这里，我们只是new了一个contruction，就直接打印出来了“这是一个构造方法”，就是因为我们自己定义了一个构造方法，并给了它一个print</span></span><br></pre></td></tr></table></figure><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>1、如果我们没有给出构造方法，JVM会自动给我们提供一个无参构造方法<br>2、如果我们给出了构造方法，JVM就不再提供默认的无参构造方法。<br>这时候如果我们还想使用无参构造方法，就必须要自己给出来，JVM一旦发现我们自己给出了构造方法（不管是有参还是无参，只要我们自己定义了），就永远不会给出默认的构造方法。<br>3、构造方法可以发生重载（方法名一致，参数列表不一样）。</p><h3 id="构造方法的作用："><a href="#构造方法的作用：" class="headerlink" title="构造方法的作用："></a>构造方法的作用：</h3><p>可以给成员变量赋初始化值。<br>给成员变量赋值的两种方式：<br>1、使用setXxx()的形式给私有的成员变量赋值<br>2、使用带参数的构造方法给私有成员变量赋值，配合this指针使用<br>无参有参构造方法举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contruction2</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    Contruction2()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个无参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Contruction2(String name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是带有参数name的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Contruction2(<span class="keyword">int</span> age)&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是带有参数age的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Contruction2(String name,<span class="keyword">int</span> age)&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是带有参数name和参数age的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name+<span class="string">&quot;---&quot;</span>+<span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContructionDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里调用无参构造方法</span></span><br><span class="line">        Contruction2 contruction2 = <span class="keyword">new</span> Contruction2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里调用一个参数的构造方法</span></span><br><span class="line">        Contruction2 contruction21 = <span class="keyword">new</span> Contruction2(<span class="string">&quot;酷酷的涛&quot;</span>);</span><br><span class="line">        Contruction2 contruction22 = <span class="keyword">new</span> Contruction2(<span class="number">22</span>);</span><br><span class="line">        System.out.println(contruction22.getName()+<span class="string">&quot;---&quot;</span>+contruction22.getAge());</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//这里调用两个参数的构造方法</span></span><br><span class="line">        Contruction2 contruction23 = <span class="keyword">new</span> Contruction2(<span class="string">&quot;酷酷的涛&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        contruction23.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是一个无参构造方法</span></span><br><span class="line"><span class="comment">//这是带有参数name的构造方法</span></span><br><span class="line"><span class="comment">//这是带有参数age的构造方法</span></span><br><span class="line"><span class="comment">//null---22</span></span><br><span class="line"><span class="comment">//这是带有参数name和参数age的构造方法</span></span><br><span class="line"><span class="comment">//酷酷的涛---22</span></span><br></pre></td></tr></table></figure><h2 id="类的组成："><a href="#类的组成：" class="headerlink" title="类的组成："></a>类的组成：</h2><p>成员变量<br>构造方法<br>成员方法<br>根据返回值：<br>void，无返回值类型<br>非void的有参构造类型<br>形式参数：<br>空参的构造方法<br>有参的构造方法</p><p>当我们在new对象的时候，其实JVM给出了一系列运行，如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;亚当&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">    Person()&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">&quot;夏娃&quot;</span>;</span><br><span class="line">        <span class="keyword">this</span>.age = <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name+<span class="string">&quot;---&quot;</span>+<span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.show();</span><br><span class="line"><span class="comment">//        System.out.println();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图解如下所示:</p><p><img src="https://i.loli.net/2021/09/02/LlcPKZzSvtf6s4a.png"></p><blockquote><p>首先是<br>将Person.class文件加载到方法区<br>再在栈中给person开辟一个栈内存空间<br>再在堆中给person开辟一个堆内存空间<br>紧接着JVM给成员变量赋予初始值，一个是null，一个是0<br>再给成员变量进行初始化<br>再通过构造方法对成员变量进行初始化<br>数据初始化完毕，将内存中的地址给栈引用</p></blockquote><h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>可以修饰成员变量和成员方法<br>static关键字的特点：<br>随着类的加载而加载<br>优先于对象存在<br>被类的所有对象共享（这也是判断是否使用静态关键字的条件）<br>可以通过类名调用<br>static关键字注意事项：<br>在静态方法中是没有this关键字的<br>静态方法只能访问静态的成员变量和静态的成员方法<br>一般情况下，只要看到一个类中有静态修饰的成员变量或者是成员方法，我们一律采用 类名.静态成员 这种方法使用<br>推荐使用类名调用<br>静态修饰的内容我们一般称为：类成员、与类相关的</p><h3 id="static关键字使用的注意事项"><a href="#static关键字使用的注意事项" class="headerlink" title="static关键字使用的注意事项"></a>static关键字使用的注意事项</h3><p>在静态方法中是没有this关键字的<br>静态方法：<br>访问内容：<br>成员变量：只能访问静态的成员变量<br>成员方法：只能访问静态的成员方法<br>非静态方法：<br>访问内容：<br>成员变量：既可以访问静态的成员变量，也可以访问非静态的成员变量<br>成员方法：既可以访问静态的成员方法，也可以访问非静态的成员方法<br>也就是：静态的只能访问静态的。</p><p>举例：静态的只能访问静态的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span></span>&#123;</span><br><span class="line">    <span class="comment">//非静态的成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//静态的成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非静态的成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(num2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//静态的成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//System.out.println(this.num);//无法从静态上下文中引用非静态 变量 this</span></span><br><span class="line">        System.out.println(num2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//静态的成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//非静态的成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Teacher teacher = <span class="keyword">new</span> Teacher();</span><br><span class="line">        teacher.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//10</span></span><br><span class="line"><span class="comment">//20 </span></span><br></pre></td></tr></table></figure><p>此时的内存静态图如下所示:</p><p><img src="https://i.loli.net/2021/09/02/jJ2YFmhPZy3Cdt5.png"></p><p>static随着类的加载而加载</p><h4 id="static内存图。"><a href="#static内存图。" class="headerlink" title="static内存图。"></a>static内存图。</h4><p>用下面这些代码来解释在有static静态关键字的时候，内存是如果工作的。<br>将内存分为 栈、堆、方法区、静态区<br>首先方法里面有 class文件区、Human的方法区、静态区<br>1、首先运行主函数main，在栈中开辟main(String[] args)空间<br>2、紧接着到了函数Human h1 = new Human(“朱一龙”,41,“中国”);<br>3、在堆中new了一个空间出来，地址是0x0001，给name和age赋<br>初始值，Human中又包括了静态引用和方法引用。<br>h1指向0x0001，之后将name赋值为“朱一龙”，将<br>age赋值为41，紧接着到了静态引用，将country赋值为中国<br>再到了方法引用，然后到了方法引用，里面包括了构造方法和<br>show方法，之后展示数据</p><p>之后就在不断的重复这一过程。</p><p>main方法的格式讲解<br>main方法的格式讲解：<br><code>public static void main(String[] args) &#123;…&#125;</code></p><p>public: 公共的，访问权限是最大的。JVM默认的就是它。<br>    由于main方法是被JVM调用的，所以他的权限要是最大的。<br>static:静态的，不需要创建对象，通过类名就可以调用，方便我们JVM虚拟机调用<br>void:无返回值的意思，一般情况下，方法写返回是为了将结果返回给调用者，<br>   而main方法是被JVM虚拟机调用的，写返回内容没有意义。<br>main:是一个方法名，也是java程序的入口方法。大部分的语言入口的名字都是main<br>    小部分的程序入口方法不是main,例如C语言，底层调用的是_start</p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础小知识</title>
      <link href="/2020/09/02/Java%E5%9F%BA%E7%A1%80%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/09/02/Java%E5%9F%BA%E7%A1%80%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="主要说说成员变量与局部变量的区别、形式参数、匿名对象与Java的封装性。"><a href="#主要说说成员变量与局部变量的区别、形式参数、匿名对象与Java的封装性。" class="headerlink" title="主要说说成员变量与局部变量的区别、形式参数、匿名对象与Java的封装性。"></a>主要说说成员变量与局部变量的区别、形式参数、匿名对象与Java的封装性。</h1><h2 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h2><h3 id="在类中定义的位置不同："><a href="#在类中定义的位置不同：" class="headerlink" title="在类中定义的位置不同："></a>在类中定义的位置不同：</h3><p>成员变量：类中，但是定义在方法外。<br>局部变量：定义在方法类中。</p><h3 id="在内存中的位置不同："><a href="#在内存中的位置不同：" class="headerlink" title="在内存中的位置不同："></a>在内存中的位置不同：</h3><p>成员变量：定义在堆中。<br>局部变量：定义在栈中。</p><h3 id="生命周期不同："><a href="#生命周期不同：" class="headerlink" title="生命周期不同："></a>生命周期不同：</h3><p>成员变量：随着对象的创建而存在，随着对象的结束而结束。<br>局部变量：随着方法的调用而存在，随着方法的结束而结束。</p><h3 id="初始化值不同："><a href="#初始化值不同：" class="headerlink" title="初始化值不同："></a>初始化值不同：</h3><p>成员变量：有默认的初始化值，比如int给的是0，String类型给的是null<br>局部变量：没有系统给它初始化值，必须在定义的时候给它赋值，才能使用。<br>注意：<br>1、方法与方法之间里面的局部变量不能互相调用。<br>2、局部变量可以和成员变量一样，在方法中使用的时候，采用就近原则。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BianLiang</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        int n1;</span></span><br><span class="line">        <span class="keyword">int</span>  n1 = <span class="number">22</span>;</span><br><span class="line">        String name = <span class="string">&quot;酷酷的涛&quot;</span>;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(n1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BianLiangDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BianLiang b1 = <span class="keyword">new</span> BianLiang();</span><br><span class="line">        b1.show(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//访问成员变量</span></span><br><span class="line">        System.out.println(b1.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//酷酷的涛</span></span><br><span class="line"><span class="comment">//22</span></span><br><span class="line"><span class="comment">//null</span></span><br></pre></td></tr></table></figure><h2 id="形式参数的问题"><a href="#形式参数的问题" class="headerlink" title="形式参数的问题"></a>形式参数的问题</h2><p>在调用方法时，括号里面的参数有两种类型，一种是基本数据类型，一种是引用数据类型。<br>基本数据类型：形式参数的改变不会影响到实际参数。<br>引用数据类型：形式参数的改变会直接影响到实际参数。</p><h2 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h2><p>匿名对象：就是没有名字的对象。<br>匿名对象的使用场景：<br>1、调用方法的时候，仅仅调用一次的时候，调用多次的时候，不适合。<br>为什么会存在匿名对象？<br>因为匿名调用完毕之后，由于栈内存中没有引用指向它，那么调用完毕之后就是垃圾，可以被垃圾回收器回收。<br>2、匿名对象可以作为实际参数进行传递。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;手机可以打电话。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone1Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">(Phone1 p)</span> </span>&#123;</span><br><span class="line">        p.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个Phone1对象</span></span><br><span class="line">        Phone1 p = <span class="keyword">new</span> Phone1();</span><br><span class="line">        p.call();</span><br><span class="line">        <span class="comment">//创建一个Phone1Demo对象</span></span><br><span class="line">        Phone1Demo p1 = <span class="keyword">new</span> Phone1Demo();</span><br><span class="line">        p1.function(p);</span><br><span class="line">        System.out.println(<span class="string">&quot;******************使用匿名类进行改进***********************&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Phone1().call();</span><br><span class="line">        <span class="keyword">new</span> Phone1Demo().function(p);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//手机可以打电话。</span></span><br><span class="line"><span class="comment">//手机可以打电话。</span></span><br><span class="line"><span class="comment">//******************使用匿名类进行改进***********************</span></span><br><span class="line"><span class="comment">//手机可以打电话。</span></span><br><span class="line"><span class="comment">//手机可以打电话。</span></span><br></pre></td></tr></table></figure><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h3 id="封装：其实就是指隐藏对象的属性和相关实现细节，仅仅对外提供公共访问的方式。Java中提供了一个关键字：private"><a href="#封装：其实就是指隐藏对象的属性和相关实现细节，仅仅对外提供公共访问的方式。Java中提供了一个关键字：private" class="headerlink" title="封装：其实就是指隐藏对象的属性和相关实现细节，仅仅对外提供公共访问的方式。Java中提供了一个关键字：private"></a>封装：其实就是指隐藏对象的属性和相关实现细节，仅仅对外提供公共访问的方式。Java中提供了一个关键字：private</h3><p>private：私有的，可以修饰成员变量和成员方法。<br>注意：被private修饰的成员变量或者是成员方法，只能在本类中访问</p><blockquote><p>对private的使用<br>1、对成员变量用private进行修饰<br>2、提供对应的getXxx()和setXxx()方法</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student2</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义成员变量</span></span><br><span class="line">    <span class="comment">//年龄</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age ;</span><br><span class="line">    <span class="comment">//姓名</span></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> a )</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;<span class="number">0</span> || a&gt;=<span class="number">200</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;赋值的年龄有问题&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            age = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄是：&quot;</span>+age);</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名是：&quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student2 stu2 = <span class="keyword">new</span> Student2();</span><br><span class="line">        stu2.setAge(<span class="number">22</span>);</span><br><span class="line"><span class="comment">//        stu2.age = 1000;    //这时，这一行直接报错，因为age被定义为私有属性，不能被直接访问</span></span><br><span class="line">        stu2.name = <span class="string">&quot;酷酷的涛&quot;</span>;</span><br><span class="line">        stu2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//年龄是：22</span></span><br><span class="line"><span class="comment">//姓名是：酷酷的涛</span></span><br></pre></td></tr></table></figure><h2 id="This关键字"><a href="#This关键字" class="headerlink" title="This关键字"></a>This关键字</h2><p>变量的使用原则：就近原则<br>直接通过类名.成员变量是报错的<br>如果这个Student3这个对象存在，它就代表着一个学生对象<br>但是，谁可以代表这个当前类的对象呢<br>Java中提供了一个关键字：this<br>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student3</span></span>&#123;</span><br><span class="line">    <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//年龄</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对name成员变量进行赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="comment">//变量的使用原则：就近原则</span></span><br><span class="line">        <span class="comment">//直接通过类名.成员变量是报错的，目前还没有说过类似的用法，所以这个是有问题的</span></span><br><span class="line">        <span class="comment">//如果这个Student3这个对象存在，他就代表着一个学生对象</span></span><br><span class="line">        <span class="comment">//但是，谁可以代表这个当前类的对象呢？</span></span><br><span class="line">        <span class="comment">//Java就提供了一个关键字：this</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student3 stu3 = <span class="keyword">new</span> Student3();</span><br><span class="line">        stu3.setAge(<span class="number">22</span>);</span><br><span class="line">        stu3.setName(<span class="string">&quot;酷酷的涛&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> age = stu3.getAge();</span><br><span class="line">        String name = stu3.getName();</span><br><span class="line">        System.out.println(name+<span class="string">&quot;**********&quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//酷酷的涛**********22</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据加密---Java实现</title>
      <link href="/2020/09/02/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86-Java%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/09/02/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86-Java%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="数据加密–Java实现"><a href="#数据加密–Java实现" class="headerlink" title="数据加密–Java实现"></a>数据加密–Java实现</h1><p>某个公司采用公用电话传递数据信息，数据是小于8位的整数，为了确保安全，在传递过程中需要加密，加密规则如下：<br>首先将数据倒序，然后将每位数字都加上5，再用和除以10的余数代替该数字，<br>最后将第一位和最后一位数字交换。 请任意给定一个小于8位的整数，<br>然后，把加密后的结果在控制台打印出来。<br>代码实现如下所示:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShuJuJiaMiDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个数据</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">123456</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个数组</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];</span><br><span class="line">        <span class="comment">//把数据上的每一位数字按照顺序放到数组中</span></span><br><span class="line">        <span class="comment">//由于，我们已经获取到了每一个数字了，所以我们干脆直接逆序赋值</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        int index = 0;</span></span><br><span class="line"><span class="comment">        arr[index] = num%10;</span></span><br><span class="line"><span class="comment">        index++;</span></span><br><span class="line"><span class="comment">        arr[index] = num/10%10;</span></span><br><span class="line"><span class="comment">        index++;</span></span><br><span class="line"><span class="comment">        arr[index] = num/10/10%10;</span></span><br><span class="line"><span class="comment">        index++;</span></span><br><span class="line"><span class="comment">        arr[index] = num/10/10/10%10;</span></span><br><span class="line"><span class="comment">        index++;</span></span><br><span class="line"><span class="comment">        arr[index] = num/10/10/10/10%10;</span></span><br><span class="line"><span class="comment">        index++;</span></span><br><span class="line"><span class="comment">        arr[index] = num/10/10/10/10/10%10;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">//用while循环改进，由于今后我们会手动输入整数，不确定长度</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            arr[index] = num%<span class="number">10</span>;</span><br><span class="line">            index++;</span><br><span class="line">            num = num/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将每位数字都加上5，再用和除以10的余数代替该数字</span></span><br><span class="line">        <span class="comment">//由于我们在给数组赋值的时候，循环结束的条件是num &gt; 0，index的变化只变化到数据的长度对应的索引+1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">            arr[i]+=<span class="number">5</span>;</span><br><span class="line">            arr[i]%=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">//最后将第一位和最后一位数字交换</span></span><br><span class="line">        <span class="keyword">int</span> tmp = arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>]=arr[index-<span class="number">1</span>];</span><br><span class="line">        arr[index-<span class="number">1</span>] = tmp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;123456加密后的数据是：&quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">            System.out.print(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类与对象</title>
      <link href="/2020/09/02/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/09/02/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><h2 id="引入面向对象的思想："><a href="#引入面向对象的思想：" class="headerlink" title="引入面向对象的思想："></a>引入面向对象的思想：</h2><p>当我们有多个数组需要遍历时，我们可以将遍历的代码封装到方法中，需要遍历时，只需要调用相应的方法即可，提高代码的复用性。<br>但当我们对数组做更多的操作时，比如对数组获取最值，数值逆序，就需要将更多的功能封装到相应的方法中，封装的方法越来越多，我们就可以将这些方法继续封装，将来再做数组的操作时，就不用找具体的方法，先找到这个类，再使用这个类中的方法，这就是面向对象思想的编程。</p><h3 id="面向对象的思想："><a href="#面向对象的思想：" class="headerlink" title="面向对象的思想："></a>面向对象的思想：</h3><p>面向对象的思想是基于面向过程的编程思想</p><h3 id="面向过程：强调的是每个功能的步骤（比如C语言）"><a href="#面向过程：强调的是每个功能的步骤（比如C语言）" class="headerlink" title="面向过程：强调的是每个功能的步骤（比如C语言）"></a>面向过程：强调的是每个功能的步骤（比如C语言）</h3><h3 id="面向对象：强调的是对象，然后让这个对象去调用功能"><a href="#面向对象：强调的是对象，然后让这个对象去调用功能" class="headerlink" title="面向对象：强调的是对象，然后让这个对象去调用功能"></a>面向对象：强调的是对象，然后让这个对象去调用功能</h3><p>面向对象的特点：<br>1）是一种更符合我们思想习惯的概念<br>2）可以将复杂的事情简单化<br>3）将我们从执行者变成了指挥者</p><p>举例：<br>吃饭：<br>面向过程：先去超市买菜–洗菜–切菜–炒菜–装盘–吃<br>面向对象：去饭店吃–你（点菜）–厨师（做菜）–服务员（上菜）–你（吃）<br>打水：<br>面向过程：拿起水杯–走到饮水机面前–选择热水还是冷水–接水–喝<br>面向对象：你祈求同桌去接水–同桌接水–你喝水</p><p>将大象装进冰箱<br>面向过程的思路：<br>1、打开冰箱门<br>2、把大象装进冰箱<br>3、关闭冰箱门<br>代码体现：</p><p>代码体现：  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">              <span class="comment">//System.out.println(&quot;打开冰箱门&quot;);</span></span><br><span class="line">              <span class="comment">//打开冰箱门这个动作，肯定不是这么一个简单输出语句就完事了</span></span><br><span class="line">              <span class="comment">//现在是仅仅是为了演示，就写了这么一个输出语句</span></span><br><span class="line">              <span class="comment">//假设我们要打开很多次冰箱门，就要写很多次这个代码</span></span><br><span class="line">              <span class="comment">//需要用方法改进</span></span><br><span class="line">          open();</span><br><span class="line">          zhuang();</span><br><span class="line">          close();</span><br><span class="line">  </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;打开冰箱门&quot;</span>);​       </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zhuang</span><span class="params">()</span></span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;把大象装进冰箱&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;关闭冰箱门&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="面向对象的思想体现："><a href="#面向对象的思想体现：" class="headerlink" title="面向对象的思想体现："></a>面向对象的思想体现：</h3><p>我们怎么才能更符合面向对象的思想呢？<br>1、我们要考虑有哪些类？<br>2、这些每个类里面都有些什么呢？<br>3、类与类之间的关系是什么样子的呢？</p><p>把大象装进冰箱的分析：（如何分析有哪些类呢？UML 名词提取法）<br>1、有哪些类呢？<br>大象<br>冰箱<br>测试类<br>2、这些每个类里面都有些什么呢？<br>大象：<br>进冰箱<br>冰箱：<br>打开冰箱门<br>关闭冰箱门<br>测试类：<br>main方法<br>代码体现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Elephant</span></span>&#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toBingXiang</span><span class="params">()</span></span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;装进冰箱&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Refrigerator</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;打开冰箱门&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;关闭冰箱门&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">            调用冰箱类中的打开冰箱门的open()方法</span><br><span class="line">            调用大象类中的装进冰箱的toBingXiang()方法</span><br><span class="line">            调用冰箱类中的关闭冰箱门的close()方法</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="面向对象的开发、设计、特征"><a href="#面向对象的开发、设计、特征" class="headerlink" title="面向对象的开发、设计、特征"></a>面向对象的开发、设计、特征</h3><p>面向对象的开发<br>就是不断的创建对象，使用对象，指挥对象做事情。</p><p>面向对象的设计<br>实就是在管理和维护对象之间的关系</p><h4 id="面向对象的特征"><a href="#面向对象的特征" class="headerlink" title="面向对象的特征"></a>面向对象的特征</h4><p>封装<br>继承<br>多态</p><h3 id="类与对象的概述："><a href="#类与对象的概述：" class="headerlink" title="类与对象的概述："></a>类与对象的概述：</h3><p>现实世界中是如何让描述一个事物呢？<br>举例：人<br>五官、姓名、年龄、性别…<br>吃饭、喝水、学习、玩…</p><blockquote><p>属性：事物的描述信息<br>行为：就是事物能够做什么</p></blockquote><p>我们学习编程语言，就是为了模拟现实世界的事物的。<br>而我们现在学习的语言是：java<br>而java中最基本的单位是：类<br>所以，我们通过java把事物用类给描述出来<br>由此可见，我们就可以得到现实生活中的事物与类之间的对应关系：</p><p>事物： 类：<br>属性：事物的描述信息 成员变量<br>行为：就是事物能够做什么 成员方法</p><p>类：是一组相关的属性和行为的集合。是一个抽象的概念。<br>对象：是该类事物的具体表现体现。具体到存在的个体。<br>举例：<br>事物：人 类：Person<br>属性：姓名、年龄、性别 成员变量：name、age、gender<br>行为：吃饭、喝水、学习 成员方法：eat、drink、study</p><p>对象：是该类事物的具体体现 举例：学生、老师、医生、程序员…</p><h4 id="类与对象举例展示"><a href="#类与对象举例展示" class="headerlink" title="类与对象举例展示"></a>类与对象举例展示</h4><p>定义一个手机类来进行测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pho</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义成员变量</span></span><br><span class="line">    <span class="comment">//品牌</span></span><br><span class="line">    String brand;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    String color;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义成员方法</span></span><br><span class="line">    <span class="comment">//打电话</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;给&quot;</span>+s+<span class="string">&quot;打电话...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发短信</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;群发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//玩游戏</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;玩游戏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过手机类创建手机对象</span></span><br><span class="line">        Pho p1 = <span class="keyword">new</span> Pho();</span><br><span class="line">        <span class="comment">//通过实例化出来的p1对象调用属性</span></span><br><span class="line">        System.out.println(p1.brand); <span class="comment">//null</span></span><br><span class="line">        System.out.println(p1.price); <span class="comment">//0</span></span><br><span class="line">        System.out.println(p1.color); <span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//给对象的成员变量赋值</span></span><br><span class="line">        p1.brand = <span class="string">&quot;华为&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        p1.price = &quot;9999&quot;; //注意  赋值需要注意成员变量的数据类型</span></span><br><span class="line">        p1.price = <span class="number">9999</span>;</span><br><span class="line">        p1.color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;手机的牌子是：&quot;</span>+p1.brand); <span class="comment">//&quot;华为&quot;</span></span><br><span class="line">        System.out.println(p1.brand+<span class="string">&quot;的价格是：&quot;</span>+p1.price); <span class="comment">//9999</span></span><br><span class="line">        System.out.println(p1.brand+<span class="string">&quot;的颜色是：&quot;</span>+p1.color); <span class="comment">//&quot;blue&quot;</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">//通过对象调用成员方法</span></span><br><span class="line">        p1.call(<span class="string">&quot;马云&quot;</span>); <span class="comment">//注意 调用对象的成员方法的时候，需要注意有无传参</span></span><br><span class="line">        p1.sendMessage();</span><br><span class="line">        p1.playGame();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">手机的牌子是：华为</span><br><span class="line">华为的价格是：<span class="number">9999</span></span><br><span class="line">华为的颜色是：blue</span><br><span class="line">给马云打电话...</span><br><span class="line">群发短信</span><br><span class="line">玩游戏</span><br></pre></td></tr></table></figure><p>一个对象的内存图解如下所示:</p><p><img src="https://i.loli.net/2021/09/02/7kA8BK4wqRy6nic.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pho1</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义成员变量</span></span><br><span class="line">    <span class="comment">//品牌</span></span><br><span class="line">    String brand;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    String color;</span><br><span class="line">    <span class="comment">//定义成员方法</span></span><br><span class="line">    <span class="comment">//打电话</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;给&quot;</span>+s+<span class="string">&quot;打电话...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发短信</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;群发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//玩游戏</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;玩游戏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建手机对象</span></span><br><span class="line">    Pho1 p1 = <span class="keyword">new</span> Pho1();</span><br><span class="line">    <span class="comment">//给对象的成员变量赋值</span></span><br><span class="line">    p1.brand = <span class="string">&quot;华为&quot;</span>;</span><br><span class="line"><span class="comment">//        p1.price = &quot;9999&quot;; //注意  赋值需要注意成员变量的数据类型</span></span><br><span class="line">    p1.price = <span class="number">9999</span>;</span><br><span class="line">    p1.color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">    System.out.println(p1.brand+<span class="string">&quot;,&quot;</span>+p1.price+<span class="string">&quot;,&quot;</span>+p1.color);</span><br><span class="line">    p1.call(<span class="string">&quot;小方&quot;</span>);</span><br><span class="line">    p1.sendMessage();</span><br><span class="line">    p1.playGame();</span><br><span class="line">    Pho1 p2 = <span class="keyword">new</span> Pho1();</span><br><span class="line">    <span class="comment">//给对象的成员变量赋值</span></span><br><span class="line">    p2.brand = <span class="string">&quot;小米&quot;</span>;</span><br><span class="line"><span class="comment">//        p1.price = &quot;9999&quot;; //注意  赋值需要注意成员变量的数据类型</span></span><br><span class="line">    p2.price = <span class="number">1999</span>;</span><br><span class="line">    p2.color = <span class="string">&quot;black&quot;</span>;</span><br><span class="line">    System.out.println(p2.brand+<span class="string">&quot;,&quot;</span>+p2.price+<span class="string">&quot;,&quot;</span>+p2.color);</span><br><span class="line">    p2.call(<span class="string">&quot;雷军&quot;</span>);</span><br><span class="line">    p2.sendMessage();</span><br><span class="line">    p2.playGame();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//华为,9999,blue</span></span><br><span class="line"><span class="comment">//给小方打电话...</span></span><br><span class="line"><span class="comment">//群发短信</span></span><br><span class="line"><span class="comment">//玩游戏</span></span><br><span class="line"><span class="comment">//小米,1999,black</span></span><br><span class="line"><span class="comment">//给雷军打电话...</span></span><br><span class="line"><span class="comment">//群发短信</span></span><br><span class="line"><span class="comment">//玩游戏</span></span><br></pre></td></tr></table></figure><p>两个对象的内存图解如下所示:</p><p><img src="https://i.loli.net/2021/09/02/w1CfPstNVqBx3ce.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pho2</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义成员变量</span></span><br><span class="line">    <span class="comment">//品牌</span></span><br><span class="line">    String brand;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    String color;</span><br><span class="line">    <span class="comment">//定义成员方法</span></span><br><span class="line">    <span class="comment">//打电话</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;给&quot;</span>+s+<span class="string">&quot;打电话...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发短信</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;群发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//玩游戏</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;玩游戏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建手机对象</span></span><br><span class="line">        Pho2 p1 = <span class="keyword">new</span> Pho2();</span><br><span class="line">        <span class="comment">//给对象的成员变量赋值</span></span><br><span class="line">        p1.brand = <span class="string">&quot;华为&quot;</span>;</span><br><span class="line"><span class="comment">//        p1.price = &quot;9999&quot;; //注意  赋值需要注意成员变量的数据类型</span></span><br><span class="line">        p1.price = <span class="number">9999</span>;</span><br><span class="line">        p1.color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">        System.out.println(p1.brand+<span class="string">&quot;,&quot;</span>+p1.price+<span class="string">&quot;,&quot;</span>+p1.color);</span><br><span class="line">        p1.call(<span class="string">&quot;杨老板&quot;</span>);</span><br><span class="line">        p1.sendMessage();</span><br><span class="line">        p1.playGame();</span><br><span class="line">        Pho2 p2 = <span class="keyword">new</span> Pho2();</span><br><span class="line">        <span class="comment">//给对象的成员变量赋值</span></span><br><span class="line">        p2.brand = <span class="string">&quot;小米&quot;</span>;</span><br><span class="line"><span class="comment">//        p1.price = &quot;9999&quot;; //注意  赋值需要注意成员变量的数据类型</span></span><br><span class="line">        p2.price = <span class="number">1999</span>;</span><br><span class="line">        p2.color = <span class="string">&quot;black&quot;</span>;</span><br><span class="line">        System.out.println(p2.brand+<span class="string">&quot;,&quot;</span>+p2.price+<span class="string">&quot;,&quot;</span>+p2.color);</span><br><span class="line">        p2.call(<span class="string">&quot;雷军&quot;</span>);</span><br><span class="line">        p2.sendMessage();</span><br><span class="line">        p2.playGame();</span><br><span class="line">        <span class="comment">//创建第三个对象</span></span><br><span class="line">        Pho2 p3 = p1;</span><br><span class="line">        p3.price = <span class="number">999</span>;</span><br><span class="line">        System.out.println(p1.price); <span class="comment">//999</span></span><br><span class="line">        System.out.println(p3.brand+<span class="string">&quot;,&quot;</span>+p3.price+<span class="string">&quot;,&quot;</span>+p3.color); <span class="comment">//&quot;华为&quot;，999，&quot;blue&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//华为,9999,blue</span></span><br><span class="line"><span class="comment">//给杨老板打电话...</span></span><br><span class="line"><span class="comment">//群发短信</span></span><br><span class="line"><span class="comment">//玩游戏</span></span><br><span class="line"><span class="comment">//小米,1999,black</span></span><br><span class="line"><span class="comment">//给雷军打电话...</span></span><br><span class="line"><span class="comment">//群发短信</span></span><br><span class="line"><span class="comment">//玩游戏</span></span><br><span class="line"><span class="comment">//999</span></span><br><span class="line"><span class="comment">//华为,999,blue</span></span><br></pre></td></tr></table></figure><p>3个对象的内存图解如下所示:</p><p><img src="https://i.loli.net/2021/09/02/5mIu9GOyUEBfVQn.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组以及Java中的内存分配</title>
      <link href="/2020/09/02/%E6%95%B0%E7%BB%84%E4%BB%A5%E5%8F%8AJava%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
      <url>/2020/09/02/%E6%95%B0%E7%BB%84%E4%BB%A5%E5%8F%8AJava%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="一维数组以及Java中的内存分配"><a href="#一维数组以及Java中的内存分配" class="headerlink" title="一维数组以及Java中的内存分配"></a>一维数组以及Java中的内存分配</h1><h2 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h2><p>1、数组是存储同一种数据类型多个元素的集合。也可以看成是一个容器。<br>2、数组既可以存储基本数据类型，也可以存储引用数据类型。</p><p>语句定义格式：<br>  1、数据类型[] 数组名<br>    举例：int[] arr1  推荐使用第一种定义方式<br>  2、数据类型 数组名[]<br>    举例：long arr2[]<br>  注意事项：<br>    针对数组定义两种格式，推荐使用第一种格式。因为第一种的可读性更强。<br>    第二种可以早期的时候确实有很多人这样用。不过，现在这样用的人越来越少了。</p><p>如果只是单纯地定义了数组是没有任何意义的，因为里面没有值，想要使用它，必须先初始化。<br>那么如何初始化呢？<br>Java中的数组必须先初始化,然后才能使用。</p><h3 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h3><p>​    所谓初始化：就是为数组中的数组元素分配内存空间，并为每个数组元素赋值。<br>数组初始化：<br>  1、动态初始化：初始化时只指定数组长度，由系统自动为数组分配初始值。<br>​    先不赋值<br>  2、静态初始化：初始化时指定每个数组元素的初始值，由系统决定数组长度。<br>​    先赋值</p><p>动态初始化：初始化时只指定数组长度，由系统为数组分配初始值。<br>动态初始化的格式：数据类型[] 数组名 = new 数据类型[数组长度];<br>举例：int[] arr = new int[3];<br>解释：定义了一个int类型的数组，这个数组中可以存放3个int类型的值。</p><h2 id="Java中的内存地址的分配"><a href="#Java中的内存地址的分配" class="headerlink" title="Java中的内存地址的分配"></a>Java中的内存地址的分配</h2><p><img src="https://i.loli.net/2021/09/02/IBuvZSPGCpkEjFw.png"></p><p>例如:定义一个数组，并为其赋值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//定义一个数组</span></span><br><span class="line">        <span class="keyword">int</span> []arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        System.out.println(arr);</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//为数组赋初值</span></span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="number">200</span>;</span><br><span class="line">        <span class="comment">//输出数组名</span></span><br><span class="line">        System.out.println(arr);</span><br><span class="line">        <span class="comment">//输出元素值</span></span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[I@28d93b30</span></span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="comment">//[I@28d93b30</span></span><br><span class="line"><span class="comment">//100</span></span><br><span class="line"><span class="comment">//200</span></span><br><span class="line"><span class="comment">//0</span></span><br></pre></td></tr></table></figure><h3 id="定义两个数组，分别动态初始化后，手动赋值，并打印数组名和个元素值"><a href="#定义两个数组，分别动态初始化后，手动赋值，并打印数组名和个元素值" class="headerlink" title="定义两个数组，分别动态初始化后，手动赋值，并打印数组名和个元素值"></a>定义两个数组，分别动态初始化后，手动赋值，并打印数组名和个元素值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义第一个数组</span></span><br><span class="line">        <span class="keyword">int</span> []arr = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">3</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="number">22</span>;</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="number">33</span>;</span><br><span class="line">        System.out.println(arr);</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">        <span class="comment">//定义第二个数组</span></span><br><span class="line">        <span class="keyword">int</span> []arr1 = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">2</span>];</span><br><span class="line">        arr1[<span class="number">0</span>] = <span class="number">44</span>;</span><br><span class="line">        arr1[<span class="number">1</span>] = <span class="number">55</span>;</span><br><span class="line">        System.out.println(arr1[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(arr1[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[I@28d93b30</span></span><br><span class="line"><span class="comment">//11</span></span><br><span class="line"><span class="comment">//22</span></span><br><span class="line"><span class="comment">//33</span></span><br><span class="line"><span class="comment">//44</span></span><br><span class="line"><span class="comment">//55</span></span><br></pre></td></tr></table></figure><p>图解如下:</p><p><img src="https://i.loli.net/2021/09/02/m1OMxWhKFL7cDaw.png"></p><p>举例<br>定义第一个数组，动态初始化，并手动赋值，并打印数组名词以及各元素值<br>定义第二个数组，动态初始化，并手动赋值，并打印数组名词以及各元素值<br>定义第三个数组，将第一个数组的地址值赋给第三个数组。（注意：数组的数据类型要一致）<br>并手动赋值，并打印数组名词以及各元素值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义第一个数组</span></span><br><span class="line">        <span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        arr1[<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">        arr1[<span class="number">1</span>] = <span class="number">22</span>;</span><br><span class="line">        arr1[<span class="number">2</span>] = <span class="number">33</span>;</span><br><span class="line">        System.out.println(arr1);</span><br><span class="line">        System.out.println(arr1[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(arr1[<span class="number">1</span>]);</span><br><span class="line">        System.out.println(arr1[<span class="number">2</span>]);</span><br><span class="line">        <span class="comment">//定义第二个数组</span></span><br><span class="line">        <span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        arr2[<span class="number">0</span>] = <span class="number">44</span>;</span><br><span class="line">        arr2[<span class="number">1</span>] = <span class="number">55</span>;</span><br><span class="line">        arr2[<span class="number">2</span>] = <span class="number">66</span>;</span><br><span class="line">        System.out.println(arr2);</span><br><span class="line">        System.out.println(arr2[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(arr2[<span class="number">1</span>]);</span><br><span class="line">        System.out.println(arr2[<span class="number">2</span>]);</span><br><span class="line">        <span class="comment">//这是第三个数组</span></span><br><span class="line">        <span class="keyword">int</span>[] arr3 = arr1;</span><br><span class="line">        arr3[<span class="number">0</span>] = <span class="number">77</span>;</span><br><span class="line">        arr3[<span class="number">1</span>] = <span class="number">88</span>;</span><br><span class="line">        System.out.println(arr3); <span class="comment">//打印的是arr1的地址值</span></span><br><span class="line">        System.out.println(arr1[<span class="number">0</span>]); <span class="comment">//77</span></span><br><span class="line">        System.out.println(arr1[<span class="number">1</span>]); <span class="comment">//88</span></span><br><span class="line">        System.out.println(arr1[<span class="number">2</span>]); <span class="comment">//33</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[I@28d93b30</span></span><br><span class="line"><span class="comment">//11</span></span><br><span class="line"><span class="comment">//22</span></span><br><span class="line"><span class="comment">//33</span></span><br><span class="line"><span class="comment">//[I@1b6d3586</span></span><br><span class="line"><span class="comment">//44</span></span><br><span class="line"><span class="comment">//55</span></span><br><span class="line"><span class="comment">//66</span></span><br><span class="line"><span class="comment">//[I@28d93b30</span></span><br><span class="line"><span class="comment">//77</span></span><br><span class="line"><span class="comment">//88</span></span><br><span class="line"><span class="comment">//33</span></span><br></pre></td></tr></table></figure><p>图解如下:</p><p><img src="https://i.loli.net/2021/09/02/ZpSVckT7IwLyC91.png"></p><h2 id="数组的静态初始化"><a href="#数组的静态初始化" class="headerlink" title="数组的静态初始化"></a>数组的静态初始化</h2><p>数组的静态初始化：<br>格式：数据类型[] 数组名 = new 数据类型[]{元素1,元素2,…};<br>简化格式：数据类型[] 数组名 = {元素1,元素2,…}</p><blockquote><p>举例：<br>    int[] arr = new int[]{1,2,3,4,5};</p><p>简化格式的举例：<br>        int[] arr1 = {6,7,8,9,10};</p><p>注意事项：<br>    1、不能同时使用动态初始化和静态初始化<br>        举例：<br>            int[] arr2 = new int[3]{1,2,3}; //错误</p></blockquote><h2 id="数组使用常见的异常"><a href="#数组使用常见的异常" class="headerlink" title="数组使用常见的异常"></a>数组使用常见的异常</h2><p>（1）数组索引越界<br><code>ArrayIndexOutOfBoundsException</code><br>访问到了数组中的不存在的索引时发生。<br>（2）空指针异常<br><code>NullPointerException</code><br>数组引用没有指向实体，却在操作实体中的元素时。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">40</span>&#125;;</span><br><span class="line">    </span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(arr[4]);</span></span><br><span class="line"></span><br><span class="line">        arr = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(arr[0]);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//40</span></span><br><span class="line"><span class="comment">//null</span></span><br></pre></td></tr></table></figure><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>二维数组：<br>就是元素是一维数组的数组</p><h3 id="格式1："><a href="#格式1：" class="headerlink" title="格式1："></a>格式1：</h3><blockquote><p>数据类型[][] 变量名 = new 数据类型[m][n]</p></blockquote><blockquote><p>​    m:表示这个二维数组有多少个元素，其中这个元素是一维数组<br>​    n:表示每个一维数组的元素有多少个<br>注意：<br>​    一下格式也可以表示一个二维数组<br>​    a:数据类型 数组名称[][] = new 数据类型[m][n];<br>​    b:数据类型[] 数组名称[] = new 数据类型[m][n];<br>举例：<br>​    int x;<br>​    int y;<br>​    int x,y;<br>​    int[] x;<br>​    int[][] x;<br>​    int[] x[];<br>​    int x[][];</p></blockquote><p>例如:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//定义了一个二维数组arr</span></span><br><span class="line">        <span class="comment">//这里的3代表是有3个一维数组</span></span><br><span class="line">        <span class="comment">//这里的2代表每个一维数组有2个元素</span></span><br><span class="line">        <span class="comment">//输出二维数组的名称</span></span><br><span class="line">        System.out.println(arr);    <span class="comment">//输出的是二维数组在堆内存对应的地址值</span></span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]); <span class="comment">//输出的是第一个一维数组在堆内存对应的地址值</span></span><br><span class="line">        System.out.println(arr[<span class="number">1</span>]); <span class="comment">//输出的是第二个一维数组在堆内存对应的地址值</span></span><br><span class="line">        System.out.println(arr[<span class="number">2</span>]); <span class="comment">//输出的是第三个一维数组在堆内存对应的地址值</span></span><br><span class="line">        <span class="comment">//输出二维数组对应的某几个元素</span></span><br><span class="line">        System.out.println(arr[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(arr[0][3]);</span></span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">[[I@28d93b30</span><br><span class="line">[I@1b6d3586</span><br><span class="line">[I@4554617c</span><br><span class="line">[I@74a14482</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><h3 id="格式二："><a href="#格式二：" class="headerlink" title="格式二："></a>格式二：</h3><p>数据类型[][] 变量名 = new 数据类型[m][n]</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][];</span><br><span class="line">        System.out.println(arr);  <span class="comment">//二维数组的地址值 [[I@4554617c</span></span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]); <span class="comment">//第一个元素的一维数组的地址值  null</span></span><br><span class="line">        System.out.println(arr[<span class="number">1</span>]); <span class="comment">//第二个元素的一维数组的地址值  null</span></span><br><span class="line">        System.out.println(arr[<span class="number">2</span>]); <span class="comment">//第三个元素的一维数组的地址值  null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//动态地为每一个一维数组分配空间</span></span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]); <span class="comment">//第一个元素的一维数组的地址值 //[I@74a14482</span></span><br><span class="line">        System.out.println(arr[<span class="number">1</span>]); <span class="comment">//第二个元素的一维数组的地址值 //[I@1540e19d</span></span><br><span class="line">        System.out.println(arr[<span class="number">2</span>]); <span class="comment">//第三个元素的一维数组的地址值 //[I@677327b6</span></span><br><span class="line">    </span><br><span class="line">        System.out.println(arr[<span class="number">0</span>][<span class="number">0</span>]); <span class="comment">//0</span></span><br><span class="line">        System.out.println(arr[<span class="number">0</span>][<span class="number">1</span>]); <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">[[I@28d93b30</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line"><span class="keyword">null</span></span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">[I@1b6d3586</span><br><span class="line">[I@4554617c</span><br><span class="line">[I@74a14482</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>图解如下:</p><p><img src="https://i.loli.net/2021/09/02/x2YTtalgIEAmeRn.png"></p><h3 id="二维数组定义格式3："><a href="#二维数组定义格式3：" class="headerlink" title="二维数组定义格式3："></a>二维数组定义格式3：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(arr); <span class="comment">//二维数组的地址值</span></span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]); <span class="comment">//二维数组的第一个元素，一维数组的地址值</span></span><br><span class="line">        System.out.println(arr[<span class="number">1</span>]); <span class="comment">//二维数组的第二个元素，一维数组的地址值</span></span><br><span class="line">        System.out.println(arr[<span class="number">2</span>]); <span class="comment">//二维数组的第三个元素，一维数组的地址值</span></span><br><span class="line">    </span><br><span class="line">        System.out.println(arr[<span class="number">0</span>][<span class="number">0</span>]); <span class="comment">//打印的是第1个一维数组的第1个元素值</span></span><br><span class="line">        System.out.println(arr[<span class="number">0</span>][<span class="number">1</span>]); <span class="comment">//打印的是第1个一维数组的第2个元素值</span></span><br><span class="line">    </span><br><span class="line">        System.out.println(arr[<span class="number">1</span>][<span class="number">0</span>]); <span class="comment">//打印的是第2个一维数组的第1个元素值</span></span><br><span class="line">        System.out.println(arr[<span class="number">1</span>][<span class="number">1</span>]); <span class="comment">//打印的是第2个一维数组的第2个元素值</span></span><br><span class="line">        System.out.println(arr[<span class="number">1</span>][<span class="number">2</span>]); <span class="comment">//打印的是第2个一维数组的第3个元素值</span></span><br><span class="line">    </span><br><span class="line">        System.out.println(arr[<span class="number">2</span>][<span class="number">0</span>]); <span class="comment">//打印的是第3个一维数组的第1个元素值</span></span><br><span class="line">        System.out.println(arr[<span class="number">2</span>][<span class="number">1</span>]); <span class="comment">//打印的是第3个一维数组的第2个元素值</span></span><br><span class="line">        System.out.println(arr[<span class="number">2</span>][<span class="number">2</span>]); <span class="comment">//打印的是第3个一维数组的第3个元素值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[[I@28d93b30</span></span><br><span class="line"><span class="comment">//[I@1b6d3586</span></span><br><span class="line"><span class="comment">//[I@4554617c</span></span><br><span class="line"><span class="comment">//[I@74a14482</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="comment">//5</span></span><br><span class="line"><span class="comment">//6</span></span><br><span class="line"><span class="comment">//7</span></span><br><span class="line"><span class="comment">//8</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流程控制语句和跳转控制语句</title>
      <link href="/2020/09/02/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%E5%92%8C%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"/>
      <url>/2020/09/02/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%E5%92%8C%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="流程控制语句和跳转语句"><a href="#流程控制语句和跳转语句" class="headerlink" title="流程控制语句和跳转语句"></a>流程控制语句和跳转语句</h1><h2 id="循环结构-while循环结构"><a href="#循环结构-while循环结构" class="headerlink" title="循环结构(while循环结构)"></a>循环结构(while循环结构)</h2><p>while循环语句的基本格式：<br>基本格式：<br>while(判断条件语句){<br>循环体语句;<br>}<br>扩展格式：<br>while(判断条件语句){<br>循环体语句;<br>控制条件语句;<br>}</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhileDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;*************使用for循环改进********************&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;***********使用while循环改进*****************&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;<span class="number">3</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//HelloWorld</span></span><br><span class="line"><span class="comment">//HelloWorld</span></span><br><span class="line"><span class="comment">//HelloWorld</span></span><br><span class="line"><span class="comment">//*************使用for循环改进********************</span></span><br><span class="line"><span class="comment">//HelloWorld</span></span><br><span class="line"><span class="comment">//HelloWorld</span></span><br><span class="line"><span class="comment">//HelloWorld</span></span><br><span class="line"><span class="comment">//***********使用while循环改进*****************</span></span><br><span class="line"><span class="comment">//HelloWorld</span></span><br><span class="line"><span class="comment">//HelloWorld</span></span><br><span class="line"><span class="comment">//HelloWorld</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">            用while循环实现1-100之和</span></span><br><span class="line"><span class="comment">            注意：for循环与while循环之间的小区别：</span></span><br><span class="line"><span class="comment">                1、使用区别：控制条件语句所控制的那个变量，在for循环结束后，就不能再被访问到了，</span></span><br><span class="line"><span class="comment">                    而while循环结束还可以继续使用，如果你想继续使用，就用while，否则推荐使用for。</span></span><br><span class="line"><span class="comment">                    原因是for循环结束，该变量就从内存中消失，能够提高内存的使用效率。</span></span><br><span class="line"><span class="comment">                2、场景区别：</span></span><br><span class="line"><span class="comment">                    for循环适合针对一个范围判断进行操作</span></span><br><span class="line"><span class="comment">                    while循环适合判断次数不明确操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhileDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;1-100的和为：&quot;</span>+sum);</span><br><span class="line">        System.out.println(<span class="string">&quot;**********************使用while循环进行改进*********************&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">1</span>;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;1-100的和为：&quot;</span>+sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1-100的和为：5050</span></span><br><span class="line"><span class="comment">//**********************使用while循环进行改进*********************</span></span><br><span class="line"><span class="comment">//1-100的和为：5050</span></span><br></pre></td></tr></table></figure><h2 id="循环结构-do…while循环语句"><a href="#循环结构-do…while循环语句" class="headerlink" title="循环结构(do…while循环语句)"></a>循环结构(do…while循环语句)</h2><p>do…while循环语句格式：<br>基本格式：<br>do{<br>循环体语句;<br>}while(判断条件语句);<br>扩展格式：<br>do{<br>循环体语句;<br>控制条件语句;<br>}while(判断条件语句);</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoWhileDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//求1-100的和</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//定义的是循环的次数</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//定义的是总和</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">while</span>(i&lt;=<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1-100的和为：&quot;</span>+sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1-100的和为：5050</span></span><br></pre></td></tr></table></figure><h2 id="跳转控制语句"><a href="#跳转控制语句" class="headerlink" title="跳转控制语句"></a>跳转控制语句</h2><p>主要有三个跳转语句：</p><pre><code> break    中断 continue    继续 return    返回</code></pre><h3 id="break："><a href="#break：" class="headerlink" title="break："></a>break：</h3><p>​    使用场景：<br>​            1、在选择结构switch语句中<br>​            2、在循环语句中，加入了if判断的情况<br>​            3、离开使用场景的存在是没有意义的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControlDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入你想要的星期的数字（1-7）&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> num = sc.nextInt();</span><br><span class="line">        <span class="comment">//break跳出当前控制语句</span></span><br><span class="line">        <span class="keyword">switch</span> (num)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期一&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期二&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期三&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;程序没有匹配&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;*********************************&quot;</span>);</span><br><span class="line">        <span class="comment">//循环打印1-10，加入break，并在3的时候停止for循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>break的作用：<br>跳出单层循环：<br>跳出多层循环：<br>带标签的跳出：<br>格式：标签名: 循环语句</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControlDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                System.out.print(i+<span class="string">&quot;*&quot;</span>+j+<span class="string">&quot;=&quot;</span>+(i*j)+<span class="string">&#x27;\t&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*******加入break循环*********&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">4</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(i+<span class="string">&quot;*&quot;</span>+j+<span class="string">&quot;=&quot;</span>+(i*j)+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;*****加入break带标签跳出多层循环******&quot;</span>);</span><br><span class="line">        wc:<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">            nc:<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">4</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span> wc;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(i+<span class="string">&quot;*&quot;</span>+j+<span class="string">&quot;=&quot;</span>+(i*j)+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span>*<span class="number">1</span>=<span class="number">1</span></span><br><span class="line"><span class="number">2</span>*<span class="number">1</span>=<span class="number">2</span><span class="number">2</span>*<span class="number">2</span>=<span class="number">4</span></span><br><span class="line"><span class="number">3</span>*<span class="number">1</span>=<span class="number">3</span><span class="number">3</span>*<span class="number">2</span>=<span class="number">6</span><span class="number">3</span>*<span class="number">3</span>=<span class="number">9</span></span><br><span class="line"><span class="number">4</span>*<span class="number">1</span>=<span class="number">4</span><span class="number">4</span>*<span class="number">2</span>=<span class="number">8</span><span class="number">4</span>*<span class="number">3</span>=<span class="number">12</span><span class="number">4</span>*<span class="number">4</span>=<span class="number">16</span></span><br><span class="line"><span class="number">5</span>*<span class="number">1</span>=<span class="number">5</span><span class="number">5</span>*<span class="number">2</span>=<span class="number">10</span><span class="number">5</span>*<span class="number">3</span>=<span class="number">15</span><span class="number">5</span>*<span class="number">4</span>=<span class="number">20</span><span class="number">5</span>*<span class="number">5</span>=<span class="number">25</span></span><br><span class="line"><span class="number">6</span>*<span class="number">1</span>=<span class="number">6</span><span class="number">6</span>*<span class="number">2</span>=<span class="number">12</span><span class="number">6</span>*<span class="number">3</span>=<span class="number">18</span><span class="number">6</span>*<span class="number">4</span>=<span class="number">24</span><span class="number">6</span>*<span class="number">5</span>=<span class="number">30</span><span class="number">6</span>*<span class="number">6</span>=<span class="number">36</span></span><br><span class="line"><span class="number">7</span>*<span class="number">1</span>=<span class="number">7</span><span class="number">7</span>*<span class="number">2</span>=<span class="number">14</span><span class="number">7</span>*<span class="number">3</span>=<span class="number">21</span><span class="number">7</span>*<span class="number">4</span>=<span class="number">28</span><span class="number">7</span>*<span class="number">5</span>=<span class="number">35</span><span class="number">7</span>*<span class="number">6</span>=<span class="number">42</span><span class="number">7</span>*<span class="number">7</span>=<span class="number">49</span></span><br><span class="line"><span class="number">8</span>*<span class="number">1</span>=<span class="number">8</span><span class="number">8</span>*<span class="number">2</span>=<span class="number">16</span><span class="number">8</span>*<span class="number">3</span>=<span class="number">24</span><span class="number">8</span>*<span class="number">4</span>=<span class="number">32</span><span class="number">8</span>*<span class="number">5</span>=<span class="number">40</span><span class="number">8</span>*<span class="number">6</span>=<span class="number">48</span><span class="number">8</span>*<span class="number">7</span>=<span class="number">56</span><span class="number">8</span>*<span class="number">8</span>=<span class="number">64</span></span><br><span class="line"><span class="number">9</span>*<span class="number">1</span>=<span class="number">9</span><span class="number">9</span>*<span class="number">2</span>=<span class="number">18</span><span class="number">9</span>*<span class="number">3</span>=<span class="number">27</span><span class="number">9</span>*<span class="number">4</span>=<span class="number">36</span><span class="number">9</span>*<span class="number">5</span>=<span class="number">45</span><span class="number">9</span>*<span class="number">6</span>=<span class="number">54</span><span class="number">9</span>*<span class="number">7</span>=<span class="number">63</span><span class="number">9</span>*<span class="number">8</span>=<span class="number">72</span><span class="number">9</span>*<span class="number">9</span>=<span class="number">81</span></span><br><span class="line">*******加入<span class="keyword">break</span>循环*********</span><br><span class="line"><span class="number">1</span>*<span class="number">1</span>=<span class="number">1</span></span><br><span class="line"><span class="number">2</span>*<span class="number">1</span>=<span class="number">2</span><span class="number">2</span>*<span class="number">2</span>=<span class="number">4</span></span><br><span class="line"><span class="number">3</span>*<span class="number">1</span>=<span class="number">3</span><span class="number">3</span>*<span class="number">2</span>=<span class="number">6</span><span class="number">3</span>*<span class="number">3</span>=<span class="number">9</span></span><br><span class="line"><span class="number">4</span>*<span class="number">1</span>=<span class="number">4</span><span class="number">4</span>*<span class="number">2</span>=<span class="number">8</span><span class="number">4</span>*<span class="number">3</span>=<span class="number">12</span></span><br><span class="line"><span class="number">5</span>*<span class="number">1</span>=<span class="number">5</span><span class="number">5</span>*<span class="number">2</span>=<span class="number">10</span><span class="number">5</span>*<span class="number">3</span>=<span class="number">15</span></span><br><span class="line"><span class="number">6</span>*<span class="number">1</span>=<span class="number">6</span><span class="number">6</span>*<span class="number">2</span>=<span class="number">12</span><span class="number">6</span>*<span class="number">3</span>=<span class="number">18</span></span><br><span class="line"><span class="number">7</span>*<span class="number">1</span>=<span class="number">7</span><span class="number">7</span>*<span class="number">2</span>=<span class="number">14</span><span class="number">7</span>*<span class="number">3</span>=<span class="number">21</span></span><br><span class="line"><span class="number">8</span>*<span class="number">1</span>=<span class="number">8</span><span class="number">8</span>*<span class="number">2</span>=<span class="number">16</span><span class="number">8</span>*<span class="number">3</span>=<span class="number">24</span></span><br><span class="line"><span class="number">9</span>*<span class="number">1</span>=<span class="number">9</span><span class="number">9</span>*<span class="number">2</span>=<span class="number">18</span><span class="number">9</span>*<span class="number">3</span>=<span class="number">27</span></span><br><span class="line">*****加入<span class="keyword">break</span>带标签跳出多层循环******</span><br><span class="line"><span class="number">1</span>*<span class="number">1</span>=<span class="number">1</span></span><br><span class="line"><span class="number">2</span>*<span class="number">1</span>=<span class="number">2</span><span class="number">2</span>*<span class="number">2</span>=<span class="number">4</span></span><br><span class="line"><span class="number">3</span>*<span class="number">1</span>=<span class="number">3</span><span class="number">3</span>*<span class="number">2</span>=<span class="number">6</span><span class="number">3</span>*<span class="number">3</span>=<span class="number">9</span></span><br><span class="line"><span class="number">4</span>*<span class="number">1</span>=<span class="number">4</span><span class="number">4</span>*<span class="number">2</span>=<span class="number">8</span><span class="number">4</span>*<span class="number">3</span>=<span class="number">12</span></span><br></pre></td></tr></table></figure><h3 id="continue："><a href="#continue：" class="headerlink" title="continue："></a>continue：</h3><p>使用场景：<br>1、在循环语句中<br>2、离开使用场景的存在是没有意义的</p><h3 id="return："><a href="#return：" class="headerlink" title="return："></a>return：</h3><p>结束循环其实是结束了main方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControlDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//循环打印1-10，加入continue</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;<span class="comment">//跳出当前此次循环，继续后面循环</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;<span class="comment">//在这里面 3 就被抽走了</span></span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;********改为return*********&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="comment">//5</span></span><br><span class="line"><span class="comment">//6</span></span><br><span class="line"><span class="comment">//7</span></span><br><span class="line"><span class="comment">//8</span></span><br><span class="line"><span class="comment">//9</span></span><br><span class="line"><span class="comment">//10</span></span><br><span class="line"><span class="comment">//********改为return*********</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法：<br>方法就是完成特定功能的代码块<br>在很多语言里面都有函数的定义<br>函数在Java中被称为方法<br>语句格式：<br>修饰符 返回值类型 方法名(参数类型 参数名1，参数类型 参数名2…) {<br>函数体;<br>return 返回值;<br>}<br>名词解释：<br>修饰符：修饰符 比较多，后面会详细介绍。目前public static<br>返回值类型：<br>就是return返回的值的类型<br>方法名：<br>一个名称，为了方便我们调用方法，自己起的名字，方便我们调用。</p><blockquote><p>参数：<br>        1、形参<br>            定义在方法上的参数名<br>        2、实参<br>            实际调用方法的时候传入的值<br>    参数类型：<br>        限定调用方法时传入参数的数据类型<br>    参数名：（形参）<br>        是一个变量，接收调用方法时传入的参数。<br>    函数体：<br>        完成功能的代码，实现方法的主要逻辑功能<br>    return：<br>        结束方法以及返回方法指定类型的值<br>    返回值：<br>        程序被return带回的结果，返回给调用者</p></blockquote><p>注意:方法和方法是平级关系，不能被嵌套使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">20</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> result = sum(x,y);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = x+y;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//30</span></span><br></pre></td></tr></table></figure><p>上式图解</p><p><img src="https://i.loli.net/2021/09/02/yjn6WK4NCUPFwd7.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入行数&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> x = sc.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入列数&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> y = sc.nextInt();</span><br><span class="line">    </span><br><span class="line">        printStar(x,y);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printStar</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=b;j++)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//请输入行数</span></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="comment">//请输入列数</span></span><br><span class="line"><span class="comment">//5</span></span><br><span class="line"><span class="comment">//* ****</span></span><br><span class="line"><span class="comment">//*    ****</span></span><br><span class="line"><span class="comment">//*    ****</span></span><br><span class="line"><span class="comment">//*    ****</span></span><br></pre></td></tr></table></figure><h2 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h2><p>方法的重载：<br>在同一个类中，允许存在一个以上的同名方法，<br>只要它们的参数个数或者参数类型不同即可。</p><p>方法重载的特点：<br>1、与返回值类型无关，只看方法名和参数列表<br>2、在调用时，虚拟机通过参数列表的不同来区分同名方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionDemo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//求加法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">byte</span> e = <span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = x+y;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x+y+z);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x+y+z+i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum3</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">byte</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x+y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中键盘录入以及循环结构</title>
      <link href="/2020/09/02/Java%E4%B8%AD%E9%94%AE%E7%9B%98%E5%BD%95%E5%85%A5%E4%BB%A5%E5%8F%8A%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/"/>
      <url>/2020/09/02/Java%E4%B8%AD%E9%94%AE%E7%9B%98%E5%BD%95%E5%85%A5%E4%BB%A5%E5%8F%8A%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Java中键盘录入以及循环结构"><a href="#Java中键盘录入以及循环结构" class="headerlink" title="Java中键盘录入以及循环结构"></a>Java中键盘录入以及循环结构</h1><h2 id="键盘录入"><a href="#键盘录入" class="headerlink" title="键盘录入"></a>键盘录入</h2><p>把数据改为键盘录入，可以提高程序的灵活性。<br>如何进行键盘录入：<br>1、导包（位置放到class定义的上面）<br><code>import java.util.Scanner;</code><br>2、创建对象<br><code>Scanner sc = new Scanner(System.in);</code><br>3、接收数据<br><code>int x = sc.nextInt();</code><br>    键盘录入两个数据，并对两个数据求和，输出结果<br>    键盘录入两个数据，获取两个结果中的最大值</p><p>  分析：<br>    1.导包<br>    2.创建Scanner对象<br>    3.使用对象的方法，输出两个值<br>    4.输出两个值相加的结果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建Scanner对象</span></span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">​    System.out.println(<span class="string">&quot;请输入第一个数据&quot;</span>);</span><br><span class="line">​    <span class="keyword">int</span> x = sc.nextInt();</span><br><span class="line"></span><br><span class="line">​    System.out.println(<span class="string">&quot;请输入第二个数据&quot;</span>);</span><br><span class="line">​    <span class="keyword">int</span> y = sc.nextInt();</span><br><span class="line"></span><br><span class="line">​    System.out.println(<span class="string">&quot;两值相加的结果为：&quot;</span>+(x+y));</span><br><span class="line"></span><br><span class="line">​    System.out.println(<span class="string">&quot;********************************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">​    <span class="comment">//键盘录入两个数据，获取两个数据中的最大值</span></span><br><span class="line">​    System.out.println(<span class="string">&quot;请输入第二题的第一个数据&quot;</span>);</span><br><span class="line">​    <span class="keyword">int</span> a = sc.nextInt();</span><br><span class="line"></span><br><span class="line">​    System.out.println(<span class="string">&quot;请输入第二题的第二个数据&quot;</span>);</span><br><span class="line">​    <span class="keyword">int</span> b = sc.nextInt();</span><br><span class="line"></span><br><span class="line">​    <span class="comment">//使用三目运算符求最大值</span></span><br><span class="line">​    <span class="keyword">int</span> result = (a&gt;b)?a:b;</span><br><span class="line">​    System.out.println(<span class="string">&quot;最大值为：&quot;</span>+result);</span><br></pre></td></tr></table></figure><h2 id="流程控制语句中的-顺序结构"><a href="#流程控制语句中的-顺序结构" class="headerlink" title="流程控制语句中的 顺序结构"></a>流程控制语句中的 顺序结构</h2><p>顺序结构是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。<br>总的来说：写在前面的先执行，写在后面的后执行。</p><p>流程控制语句中的 选择结构<br>选择结构也被称为 分支结构。<br>选择结构有特定的语法规则，代码要执行具体的逻辑运算进行判断，逻辑运算的结果有两个，所以产生选择，按照不同的选择执行不同的代码。</p><p>Java中提供两种选择结构语句：<br>if语句<br>switch语句</p><p>if语句的三种格式：</p><h3 id="（1）if-关系表达式"><a href="#（1）if-关系表达式" class="headerlink" title="（1）if(关系表达式){"></a>（1）if(关系表达式){</h3><p>语句体<br>}</p><p>执行流程：<br>首先判断关系表达式里的结果值，无论关系表达式里面简单还是复杂，最后结果一定要是Boolean类型<br>如果是true就进入if大括号内，执行语句体<br>如果是false就不进入if大括号，继续执行后面的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IfDemo1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;<span class="number">90</span>)&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;a是小于90的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;程序执行完毕&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序执行完毕</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>if语句编写的注意事项<br>1、if判断里面的关系表达式一定要严格遵循结果是Boolean类型的规则<br>2、if语句控制的语句体如果是一条语句，大括号可以省略；<br>如果是多条语句，就不能省略，建议永远不省略<br>3、一般来说：有左大括号就没有分号，有分号就没有左大括号</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IfDemo2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">3</span>);<span class="comment">//这就默认有了一个空的语句体</span></span><br><span class="line">    <span class="comment">//这是一个普通的代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;x是大于3的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;程序执行完毕&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//x是大于3的</span></span><br><span class="line"><span class="comment">//程序执行完毕</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br></pre></td></tr></table></figure><h3 id="（2）if-关系表达式"><a href="#（2）if-关系表达式" class="headerlink" title="（2）if(关系表达式){"></a>（2）if(关系表达式){</h3><p>语句体1;<br>}else{<br>语句体2;<br>}</p><p>执行流程：<br>1、先判断关系表达式里面的结果值，无论关系表达式里面是简单还是复杂，最后结果一定是Boolean类型<br>2、如果关系表达式的结果是true，那么就执行语句体1，不会执行else后面的语句体<br>3、如果关系表达式的结果是false，那么就执行else里面的语句体2</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IfDemo3</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> a = <span class="number">13965873016L</span>;</span><br><span class="line">    <span class="keyword">if</span>(!(a==<span class="number">13965873016L</span>))&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure><h4 id="这里讲解一种三元运算符和if语句的第二种格式相转换的问题。"><a href="#这里讲解一种三元运算符和if语句的第二种格式相转换的问题。" class="headerlink" title="这里讲解一种三元运算符和if语句的第二种格式相转换的问题。"></a>这里讲解一种三元运算符和if语句的第二种格式相转换的问题。</h4><p>三元运算符，它根据比较判断后，给出的也是两个结果，所以，这种情况和if语句的第二种格式很相似，他们在某些情况下应该是可以相互转换的。<br>1、当选择结构存在最后输出的语句是控制台输出，就无法改进成三元运算符<br>2、当if第二种结构的最后输出语句是一个结果值的时候，可以使用三元运算符进行改进</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IfDemo6</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建Scanner对象</span></span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入第一个数&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> x = sc.nextInt();</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入第二个数&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> y = sc.nextInt();</span><br><span class="line">    <span class="keyword">if</span>(x&gt;y)&#123;<span class="comment">//不考虑相等的情况</span></span><br><span class="line">      System.out.println(<span class="string">&quot;最大值x：&quot;</span>+x);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;最大值y：&quot;</span>+y);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;*********************************&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;三元运算符进行改进&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> max = (x&gt;y)?x:y;</span><br><span class="line">    System.out.println(<span class="string">&quot;最大值：&quot;</span>+max);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//请输入第一个数</span></span><br><span class="line"><span class="comment">//34</span></span><br><span class="line"><span class="comment">//请输入第二个数</span></span><br><span class="line"><span class="comment">//45</span></span><br><span class="line"><span class="comment">//最大值y：45</span></span><br><span class="line"><span class="comment">//*********************************</span></span><br><span class="line"><span class="comment">//三元运算符进行改进</span></span><br><span class="line"><span class="comment">//最大值：45</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">26</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">28</span></span><br></pre></td></tr></table></figure><h3 id="（3）if语句的第三种格式："><a href="#（3）if语句的第三种格式：" class="headerlink" title="（3）if语句的第三种格式："></a>（3）if语句的第三种格式：</h3><p>if(关系表达式1){<br>语句体1;<br>}else if(关系表达式){<br>语句体2;<br>}<br>…<br>else{<br>语句体n+1;<br>}</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IfDemo5</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建Scanner对象</span></span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入第一个数&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> x = sc.nextInt();</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入第二个数&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> y = sc.nextInt();</span><br><span class="line">    <span class="keyword">if</span>(x&gt;y)&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;最大值x:&quot;</span>+x);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (x==y)&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;两个数相等&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;最大值y:&quot;</span>+y);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//请输入第一个数</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//请输入第二个数</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//最大值y:2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">23</span></span><br></pre></td></tr></table></figure><p>这里补充一个小知识点：第三种情况下的else可以省去，但就不属于if中的格式了</p><pre><code> #### 练习题：使用if嵌套输出三个数中的最大值</code></pre><p>1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IfDemo7</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入第一个数&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> x1 = sc.nextInt();</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入第二个数&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> x2 = sc.nextInt();</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入第三个数&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> x3 = sc.nextInt();</span><br><span class="line">    <span class="keyword">if</span>(x1 &gt; x2)&#123;</span><br><span class="line">      <span class="keyword">if</span>(x1 &gt; x3)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;最大值是x1:&quot;</span>+x1);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x2 &gt; x3)&#123;   <span class="comment">//潜台词就是x1&lt;x3，x1&gt;x2</span></span><br><span class="line">      System.out.println(<span class="string">&quot;最大值是x2:&quot;</span>+x2);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;     <span class="comment">//潜台词就是x2&lt;x3，x1&lt;x3，x1&gt;x2</span></span><br><span class="line">      System.out.println(<span class="string">&quot;最大值是x3:&quot;</span>+x3);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//请输入第一个数</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//请输入第二个数</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//请输入第三个数</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//最大值是x3:3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">26</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">28</span></span><br></pre></td></tr></table></figure><h2 id="流程控制语句中的-switch选择结构"><a href="#流程控制语句中的-switch选择结构" class="headerlink" title="流程控制语句中的 switch选择结构"></a>流程控制语句中的 switch选择结构</h2><p>switch语句格式：<br>switch(表达式){<br>case 值1：<br>语句体1;<br>break;<br>case 值2：<br>语句体2;<br>break;<br>…<br>default:<br>语句体n+1;<br>break;<br>}</p><p>switch表达式的一些注意点：<br>表达式的取值：byte、short、int（没有long）、char（不能有浮点数）<br>JDK5(1.5)之后可以是枚举<br>JDK7(1.7)之后可以是String<br>case后面跟的是要和表达式进行比较的值<br>语句体部分可以是一条或者多条语句<br>break表示中断，结束的意思，可以结束switch语句<br>default语句表示所有情况都不匹配的时候，就执行该处的内容，和if语句的else相似</p><p>执行流程：<br>1、首先计算表达式的值<br>2、拿着计算好的值与case对应值按照从上到下的顺序进行比较，如有相同，开始执行该case对应的语句体<br>3、当语句体执行完之后，会执行紧接着的break语句，执行break语句就代表着switch选择结构结束（跳出switch选择）<br>4、当从上到下依次寻找case对应的值的时候，没有找到相匹配的值，就会执行default中的语句体，最后跳出循环</p><h3 id="switch语句的注意事项"><a href="#switch语句的注意事项" class="headerlink" title="switch语句的注意事项:"></a>switch语句的注意事项:</h3><p>case 后面只能是常量，不能是变量，而且，多个case后面的值不能出现相同的<br>default可以省略吗?<br>可以省略。一般不建议。除非判断的值是固定的。(单选题)<br>break可以省略吗?<br>可以省略，一般不建议。否则结果可能不是你想要的<br>当所有break语句都省略的时候，表达式的值与case的值进行匹配，从匹配到的那个case语句体开始执行，一直执行到结尾，直到最后一个语句<br>default的位置一定要在最后吗?<br>可以出现在switch语句任意位置。<br>1、当计算完表达式的值后，先与每一个case按照顺序去匹配，如果所有的case都补匹配，那么最后再执行default,这个和你default放再哪里的<br>位置并没有关系。<br>2、即使你放在了第一个，某些case没有写break语句，那么也会先去匹配case，记住一句话，只有当所有case都不匹配的时候，才会去执行<br>default;<br>switch语句的结束条件<br>遇到break<br>执行到程序的末尾</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwitchDemo5</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">switch</span>(x)&#123;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        y++; <span class="comment">// 4</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        y++; <span class="comment">// 5</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        y++; <span class="comment">// 6</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;y=&quot;</span>+y); <span class="comment">// 6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure><h2 id="流程控制语句-for循环"><a href="#流程控制语句-for循环" class="headerlink" title="流程控制语句 for循环"></a>流程控制语句 for循环</h2><p>for(初始化语句;判断条件语句;控制条件语句) {<br>循环体语句;<br>}<br>/*<br>循环结构：<br>循环语句可以在满足循环条件的情况下，反复执行某一段代码，<br>这段被重复执行的代码被称为循环体语句，当反复执行这个循环体时，<br>需要在合适的时候把循环判断条件修改为false，从而结束循环，否则循环将一直执行下去，形成死循环。</p><h3 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h3><p>1、for循环<br>2、while循环</p><h3 id="循环的组成："><a href="#循环的组成：" class="headerlink" title="循环的组成："></a>循环的组成：</h3><p>初始化语句：<br>一条或者多条语句，这些语句完成一些初始化操作。<br>判断条件语句：<br>这是一个boolean 表达式，这个表达式能决定是否执行循环体。<br>循环体语句：<br>这个部分是循环体语句，也就是我们要多次做的事情。<br>控制条件语句：<br>这个部分在一次循环体结束后，下一次循环判断条件执行前执行。通过用于控制循环条件中的变量，使得循环在合适的时候结束。</p><p>for循环：<br>语句格式：<br>for(初始化语句;判断语句;控制条件语句){<br>语句体;<br>}</p><p> 执行流程：<br>  1、先初始化语句<br>  2、执行判断语句，判断语句一般返回的结果是boolean类型<br>    如果判断语句返回的是true,则执行语句体；<br>    如果判断语句返回的是false,则跳出当前for循环<br>  3、如果判断语句是true,且执行完了语句体，接着去执行控制条件语句<br>  4、再者去执行判断语句，如果是true，继续执行第二步。<br>使用for循环的注意事项：<br>1、判断条件语句的结果是一个boolean类型<br>2、循环体语句如果是一条语句，大括号可以省略；<br>如果是多条语句，大括号不能省略。建议永远不要省略，如果省略，循环只对第一条语句有效。<br>3、一般来说：有左大括号就没有分号，有分号就没有左大括号<br>4、初始化语句可以不在for循环的语句结构中出现，但是必须在其执行之前定义。<br>5、判断语句一定不能不能省略，否则就是死循环<br>6、控制条件语句可以不在for循环的语句结构中出现，但是，必须在语句体中进行变化。<br>*/</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForDemo2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;=<span class="number">10</span>;) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;HelloWorld!&quot;</span>);</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//想要终止for的死循环，就将判断条件的结果写为false即可。</span></span><br><span class="line">    <span class="keyword">for</span>(;i&lt;<span class="number">0</span>;)&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;这是死循环&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java数据类型和运算符</title>
      <link href="/2020/09/02/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2020/09/02/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="Java数据类型和运算符"><a href="#Java数据类型和运算符" class="headerlink" title="Java数据类型和运算符"></a>Java数据类型和运算符</h1><h2 id="以下是数据类型以及Java中运算符的一些理解"><a href="#以下是数据类型以及Java中运算符的一些理解" class="headerlink" title="以下是数据类型以及Java中运算符的一些理解"></a>以下是数据类型以及Java中运算符的一些理解</h2><p>Java是一种 强类型 的语言，每种数据都定义了一种具体的数据类型，并且在内存中分配了不同大小空间。<br>数据类型分为基本数据类型以及引用数据类型，这里暂时只提及基本数据类型。</p><p>（由小到大）<br>整数类型   byte、short、int、long<br>浮点类型   float、double<br>字符型   char<br>布尔型   boolean</p><p>数据类型的大小范围：<br>类型                 占用存储空间             表数范围<br>byte                 1字节                   -128<del>127     (2的八次幂)<br>short               2字节                   -2^15</del>2^15-1   （2的十六次幂，但从零开始）<br>int                 4字节                   -2^31<del>2^31-1<br>long                 8字节                   -2^63</del>2^63-1<br>float                 4字节                   -3.403E38<del>3.403E38<br>double               8字节                   -1.798E308</del>1.798E308</p><p>作用域：<br>   变量定义在哪一级大括号中，哪个大括号的范围就是这个变量的作用域。相同的作用域中不能定义两个同名变量。</p><p>初始化值：<br>   没有初始化值不能直接使用<br>2.运算符<br>运算符包括算术运算符、赋值运算符、比较运算符、逻辑运算符、位运算符、三目运算符<br>+的作用：<br>加法<br>正数<br>字符串连接符</p><p>3.关系运算符<br>== 相等于 4==3 false<br>!= 不等于 4!=3 true<br>&lt; 小于 4&lt;3 false<br>&gt; 大于 4&gt;3 true<br>&lt;= 小于等于 4&lt;=3 false<br>&gt;= 大于等于 4&gt;=3 false</p><p>关系运算符的计算结果是一个Boolean值，true或false</p><p>4.逻辑运算符<br>运算符 运算 范例 结果<br>&amp; AND(与) false&amp;true false<br>| OR(或) false|true true<br>^ XOR(异或) true^false true<br>! Not(非) !true false<br>&amp;&amp; AND(短路) false&amp;true false<br>|| OR(短路) false||true true</p><p>特点：一般用于连接Boolean类型的表达式或值<br>结论：<br>&amp; 逻辑与：有false则false<br>| 逻辑或：有true则true<br>^ 逻辑异或 相同为false，不同为true<br>！非：就是非<br>&amp;&amp;，||<br>&amp;&amp;和&amp;的区别，||和|的区别<br>A：最终结果是一样的<br>B：&amp;&amp;具有短路效果，左边为false时，右边不执行<br>||具有短路效果，左边为true时，右边不执行</p><p>5.位运算符<br>&lt;&lt; 左移 3&lt;&lt;2 = 12 –&gt;322=12<br>&gt;&gt; 右移 3&gt;&gt;1 = 1 –&gt;3/2=1<br>&gt;&gt;&gt; 无符号右移 3&gt;&gt;&gt;1 = 1 –&gt; 3/2=1<br>&amp; 与运算 6&amp;3 = 2<br>| 或运算 6|3 = 7<br>^ 异或运算 6^3 = 5<br>~ 反码 ~6 = -7</p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java打印1000以内的完数</title>
      <link href="/2020/09/02/Java%E6%89%93%E5%8D%B01000%E4%BB%A5%E5%86%85%E7%9A%84%E5%AE%8C%E6%95%B0/"/>
      <url>/2020/09/02/Java%E6%89%93%E5%8D%B01000%E4%BB%A5%E5%86%85%E7%9A%84%E5%AE%8C%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Java实现1000以内完数的输出"><a href="#Java实现1000以内完数的输出" class="headerlink" title="Java实现1000以内完数的输出"></a>Java实现1000以内完数的输出</h1><h2 id="实现代码如下所示"><a href="#实现代码如下所示" class="headerlink" title="实现代码如下所示"></a>实现代码如下所示</h2><p>实现代码如下所示:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">wanshu</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">1000</span>;i++)&#123;<span class="comment">//遍历1000以内的数</span></span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= i/<span class="number">2</span>;j++)&#123;<span class="comment">//优化1：只需要和i/2相比较，优化了时间。</span></span><br><span class="line">                <span class="keyword">if</span>(i % j == <span class="number">0</span>)&#123;</span><br><span class="line">                    sum += j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == sum)&#123;<span class="comment">//如果输入的i和累加之后的数值相同，那就说明这个数是完数。</span></span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>引用图片</title>
      <link href="/2020/09/02/title/"/>
      <url>/2020/09/02/title/</url>
      
        <content type="html"><![CDATA[<h1 id="这是本地引用格式"><a href="#这是本地引用格式" class="headerlink" title="这是本地引用格式"></a>这是本地引用格式</h1><img src="/2020/09/02/title/aisi.jpg" class><p>引用图片的格式</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
